/* --- Bundle de Código Generado ---
 * Modo: full
 * Ficheros Incluidos: 165
 * Fecha: 2025-08-03T16:43:42.041Z
 */

// --- Ruta: vitest.config.ts ---
import { defineConfig } from 'vitest/config';
import { svelte } from '@sveltejs/vite-plugin-svelte';
import path from 'path';
export default defineConfig({
	plugins: [svelte()],
	resolve: {
		alias: {
			$lib: path.resolve(__dirname, './src/lib')
		},
		// Justificación: Se añade la condición 'browser' para el modo de test.
		// Esto fuerza a Vite a resolver los módulos de Svelte a su versión de navegador,
		// lo que hace que las funciones de ciclo de vida como `mount` estén disponibles
		// y soluciona el error `lifecycle_function_unavailable`.
		conditions: ['browser']
	},
	test: {
		// Justificación: Se restaura 'jsdom' como entorno global, ya que la condición
		// de resolución es la solución real al problema.
		environment: 'jsdom',
		include: ['src/**/*.{test,spec}.{js,ts}'],
		exclude: ['e2e/**']
	}
});

// --- Ruta: vite.config.ts ---
import tailwindcss from '@tailwindcss/vite';
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';
export default defineConfig({
	plugins: [tailwindcss(), sveltekit()],
	ssr: {
		// Justificación: `bits-ui` tiene problemas de inicialización en el entorno SSR de Vite.
		// Al añadirlo a `noExternal`, forzamos a Vite a procesar y empaquetar este módulo
		// junto con nuestro código de servidor, lo que resuelve el error `Cannot read properties of undefined`.
		// Esta es la solución estándar para este tipo de problemas de compatibilidad de módulos.
		noExternal: ['bits-ui']
	}
});

// --- Ruta: tsconfig.json ---
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}

// --- Ruta: tailwind.config.ts ---
// Ruta: tailwind.config.ts
import type { Config } from 'tailwindcss';
export default {
	content: ['./src/**/*.{html,js,svelte,ts}'],
	theme: {
		extend: {}
	},
	plugins: []
} satisfies Config;

// --- Ruta: svelte.config.js ---
import adapter from '@sveltejs/adapter-cloudflare';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';
/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: vitePreprocess(),
	kit: {
		// adapter-auto only supports some environments, see https://svelte.dev/docs/kit/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://svelte.dev/docs/kit/adapters for more information about adapters.
		adapter: adapter()
	}
};
export default config;

// --- Ruta: package.json ---
{
	"name": "recetario",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"prepare": "svelte-kit sync || echo ''",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"format": "prettier --write .",
		"lint": "prettier --check . && eslint .",
		"test:unit": "vitest",
		"test": "vitest run",
		"seed": "node scripts/seed.js"
	},
	"prisma": {
		"seed": "node scripts/seed.js"
	},
	"devDependencies": {
		"@eslint/compat": "^1.2.5",
		"@eslint/js": "^9.18.0",
		"@faker-js/faker": "^9.9.0",
		"@internationalized/date": "^3.8.2",
		"@lucide/svelte": "^0.515.0",
		"@sveltejs/adapter-auto": "^6.0.0",
		"@sveltejs/adapter-cloudflare": "^4.4.0",
		"@sveltejs/kit": "^2.22.0",
		"@sveltejs/vite-plugin-svelte": "^6.0.0",
		"@tailwindcss/vite": "^4.1.11",
		"@testing-library/svelte": "^5.2.8",
		"@types/bcryptjs": "^2.4.6",
		"@types/cheerio": "^0.22.35",
		"@types/dompurify": "^3.0.5",
		"@types/marked": "^5.0.2",
		"@types/node": "^24.1.0",
		"autoprefixer": "^10.4.21",
		"bits-ui": "^2.8.13",
		"clsx": "^2.1.1",
		"eslint": "^9.18.0",
		"eslint-config-prettier": "^10.0.1",
		"eslint-plugin-svelte": "^3.0.0",
		"glob": "^11.0.3",
		"globals": "^16.0.0",
		"ignore": "^7.0.5",
		"jsdom": "^26.1.0",
		"postcss": "^8.5.6",
		"prettier": "^3.4.2",
		"prettier-plugin-svelte": "^3.3.3",
		"prettier-plugin-tailwindcss": "^0.6.5",
		"prisma": "^6.13.0",
		"shadcn-svelte": "^1.0.6",
		"svelte": "^5.0.0",
		"svelte-check": "^4.0.0",
		"tailwind-merge": "^3.3.1",
		"tailwind-variants": "^1.0.0",
		"tailwindcss": "^4.1.11",
		"tailwindcss-animate": "^1.0.7",
		"tw-animate-css": "^1.3.6",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.20.0",
		"vite": "^7.0.4",
		"vitest": "^3.2.3"
	},
	"optionalDependencies": {
		"@cloudflare/workerd-darwin-64": "^1.20250726.0",
		"@cloudflare/workerd-linux-64": "^1.20250726.0",
		"@cloudflare/workerd-win32-64": "^1.20250726.0"
	},
	"overrides": {
		"esbuild": "^0.20.2"
	},
	"dependencies": {
		"@prisma/adapter-d1": "^6.13.0",
		"@prisma/client": "^6.13.0",
		"bcryptjs": "^3.0.2",
		"cheerio": "^1.1.2",
		"dompurify": "^3.2.6",
		"jose": "^6.0.12",
		"ky": "^1.8.2",
		"lucide-svelte": "^0.535.0",
		"marked": "^16.1.1",
		"sharp": "^0.34.3",
		"slugify": "^1.6.6",
		"zod": "^4.0.14"
	}
}

// --- Ruta: migration.sql ---
-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "normalizedName" TEXT NOT NULL,
    "brand" TEXT,
    "imageUrl" TEXT,
    "calories" REAL,
    "fat" REAL,
    "protein" REAL,
    "carbs" REAL,
    "fullPayload" JSONB,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);
-- CreateTable
CREATE TABLE "CustomIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "normalizedName" TEXT NOT NULL,
    "calories" REAL NOT NULL,
    "fat" REAL NOT NULL,
    "protein" REAL NOT NULL,
    "carbs" REAL NOT NULL
);
-- CreateTable
CREATE TABLE "Recipe" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "normalizedTitle" TEXT NOT NULL,
    "steps" JSONB NOT NULL,
    "imageUrl" TEXT
);
-- CreateTable
CREATE TABLE "RecipeUrl" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "url" TEXT NOT NULL,
    "recipeId" TEXT NOT NULL,
    CONSTRAINT "RecipeUrl_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);
-- CreateTable
CREATE TABLE "RecipeIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "recipeId" TEXT NOT NULL,
    "productId" TEXT,
    "customIngredientId" TEXT,
    "quantity" REAL NOT NULL,
    CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_customIngredientId_fkey" FOREIGN KEY ("customIngredientId") REFERENCES "CustomIngredient" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);
-- CreateIndex
CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name");
-- CreateIndex
CREATE UNIQUE INDEX "RecipeUrl_recipeId_url_key" ON "RecipeUrl"("recipeId", "url");

// --- Ruta: eslint.config.js ---
import prettier from 'eslint-config-prettier';
import { includeIgnoreFile } from '@eslint/compat';
import js from '@eslint/js';
import svelte from 'eslint-plugin-svelte';
import globals from 'globals';
import { fileURLToPath } from 'node:url';
import ts from 'typescript-eslint';
import svelteConfig from './svelte.config.js';
const gitignorePath = fileURLToPath(new URL('./.gitignore', import.meta.url));
export default ts.config(
	includeIgnoreFile(gitignorePath),
	js.configs.recommended,
	...ts.configs.recommended,
	...svelte.configs.recommended,
	prettier,
	...svelte.configs.prettier,
	{
		languageOptions: {
			globals: { ...globals.browser, ...globals.node }
		},
		rules: {
			// typescript-eslint strongly recommend that you do not use the no-undef lint rule on TypeScript projects.
			// see: https://typescript-eslint.io/troubleshooting/faqs/eslint/#i-get-errors-from-the-no-undef-rule-about-global-variables-not-being-defined-even-though-there-are-no-typescript-errors
			'no-undef': 'off'
		}
	},
	{
		files: ['**/*.svelte', '**/*.svelte.ts', '**/*.svelte.js'],
		languageOptions: {
			parserOptions: {
				projectService: true,
				extraFileExtensions: ['.svelte'],
				parser: ts.parser,
				svelteConfig
			}
		}
	}
);

// --- Ruta: components.json ---
{
	"$schema": "https://shadcn-svelte.com/schema.json",
	"tailwind": {
		"css": "src/app.css",
		"baseColor": "slate"
	},
	"aliases": {
		"components": "$lib/components",
		"utils": "$lib/utils",
		"ui": "$lib/components/ui",
		"hooks": "$lib/hooks",
		"lib": "$lib"
	},
	"typescript": true,
	"registry": "https://shadcn-svelte.com/registry"
}

// --- Ruta: .prettierrc ---
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"],
	"overrides": [
		{
			"files": "*.svelte",
			"options": {
				"parser": "svelte"
			}
		}
	],
	"tailwindStylesheet": "./src/app.css"
}

// --- Ruta: .prettierignore ---
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
bun.lock
bun.lockb
# Miscellaneous
/static/

// --- Ruta: .npmrc ---
engine-strict=true

// --- Ruta: .env.test ---
# Fichero: .env.test
# Justificación: Este fichero de entorno es cargado automáticamente por Vitest.
# Define la URL de la base de datos para que apunte a un fichero separado,
# aislando completamente los tests de la base de datos de desarrollo.
DATABASE_URL="file:./test.db"

// --- Ruta: scripts/seed.js ---
// Fichero: scripts/seed.js
import { faker } from '@faker-js/faker';
import { PrismaClient } from '@prisma/client';
import slugify from 'slugify';
const prisma = new PrismaClient();
// =================================================================
// --- FASE 1: OBTENCIÓN DE PRODUCTOS DE OPENFOODFACTS (OFF) ---
// =================================================================
const SEARCH_TERMS_FOR_SEEDING = [
	'Atún Hacendado',
	'Tortiglioni Hacendado',
	'Yogur Hacendado',
	'Aceite Hacendado',
	'Leche Hacendado',
	'Galletas Hacendado',
	'Huevos Hacendado',
	'Arroz Hacendado',
	'Pechuga Hacendado',
	'Mantequilla Hacendado',
	'Pavo Hacendado',
	'Queso Hacendado'
];
/**
 * Busca un producto en OpenFoodFacts y lo guarda en la base de datos si es válido.
 * @param {string} searchTerm - Término de búsqueda para el producto.
 * @returns {Promise<import('@prisma/client').Product | null>} El producto creado o null si no es válido.
 */
async function fetchAndCreateProduct(searchTerm) {
	console.log(`[OFF] Buscando producto para el término: "${searchTerm}"...`);
	const searchUrl = `https://world.openfoodfacts.org/cgi/search.pl?search_terms=${encodeURIComponent(
		searchTerm
	)}&search_simple=1&action=process&json=1&page_size=5`;
	try {
		const response = await fetch(searchUrl);
		if (!response.ok) {
			throw new Error(`La API de OFF devolvió el estado ${response.status}`);
		}
		const data = await response.json();
		// Buscamos el primer producto que tenga todos los datos que necesitamos
		const productData = data.products.find((p) => {
			const nutriments = p.nutriments;
			return (
				p.code &&
				p.product_name &&
				p.image_url &&
				nutriments &&
				nutriments['energy-kcal_100g'] &&
				nutriments.proteins_100g &&
				nutriments.fat_100g &&
				nutriments.carbohydrates_100g
			);
		});
		if (!productData) {
			console.warn(`-> [ADVERTENCIA] No se encontró un producto válido para "${searchTerm}".`);
			return null;
		}
		const barcode = productData.code;
		console.log(`-> [INFO] Producto encontrado: "${productData.product_name}" (${barcode})`);
		// Comprobar si el producto ya existe en nuestra BD
		const existingProduct = await prisma.product.findUnique({ where: { id: barcode } });
		if (existingProduct) {
			console.log(`-> [CACHE] El producto "${existingProduct.name}" ya existe. Omitiendo.`);
			return existingProduct;
		}
		// Transformar y crear el producto
		const newProduct = {
			id: barcode,
			name: productData.product_name,
			normalizedName: productData.product_name.toLowerCase(),
			brand: productData.brands || 'Marca no especificada',
			imageUrl: productData.image_url,
			calories: productData.nutriments['energy-kcal_100g'] || 0,
			protein: productData.nutriments.proteins_100g || 0,
			fat: productData.nutriments.fat_100g || 0,
			carbs: productData.nutriments.carbohydrates_100g || 0,
			fullPayload: productData
		};
		const createdProduct = await prisma.product.create({ data: newProduct });
		console.log(`-> [ÉXITO] Producto "${createdProduct.name}" guardado en la base de datos.`);
		return createdProduct;
	} catch (error) {
		console.error(`-> [ERROR] Fallo al procesar "${searchTerm}":`, error.message);
		return null;
	}
}
// =================================================================
// --- FASE 2: CREACIÓN DE INGREDIENTES Y RECETAS ---
// =================================================================
const BASE_INGREDIENTS = [
	'Pollo', 'Ternera', 'Salmón', 'Lentejas', 'Garbanzos', 'Arroz',
	'Quinoa', 'Patata', 'Brócoli', 'Espinacas', 'Tomate', 'Cebolla', 'Ajo', 'Pimiento'
];
/**
 * Genera un array de pasos para una receta con formato Markdown.
 * @returns {string[]} Un array de strings con los pasos.
 */
function createMarkdownSteps() {
	const numSteps = faker.number.int({ min: 3, max: 6 });
	const steps = [];
	for (let i = 0; i < numSteps; i++) {
		let stepText = faker.lorem.sentence();
		// Añadir Markdown aleatoriamente
		if (Math.random() > 0.5) {
			const wordToEmphasize = faker.helpers.arrayElement(stepText.split(' '));
			const markdownType = Math.random() > 0.5 ? '**' : '*'; // Negrita o cursiva
			stepText = stepText.replace(wordToEmphasize, `${markdownType}${wordToEmphasize}${markdownType}`);
		}
		steps.push(stepText);
	}
	return steps;
}
async function main() {
	console.log('--- Limpiando la base de datos... ---');
	await prisma.recipeIngredient.deleteMany();
	await prisma.recipeUrl.deleteMany();
	await prisma.recipe.deleteMany();
	await prisma.customIngredient.deleteMany();
	await prisma.product.deleteMany();
	console.log('✅ Base de datos limpia.');
	console.log('\n--- Fase 1: Poblando productos desde OpenFoodFacts... ---');
	const productPromises = SEARCH_TERMS_FOR_SEEDING.map(fetchAndCreateProduct);
	const seededProducts = (await Promise.all(productPromises)).filter(p => p !== null);
	console.log(`✅ Fase 1 completada. ${seededProducts.length} productos de OFF procesados.`);
	console.log('\n--- Fase 2: Creando ingredientes personalizados... ---');
	const customIngredients = [];
	for (const name of BASE_INGREDIENTS) {
		const ingredient = await prisma.customIngredient.create({
			data: {
				name: name,
				normalizedName: name.toLowerCase(),
				calories: parseFloat(faker.number.float({ min: 50, max: 500, precision: 0.1 }).toFixed(1)),
				protein: parseFloat(faker.number.float({ min: 0, max: 30, precision: 0.1 }).toFixed(1)),
				fat: parseFloat(faker.number.float({ min: 0, max: 50, precision: 0.1 }).toFixed(1)),
				carbs: parseFloat(faker.number.float({ min: 0, max: 100, precision: 0.1 }).toFixed(1))
			}
		});
		customIngredients.push(ingredient);
	}
	console.log(`✅ Fase 2 completada. ${customIngredients.length} ingredientes personalizados creados.`);
	console.log('\n--- Fase 3: Creando recetas de prueba... ---');
	const allAvailableIngredients = [
		...seededProducts.map((p) => ({ id: p.id, type: 'product', name: p.name })),
		...customIngredients.map((c) => ({ id: c.id, type: 'custom', name: c.name }))
	];
	const usedSlugs = new Set();
	for (let i = 0; i < 200; i++) {
		const mainIngredient = faker.helpers.arrayElement(allAvailableIngredients);
		const recipeTitle = `${mainIngredient.name} ${faker.food.adjective()}`;
		// --- Lógica de Unicidad de Slug para el Seeding ---
		const baseSlug = slugify(recipeTitle, { lower: true, strict: true });
		let finalSlug = baseSlug;
		let counter = 2;
		while (usedSlugs.has(finalSlug)) {
			finalSlug = `${baseSlug}-${counter}`;
			counter++;
		}
		usedSlugs.add(finalSlug);
		// --- Fin de la lógica de unicidad ---
		const otherIngredients = allAvailableIngredients.filter((ing) => ing.id !== mainIngredient.id);
		const secondaryIngredients = faker.helpers.arrayElements(
			otherIngredients,
			faker.number.int({ min: 2, max: 5 })
		);
		const recipeIngredients = [mainIngredient, ...secondaryIngredients];
		console.log(`[RECETA ${i + 1}/200] Creando: "${recipeTitle}" (slug: ${finalSlug})...
`);
		await prisma.recipe.create({
			data: {
				title: recipeTitle,
				slug: finalSlug,
				normalizedTitle: recipeTitle.toLowerCase(),
				steps: createMarkdownSteps(), // Usamos la nueva función
				imageUrl: `https://picsum.photos/seed/${encodeURIComponent(recipeTitle)}/800/600`,
				urls: {
					create: [{ url: faker.internet.url() }]
				},
				ingredients: {
					create: recipeIngredients.map((ing) => ({
						productId: ing.type === 'product' ? ing.id : undefined,
						customIngredientId: ing.type === 'custom' ? ing.id : undefined,
						quantity: parseFloat(faker.number.float({ min: 50, max: 500, precision: 1 }).toFixed(1))
					}))
				}
			}
		});
	}
	console.log('✅ Fase 3 completada. 200 recetas creadas.');
}
main()
	.catch((e) => {
		console.error(e);
		process.exit(1);
	})
	.finally(async () => {
		await prisma.$disconnect();
		console.log('\n🎉 ¡Seeding completado con éxito! La base de datos está lista para usar.');
	});

// --- Ruta: scripts/hash-password.js ---
// Ruta: scripts/hash-password.js
// Uso: node scripts/hash-password.js 'tu_contraseña_aqui'
import { hash } from 'bcryptjs';
const password = process.argv[2];
if (!password) {
	console.error('Por favor, proporciona una contraseña como argumento.');
	process.exit(1);
}
const SALT_ROUNDS = 10;
hash(password, SALT_ROUNDS).then((hash) => {
	console.log('Contraseña:', password);
	console.log('Hash:', hash);
	console.log('\nCopia este hash en tu fichero .env como ADMIN_PASSWORD_HASH');
});

// --- Ruta: prisma/schema.prisma ---
// Ruta: prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "sqlite"
  // Justificación: Se usa una variable de entorno para la URL de la base de datos.
  // Esto permite que los tests apunten a una base de datos separada (`test.db`)
  // sin afectar a la de desarrollo (`dev.db`), aislando los entornos.
  url      = env("DATABASE_URL")
}
model Product {
  id                String             @id // Código de barras
  name              String
  normalizedName    String // Para búsqueda case/accent-insensitive
  brand             String?
  imageUrl          String?
  calories          Float?             // Valor por 100g
  fat               Float?             // Valor por 100g
  protein           Float?             // Valor por 100g
  carbs             Float?             // Valor por 100g
  fullPayload       Json?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  recipeIngredients RecipeIngredient[]
}
model CustomIngredient {
  id                String             @id @default(cuid())
  name              String             @unique
  normalizedName    String // Para búsqueda case/accent-insensitive
  calories          Float
  fat               Float
  protein           Float
  carbs             Float
  recipeIngredients RecipeIngredient[]
}
model Recipe {
  id              String             @id @default(cuid())
  title           String
  slug            String             @unique
  normalizedTitle String // Para búsqueda case/accent-insensitive
  steps           Json
  // Justificación (Paso 1.1): Campo para almacenar la URL de la imagen de la receta.
  // Es opcional para permitir recetas sin imagen o para usar la imagen de una URL de referencia.
  imageUrl    String?
  ingredients RecipeIngredient[]
  // Justificación (Paso 1.1): Relación uno-a-muchos para almacenar las URLs de referencia de la receta.
  urls        RecipeUrl[]
}
// Justificación (Paso 1.1): Nuevo modelo para almacenar las URLs de referencia asociadas a una receta.
// Esto sigue las buenas prácticas de normalización de bases de datos.
model RecipeUrl {
  id       String @id @default(cuid())
  url      String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId String
  @@unique([recipeId, url])
}
model RecipeIngredient {
  id                 String            @id @default(cuid())
  recipe             Recipe            @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId           String
  // Se relaciona directamente con un Product o un CustomIngredient
  product            Product?          @relation(fields: [productId], references: [id])
  productId          String?
  customIngredient   CustomIngredient? @relation(fields: [customIngredientId], references: [id])
  customIngredientId String?
  quantity           Float             // En gramos
}

// --- Ruta: src/demo.spec.ts ---
import { describe, it, expect } from 'vitest';
describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});

// --- Ruta: src/app.html ---
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

// --- Ruta: src/app.d.ts ---
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}
export {};

// --- Ruta: src/routes/page.server.spec.ts ---
// Fichero: src/routes/page.server.spec.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { load, actions } from './+page.server';
import { recipeService } from '$lib/server/services/recipeService';
import { fail } from '@sveltejs/kit';
vi.mock('$lib/server/services/recipeService');
type PageServerLoadEvent = Parameters<typeof load>[0];
type ActionEvent = Parameters<typeof actions.delete>[0];
type Recipes = Awaited<ReturnType<typeof recipeService.findPaginated>>;
// Justificación: Se define explícitamente la estructura del tipo devuelto por `load`.
// La inferencia automática (`Awaited<ReturnType<typeof load>>`) falla debido a los
// genéricos complejos de SvelteKit, por lo que un tipo explícito es más robusto.
interface LoadResult {
	recipes: Recipes;
	hasMore: boolean;
}
describe('+page.server', () => {
	beforeEach(() => {
		vi.resetAllMocks();
	});
	describe('load', () => {
		it('should call findPaginated and return recipes with hasMore: true', async () => {
			const mockRecipes = Array(51).fill({ id: '1', title: 'Receta' });
			vi.mocked(recipeService.findPaginated).mockResolvedValue(mockRecipes as Recipes);
			const result = (await load({} as unknown as PageServerLoadEvent)) as LoadResult;
			expect(recipeService.findPaginated).toHaveBeenCalledWith(null, 51, 0);
			expect(result.recipes).toHaveLength(50);
			expect(result.hasMore).toBe(true);
		});
		it('should call findPaginated and return recipes with hasMore: false', async () => {
			const mockRecipes = Array(30).fill({ id: '1', title: 'Receta' });
			vi.mocked(recipeService.findPaginated).mockResolvedValue(mockRecipes as Recipes);
			const result = (await load({} as unknown as PageServerLoadEvent)) as LoadResult;
			expect(recipeService.findPaginated).toHaveBeenCalledWith(null, 51, 0);
			expect(result.recipes).toHaveLength(30);
			expect(result.hasMore).toBe(false);
		});
	});
	describe('actions.delete', () => {
		beforeEach(() => {
			vi.spyOn(console, 'error').mockImplementation(() => {});
		});
		afterEach(() => {
			vi.mocked(console.error).mockRestore();
		});
		it('should call recipeService.deleteById with the correct id on success', async () => {
			const formData = new FormData();
			formData.append('id', 'recipe-to-delete');
			const mockRequest = {
				formData: async () => formData
			};
			await actions.delete({ request: mockRequest } as unknown as ActionEvent);
			expect(recipeService.deleteById).toHaveBeenCalledWith('recipe-to-delete');
		});
		it('should return a 400 fail if the id is missing', async () => {
			const formData = new FormData();
			const mockRequest = {
				formData: async () => formData
			};
			const result = await actions.delete({ request: mockRequest } as unknown as ActionEvent);
			expect(recipeService.deleteById).not.toHaveBeenCalled();
			expect(result).toEqual(fail(400, { message: 'ID de receta no válido' }));
		});
		it('should return a 500 fail if recipeService.deleteById throws an error', async () => {
			const formData = new FormData();
			formData.append('id', 'recipe-that-fails');
			const mockRequest = {
				formData: async () => formData
			};
			const testError = new Error('Database connection failed');
			vi.mocked(recipeService.deleteById).mockRejectedValue(testError);
			const result = await actions.delete({ request: mockRequest } as unknown as ActionEvent);
			expect(recipeService.deleteById).toHaveBeenCalledWith('recipe-that-fails');
			expect(result).toEqual(
				fail(500, { message: 'No se pudo eliminar la receta. Por favor, inténtelo de nuevo.' })
			);
		});
	});
});

// --- Ruta: src/routes/+page.svelte ---
<!--
// Fichero: src/routes/+page.svelte
// --- VERSIÓN FINAL CON ABORTCONTROLLER ---
-->
<script lang="ts">
	import RecipeCard from '$lib/components/recipes/RecipeCard.svelte';
	import EditQuantitiesDialog from '$lib/components/recipes/EditQuantitiesDialog.svelte';
	import DeleteRecipeDialog from '$lib/components/recipes/DeleteRecipeDialog.svelte';
	import { Button } from '$lib/components/ui/button/index.js';
	import { Input } from '$lib/components/ui/input/index.js';
	import Plus from 'lucide-svelte/icons/plus';
	import SlidersHorizontal from 'lucide-svelte/icons/sliders-horizontal';
	const RECIPES_PER_PAGE = 50;
	let { data } = $props();
	type Recipe = (typeof data.recipes)[number];
	// --- ESTADO REACTIVO ---
	let recipes = $state(data.recipes);
	let searchQuery = $state('');
	let isLoading = $state(false);
	let hasMore = $state(data.hasMore);
	let sentinel: HTMLDivElement | undefined = $state();
	let controller: AbortController;
	let selectedRecipe = $state<Recipe | null>(null);
	let isEditDialogOpen = $state(false);
	let isDeleteDialogOpen = $state(false);
	const isAdmin = $derived(!!data.user?.isAdmin);
	// --- LÓGICA DE CARGA Y BÚSQUEDA ---
	async function fetchRecipes(isNewSearch = false) {
		if (isLoading && !isNewSearch) return;
		isLoading = true;
		const offset = isNewSearch ? 0 : recipes.length;
		// Justificación: Se usa AbortController para la búsqueda simple, manteniendo
		// la consistencia con la búsqueda avanzada y previniendo race conditions.
		if (isNewSearch) {
			controller?.abort();
			controller = new AbortController();
		}
		const signal = controller?.signal;
		const url = `/api/recipes?q=${encodeURIComponent(searchQuery)}&limit=${RECIPES_PER_PAGE}&offset=${offset}`;
		try {
			const response = await fetch(url, { signal });
			const result = await response.json();
			if (signal?.aborted) return;
			if (isNewSearch) {
				recipes = result.recipes;
			} else {
				recipes.push(...result.recipes);
			}
			hasMore = result.hasMore;
		} catch (error) {
			if (error instanceof DOMException && error.name === 'AbortError') {
				return;
			}
			console.error('Error al cargar recetas:', error);
		} finally {
			if (!signal?.aborted) {
				isLoading = false;
			}
		}
	}
	$effect(() => {
		searchQuery; // Dependencia del efecto
		const handler = setTimeout(() => {
			fetchRecipes(true);
		}, 300); // Se mantiene un pequeño debounce aquí para no lanzar búsquedas en cada letra
		return () => clearTimeout(handler);
	});
	$effect(() => {
		if (!sentinel) return;
		const observer = new IntersectionObserver((entries) => {
			if (entries[0].isIntersecting && hasMore && !isLoading) {
				fetchRecipes();
			}
		});
		observer.observe(sentinel);
		return () => observer.disconnect();
	});
	function handleOpenEditDialog(recipe: Recipe) {
		selectedRecipe = recipe;
		isEditDialogOpen = true;
	}
	function handleOpenDeleteDialog(recipe: Recipe) {
		selectedRecipe = recipe;
		isDeleteDialogOpen = true;
	}
</script>
<div class="container mx-auto p-4 md:p-8">
	<header class="flex items-center justify-between gap-2 mb-8">
		<div class="relative flex-grow">
			<Input bind:value={searchQuery} placeholder="Buscar por receta o ingrediente..." />
		</div>
		<Button href="/recetas/busqueda-avanzada" variant="ghost" size="icon" aria-label="Búsqueda avanzada">
			<SlidersHorizontal class="h-4 w-4" />
		</Button>
		<Button href="/recetas/nueva">
			<Plus class="mr-2 h-4 w-4" />
			Añadir Receta
		</Button>
	</header>
	<main class="columns-1 md:columns-2 lg:columns-3 xl:columns-4 gap-4">
		{#each recipes as recipe (recipe.id)}
			<div class="mb-4 break-inside-avoid">
				<RecipeCard
					{recipe}
					{isAdmin}
					onEditQuantities={() => handleOpenEditDialog(recipe)}
					onDelete={() => handleOpenDeleteDialog(recipe)}
				/>
			</div>
		{/each}
	</main>
	{#if hasMore}
		<div bind:this={sentinel} class="h-10 flex justify-center items-center text-muted-foreground">
			{#if isLoading}
				<span>Cargando...</span>
			{/if}
		</div>
	{/if}
	{#if recipes.length === 0 && !isLoading}
		<div class="col-span-full text-center py-16 text-muted-foreground">
			<p class="text-lg font-medium">No se encontraron recetas.</p>
			<p>Prueba con otro término de búsqueda o añade una nueva receta.</p>
		</div>
	{/if}
</div>
<EditQuantitiesDialog
	recipe={selectedRecipe}
	bind:open={isEditDialogOpen}
	onOpenChange={(isOpen: boolean) => (isEditDialogOpen = isOpen)}
/>
<DeleteRecipeDialog
	recipe={selectedRecipe}
	bind:open={isDeleteDialogOpen}
	onOpenChange={(isOpen: boolean) => (isDeleteDialogOpen = isOpen)}
/>

// --- Ruta: src/routes/+page.server.ts ---
import type { PageServerLoad, Actions } from './$types';
import { recipeService } from '$lib/server/services/recipeService';
import { fail } from '@sveltejs/kit';
const RECIPES_PER_PAGE = 50;
/**
 * Función `load` para la carga inicial de datos.
 * Carga el primer lote de recetas de forma paginada.
 */
export const load: PageServerLoad = async () => {
	// Justificación: Se llama a `findPaginated` para cargar solo la primera página
	// de resultados. Esto mejora drásticamente el tiempo de carga inicial.
	// Se solicita un elemento más para determinar si hay más páginas.
	const recipesPlusOne = await recipeService.findPaginated(null, RECIPES_PER_PAGE + 1, 0);
	const hasMore = recipesPlusOne.length > RECIPES_PER_PAGE;
	const recipes = recipesPlusOne.slice(0, RECIPES_PER_PAGE);
	return {
		recipes,
		hasMore
	};
};
/**
 * Acciones del servidor para la página de recetas.
 */
export const actions: Actions = {
	/**
	 * Acción `delete`: Gestiona la eliminación de una receta.
	 */
	delete: async ({ request }) => {
		const data = await request.formData();
		const id = data.get('id');
		if (typeof id !== 'string' || !id) {
			return fail(400, { message: 'ID de receta no válido' });
		}
		try {
			await recipeService.deleteById(id);
			return {
				status: 200,
				message: 'Receta eliminada correctamente'
			};
		} catch (error) {
			console.error('Error al eliminar la receta:', error);
			return fail(500, {
				message: 'No se pudo eliminar la receta. Por favor, inténtelo de nuevo.'
			});
		}
	}
};

// --- Ruta: src/routes/+layout.svelte ---
<script>
	import '../app.css';
	let { children } = $props();
</script>
{@render children()}

// --- Ruta: src/routes/+layout.server.ts ---
import { redirect } from '@sveltejs/kit';
import type { LayoutServerLoad } from './$types';
import { verifyToken } from '$lib/server/auth';
// Fichero: src/routes/+layout.server.ts
// Este load se ejecuta en cada petición del lado del servidor.
// Su propósito es proteger todas las rutas y asegurar que solo usuarios
// autenticados puedan acceder a la aplicación.
export const load: LayoutServerLoad = async ({ cookies, url }) => {
	// Excluimos la ruta de login de la verificación para evitar un bucle de redirecciones.
	if (url.pathname === '/login') {
		return {};
	}
	const token = cookies.get('session');
	// Si no hay token, el usuario no está autenticado.
	// Redirigimos a la página de login.
	if (!token) {
		throw redirect(307, '/login');
	}
	try {
		// Verificamos la validez del token. La función `verifyToken` se encarga
		// de la lógica de validación criptográfica.
		const user = await verifyToken(token);
		// Si el token es válido, devolvemos los datos del usuario.
		// Estos datos estarán disponibles en el objeto `data` en las páginas y layouts.
		return {
			user
		};
	} catch (error) {
		// Si el token es inválido (expirado, malformado, etc.), lo consideramos un fallo de autenticación.
		console.error('Fallo en la verificación del token:', error);
		// Eliminamos la cookie inválida para limpiar el estado del cliente.
		cookies.delete('session', { path: '/' });
		// Redirigimos al usuario a la página de login.
		throw redirect(307, '/login');
	}
};

// --- Ruta: prisma/migrations/migration_lock.toml ---
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "sqlite"

// --- Ruta: src/lib/utils.ts ---
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';
export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}
/**
 * Normaliza un texto para búsquedas: lo convierte a minúsculas y elimina los acentos.
 * Ejemplo: "Azúcar Moreno" -> "azucar moreno"
 * @param text - El texto a normalizar.
 * @returns El texto normalizado.
 */
export function normalizeText(text: string): string {
	return text
		.toLowerCase()
		.normalize('NFD') // Descompone los caracteres acentuados en base + diacrítico
		.replace(/[\u0300-\u036f]/g, ''); // Elimina los diacríticos
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type WithoutChild<T> = T extends { child?: any } ? Omit<T, 'child'> : T;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type WithoutChildren<T> = T extends { children?: any } ? Omit<T, 'children'> : T;
export type WithoutChildrenOrChild<T> = WithoutChildren<WithoutChild<T>>;
export type WithElementRef<T, U extends HTMLElement = HTMLElement> = T & { ref?: U | null };

// --- Ruta: src/lib/recipeCalculator.ts ---
// Ruta: src/lib/recipeCalculator.ts
// Justificación: Aislar la lógica de cálculo en funciones puras hace que el código
// sea más predecible, fácil de testear y reutilizable. Este módulo no tiene
// dependencias externas (como Prisma o APIs), solo recibe datos y devuelve un resultado.
// Definimos un tipo para los ingredientes que usará la calculadora.
// Esto nos desacopla de los modelos de Prisma.
export type CalculableIngredient = {
	quantity: number; // en gramos
	calories?: number | null; // por 100g
	protein?: number | null;
	fat?: number | null;
	carbs?: number | null;
};
export type NutritionalInfo = {
	totalCalories: number;
	totalProtein: number;
	totalFat: number;
	totalCarbs: number;
};
/**
 * Calcula la información nutricional total para una lista de ingredientes.
 * @param ingredients - Un array de ingredientes con su cantidad y valores nutricionales por 100g.
 * @returns Un objeto con los totales de calorías, proteínas, grasas y carbohidratos.
 */
export function calculateNutritionalInfo(ingredients: CalculableIngredient[]): NutritionalInfo {
	const totals: NutritionalInfo = {
		totalCalories: 0,
		totalProtein: 0,
		totalFat: 0,
		totalCarbs: 0
	};
	for (const ingredient of ingredients) {
		const factor = ingredient.quantity / 100;
		totals.totalCalories += (ingredient.calories || 0) * factor;
		totals.totalProtein += (ingredient.protein || 0) * factor;
		totals.totalFat += (ingredient.fat || 0) * factor;
		totals.totalCarbs += (ingredient.carbs || 0) * factor;
	}
	// Redondeamos a 2 decimales para una mejor presentación
	return {
		totalCalories: Math.round(totals.totalCalories * 100) / 100,
		totalProtein: Math.round(totals.totalProtein * 100) / 100,
		totalFat: Math.round(totals.totalFat * 100) / 100,
		totalCarbs: Math.round(totals.totalCarbs * 100) / 100
	};
}

// --- Ruta: src/lib/recipeCalculator.spec.ts ---
// Fichero: src/lib/recipeCalculator.spec.ts
import { describe, it, expect } from 'vitest';
import { calculateNutritionalInfo, type CalculableIngredient } from './recipeCalculator';
// Justificación: Se crea una suite de tests para la función `calculateNutritionalInfo`.
// El objetivo es asegurar la precisión de los cálculos nutricionales, que son una
// característica crítica de la aplicación.
describe('calculateNutritionalInfo', () => {
	// Test 1: Cálculo básico con datos completos.
	it('should calculate totals correctly for a list of standard ingredients', () => {
		const ingredients: CalculableIngredient[] = [
			{ quantity: 150, calories: 100, protein: 10, fat: 5, carbs: 20 }, // 1.5x
			{ quantity: 50, calories: 200, protein: 2, fat: 1, carbs: 40 } // 0.5x
		];
		const result = calculateNutritionalInfo(ingredients);
		expect(result.totalCalories).toBe(150 + 100); // 250
		expect(result.totalProtein).toBe(15 + 1); // 16
		expect(result.totalFat).toBe(7.5 + 0.5); // 8
		expect(result.totalCarbs).toBe(30 + 20); // 50
	});
	// Test 2: Manejo de un array de ingredientes vacío.
	it('should return all zeros when the ingredient list is empty', () => {
		const ingredients: CalculableIngredient[] = [];
		const result = calculateNutritionalInfo(ingredients);
		expect(result.totalCalories).toBe(0);
		expect(result.totalProtein).toBe(0);
		expect(result.totalFat).toBe(0);
		expect(result.totalCarbs).toBe(0);
	});
	// Test 3: Manejo de valores nulos o indefinidos.
	it('should treat null or undefined nutritional values as zero', () => {
		const ingredients: CalculableIngredient[] = [
			{ quantity: 100, calories: 100, protein: 10, fat: null, carbs: 20 },
			{ quantity: 100, calories: 50, protein: 5, fat: 5, carbs: undefined }
		];
		const result = calculateNutritionalInfo(ingredients);
		expect(result.totalCalories).toBe(150);
		expect(result.totalProtein).toBe(15);
		expect(result.totalFat).toBe(5); // Solo el segundo ingrediente aporta grasa.
		expect(result.totalCarbs).toBe(20); // Solo el primer ingrediente aporta carbohidratos.
	});
	// Test 4: Ingredientes con cantidad cero.
	it('should contribute nothing to the totals if an ingredient has zero quantity', () => {
		const ingredients: CalculableIngredient[] = [
			{ quantity: 100, calories: 100, protein: 10, fat: 10, carbs: 10 },
			{ quantity: 0, calories: 1000, protein: 100, fat: 100, carbs: 100 } // Este no debe contar.
		];
		const result = calculateNutritionalInfo(ingredients);
		expect(result.totalCalories).toBe(100);
		expect(result.totalProtein).toBe(10);
		expect(result.totalFat).toBe(10);
		expect(result.totalCarbs).toBe(10);
	});
	// Test 5: Precisión con números decimales.
	it('should handle floating point numbers correctly and round to 2 decimal places', () => {
		const ingredients: CalculableIngredient[] = [
			{ quantity: 125.5, calories: 88.5, protein: 5.25, fat: 2.75, carbs: 10.5 }
		];
		const result = calculateNutritionalInfo(ingredients);
		// (125.5 / 100) * 88.5 = 111.0675 -> 111.07
		expect(result.totalCalories).toBe(111.07);
		// (125.5 / 100) * 5.25 = 6.58875 -> 6.59
		expect(result.totalProtein).toBe(6.59);
		// (125.5 / 100) * 2.75 = 3.45125 -> 3.45
		expect(result.totalFat).toBe(3.45);
		// (125.5 / 100) * 10.5 = 13.1775 -> 13.18
		expect(result.totalCarbs).toBe(13.18);
	});
});

// --- Ruta: src/lib/index.ts ---
// place files you want to import through the `$lib` alias in this folder.

// --- Ruta: src/routes/login/+page.svelte ---
<!-- Ruta: src/routes/login/+page.svelte -->
<script lang="ts">
	import { enhance } from '$app/forms';
	import type { ActionData } from './$types';
	import * as Card from '$lib/components/ui/card';
	import { Button } from '$lib/components/ui/button';
	import { Input } from '$lib/components/ui/input';
	import { Label } from '$lib/components/ui/label';
	export let form: ActionData;
	let loading = false;
</script>
<div class="flex min-h-screen items-center justify-center bg-muted/40">
	<Card.Root class="w-full max-w-sm">
		<Card.Header class="space-y-1 text-center">
			<Card.Title class="text-2xl font-bold">Admin Login</Card.Title>
			<Card.Description>Introduce tus credenciales para acceder al panel</Card.Description>
		</Card.Header>
		<Card.Content>
			<!-- Justificación (form action y enhance): Se usa un <form> estándar con un `action`
			que apunta a la acción por defecto de esta misma página (`?/default`).
			`use:enhance` intercepta el envío, lo hace vía fetch, y maneja el resultado
			(actualizar `form`, redirigir, etc.) de forma automática y robusta. -->
			<form
				method="POST"
				action="?/login"
				use:enhance={() => {
					loading = true;
					return async ({ update }) => {
						await update();
						loading = false;
					};
				}}
				class="space-y-4"
			>
				<div class="space-y-2">
					<Label for="user">Usuario</Label>
					<Input id="user" name="user" type="text" required />
				</div>
				<div class="space-y-2">
					<Label for="password">Contraseña</Label>
					<Input id="password" name="password" type="password" required />
				</div>
				{#if form?.message}
					<p class="text-sm font-medium text-destructive">{form.message}</p>
				{/if}
				<Button type="submit" class="w-full" disabled={loading}>
					{loading ? 'Entrando...' : 'Entrar'}
				</Button>
			</form>
		</Card.Content>
	</Card.Root>
</div>

// --- Ruta: src/routes/login/+page.server.ts ---
// Ruta: src/routes/login/+page.server.ts
import { type Actions, fail, redirect } from '@sveltejs/kit';
import { comparePasswords, createSessionToken } from '$lib/server/auth';
import { env } from '$env/dynamic/private';
// Justificación: Se define una 'action' de SvelteKit en lugar de un endpoint de API.
// Esto integra el manejo del formulario directamente con el ciclo de vida de la página,
// lo que es más robusto y la forma idiomática de manejar envíos de formularios en SvelteKit.
export const actions: Actions = {
	login: async ({ request, cookies }) => {
		const data = await request.formData();
		const user = data.get('user');
		const password = data.get('password');
		// 1. Validación de entrada
		if (!user || !password || typeof user !== 'string' || typeof password !== 'string') {
			return fail(400, { message: 'Usuario y contraseña son requeridos' });
		}
		// 2. Verificación de credenciales
		if (!env.ADMIN_PASSWORD_HASH) {
			console.error('La variable de entorno ADMIN_PASSWORD_HASH no está configurada.');
			return fail(500, { message: 'Error de configuración en el servidor' });
		}
		const isAdminUser = user === 'juanjocerero';
		const isPasswordValid = await comparePasswords(password, env.ADMIN_PASSWORD_HASH);
		if (!isAdminUser || !isPasswordValid) {
			return fail(401, { message: 'Credenciales inválidas' });
		}
		// 3. Creación del token y establecimiento de la cookie
		const token = await createSessionToken({ sub: 'admin' });
		cookies.set('session', token, {
			path: '/',
			httpOnly: true,
			secure: process.env.NODE_ENV === 'production',
			sameSite: 'strict',
			maxAge: 60 * 60 * 24 // 1 día
		});
		// 4. Redirección
		// Justificación (redirect): En lugar de devolver un JSON, una 'action' exitosa
		// puede lanzar una redirección. SvelteKit la gestionará correctamente,
		// tanto en el lado del servidor como en el cliente (si se usa `enhance`).
		throw redirect(303, '/');
	}
};

// --- Ruta: prisma/migrations/20250803163534_add_recipe_slug/migration.sql ---
/*
  Warnings:
  - Added the required column `slug` to the `Recipe` table without a default value. This is not possible if the table is not empty.
*/
-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_Recipe" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "normalizedTitle" TEXT NOT NULL,
    "steps" JSONB NOT NULL,
    "imageUrl" TEXT
);
INSERT INTO "new_Recipe" ("id", "imageUrl", "normalizedTitle", "steps", "title") SELECT "id", "imageUrl", "normalizedTitle", "steps", "title" FROM "Recipe";
DROP TABLE "Recipe";
ALTER TABLE "new_Recipe" RENAME TO "Recipe";
CREATE UNIQUE INDEX "Recipe_slug_key" ON "Recipe"("slug");
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250802143934_add_normalized_title_to_recipe/migration.sql ---
/*
  Warnings:
  - Added the required column `normalizedTitle` to the `Recipe` table without a default value. This is not possible if the table is not empty.
*/
-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_Recipe" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "normalizedTitle" TEXT NOT NULL,
    "description" TEXT,
    "steps" TEXT NOT NULL,
    "imageUrl" TEXT
);
INSERT INTO "new_Recipe" ("description", "id", "imageUrl", "steps", "title") SELECT "description", "id", "imageUrl", "steps", "title" FROM "Recipe";
DROP TABLE "Recipe";
ALTER TABLE "new_Recipe" RENAME TO "Recipe";
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250803153006_remove_description_and_json_steps/migration.sql ---
/*
  Warnings:
  - You are about to drop the column `description` on the `Recipe` table. All the data in the column will be lost.
  - You are about to alter the column `steps` on the `Recipe` table. The data in that column could be lost. The data in that column will be cast from `String` to `Json`.
*/
-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_Recipe" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "normalizedTitle" TEXT NOT NULL,
    "steps" JSONB NOT NULL,
    "imageUrl" TEXT
);
INSERT INTO "new_Recipe" ("id", "imageUrl", "normalizedTitle", "steps", "title") SELECT "id", "imageUrl", "normalizedTitle", "steps", "title" FROM "Recipe";
DROP TABLE "Recipe";
ALTER TABLE "new_Recipe" RENAME TO "Recipe";
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250801182228_add_recipe_images_and_urls/migration.sql ---
-- AlterTable
ALTER TABLE "Recipe" ADD COLUMN "imageUrl" TEXT;
-- CreateTable
CREATE TABLE "RecipeUrl" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "url" TEXT NOT NULL,
    "recipeId" TEXT NOT NULL,
    CONSTRAINT "RecipeUrl_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);
-- CreateIndex
CREATE UNIQUE INDEX "RecipeUrl_recipeId_url_key" ON "RecipeUrl"("recipeId", "url");

// --- Ruta: prisma/migrations/20250801180502_init/migration.sql ---
/*
  Warnings:
  - You are about to drop the `ProductCache` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the column `productCacheId` on the `RecipeIngredient` table. All the data in the column will be lost.
*/
-- DropTable
PRAGMA foreign_keys=off;
DROP TABLE "ProductCache";
PRAGMA foreign_keys=on;
-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "normalizedName" TEXT NOT NULL,
    "brand" TEXT,
    "imageUrl" TEXT,
    "calories" REAL,
    "fat" REAL,
    "protein" REAL,
    "carbs" REAL,
    "fullPayload" JSONB,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);
-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_CustomIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "normalizedName" TEXT NOT NULL,
    "calories" REAL NOT NULL,
    "fat" REAL NOT NULL,
    "protein" REAL NOT NULL,
    "carbs" REAL NOT NULL
);
INSERT INTO "new_CustomIngredient" ("calories", "carbs", "fat", "id", "name", "normalizedName", "protein") SELECT "calories", "carbs", "fat", "id", "name", "normalizedName", "protein" FROM "CustomIngredient";
DROP TABLE "CustomIngredient";
ALTER TABLE "new_CustomIngredient" RENAME TO "CustomIngredient";
CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name");
CREATE TABLE "new_RecipeIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "recipeId" TEXT NOT NULL,
    "productId" TEXT,
    "customIngredientId" TEXT,
    "quantity" REAL NOT NULL,
    CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_customIngredientId_fkey" FOREIGN KEY ("customIngredientId") REFERENCES "CustomIngredient" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);
INSERT INTO "new_RecipeIngredient" ("customIngredientId", "id", "quantity", "recipeId") SELECT "customIngredientId", "id", "quantity", "recipeId" FROM "RecipeIngredient";
DROP TABLE "RecipeIngredient";
ALTER TABLE "new_RecipeIngredient" RENAME TO "RecipeIngredient";
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250731184218_add_normalized_names/migration.sql ---
-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_CustomIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "normalizedName" TEXT NOT NULL DEFAULT '',
    "calories" REAL NOT NULL,
    "fat" REAL NOT NULL,
    "protein" REAL NOT NULL,
    "carbs" REAL NOT NULL
);
INSERT INTO "new_CustomIngredient" ("calories", "carbs", "fat", "id", "name", "protein") SELECT "calories", "carbs", "fat", "id", "name", "protein" FROM "CustomIngredient";
DROP TABLE "CustomIngredient";
ALTER TABLE "new_CustomIngredient" RENAME TO "CustomIngredient";
CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name");
CREATE TABLE "new_ProductCache" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "productName" TEXT NOT NULL,
    "normalizedProductName" TEXT NOT NULL DEFAULT '',
    "brand" TEXT,
    "imageUrl" TEXT,
    "calories" REAL,
    "fat" REAL,
    "protein" REAL,
    "carbs" REAL,
    "fullPayload" JSONB,
    "updatedAt" DATETIME NOT NULL
);
INSERT INTO "new_ProductCache" ("brand", "calories", "carbs", "fat", "fullPayload", "id", "imageUrl", "productName", "protein", "updatedAt") SELECT "brand", "calories", "carbs", "fat", "fullPayload", "id", "imageUrl", "productName", "protein", "updatedAt" FROM "ProductCache";
DROP TABLE "ProductCache";
ALTER TABLE "new_ProductCache" RENAME TO "ProductCache";
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250730185406_init/migration.sql ---
-- CreateTable
CREATE TABLE "ProductCache" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "productName" TEXT NOT NULL,
    "brand" TEXT,
    "imageUrl" TEXT,
    "calories" REAL,
    "fat" REAL,
    "protein" REAL,
    "carbs" REAL,
    "fullPayload" JSONB,
    "updatedAt" DATETIME NOT NULL
);
-- CreateTable
CREATE TABLE "CustomIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "calories" REAL NOT NULL,
    "fat" REAL NOT NULL,
    "protein" REAL NOT NULL,
    "carbs" REAL NOT NULL
);
-- CreateTable
CREATE TABLE "Recipe" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "steps" TEXT NOT NULL
);
-- CreateTable
CREATE TABLE "RecipeIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "recipeId" TEXT NOT NULL,
    "productCacheId" TEXT,
    "customIngredientId" TEXT,
    "quantity" REAL NOT NULL,
    CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_productCacheId_fkey" FOREIGN KEY ("productCacheId") REFERENCES "ProductCache" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_customIngredientId_fkey" FOREIGN KEY ("customIngredientId") REFERENCES "CustomIngredient" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);
-- CreateIndex
CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name");

// --- Ruta: src/lib/server/zodErrors.ts ---
// Ruta: src/lib/server/zodErrors.ts
import type { ZodError } from 'zod';
/**
 * Crea una respuesta de fallo estandarizada para las acciones de formulario de SvelteKit.
 * Garantiza que el objeto devuelto siempre tenga la misma estructura.
 *
 * @param message - El mensaje de error general que se mostrará al usuario.
 * @param error - (Opcional) Un error de Zod. Si se proporciona, se formateará
 *                y se añadirá al campo `errors`.
 * @returns Un objeto consistente para ser usado con `fail()`.
 */
export function createFailResponse(message: string, error?: ZodError) {
	const response: { message: string; errors: Record<string, string | undefined> } = {
		message,
		errors: {}
	};
	if (error) {
		for (const issue of error.issues) {
			if (issue.path.length > 0) {
				const field = issue.path.join('.');
				if (!response.errors[field]) {
					response.errors[field] = issue.message;
				}
			}
		}
	}
	return response;
}

// --- Ruta: src/lib/server/slug.ts ---
// Ruta: src/lib/server/slug.ts
import slugify from 'slugify';
import prisma from '$lib/server/prisma';
/**
 * Genera un slug único para una receta a partir de su título.
 * Si el slug inicial ya existe, le añade un sufijo numérico incremental.
 * @param {string} title - El título de la receta.
 * @returns {Promise<string>} Un slug único garantizado.
 */
export async function generateUniqueSlug(title: string): Promise<string> {
	const baseSlug = slugify(title, { lower: true, strict: true });
	let uniqueSlug = baseSlug;
	let counter = 2;
	// Hacemos un bucle para encontrar un slug que no exista en la base de datos.
	// Esto previene errores de constraint 'unique' al insertar.
	while (await prisma.recipe.findUnique({ where: { slug: uniqueSlug } })) {
		uniqueSlug = `${baseSlug}-${counter}`;
		counter++;
	}
	return uniqueSlug;
}

// --- Ruta: src/lib/server/prisma.ts ---
// Ruta: src/lib/server/prisma.ts
import { PrismaClient } from '@prisma/client';
// Justificación: Se sigue el patrón singleton recomendado por Prisma
// para evitar crear múltiples conexiones a la base de datos en entornos
// serverless o durante el hot-reloading en desarrollo.
// La importación desde '@prisma/client' funciona porque `npx prisma generate`
// redirige este alias a la implementación generada en `node_modules/.prisma/client`.
const prisma = new PrismaClient();
export default prisma;

// --- Ruta: src/lib/server/auth.ts ---
// Ruta: src/lib/server/auth.ts
import { SignJWT, jwtVerify } from 'jose';
import { hash, compare } from 'bcryptjs';
import { env } from '$env/dynamic/private';
// Justificación (bcrypt): Usamos bcrypt para hashear contraseñas. Es un algoritmo
// adaptativo y lento por diseño, lo que lo hace resistente a ataques de fuerza bruta.
const SALT_ROUNDS = 10; // Número de rondas de salting. 10 es un buen equilibrio.
export async function hashPassword(password: string) {
	return await hash(password, SALT_ROUNDS);
}
export async function comparePasswords(password: string, hash: string) {
	return await compare(password, hash);
}
// Justificación (JWT en Cookie): Usamos JSON Web Tokens (JWT) para gestionar sesiones.
// El token se firma en el servidor con un secreto y se envía al cliente en una cookie
// HttpOnly, lo que previene el acceso desde JavaScript (ataques XSS).
// Justificación: Se comprueba que la variable de entorno crítica exista al iniciar.
// Si no, es un error de configuración del servidor y la aplicación no debe arrancar.
if (!env.SESSION_SECRET) {
	throw new Error(
		'La variable de entorno SESSION_SECRET no está configurada. La aplicación no puede iniciarse de forma segura.'
	);
}
const secret = new TextEncoder().encode(env.SESSION_SECRET);
const algorithm = 'HS256'; // Algoritmo de firma
export async function createSessionToken(payload: { sub: string; [key: string]: unknown }) {
	return await new SignJWT(payload)
		.setProtectedHeader({ alg: algorithm })
		.setExpirationTime('24h') // El token expira en 24 horas
		.setIssuedAt()
		.setSubject(payload.sub)
		.sign(secret);
}
export async function verifyToken(token: string) {
	try {
		const { payload } = await jwtVerify(token, secret, {
			algorithms: [algorithm]
		});
		// Justificación: Añadimos explícitamente la propiedad `isAdmin` si el
		// sujeto (sub) del token es 'admin'. Esto asegura que el objeto `user`
		// que se pasa a la aplicación contiene la información de rol necesaria.
		const user = {
			sub: payload.sub,
			isAdmin: payload.sub === 'admin'
		};
		return user;
	} catch (error) {
		return null; // El token es inválido o ha expirado
	}
}

// --- Ruta: src/lib/schemas/searchSchema.ts ---
// Fichero: src/lib/schemas/searchSchema.ts
import { z } from 'zod';
// Justificación: Se define un esquema de Zod para validar el cuerpo (body)
// de las peticiones de búsqueda avanzada. Esto asegura que los datos que llegan
// al endpoint tienen la forma correcta, previniendo errores y ataques.
const RangeFilterSchema = z.object({
	min: z.coerce.number().optional(),
	max: z.coerce.number().optional()
});
const GramsFilterSchema = z.object({
	calories: RangeFilterSchema.optional(),
	protein: RangeFilterSchema.optional(),
	carbs: RangeFilterSchema.optional(),
	fat: RangeFilterSchema.optional()
});
const PercentFilterSchema = z.object({
	protein: RangeFilterSchema.optional(),
	carbs: RangeFilterSchema.optional(),
	fat: RangeFilterSchema.optional()
});
export const SearchFiltersSchema = z.object({
	ingredients: z.array(z.string()).optional(),
	grams: GramsFilterSchema.optional(),
	percent: PercentFilterSchema.optional(),
	sortBy: z.string().optional(),
	limit: z.coerce.number().default(50),
	offset: z.coerce.number().default(0)
});
export type SearchFilters = z.infer<typeof SearchFiltersSchema>;

// --- Ruta: src/lib/schemas/recipeSchema.ts ---
// Ruta: src/lib/schemas/recipeSchema.ts
import { z } from 'zod';
// Justificación: Este es el esquema para un único ingrediente DENTRO de una receta.
// Es el Data Transfer Object (DTO) que esperamos del frontend.
const RecipeIngredientSchema = z.object({
	id: z.string(), // ID del ProductCache o CustomIngredient
	type: z.enum(['product', 'custom']), // Para saber a qué tabla enlazar
	quantity: z.coerce.number().positive({ message: 'La cantidad debe ser mayor que cero.' })
});
// Justificación: Esquema principal para la creación y actualización de recetas.
// Valida la estructura completa del objeto que se enviará a la API.
export const RecipeSchema = z.object({
	title: z.string().min(1, { message: 'El título no puede estar vacío.' }),
	steps: z
		.array(z.string().min(1, { message: 'El paso no puede estar vacío.' }))
		.min(1, { message: 'Debe haber al menos un paso.' }),
	ingredients: z
		.array(RecipeIngredientSchema)
		.min(1, { message: 'La receta debe tener al menos un ingrediente.' }),
	// Justificación (Paso 3.1): Añadimos la validación para la URL de la imagen.
	// Debe ser una cadena opcional que puede ser un data URL.
	imageUrl: z.string().optional(),
	// Justificación (Paso 3.1): Añadimos la validación para las URLs de referencia.
	// Debe ser un array de strings que sean URLs válidas.
	urls: z.array(z.string().url({ message: 'La URL no es válida.' })).optional()
});
// Exportamos los tipos inferidos para usarlos en el código sin tener que
// depender directamente de Zod, mejorando el desacoplamiento.
export type RecipeIngredient = z.infer<typeof RecipeIngredientSchema>;
export type RecipeData = z.infer<typeof RecipeSchema>;

// --- Ruta: src/lib/schemas/ingredientSchema.ts ---
// Ruta: src/lib/schemas/ingredientSchema.ts
import { z } from 'zod';
// Justificación: Se exporta como 'const' para que sea un valor en tiempo de ejecución.
// Esto permite que otros módulos lo importen para usarlo en funciones como 'z.infer'
// y para la validación de datos. 'verbatimModuleSyntax' en tsconfig.json lo requiere.
export const IngredientSchema = z.object({
	name: z.string().min(1, { message: 'El nombre no puede estar vacío.' }),
	// Usamos z.coerce.number() para convertir la entrada (que puede ser string) a número.
	calories: z.coerce.number().min(0, { message: 'Las calorías no pueden ser negativas.' }),
	fat: z.coerce.number().min(0, { message: 'La grasa no puede ser negativa.' }),
	protein: z.coerce.number().min(0, { message: 'La proteína no puede ser negativa.' }),
	carbs: z.coerce.number().min(0, { message: 'Los carbohidratos no pueden ser negativos.' })
});
// Exportamos también el tipo inferido para usarlo en el frontend o donde se necesite
// la forma de los datos sin importar el validador.
export type Ingredient = z.infer<typeof IngredientSchema>;

// --- Ruta: src/lib/runes/useDebounce.svelte.ts ---
// Fichero: src/lib/runes/useDebounce.svelte.ts
/**
 * Una runa de Svelte 5 personalizada que retrasa la actualización de un valor.
 * @param value La señal reactiva cuyo valor se quiere retrasar.
 * @param delay El tiempo de espera en milisegundos.
 * @returns Una nueva señal que contiene el valor retrasado.
 */
export function useDebounce<T>(value: () => T, delay: number): () => T {
	let debouncedValue = $state(value());
	let timeoutId: ReturnType<typeof setTimeout> | null = null;
	$effect(() => {
		const currentValue = value();
		if (timeoutId) {
			clearTimeout(timeoutId);
		}
		timeoutId = setTimeout(() => {
			debouncedValue = currentValue;
		}, delay);
		return () => {
			if (timeoutId) {
				clearTimeout(timeoutId);
			}
		};
	});
	return () => debouncedValue;
}

// --- Ruta: src/routes/recetas/nueva/+page.svelte ---
<!-- Ruta: src/routes/recetas/nueva/+page.svelte -->
<script lang="ts">
	import { Button } from '$lib/components/ui/button';
	import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card';
	import { Input } from '$lib/components/ui/input';
	import { Label } from '$lib/components/ui/label';
	import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table';
	import { Textarea } from '$lib/components/ui/textarea';
	import { calculateNutritionalInfo, type CalculableIngredient } from '$lib/recipeCalculator';
	import type { RecipeIngredient } from '$lib/schemas/recipeSchema';
	import * as Popover from '$lib/components/ui/popover';
	import * as Command from '$lib/components/ui/command';
	import { ChevronsUpDown, Trash2 } from 'lucide-svelte';
	import { enhance } from '$app/forms';
	import type { ActionData } from './$types';
	import UrlImageFetcher from '$lib/components/recipes/UrlImageFetcher.svelte';
	let { form }: { form: ActionData } = $props();
	type IngredientWithDetails = RecipeIngredient & CalculableIngredient & { name: string };
	type SearchResult = {
		id: string;
		name: string;
		source: 'local' | 'off';
		type: 'custom' | 'product';
		imageUrl: string | null;
	};
	// --- Estado del formulario ---
	let title = $state('');
	let steps = $state(['']);
	let imageUrl = $state('');
	let urls = $state<string[]>([]);
	let ingredients = $state<IngredientWithDetails[]>([]);
	// --- Estado del buscador de ingredientes ---
	let searchResults = $state<SearchResult[]>([]);
	let isSearching = $state(false);
	let open = $state(false);
	let inputValue = $state('');
	let searchTerm = $state('');
	$effect(() => {
		let eventSource: EventSource | null = null;
		if (searchTerm.length < 3) {
			searchResults = [];
			isSearching = false;
		} else {
			isSearching = true;
			searchResults = [];
			eventSource = new EventSource(`/api/ingredients/search?q=${encodeURIComponent(searchTerm)}`);
			eventSource.addEventListener('message', (e) => {
				const newResults = JSON.parse(e.data);
				searchResults = [...searchResults, ...newResults];
			});
			eventSource.addEventListener('stream_error', (e) => {
				const errorData = JSON.parse((e as MessageEvent).data);
				console.error('Error de stream recibido:', errorData);
			});
			eventSource.onerror = (err) => {
				console.error('Error en la conexión de EventSource:', err);
				isSearching = false;
				eventSource?.close();
			};
			eventSource.addEventListener('close', () => {
				isSearching = false;
				eventSource?.close();
			});
		}
		return () => {
			eventSource?.close();
		};
	});
	async function addIngredient(result: SearchResult) {
		if (ingredients.some((ing) => ing.id === result.id && ing.type === result.type)) return;
		try {
			const response = await fetch(`/api/ingredients/details/${result.id}?type=${result.type}`);
			if (!response.ok) throw new Error('Failed to fetch ingredient details');
			const details: CalculableIngredient = await response.json();
			ingredients.push({
				...result,
				quantity: 100,
				calories: details.calories,
				protein: details.protein,
				fat: details.fat,
				carbs: details.carbs
			});
		} catch (error) {
			console.error('Error adding ingredient:', error);
		} finally {
			open = false;
			searchResults = [];
			searchTerm = '';
			inputValue = '';
		}
	}
	function removeIngredient(index: number) {
		ingredients.splice(index, 1);
	}
	// --- Gestión de subida de imagen ---
	function handleImageUpload(event: Event) {
		const target = event.target as HTMLInputElement;
		const file = target.files?.[0];
		if (file) {
			const reader = new FileReader();
			reader.onload = (e) => {
				imageUrl = e.target?.result as string;
			};
			reader.readAsDataURL(file);
		}
	}
	// --- Cálculos y envío ---
	let nutritionalInfo = $derived(calculateNutritionalInfo(ingredients));
	let isSubmitting = $state(false);
</script>
<Card class="max-w-4xl mx-auto my-8">
	<CardHeader>
		<CardTitle>Crear Nueva Receta</CardTitle>
	</CardHeader>
	<CardContent>
		<form
			method="POST"
			use:enhance={() => {
				isSubmitting = true;
				return async ({ result }) => {
					// La redirección se maneja automáticamente por el servidor en caso de éxito.
					// Solo necesitamos gestionar el estado de `isSubmitting`.
					if (result.type === 'failure' || result.type === 'error') {
						isSubmitting = false;
					}
				};
			}}
			class="space-y-6"
		>
			<!-- Campos ocultos para enviar datos complejos -->
			<input type="hidden" name="ingredients" value={JSON.stringify(ingredients.map(({ id, quantity, type }) => ({ id, quantity, type })))} />
			<input type="hidden" name="urls" value={JSON.stringify(urls.filter(u => u.trim() !== ''))} />
			<input type="hidden" name="steps" value={JSON.stringify(steps.filter(s => s.trim() !== ''))} />
			<input type="hidden" name="imageUrl" value={imageUrl} />
			<!-- Campos del formulario -->
			<div class="space-y-2">
				<Label for="title">Título</Label>
				<Input id="title" name="title" bind:value={title} required />
				{#if form?.errors?.title}
					<p class="text-sm text-red-500">{form.errors.title}</p>
				{/if}
			</div>
			<div class="space-y-2">
				<Label for="image">Imagen de la Receta</Label>
				<div class="flex items-center gap-4">
					{#if imageUrl}
						<img
							src={imageUrl}
							alt="Previsualización de la receta"
							class="h-24 w-24 rounded-md object-cover"
						/>
					{/if}
					<Input id="image" type="file" onchange={handleImageUpload} accept="image/*" />
				</div>
				<p class="text-sm text-gray-500">
					Sube una imagen o deja el campo vacío para intentar usar la de la primera URL de referencia.
				</p>
			</div>
			<div class="space-y-2">
				<Label>URLs de Referencia</Label>
				<UrlImageFetcher bind:urls bind:imageUrl />
				{#if form?.errors?.urls}
					<p class="text-sm text-red-500">{form.errors.urls}</p>
				{/if}
			</div>
			<div class="space-y-4">
				<Label class="text-lg font-medium">Pasos de la Receta</Label>
				{#each steps as step, i}
					<div class="flex items-start gap-2">
						<div class="flex-1 space-y-1">
							<Label for={`step-${i}`} class="text-sm font-normal text-gray-600">Paso {i + 1}</Label>
							<Textarea
								id={`step-${i}`}
								name={`step-${i}`}
								bind:value={steps[i]}
								rows={3}
								placeholder="Describe este paso... (soporta Markdown)"
							/>
						</div>
						<Button
							type="button"
							variant="ghost"
							size="icon"
							onclick={() => steps.splice(i, 1)}
							class="mt-6"
							aria-label="Eliminar paso"
						>
							<Trash2 class="h-4 w-4" />
						</Button>
					</div>
				{/each}
				<Button type="button" variant="outline" onclick={() => steps.push('')}>
					Añadir Paso
				</Button>
				{#if form?.errors?.steps}
					<p class="text-sm text-red-500">{form.errors.steps}</p>
				{/if}
			</div>
			<!-- Buscador y tabla de ingredientes -->
			<div class="space-y-2">
				<Label>Añadir Ingrediente</Label>
				<Popover.Root bind:open>
					<Popover.Trigger
						class="inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border w-full justify-between h-9 px-4 py-2"
						role="combobox"
						aria-expanded={open}
					>
						<div class="flex items-center justify-between w-full">
							{inputValue || 'Seleccionar ingrediente...'}
							<ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" />
						</div>
					</Popover.Trigger>
					<Popover.Content class="w-[--trigger-width] p-0">
						<Command.Root filter={() => 1}>
							<Command.Input bind:value={searchTerm} placeholder="Buscar ingrediente..." />
							<Command.List>
								{#if searchResults.length > 0}
									{#each searchResults as result (result.id + result.type)}
										<Command.Item
											value={result.name}
											onSelect={() => {
												inputValue = result.name;
												addIngredient(result);
											}}
											class={`flex items-center gap-2 ${result.source === 'local' ? 'ring-1 ring-green-500 rounded-sm' : ''}`}
										>
											<img
												src={result.imageUrl || 'https://placehold.co/40x40?text=N/A'}
												alt={result.name}
												class="h-8 w-8 rounded-sm object-cover"
											/>
											<span>{result.name}</span>
										</Command.Item>
									{/each}
								{:else}
									<div class="p-4 text-sm text-center text-gray-500">
										{#if isSearching}
											Buscando...
										{:else if searchTerm.length < 3}
											Escribe al menos 3 caracteres para buscar...
										{:else}
											No se encontraron resultados.
										{/if}
									</div>
								{/if}
							</Command.List>
						</Command.Root>
					</Popover.Content>
				</Popover.Root>
			</div>
			<div class="space-y-2">
				<h3 class="text-lg font-medium">Ingredientes de la Receta</h3>
				<Table>
					<TableHeader>
						<TableRow>
							<TableHead>Nombre</TableHead>
							<TableHead class="w-[150px]">Cantidad (g)</TableHead>
							<TableHead class="w-[100px] text-right">Acciones</TableHead>
						</TableRow>
					</TableHeader>
					<TableBody>
						{#each ingredients as ingredient, i}
							<TableRow>
								<TableCell>{ingredient.name}</TableCell>
								<TableCell>
									<Input type="number" bind:value={ingredient.quantity} min="1" class="w-full" />
								</TableCell>
								<TableCell class="text-right">
									<Button
										type="button"
										variant="destructive"
										size="sm"
										onclick={() => removeIngredient(i)}
									>
										Quitar
									</Button>
								</TableCell>
							</TableRow>
						{/each}
						{#if ingredients.length === 0}
							<TableRow>
								<TableCell colspan={3} class="text-center text-gray-500">
									Añade ingredientes usando el buscador.
								</TableCell>
							</TableRow>
						{/if}
					</TableBody>
				</Table>
				{#if form?.errors?.ingredients}
					<p class="text-sm text-red-500">{form.errors.ingredients}</p>
				{/if}
			</div>
			<!-- Información nutricional -->
			<div class="space-y-2 p-4 border rounded-lg bg-gray-50">
				<h3 class="text-lg font-medium">Información Nutricional (Total)</h3>
				<div class="grid grid-cols-2 md:grid-cols-4 gap-4">
					<div>
						<p class="font-bold text-xl">{nutritionalInfo.totalCalories.toFixed(2)}</p>
						<p class="text-sm text-gray-600">Calorías (kcal)</p>
					</div>
					<div>
						<p class="font-bold text-xl">{nutritionalInfo.totalProtein.toFixed(2)} g</p>
						<p class="text-sm text-gray-600">Proteínas</p>
					</div>
					<div>
						<p class="font-bold text-xl">{nutritionalInfo.totalFat.toFixed(2)} g</p>
						<p class="text-sm text-gray-600">Grasas</p>
					</div>
					<div>
						<p class="font-bold text-xl">{nutritionalInfo.totalCarbs.toFixed(2)} g</p>
						<p class="text-sm text-gray-600">Carbohidratos</p>
					</div>
				</div>
			</div>
			<div class="flex justify-end">
				<Button type="submit" disabled={isSubmitting}>
					{isSubmitting ? 'Guardando...' : 'Guardar Receta'}
				</Button>
			</div>
			{#if form?.message}
				<p class="text-sm text-red-500 text-right">{form.message}</p>
			{/if}
		</form>
	</CardContent>
</Card>

// --- Ruta: src/routes/recetas/nueva/+page.server.ts ---
// Ruta: src/routes/recetas/nueva/+page.server.ts
import { fail, redirect } from '@sveltejs/kit';
import { recipeService } from '$lib/server/services/recipeService';
import type { Actions } from './$types';
import { RecipeSchema } from '$lib/schemas/recipeSchema';
import { createFailResponse } from '$lib/server/zodErrors';
// Justificación: Se crea un `actions` object para manejar la creación de la receta.
// Esto alinea la página de 'nueva receta' con las mejores prácticas de SvelteKit
// que ya implementamos en la página de 'editar'.
export const actions: Actions = {
	default: async ({ request }) => {
		const formData = await request.formData();
		const data = Object.fromEntries(formData.entries());
		const dataToValidate = {
			...data,
			// Los datos complejos se envían como JSON string desde el cliente.
			ingredients: JSON.parse(data.ingredients as string),
			urls: JSON.parse(data.urls as string),
			steps: JSON.parse(data.steps as string)
		};
		const validation = RecipeSchema.safeParse(dataToValidate);
		if (!validation.success) {
			const response = createFailResponse(
				'La validación falló. Revisa los campos.',
				validation.error
			);
			return fail(400, response);
		}
		try {
			const newRecipe = await recipeService.create(validation.data);
			if (newRecipe) {
				// Justificación: En caso de éxito, se redirige al usuario a la página
				// de la receta recién creada usando `redirect` de SvelteKit y el nuevo slug.
				throw redirect(303, `/recetas/${newRecipe.slug}`);
			}
			// Este caso no debería ocurrir si el servicio funciona, pero es un fallback.
			return fail(500, createFailResponse('La receta no se pudo crear.'));
		} catch (err) {
			// Si el error es una redirección, SvelteKit la manejará.
			if ((err as { status?: number })?.status === 303) {
				throw err;
			}
			console.error(err);
			const response = createFailResponse('No se pudo crear la receta en el servidor.');
			return fail(500, response);
		}
	}
};

// --- Ruta: src/routes/recetas/busqueda-avanzada/+page.svelte ---
<script lang="ts">
	// --- LECCIONES APRENDIDAS Y PATRONES DE SVELTE 5 ---
	// Este componente ha sido objeto de una depuración intensiva que ha revelado
	// varias sutilezas importantes sobre Svelte 5 y SvelteKit. A continuación,
	// se documentan los patrones clave utilizados y las lecciones aprendidas.
	//
	// 1. GESTIÓN DEL ESTADO:
	//    - Se utiliza `$state` para toda la información que puede cambiar y debe
	//      provocar una actualización de la UI.
	//    - El estado se divide conceptualmente entre la "causa" (los filtros que
	//      el usuario modifica) y el "efecto" (los resultados de la búsqueda y
	//      el estado de la UI, como `isLoading`). Esto mejora la claridad del
	//      flujo de datos.
	//
	// 2. EL PROBLEMA DE LA CARGA INICIAL (BUG RESUELTO):
	//    - PROBLEMA: Inicialmente, la página mostraba brevemente todas las recetas
	//      antes de vaciar la lista. Esto ocurría porque la lógica del scroll
	//      infinito se activaba prematuramente.
	//    - SOLUCIÓN: La variable `hasMore` se inicializa en `false`. Esto previene
	//      que el `div` "sentinel" del IntersectionObserver se renderice en la
	//      carga inicial, evitando así la llamada a `loadMore()` con filtros vacíos.
	//
	// 3. PERSISTENCIA DE ESTADO EN NAVEGACIÓN (`snapshot`):
	//    - PROBLEMA: Se necesita mantener el estado de la búsqueda (filtros y
	//      resultados) cuando el usuario navega a una receta y vuelve atrás.
	//    - INTENTO FALLIDO 1: Usar `history.replaceState` directamente. Esto entra
	//      en conflicto con el router de SvelteKit, que es el dueño del historial,
	//      provocando warnings y comportamiento errático.
	//    - INTENTO FALLIDO 2: Usar `replaceState` de `$app/navigation` en un `$effect`.
	//      Esto causó un bucle infinito porque el efecto dependía de datos (`$page`)
	//      que él mismo modificaba, y además provocaba un "hydration mismatch"
	//      al intentar restaurar el estado antes de que el componente se montara
	//      de forma consistente en el cliente y el servidor.
	//    - SOLUCIÓN CORRECTA: Utilizar el objeto `snapshot` exportado. SvelteKit
	//      gestiona este ciclo de vida de forma segura:
	//        - `capture()`: Se llama ANTES de salir de la página. Guardamos una
	//          copia del estado. SvelteKit se encarga de almacenarla.
	//        - `restore()`: Se llama AL VOLVER a la página. SvelteKit nos devuelve
	//          los datos que guardamos para que podamos restaurar el estado.
	//      Este es el patrón canónico y robusto para la persistencia de estado
	//      de UI en SvelteKit.
	//
	// 4. REACTIVIDAD: `$derived` vs. FUNCIONES PURAS:
	//    - PROBLEMA: Durante la depuración, se sospechó de una condición de carrera
	//      en la inicialización de los `$derived` stores, donde un `$effect` podía
	//      ejecutarse antes de que el valor derivado se hubiera estabilizado.
	//    - SOLUCIÓN DE DEPURACIÓN: Reemplazar `$derived` por una función pura
	//      (`areFiltersActive()`) para asegurar que el cálculo se realizara en el
	//      momento exacto de la llamada. Esto resolvió el problema, confirmando
	//      la hipótesis de la condición de carrera.
	//    - CONCLUSIÓN: Aunque `$derived` es potente, para lógica crítica que se
	//      ejecuta en la inicialización y que controla si se realizan o no
	//      peticiones de red, una función pura puede ser más segura y predecible,
	//      evitando posibles bugs de timing en el ciclo de vida.
	//
	// 5. COMUNICACIÓN ENTRE COMPONENTES:
	//    - Se sigue un patrón de "callbacks" (eventos). El componente padre
	//      (`+page.svelte`) mantiene la propiedad del estado (`filters`) y pasa
	//      funciones (`onGramsChange`, etc.) al hijo (`MacroFilters.svelte`).
	//    - El hijo, en lugar de modificar los datos directamente (lo que Svelte 5
	//      desaconseja y marca con un warning), llama a estas funciones para
	//      notificar al padre de que debe realizar un cambio. Esto mantiene un
	//      flujo de datos unidireccional y predecible.
	import { browser } from '$app/environment';
	import IngredientCombobox from '$lib/components/recipes/IngredientCombobox.svelte';
	import MacroFilters from '$lib/components/recipes/MacroFilters.svelte';
	import type {
		GramFilters,
		PercentFilters
	} from '$lib/components/recipes/MacroFilters.svelte';
	import RecipeCard from '$lib/components/recipes/RecipeCard.svelte';
	import { Badge } from '$lib/components/ui/badge/index.js';
	import X from 'lucide-svelte/icons/x';
	type Ingredient = {
		id: string;
		name: string;
		type: 'product' | 'custom';
		source: 'local' | 'off';
		imageUrl: string | null;
	};
	type Recipe = any;
	// --- TIPOS LOCALES ---
	type SearchPayload = {
		ingredients: string[];
		grams: GramFilters;
		percent: PercentFilters;
		sortBy: string;
	};
	// --- ESTADO DE FILTROS (LA "CAUSA") ---
	let filters = $state({
		selectedIngredients: [] as Ingredient[],
		gramFilters: { calories: {}, protein: {}, carbs: {}, fat: {} } as GramFilters,
		percentFilters: { protein: {}, carbs: {}, fat: {} } as PercentFilters,
		sortBy: 'title_asc'
	});
	// --- ESTADO DE RESULTADOS Y UI (EL "EFECTO") ---
	let recipes = $state<Recipe[]>([]);
	let isLoading = $state(false);
	let hasMore = $state(false);
	let sentinel: HTMLDivElement | undefined = $state();
	let controller: AbortController | undefined;
	// --- PERSISTENCIA DE ESTADO CON SNAPSHOT ---
	// Este es el mecanismo oficial de SvelteKit para guardar y restaurar el estado
	// de un componente durante la navegación del historial (ej. botón "atrás").
	export const snapshot = {
		capture: () => {
			// SvelteKit llama a esta función ANTES de que el usuario navegue fuera de esta página.
			// Devolvemos un objeto serializable con los datos que queremos preservar.
			// Usamos JSON.parse/stringify para crear una copia profunda y evitar problemas de referencias.
			return {
				filters: JSON.parse(JSON.stringify(filters)),
				recipes: JSON.parse(JSON.stringify(recipes))
			};
		},
		restore: (data: any) => {
			// SvelteKit llama a esta función CUANDO el usuario vuelve a esta página.
			// 'data' es el objeto que devolvimos en `capture`.
			// Restauramos el estado del componente con estos datos.
			if (data && data.filters && data.recipes) {
				filters = data.filters;
				recipes = data.recipes;
			}
		}
	};
	// --- FUNCIÓN DE COMPROBACIÓN ---
	// Se utiliza una función pura en lugar de un `$derived` store para determinar si hay filtros activos.
	// Esto resolvió un bug de condición de carrera donde los `$effect` se ejecutaban
	// antes de que el valor de `$derived` se estabilizara en la carga inicial.
	// Llamar a una función nos da la garantía de que el cálculo se hace en el momento preciso.
	function areFiltersActive() {
		const hasMacroGrams = Object.values(filters.gramFilters).some(
			(range) => range && (range.min != null || range.max != null)
		);
		const hasMacroPercent = Object.values(filters.percentFilters).some(
			(range) => range && (range.min != null || range.max != null)
		);
		return filters.selectedIngredients.length > 0 || hasMacroGrams || hasMacroPercent;
	}
	// --- LÓGICA DE BÚSQUEDA ---
	async function performSearch(payload: SearchPayload) {
		// Guardia de seguridad para no hacer peticiones a la API sin filtros.
		if (!areFiltersActive()) {
			recipes = [];
			hasMore = false;
			return;
		}
		isLoading = true;
		const signal = controller?.signal;
		try {
			const body = { ...payload, offset: 0 };
			const response = await fetch('/api/recipes/search', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(body),
				signal
			});
			const result = await response.json();
			if (signal?.aborted) return;
			recipes = result.recipes;
			hasMore = result.hasMore;
		} catch (error) {
			if (error instanceof DOMException && error.name === 'AbortError') return;
			console.error('Error en la búsqueda:', error);
		} finally {
			if (!signal?.aborted) isLoading = false;
		}
	}
	async function loadMore(payload: SearchPayload) {
		// Doble guardia: no cargar más si no hay filtros o si ya se está cargando.
		if (!areFiltersActive() || isLoading) return;
		isLoading = true;
		try {
			const body = { ...payload, offset: recipes.length };
			const response = await fetch('/api/recipes/search', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(body)
			});
			const result = await response.json();
			recipes.push(...result.recipes);
			hasMore = result.hasMore;
		} catch (error) {
			console.error('Error al cargar más recetas:', error);
		} finally {
			isLoading = false;
		}
	}
	// --- EFECTOS ---
	// Efecto principal para la búsqueda. Se activa cuando los filtros cambian.
	$effect(() => {
		if (!browser) return;
		// Si no hay filtros, se limpia el estado de los resultados.
		// Esto previene una búsqueda en la carga inicial.
		if (!areFiltersActive()) {
			recipes = [];
			hasMore = false;
			return;
		}
		// AbortController para cancelar peticiones en curso si el usuario sigue escribiendo.
		controller?.abort();
		controller = new AbortController();
		const payload: SearchPayload = {
			ingredients: filters.selectedIngredients.map((i) => i.id),
			grams: filters.gramFilters,
			percent: filters.percentFilters,
			sortBy: filters.sortBy
		};
		// Debounce para no lanzar una petición en cada pulsación de tecla.
		const timerId = setTimeout(() => {
			performSearch(payload);
		}, 350);
		// Función de limpieza: se ejecuta antes de la siguiente ejecución del efecto.
		return () => clearTimeout(timerId);
	});
	// Efecto para el scroll infinito.
	$effect(() => {
		if (!sentinel) return;
		const observer = new IntersectionObserver((entries) => {
			// Solo carga más si el sentinel es visible, hay más resultados, no se está
			// cargando ya, y (crucialmente) hay filtros activos.
			if (entries[0].isIntersecting && hasMore && !isLoading && areFiltersActive()) {
				const payload: SearchPayload = {
					ingredients: filters.selectedIngredients.map((i) => i.id),
					grams: filters.gramFilters,
					percent: filters.percentFilters,
					sortBy: filters.sortBy
				};
				loadMore(payload);
			}
		});
		observer.observe(sentinel);
		return () => observer.disconnect();
	});
	// --- MANEJADORES DE EVENTOS ---
	// Estos manejadores actualizan el estado `filters` de forma inmutable,
	// lo que garantiza que la reactividad de Svelte 5 se dispare correctamente.
	function handleAddIngredient(ingredient: Ingredient) {
		if (!filters.selectedIngredients.some((i) => i.id === ingredient.id)) {
			filters.selectedIngredients = [...filters.selectedIngredients, ingredient];
		}
	}
	function handleRemoveIngredient(ingredientId: string) {
		filters.selectedIngredients = filters.selectedIngredients.filter((i) => i.id !== ingredientId);
	}
	function clearIngredients() {
		filters.selectedIngredients = [];
	}
	function handleGramsChange(macro: keyof GramFilters, key: 'min' | 'max', value: number | undefined) {
		filters.gramFilters = {
			...filters.gramFilters,
			[macro]: {
				...filters.gramFilters[macro],
				[key]: value
			}
		};
	}
	function handlePercentChange(
		macro: keyof PercentFilters,
		key: 'min' | 'max',
		value: number | undefined
	) {
		filters.percentFilters = {
			...filters.percentFilters,
			[macro]: {
				...filters.percentFilters[macro],
				[key]: value
			}
		};
	}
	function handleClearMacros() {
		filters.gramFilters = { calories: {}, protein: {}, carbs: {}, fat: {} };
		filters.percentFilters = { protein: {}, carbs: {}, fat: {} };
	}
</script>
<div class="container mx-auto p-4 md:p-8">
	<header class="mb-8 flex items-center justify-between">
		<div>
			<h1 class="text-3xl font-bold tracking-tight">Búsqueda Avanzada</h1>
			<p class="text-muted-foreground">
				Filtra por ingredientes, macronutrientes y más.
			</p>
		</div>
	</header>
	<div class="grid grid-cols-1 gap-8 lg:grid-cols-3">
		<aside class="lg:col-span-1">
			<div class="space-y-6 rounded-lg border p-4 sticky top-4">
				<div class="space-y-2">
					<h3 class="text-lg font-semibold">Ingredientes</h3>
					<IngredientCombobox
						onSelect={handleAddIngredient}
						selectedIds={filters.selectedIngredients.map((i) => i.id)}
						onClear={clearIngredients}
					/>
					<div class="flex flex-wrap gap-2 pt-2 min-h-[24px]">
						{#each filters.selectedIngredients as ingredient (ingredient.id)}
							<Badge variant="secondary" class="flex items-center gap-2">
								{ingredient.name}
								<button
									onclick={() => handleRemoveIngredient(ingredient.id)}
									class="focus:ring-ring rounded-sm focus:outline-none focus:ring-2 focus:ring-offset-2"
								>
									<X class="h-3 w-3" />
								</button>
							</Badge>
						{/each}
					</div>
				</div>
				<hr />
				<MacroFilters
					gramFilters={filters.gramFilters}
					percentFilters={filters.percentFilters}
					onGramsChange={handleGramsChange}
					onPercentChange={handlePercentChange}
					onClear={handleClearMacros}
				/>
			</div>
		</aside>
		<main class="lg:col-span-2">
			<div class="space-y-4">
				{#if recipes.length > 0}
					<div class="columns-1 md:columns-2 gap-4">
						{#each recipes as recipe (recipe.id)}
							<div class="mb-4 break-inside-avoid">
								<RecipeCard {recipe} isAdmin={false} onEditQuantities={() => {}} onDelete={() => {}} />
							</div>
						{/each}
					</div>
				{:else if !isLoading}
					<div class="rounded-lg border p-8 text-center">
						<p class="text-muted-foreground">
							{#if areFiltersActive()}
								No se encontraron recetas con estos criterios.
							{:else}
								Selecciona uno o más filtros para empezar a buscar.
							{/if}
						</p>
					</div>
				{/if}
				{#if hasMore}
					<div bind:this={sentinel} class="h-10 flex justify-center items-center text-muted-foreground">
						{#if isLoading}
							<span>Cargando...</span>
						{/if}
					</div>
				{/if}
			</div>
		</main>
	</div>
</div>

// --- Ruta: src/routes/recetas/[slug]/+page.svelte ---
<!-- Ruta: src/routes/recetas/[id]/+page.svelte -->
<script lang="ts">
	import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '$lib/components/ui/card';
	import {
		Table,
		TableBody,
		TableCell,
		TableHead,
		TableHeader,
		TableRow
	} from '$lib/components/ui/table';
	import { calculateNutritionalInfo } from '$lib/recipeCalculator';
	import type { PageData } from './$types';
	import { Button } from '$lib/components/ui/button';
	import { marked } from 'marked';
	import DOMPurify from 'dompurify';
	import { browser } from '$app/environment';
	let { data }: { data: PageData } = $props();
	const { recipe } = data;
	// Tipos explícitos para mayor claridad y seguridad
	type IngredientFromLoader = PageData['recipe']['ingredients'][number];
	type MappedIngredient = {
		name: string;
		quantity: number;
		calories: number;
		protein: number;
		fat: number;
		carbs: number;
	};
	const ingredientsList = $derived(
		recipe.ingredients
			.map((ing: IngredientFromLoader) => {
				const details = ing.product ?? ing.customIngredient;
				if (!details) return null;
				return {
					name: details.name,
					quantity: ing.quantity,
					calories: details.calories ?? 0,
					protein: details.protein ?? 0,
					fat: details.fat ?? 0,
					carbs: details.carbs ?? 0
				};
			})
			.filter((i: MappedIngredient | null): i is MappedIngredient => i !== null)
	);
	const nutritionalInfo = $derived(calculateNutritionalInfo(ingredientsList));
	// Función robusta para parsear los pasos, que ya vienen como array desde el servidor
	const getRecipeSteps = (stepsData: unknown): string[] => {
		if (Array.isArray(stepsData)) {
			return stepsData.map(String);
		}
		// Fallback por si en el cliente llega como string JSON
		if (browser && typeof stepsData === 'string') {
			try {
				const parsed = JSON.parse(stepsData);
				return Array.isArray(parsed) ? parsed.map(String) : [String(stepsData)];
			} catch (e) {
				return [String(stepsData)]; // No era JSON, tratar como texto plano
			}
		}
		return [];
	};
	const steps = $derived(getRecipeSteps(recipe.steps));
	// Función para sanitizar el HTML de forma segura en el navegador
	const sanitizeHtml = (html: string) => {
		if (browser) {
			return DOMPurify.sanitize(html);
		}
		// En SSR, devolvemos el HTML sin sanitizar, asumiendo que la fuente es confiable.
		// La sanitización del cliente lo protegerá al renderizar.
		return html;
	};
</script>
<div class="max-w-4xl mx-auto my-8 space-y-8">
	<header class="space-y-4">
		<div class="flex justify-between items-start">
			<div class="flex-1">
				<h1 class="text-4xl font-bold tracking-tight">{recipe.title}</h1>
			</div>
			<a href="/recetas/{recipe.slug}/editar">
				<Button variant="outline">Editar</Button>
			</a>
		</div>
		{#if recipe.imageUrl}
			<div class="w-full aspect-video rounded-lg overflow-hidden">
				<img
					src={recipe.imageUrl}
					alt="Foto de {recipe.title}"
					class="w-full h-full object-cover"
				/>
			</div>
		{/if}
	</header>
	<div class="grid grid-cols-1 md:grid-cols-3 gap-8">
		<div class="md:col-span-2 space-y-8">
			<!-- Pasos Renderizados con Markdown y Sanitizados -->
			<Card>
				<CardHeader>
					<CardTitle>Preparación</CardTitle>
				</CardHeader>
				<CardContent>
					<div class="prose max-w-none">
						<ol>
							{#each steps as step}
								<li>
									{@html sanitizeHtml(
										marked.parse(step, { gfm: true, breaks: true, async: false })
									)}
								</li>
							{/each}
						</ol>
					</div>
				</CardContent>
			</Card>
			{#if recipe.urls && recipe.urls.length > 0}
				<Card>
					<CardHeader>
						<CardTitle>Referencias</CardTitle>
					</CardHeader>
					<CardContent>
						<ul class="list-disc pl-5 space-y-2">
							{#each recipe.urls as ref}
								<li>
									<a
										href={ref.url}
										target="_blank"
										rel="noopener noreferrer"
										class="text-blue-600 hover:underline"
									>
										{ref.url}
									</a>
								</li>
							{/each}
						</ul>
					</CardContent>
				</Card>
			{/if}
		</div>
		<div class="space-y-8">
			<!-- Información Nutricional -->
			<Card>
				<CardHeader>
					<CardTitle>Información Nutricional</CardTitle>
					<CardDescription>Valores totales para la receta.</CardDescription>
				</CardHeader>
				<CardContent class="grid grid-cols-2 gap-4">
					<div>
						<p class="font-bold text-lg">{nutritionalInfo.totalCalories.toFixed(0)}</p>
						<p class="text-sm text-gray-600">Calorías (kcal)</p>
					</div>
					<div>
						<p class="font-bold text-lg">{nutritionalInfo.totalProtein.toFixed(1)} g</p>
						<p class="text-sm text-gray-600">Proteínas</p>
					</div>
					<div>
						<p class="font-bold text-lg">{nutritionalInfo.totalFat.toFixed(1)} g</p>
						<p class="text-sm text-gray-600">Grasas</p>
					</div>
					<div>
						<p class="font-bold text-lg">{nutritionalInfo.totalCarbs.toFixed(1)} g</p>
						<p class="text-sm text-gray-600">Carbohidratos</p>
					</div>
				</CardContent>
			</Card>
			<!-- Ingredientes -->
			<Card>
				<CardHeader>
					<CardTitle>Ingredientes</CardTitle>
				</CardHeader>
				<CardContent>
					<Table>
						<TableHeader>
							<TableRow>
								<TableHead>Nombre</TableHead>
								<TableHead class="text-right">Cantidad</TableHead>
							</TableRow>
						</TableHeader>
						<TableBody>
							{#each ingredientsList as ingredient}
								<TableRow>
									<TableCell class="font-medium">{ingredient.name}</TableCell>
									<TableCell class="text-right">{ingredient.quantity} g</TableCell>
								</TableRow>
							{/each}
						</TableBody>
					</Table>
				</CardContent>
			</Card>
		</div>
	</div>
</div>

// --- Ruta: src/routes/recetas/[slug]/+page.server.ts ---
// Ruta: src/routes/recetas/[slug]/+page.server.ts
import { error, fail } from '@sveltejs/kit';
import { recipeService } from '$lib/server/services/recipeService';
import type { PageServerLoad, Actions } from './$types';
import { RecipeSchema } from '$lib/schemas/recipeSchema';
// Justificación: Se importa la nueva utilidad unificada para crear respuestas de error.
import { createFailResponse } from '$lib/server/zodErrors';
export const load: PageServerLoad = async ({ params }) => {
	const recipe = await recipeService.getBySlug(params.slug);
	if (!recipe) {
		throw error(404, 'Receta no encontrada');
	}
	return {
		recipe
	};
};
export const actions: Actions = {
	default: async ({ request, params }) => {
		const formData = await request.formData();
		const data = Object.fromEntries(formData.entries());
		const dataToValidate = {
			...data,
			ingredients: JSON.parse(data.ingredients as string),
			urls: JSON.parse(data.urls as string),
			steps: JSON.parse(data.steps as string)
		};
		const validation = RecipeSchema.safeParse(dataToValidate);
		if (!validation.success) {
			// Justificación: Se usa la nueva utilidad para el fallo de validación.
			const response = createFailResponse('La validación falló. Revisa los campos.', validation.error);
			return fail(400, response);
		}
		try {
			// Aquí necesitamos el ID, no el slug, para la actualización.
			// Lo obtenemos de la receta original cargada.
			const originalRecipe = await recipeService.getBySlug(params.slug);
			if (!originalRecipe) {
				throw error(404, 'Receta no encontrada para actualizar');
			}
			const updatedRecipe = await recipeService.update(originalRecipe.id, validation.data);
			return {
				status: 200,
				body: {
					recipe: updatedRecipe
				}
			};
		} catch (err) {
			console.error(err);
			// Justificación: Se usa la misma utilidad para el fallo del servidor,
			// garantizando una estructura de respuesta 100% consistente.
			const response = createFailResponse('No se pudo actualizar la receta.');
			return fail(500, response);
		}
	}
};

// --- Ruta: src/routes/api/scrape-image/api.spec.ts ---
// Ruta: src/routes/api/scrape-image/api.spec.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { POST } from './+server';
import { imageService } from '$lib/server/services/imageService';
vi.mock('$lib/server/services/imageService', () => ({
	imageService: {
		getImageFromUrl: vi.fn()
	}
}));
vi.mock('@sveltejs/kit', async (importOriginal) => {
	const original = await importOriginal<typeof import('@sveltejs/kit')>();
	return {
		...original,
		error: vi.fn((status, message) => ({ status, message }))
	};
});
// Justificación: Se crea un alias para el tipo del evento de la API para mejorar
// la legibilidad y mantener la consistencia con otros ficheros de test.
type ApiEvent = Parameters<typeof POST>[0];
describe('POST /api/scrape-image', () => {
	beforeEach(() => {
		vi.resetAllMocks();
		vi.spyOn(console, 'error').mockImplementation(() => {});
	});
	afterEach(() => {
		vi.mocked(console.error).mockRestore();
	});
	it('should return a 200 response with the image URL on success', async () => {
		const mockImageUrl = 'data:image/webp;base64,mock-image-data';
		vi.mocked(imageService.getImageFromUrl).mockResolvedValue(mockImageUrl);
		const request = new Request('http://localhost/api/scrape-image', {
			method: 'POST',
			body: JSON.stringify({ url: 'https://example.com' })
		});
		const response = await POST({ request } as unknown as ApiEvent);
		const body = await response.json();
		expect(response.status).toBe(200);
		expect(body).toEqual({ imageUrl: mockImageUrl });
		expect(imageService.getImageFromUrl).toHaveBeenCalledWith('https://example.com');
	});
	it('should throw a 400 error for an invalid URL', async () => {
		const request = new Request('http://localhost/api/scrape-image', {
			method: 'POST',
			body: JSON.stringify({ url: 'invalid-url' })
		});
		await expect(POST({ request } as unknown as ApiEvent)).rejects.toEqual({
			status: 400,
			message: 'URL no válida'
		});
	});
	it('should throw a 404 error if no image is found', async () => {
		vi.mocked(imageService.getImageFromUrl).mockResolvedValue(null);
		const request = new Request('http://localhost/api/scrape-image', {
			method: 'POST',
			body: JSON.stringify({ url: 'https://example.com/no-image' })
		});
		await expect(POST({ request } as unknown as ApiEvent)).rejects.toEqual({
			status: 404,
			message: 'No se pudo encontrar una imagen en la URL proporcionada'
		});
	});
	it('should throw a 500 error for internal server errors', async () => {
		vi.mocked(imageService.getImageFromUrl).mockRejectedValue(new Error('Internal processing error'));
		const request = new Request('http://localhost/api/scrape-image', {
			method: 'POST',
			body: JSON.stringify({ url: 'https://example.com/error-page' })
		});
		await expect(POST({ request } as unknown as ApiEvent)).rejects.toEqual({
			status: 500,
			message: 'Error interno al procesar la imagen'
		});
	});
});

// --- Ruta: src/routes/api/scrape-image/+server.ts ---
// Ruta: src/routes/api/scrape-image/+server.ts
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { imageService } from '$lib/server/services/imageService';
// Justificación (Paso 1): Creamos un endpoint POST dedicado para el scraping de imágenes.
// Esto permite al frontend solicitar la extracción de una imagen de forma asíncrona
// sin exponer directamente la lógica del servidor.
export const POST: RequestHandler = async ({ request }) => {
	try {
		const { url } = await request.json();
		// Justificación: Validamos que la URL sea una URL HTTP/HTTPS válida
		// antes de procesarla para evitar errores y posibles abusos.
		if (!url || !url.startsWith('http')) {
			throw error(400, 'URL no válida');
		}
		const imageUrl = await imageService.getImageFromUrl(url);
		if (!imageUrl) {
			// Si no se encuentra imagen, devolvemos un 404 específico.
			throw error(404, 'No se pudo encontrar una imagen en la URL proporcionada');
		}
		return json({ imageUrl });
	} catch (e) {
		// Manejo de errores centralizado. Si es un error de SvelteKit (o un objeto con forma de error), lo relanzamos.
		// Si no, devolvemos un error 500 genérico.
		if (typeof e === 'object' && e !== null && 'status' in e) {
			throw e;
		}
		console.error('Error scraping image:', e);
		throw error(500, 'Error interno al procesar la imagen');
	}
};

// --- Ruta: src/routes/api/recipes/server.spec.ts ---
// Fichero: src/routes/api/recipes/+server.spec.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { GET } from './+server';
import { recipeService } from '$lib/server/services/recipeService';
import { json } from '@sveltejs/kit';
vi.mock('$lib/server/services/recipeService');
vi.mock('@sveltejs/kit', async (importOriginal) => {
	const original = await importOriginal<typeof import('@sveltejs/kit')>();
	return {
		...original,
		json: vi.fn()
	};
});
type ApiEvent = Parameters<typeof GET>[0];
type Recipes = Awaited<ReturnType<typeof recipeService.findPaginated>>;
describe('GET /api/recipes', () => {
	beforeEach(() => {
		vi.resetAllMocks();
	});
	it('should call recipeService.findPaginated with correct default parameters', async () => {
		// Justificación: Se añade un mock de retorno para evitar el TypeError.
		// El test se centra en verificar los argumentos de la llamada, no el resultado.
		vi.mocked(recipeService.findPaginated).mockResolvedValue([]);
		const url = new URL('http://localhost/api/recipes');
		await GET({ url } as unknown as ApiEvent);
		expect(recipeService.findPaginated).toHaveBeenCalledWith(null, 51, 0);
	});
	it('should call recipeService.findPaginated with provided query parameters', async () => {
		// Justificación: Se añade un mock de retorno para evitar el TypeError.
		vi.mocked(recipeService.findPaginated).mockResolvedValue([]);
		const url = new URL('http://localhost/api/recipes?q=pollo&limit=10&offset=20');
		await GET({ url } as unknown as ApiEvent);
		expect(recipeService.findPaginated).toHaveBeenCalledWith('pollo', 11, 20);
	});
	it('should return hasMore: true when the service returns more items than the limit', async () => {
		const url = new URL('http://localhost/api/recipes?limit=10');
		const mockRecipes = Array(11).fill({ id: '1' });
		vi.mocked(recipeService.findPaginated).mockResolvedValue(mockRecipes as Recipes);
		await GET({ url } as unknown as ApiEvent);
		expect(json).toHaveBeenCalledWith({
			recipes: mockRecipes.slice(0, 10),
			hasMore: true
		});
	});
	it('should return hasMore: false when the service returns fewer items than the limit', async () => {
		const url = new URL('http://localhost/api/recipes?limit=10');
		const mockRecipes = Array(5).fill({ id: '1' });
		vi.mocked(recipeService.findPaginated).mockResolvedValue(mockRecipes as Recipes);
		await GET({ url } as unknown as ApiEvent);
		expect(json).toHaveBeenCalledWith({
			recipes: mockRecipes,
			hasMore: false
		});
	});
	it('should return a 500 error if the service throws an exception', async () => {
		const url = new URL('http://localhost/api/recipes');
		vi.mocked(recipeService.findPaginated).mockRejectedValue(new Error('Database error'));
		vi.spyOn(console, 'error').mockImplementation(() => {});
		await GET({ url } as unknown as ApiEvent);
		expect(json).toHaveBeenCalledWith({ message: 'Error interno del servidor' }, { status: 500 });
		vi.mocked(console.error).mockRestore();
	});
});

// --- Ruta: src/routes/api/recipes/+server.ts ---
// Fichero: src/routes/api/recipes/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { recipeService } from '$lib/server/services/recipeService';
const DEFAULT_LIMIT = 50;
/**
 * Endpoint GET para buscar y paginar recetas.
 * Acepta los siguientes parámetros de búsqueda en la URL:
 * - `q`: El término de búsqueda (opcional).
 * - `limit`: El número de resultados a devolver (por defecto 50).
 * - `offset`: El número de resultados a saltar.
 */
export const GET: RequestHandler = async ({ url }) => {
	try {
		const searchTerm = url.searchParams.get('q');
		const limit = parseInt(url.searchParams.get('limit') ?? `${DEFAULT_LIMIT}`, 10);
		const offset = parseInt(url.searchParams.get('offset') ?? '0', 10);
		// Justificación (Paginación eficiente): Solicitamos un elemento más del límite
		// para determinar si existen más resultados sin necesidad de una segunda consulta
		// o un `count()` total, lo cual es mucho más performante.
		const recipesPlusOne = await recipeService.findPaginated(searchTerm, limit + 1, offset);
		const hasMore = recipesPlusOne.length > limit;
		// Devolvemos solo el número de recetas solicitado originalmente.
		const recipes = recipesPlusOne.slice(0, limit);
		return json({
			recipes,
			hasMore
		});
	} catch (error) {
		console.error('Error en el endpoint de búsqueda de recetas:', error);
		// Devolvemos un error 500 genérico para no exponer detalles internos.
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/admin/ingredientes/+page.svelte ---
<!-- Ruta: src/routes/admin/ingredientes/+page.svelte -->
<script lang="ts">
	import { enhance } from '$app/forms';
	import { Button, buttonVariants } from '$lib/components/ui/button';
	import * as Dialog from '$lib/components/ui/dialog';
	import { Input } from '$lib/components/ui/input';
	import { Label } from '$lib/components/ui/label';
	import * as Table from '$lib/components/ui/table';
	import type { ActionData, PageData } from './$types';
	import SyncDialog from '$lib/components/admin/SyncDialog.svelte';
	import { invalidateAll } from '$app/navigation';
	let { data, form } = $props<{ data: PageData; form: ActionData }>();
	// --- Lógica para el diálogo de sincronización ---
	let isSyncDialogOpen = $state(false);
	let syncState = $state<'idle' | 'loading' | 'success' | 'error'>('idle');
	let syncResult = $state<any>(null);
	// Justificación: Esta función maneja el flujo de la sincronización en el cliente.
	// Llama al endpoint del backend, gestiona los estados de carga/éxito/error
	// y actualiza los datos de la página al finalizar para reflejar los cambios.
	async function handleSync() {
		syncState = 'loading';
		// isSyncDialogOpen se controla automáticamente por el Dialog.Trigger
		try {
			const response = await fetch('/api/ingredients/sync', {
				method: 'POST',
				credentials: 'include' // Justificación: Se incluye para enviar la cookie de sesión.
			});
			if (!response.ok) {
				throw new Error('Falló la petición de sincronización');
			}
			syncResult = await response.json();
			syncState = 'success';
			// Justificación: invalidamos los datos de la página actual para que SvelteKit
			// los vuelva a cargar del servidor, mostrando así los ingredientes actualizados.
			await invalidateAll();
		} catch (error) {
			console.error('Error durante la sincronización:', error);
			syncState = 'error';
		}
	}
</script>
<div class="container mx-auto py-10">
	<div class="flex justify-between items-center mb-6">
		<h1 class="text-2xl font-bold">Gestión de Ingredientes</h1>
		<div class="flex gap-2">
			<!-- Botón de Sincronización -->
			<Dialog.Root bind:open={isSyncDialogOpen}>
				<Dialog.Trigger class={buttonVariants({ variant: 'outline' })} onclick={handleSync}>
					Sincronizar con OFF
				</Dialog.Trigger>
				{#if isSyncDialogOpen}
					<SyncDialog state={syncState} result={syncResult} />
				{/if}
			</Dialog.Root>
			<a href="/admin/ingredientes/off" class={buttonVariants({ variant: 'outline' })}>
				Añadir desde Open Food Facts
			</a>
			<Dialog.Root>
				<Dialog.Trigger class={buttonVariants()}>Añadir Ingrediente Personalizado</Dialog.Trigger>
				<Dialog.Content class="sm:max-w-[425px]">
					<Dialog.Header>
						<Dialog.Title>Añadir Nuevo Ingrediente</Dialog.Title>
						<Dialog.Description>
							Completa los detalles del ingrediente personalizado. Todos los valores son por 100g.
						</Dialog.Description>
					</Dialog.Header>
					<form method="POST" action="?/create" use:enhance>
						<div class="grid gap-4 py-4">
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="name" class="text-right">Nombre</Label>
								<Input id="name" name="name" class="col-span-3" />
							</div>
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="calories" class="text-right">Calorías</Label>
								<Input id="calories" name="calories" type="number" step="0.1" class="col-span-3" />
							</div>
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="protein" class="text-right">Proteínas</Label>
								<Input id="protein" name="protein" type="number" step="0.1" class="col-span-3" />
							</div>
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="fat" class="text-right">Grasas</Label>
								<Input id="fat" name="fat" type="number" step="0.1" class="col-span-3" />
							</div>
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="carbs" class="text-right">Carbohidratos</Label>
								<Input id="carbs" name="carbs" type="number" step="0.1" class="col-span-3" />
							</div>
						</div>
						<Dialog.Footer>
							<Dialog.Close class={buttonVariants()} type="submit">Guardar Ingrediente</Dialog.Close>
						</Dialog.Footer>
					</form>
				</Dialog.Content>
			</Dialog.Root>
		</div>
	</div>
	<div class="rounded-md border">
		<Table.Root>
			<Table.Header>
				<Table.Row>
					<Table.Head>Nombre</Table.Head>
					<Table.Head>Origen</Table.Head>
					<Table.Head class="text-right">Calorías (por 100g)</Table.Head>
					<Table.Head class="text-right">Proteínas (g)</Table.Head>
					<Table.Head class="text-right">Grasas (g)</Table.Head>
					<Table.Head class="text-right">Carbs (g)</Table.Head>
					<Table.Head class="text-right">Acciones</Table.Head>
				</Table.Row>
			</Table.Header>
			<Table.Body>
				{#each data.ingredients as ingredient (ingredient.id)}
					<Table.Row>
						<Table.Cell class="font-medium">{ingredient.name}</Table.Cell>
						<Table.Cell>
							{#if ingredient.source === 'custom'}
								<span
									class="bg-blue-100 text-blue-800 text-xs font-medium me-2 px-2.5 py-0.5 rounded dark:bg-blue-900 dark:text-blue-300"
								>
									Personalizado
								</span>
							{:else}
								<span
									class="bg-green-100 text-green-800 text-xs font-medium me-2 px-2.5 py-0.5 rounded dark:bg-green-900 dark:text-green-300"
								>
									Caché de OFF
								</span>
							{/if}
						</Table.Cell>
						<Table.Cell class="text-right">{ingredient.calories?.toFixed(2) ?? 'N/A'}</Table.Cell>
						<Table.Cell class="text-right">{ingredient.protein?.toFixed(2) ?? 'N/A'}</Table.Cell>
						<Table.Cell class="text-right">{ingredient.fat?.toFixed(2) ?? 'N/A'}</Table.Cell>
						<Table.Cell class="text-right">{ingredient.carbs?.toFixed(2) ?? 'N/A'}</Table.Cell>
						<Table.Cell class="text-right">
							<Dialog.Root>
								<Button
									variant="outline"
									size="sm"
									disabled={ingredient.source !== 'custom'}
									onclick={(e) => {
										if (ingredient.source !== 'custom') e.preventDefault();
										// Lógica para abrir el diálogo si es necesario
									}}
								>
									Editar
								</Button>
								<Dialog.Content class="sm:max-w-[425px]">
									<Dialog.Header>
										<Dialog.Title>Editar Ingrediente</Dialog.Title>
									</Dialog.Header>
									<form method="POST" action="?/update" use:enhance>
										<input type="hidden" name="id" value={ingredient.id} />
										<div class="grid gap-4 py-4">
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="name-edit" class="text-right">Nombre</Label>
												<Input
													id="name-edit"
													name="name"
													value={ingredient.name}
													class="col-span-3"
												/>
											</div>
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="calories-edit" class="text-right">Calorías</Label>
												<Input
													id="calories-edit"
													name="calories"
													type="number"
													step="0.1"
													value={ingredient.calories}
													class="col-span-3"
												/>
											</div>
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="protein-edit" class="text-right">Proteínas</Label>
												<Input
													id="protein-edit"
													name="protein"
													type="number"
													step="0.1"
													value={ingredient.protein}
													class="col-span-3"
												/>
											</div>
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="fat-edit" class="text-right">Grasas</Label>
												<Input
													id="fat-edit"
													name="fat"
													type="number"
													step="0.1"
													value={ingredient.fat}
													class="col-span-3"
												/>
											</div>
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="carbs-edit" class="text-right">Carbohidratos</Label>
												<Input
													id="carbs-edit"
													name="carbs"
													type="number"
													step="0.1"
													value={ingredient.carbs}
													class="col-span-3"
												/>
											</div>
										</div>
										<Dialog.Footer>
											<Dialog.Close class={buttonVariants()} type="submit">Guardar Cambios</Dialog.Close>
										</Dialog.Footer>
									</form>
								</Dialog.Content>
							</Dialog.Root>
							<Dialog.Root>
								<Dialog.Trigger
									class={buttonVariants({ variant: 'destructive', size: 'sm' }) + ' ml-2'}
								>
									Eliminar
								</Dialog.Trigger>
								<Dialog.Content class="sm:max-w-[425px]">
									<Dialog.Header>
										<Dialog.Title>Confirmar Eliminación</Dialog.Title>
										<Dialog.Description>
											¿Estás seguro de que quieres eliminar el ingrediente "{ingredient.name}"? Esta
											acción no se puede deshacer.
										</Dialog.Description>
									</Dialog.Header>
									<form method="POST" action="?/delete" use:enhance>
										<input type="hidden" name="id" value={ingredient.id} />
										<input type="hidden" name="source" value={ingredient.source} />
										<Dialog.Footer>
											<Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cancelar</Dialog.Close>
											<Button variant="destructive" type="submit">Eliminar</Button>
										</Dialog.Footer>
									</form>
								</Dialog.Content>
							</Dialog.Root>
						</Table.Cell>
					</Table.Row>
				{:else}
					<Table.Row>
						<Table.Cell colspan={7} class="text-center">No hay ingredientes.</Table.Cell>
					</Table.Row>
				{/each}
			</Table.Body>
		</Table.Root>
	</div>
</div>

// --- Ruta: src/routes/admin/ingredientes/+page.server.ts ---
// Ruta: src/routes/admin/ingredientes/+page.server.ts
import { fail } from '@sveltejs/kit';
import type { PageServerLoad, Actions } from './$types';
// Justificación (load): La función `load` ahora llama al endpoint GET de la API usando `fetch`.
// Esto asegura que la página y la API están desacopladas. La página consume su propia API,
// una práctica conocida como "dogfooding", que garantiza que la API es robusta.
export const load: PageServerLoad = async ({ fetch }) => {
	const response = await fetch('/api/ingredients');
	if (!response.ok) {
		// En un caso real, podrías manejar el error de forma más elegante.
		return { ingredients: [] };
	}
	const ingredients = await response.json();
	return {
		ingredients
	};
};
// Justificación (actions): Las acciones ahora empaquetan los datos del formulario y los envían
// al endpoint de la API correspondiente usando `fetch`. La lógica de negocio y la validación
// residen únicamente en la API, y esta acción solo se encarga de la comunicación.
export const actions: Actions = {
	create: async ({ request, fetch }) => {
		const formData = await request.formData();
		const response = await fetch('/api/ingredients', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(Object.fromEntries(formData))
		});
		if (!response.ok) {
			const result = await response.json();
			return fail(response.status, {
				data: Object.fromEntries(formData),
				errors: result.errors
			});
		}
		return { success: true, message: 'Ingrediente creado con éxito' };
	},
	update: async ({ request, fetch }) => {
		const formData = await request.formData();
		const id = formData.get('id') as string;
		const response = await fetch(`/api/ingredients/${id}`,
		{
			method: 'PUT',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(Object.fromEntries(formData))
		});
		if (!response.ok) {
			const result = await response.json();
			return fail(response.status, {
				data: Object.fromEntries(formData),
				errors: result.errors,
				id
			});
		}
		return { success: true, message: 'Ingrediente actualizado con éxito' };
	},
	delete: async ({ request, fetch }) => {
		const formData = await request.formData();
		const id = formData.get('id') as string;
		const source = formData.get('source') as string;
		// Justificación: La lógica para determinar qué endpoint llamar ahora reside aquí,
		// basándose en el 'source' del ingrediente.
		const apiPath = source === 'custom' ? `/api/ingredients/${id}` : `/api/products/${id}`;
		const response = await fetch(apiPath, {
			method: 'DELETE'
		});
		if (!response.ok) {
			return fail(response.status, { message: 'Error al eliminar el ingrediente' });
		}
		return { success: true, message: 'Ingrediente eliminado con éxito' };
	}
};

// --- Ruta: src/routes/api/ingredients/+server.ts ---
// Ruta: src/routes/api/ingredients/+server.ts
import { json, type RequestHandler } from '@sveltejs/kit';
import { ingredientService } from '$lib/server/services/ingredientService';
import { IngredientSchema } from '$lib/schemas/ingredientSchema';
import { ZodError } from 'zod';
// Justificación: Se importa la nueva utilidad unificada.
import { createFailResponse } from '$lib/server/zodErrors';
export const GET: RequestHandler = async () => {
	try {
		const ingredients = await ingredientService.getAllUnified();
		return json(ingredients);
	} catch (error) {
		console.error('Error fetching ingredients:', error);
		// Justificación: Se usa la nueva utilidad para unificar la respuesta de error.
		return json(createFailResponse('Error interno del servidor'), { status: 500 });
	}
};
export const POST: RequestHandler = async ({ request }) => {
	try {
		const body = await request.json();
		const validatedData = IngredientSchema.parse(body);
		const newIngredient = await ingredientService.create(validatedData);
		return json(newIngredient, { status: 201 });
	} catch (error) {
		if (error instanceof ZodError) {
			// Justificación: Se usa la nueva utilidad para el error de validación.
			return json(createFailResponse('La validación falló', error), { status: 400 });
		}
		console.error('Error creating ingredient:', error);
		// Justificación: Se usa la nueva utilidad para unificar la respuesta de error.
		return json(createFailResponse('Error interno del servidor'), { status: 500 });
	}
};

// --- Ruta: src/lib/server/services/recipeService.ts ---
// Ruta: src/lib/server/services/recipeService.ts
import prisma from '$lib/server/prisma';
import { Prisma } from '@prisma/client';
import type { SearchFilters as ZodSearchFilters } from '$lib/schemas/searchSchema';
import type { RecipeData } from '$lib/schemas/recipeSchema';
import { generateUniqueSlug } from '$lib/server/slug';
const recipeInclude = {
	ingredients: {
		include: {
			product: true,
			customIngredient: true
		}
	},
	urls: true
};
// Justificación: Se usa Prisma.RecipeGetPayload para generar automáticamente
// el tipo correcto que corresponde a la consulta, incluyendo las relaciones.
// Esto es más robusto y menos propenso a errores que definir el tipo manualmente.
type FullRecipe = Prisma.RecipeGetPayload<{
	include: typeof recipeInclude;
}>;
// --- Tipos para Búsqueda Avanzada ---
export type MacroFilter = {
	min?: number;
	max?: number;
};
export type AdvancedSearchFilters = ZodSearchFilters;
type RawRecipeQueryResult = {
	id: string;
	title: string;
	imageUrl: string | null;
};
export const recipeService = {
	async getAll(): Promise<FullRecipe[]> {
		return await prisma.recipe.findMany({
			include: recipeInclude,
			orderBy: { title: 'asc' }
		});
	},
	async getById(id: string): Promise<FullRecipe | null> {
		return await prisma.recipe.findUnique({
			where: { id },
			include: recipeInclude
		});
	},
	async getBySlug(slug: string): Promise<FullRecipe | null> {
		return await prisma.recipe.findUnique({
			where: { slug },
			include: recipeInclude
		});
	},
	async create(data: RecipeData) {
		const { title, steps, ingredients, urls, imageUrl } = data;
		const slug = await generateUniqueSlug(title);
		return await prisma.$transaction(async (tx) => {
			const newRecipe = await tx.recipe.create({
				data: {
					title,
					slug,
					normalizedTitle: title.toLowerCase(),
					steps,
					imageUrl,
					urls: {
						create: urls?.map((url: string) => ({ url }))
					}
				}
			});
			for (const ingredient of ingredients) {
				await tx.recipeIngredient.create({
					data: {
						recipeId: newRecipe.id,
						quantity: ingredient.quantity,
						productId: ingredient.type === 'product' ? ingredient.id : null,
						customIngredientId: ingredient.type === 'custom' ? ingredient.id : null
					}
				});
			}
			return newRecipe;
		});
	},
	async update(id: string, data: RecipeData) {
		const { title, steps, ingredients, urls, imageUrl } = data;
		// Comprobar si el título ha cambiado para regenerar el slug
		const originalRecipe = await prisma.recipe.findUnique({ where: { id } });
		let slug: string | undefined;
		if (originalRecipe && originalRecipe.title !== title) {
			slug = await generateUniqueSlug(title);
		}
		return await prisma.$transaction(async (tx) => {
			await tx.recipe.update({
				where: { id },
				data: {
					title,
					slug, // Se actualiza solo si se ha generado uno nuevo
					normalizedTitle: title.toLowerCase(),
					steps,
					imageUrl
				}
			});
			await tx.recipeIngredient.deleteMany({ where: { recipeId: id } });
			for (const ingredient of ingredients) {
				await tx.recipeIngredient.create({
					data: {
						recipeId: id,
						quantity: ingredient.quantity,
						productId: ingredient.type === 'product' ? ingredient.id : null,
						customIngredientId: ingredient.type === 'custom' ? ingredient.id : null
					}
				});
			}
			await tx.recipeUrl.deleteMany({ where: { recipeId: id } });
			if (urls && urls.length > 0) {
				await tx.recipeUrl.createMany({
					data: urls.map((url: string) => ({ recipeId: id, url }))
				});
			}
			return await tx.recipe.findUnique({ where: { id }, include: recipeInclude });
		});
	},
	async deleteById(id: string) {
		return await prisma.recipe.delete({
			where: { id }
		});
	},
	async findPaginated(searchTerm: string | null, limit: number, offset: number) {
		const normalizedSearchTerm = searchTerm?.toLowerCase();
		const whereClause: Prisma.RecipeWhereInput = normalizedSearchTerm
			? {
					OR: [
						{ normalizedTitle: { contains: normalizedSearchTerm } },
						{
							ingredients: {
								some: {
									OR: [
										{ product: { normalizedName: { contains: normalizedSearchTerm } } },
										{ customIngredient: { normalizedName: { contains: normalizedSearchTerm } } }
									]
								}
							}
						}
					]
				}
			: {};
		return prisma.recipe.findMany({
			where: whereClause,
			include: recipeInclude,
			orderBy: { title: 'asc' },
			take: limit,
			skip: offset
		});
	},
	async findAdvanced(filters: AdvancedSearchFilters): Promise<FullRecipe[]> {
		const { ingredients, grams, percent, sortBy, limit, offset } = filters;
		const withClause = Prisma.sql`
			WITH "RecipeTotals" AS (
				SELECT
					ri."recipeId",
					SUM(COALESCE(p.calories, ci.calories, 0) * ri.quantity / 100.0) AS "totalCalories",
					SUM(COALESCE(p.protein, ci.protein, 0) * ri.quantity / 100.0) AS "totalProtein",
					SUM(COALESCE(p.carbs, ci.carbs, 0) * ri.quantity / 100.0) AS "totalCarbs",
					SUM(COALESCE(p.fat, ci.fat, 0) * ri.quantity / 100.0) AS "totalFat"
				FROM "RecipeIngredient" ri
				LEFT JOIN "Product" p ON ri."productId" = p.id
				LEFT JOIN "CustomIngredient" ci ON ri."customIngredientId" = ci.id
				GROUP BY ri."recipeId"
			),
			"RecipePercentages" AS (
				SELECT
					"recipeId",
					"totalCalories",
					"totalProtein",
					"totalCarbs",
					"totalFat",
					"totalProtein" * 4 * 100.0 / NULLIF("totalCalories", 0) AS "percentProtein",
					"totalCarbs" * 4 * 100.0 / NULLIF("totalCalories", 0) AS "percentCarbs",
					"totalFat" * 9 * 100.0 / NULLIF("totalCalories", 0) AS "percentFat"
				FROM "RecipeTotals"
			)
		`;
		const selectClause = Prisma.sql`
			SELECT r.id, r.title, r.imageUrl
			FROM "Recipe" r
			JOIN "RecipePercentages" rt ON r.id = rt."recipeId"
		`;
		const whereConditions: Prisma.Sql[] = [];
		if (ingredients && ingredients.length > 0) {
			// Justificación: Se itera sobre cada ID de ingrediente para construir una
			// subconsulta `EXISTS`. Esto asegura que la receta contenga TODOS los
			// ingredientes seleccionados. La lógica se ha hecho robusta para
			// manejar IDs con o sin prefijo, infiriendo el tipo si este falta.
			ingredients.forEach((ingredientId) => {
				let isProduct = false;
				let id = ingredientId;
				if (id.startsWith('product-')) {
					isProduct = true;
					id = id.replace('product-', '');
				} else if (id.startsWith('custom-')) {
					id = id.replace('custom-', '');
				} else if (!isNaN(Number(id))) {
					// Si no hay prefijo pero es numérico, asumimos que es un producto (código de barras).
					isProduct = true;
				}
				// Si no tiene prefijo y no es numérico, se asume que es un CUID de un ingrediente custom.
				if (isProduct) {
					whereConditions.push(Prisma.sql`
						EXISTS (
							SELECT 1 FROM "RecipeIngredient" ri
							WHERE ri."recipeId" = r.id AND ri."productId" = ${id}
						)
					`);
				} else {
					whereConditions.push(Prisma.sql`
						EXISTS (
							SELECT 1 FROM "RecipeIngredient" ri
							WHERE ri."recipeId" = r.id AND ri."customIngredientId" = ${id}
						)
					`);
				}
			});
		}
		if (grams?.calories?.min != null) whereConditions.push(Prisma.sql`rt."totalCalories" >= ${grams.calories.min}`);
		if (grams?.calories?.max != null) whereConditions.push(Prisma.sql`rt."totalCalories" <= ${grams.calories.max}`);
		if (grams?.protein?.min != null) whereConditions.push(Prisma.sql`rt."totalProtein" >= ${grams.protein.min}`);
		if (grams?.protein?.max != null) whereConditions.push(Prisma.sql`rt."totalProtein" <= ${grams.protein.max}`);
		if (grams?.carbs?.min != null) whereConditions.push(Prisma.sql`rt."totalCarbs" >= ${grams.carbs.min}`);
		if (grams?.carbs?.max != null) whereConditions.push(Prisma.sql`rt."totalCarbs" <= ${grams.carbs.max}`);
		if (grams?.fat?.min != null) whereConditions.push(Prisma.sql`rt."totalFat" >= ${grams.fat.min}`);
		if (grams?.fat?.max != null) whereConditions.push(Prisma.sql`rt."totalFat" <= ${grams.fat.max}`);
		if (percent?.protein?.min != null) whereConditions.push(Prisma.sql`rt."percentProtein" >= ${percent.protein.min}`);
		if (percent?.protein?.max != null) whereConditions.push(Prisma.sql`rt."percentProtein" <= ${percent.protein.max}`);
		if (percent?.carbs?.min != null) whereConditions.push(Prisma.sql`rt."percentCarbs" >= ${percent.carbs.min}`);
		if (percent?.carbs?.max != null) whereConditions.push(Prisma.sql`rt."percentCarbs" <= ${percent.carbs.max}`);
		if (percent?.fat?.min != null) whereConditions.push(Prisma.sql`rt."percentFat" >= ${percent.fat.min}`);
		if (percent?.fat?.max != null) whereConditions.push(Prisma.sql`rt."percentFat" <= ${percent.fat.max}`);
		const whereClause = whereConditions.length > 0 ? Prisma.sql`WHERE ${Prisma.join(whereConditions, ' AND ')}` : Prisma.empty;
		let orderByClause: Prisma.Sql;
		switch (sortBy) {
			case 'calories_asc': orderByClause = Prisma.sql`ORDER BY rt."totalCalories" ASC`; break;
			case 'calories_desc': orderByClause = Prisma.sql`ORDER BY rt."totalCalories" DESC`; break;
			case 'protein_desc':
				orderByClause = (percent?.protein?.min != null || percent?.protein?.max != null)
					? Prisma.sql`ORDER BY rt."percentProtein" DESC`
					: Prisma.sql`ORDER BY rt."totalProtein" DESC`;
				break;
			default: orderByClause = Prisma.sql`ORDER BY r.title ASC`;
		}
		const paginationClause = Prisma.sql`LIMIT ${limit} OFFSET ${offset}`;
		const fullQuery = Prisma.sql`${withClause} ${selectClause} ${whereClause} ${orderByClause} ${paginationClause}`;
		const result = await prisma.$queryRaw<RawRecipeQueryResult[]>(fullQuery);
		const recipeIds = result.map((r) => r.id);
		if (recipeIds.length === 0) return [];
		const recipesInOrder = await prisma.recipe.findMany({
			where: { id: { in: recipeIds } },
			include: recipeInclude
		});
		return recipeIds.map(id => recipesInOrder.find(r => r.id === id)).filter((r): r is FullRecipe => !!r);
	}
};

// --- Ruta: src/lib/server/services/recipeService.spec.ts ---
// Ruta: src/lib/server/services/recipeService.spec.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { recipeService } from './recipeService';
import { imageService } from './imageService';
import prisma from '$lib/server/prisma';
import type { RecipeData } from '$lib/schemas/recipeSchema';
// Justificación (Paso 4.2): Mockeamos el imageService para que los tests de recipeService
// no dependan de la red ni de la lógica de extracción de imágenes.
vi.mock('./imageService', () => ({
	imageService: {
		getImageFromUrl: vi.fn()
	}
}));
// Justificación: Usamos una base de datos de prueba en memoria para cada test,
// asegurando un entorno limpio y aislado para cada caso.
beforeEach(async () => {
	// Limpiamos la base de datos antes de cada test
	await prisma.recipeIngredient.deleteMany();
	await prisma.recipeUrl.deleteMany();
	await prisma.recipe.deleteMany();
	await prisma.customIngredient.deleteMany();
	vi.clearAllMocks();
});
const MOCK_RECIPE_DATA: RecipeData = {
	title: 'Test Recipe',
	description: 'A test description',
	steps: 'Step 1. Do this.',
	ingredients: [],
	urls: ['https://example.com/recipe'],
	imageUrl: ''
};
describe('recipeService with images and URLs', () => {
	it('should create a recipe with a user-provided image', async () => {
		// Arrange
		const recipeData = { ...MOCK_RECIPE_DATA, imageUrl: 'data:image/png;base64,test' };
		// Act
		const result = await recipeService.create(recipeData);
		// Assert
		expect(result).toBeDefined();
		expect(result.title).toBe(recipeData.title);
		expect(result.imageUrl).toBe(recipeData.imageUrl);
		expect(imageService.getImageFromUrl).not.toHaveBeenCalled(); // No debe llamar al servicio si la imagen ya viene
	});
	it('should call imageService to get an image if no image is provided but a URL is', async () => {
		// Arrange
		const recipeData = { ...MOCK_RECIPE_DATA, imageUrl: undefined };
		const fetchedImageUrl = 'data:image/webp;base64,fetched-image';
		(imageService.getImageFromUrl as vi.Mock).mockResolvedValue(fetchedImageUrl);
		// Act
		const result = await recipeService.create(recipeData);
		// Assert
		expect(result).toBeDefined();
		expect(imageService.getImageFromUrl).toHaveBeenCalledWith(recipeData.urls![0]);
		expect(result.imageUrl).toBe(fetchedImageUrl);
	});
	it('should create a recipe with URLs', async () => {
		// Arrange
		const recipeData = { ...MOCK_RECIPE_DATA };
		// Act
		const result = await recipeService.create(recipeData);
		const dbRecipe = await prisma.recipe.findUnique({
			where: { id: result!.id },
			include: { urls: true }
		});
		// Assert
		expect(dbRecipe).toBeDefined();
		expect(dbRecipe?.urls).toHaveLength(1);
		expect(dbRecipe?.urls[0].url).toBe(recipeData.urls![0]);
	});
	it('should update a recipe, removing old URLs and adding new ones', async () => {
		// Arrange
		// 1. Creamos una receta inicial con una URL
		const initialRecipe = await prisma.recipe.create({
			data: {
				title: 'Initial',
				normalizedTitle: 'initial',
				steps: 'Initial',
				urls: { create: { url: 'https://initial.com' } }
			}
		});
		// 2. Preparamos los datos de actualización con una nueva URL
		const updateData = {
			...MOCK_RECIPE_DATA,
			title: 'Updated Recipe',
			urls: ['https://updated.com']
		};
		// Act
		const updatedRecipe = await recipeService.update(initialRecipe.id, updateData);
		// Assert
		const dbRecipe = await prisma.recipe.findUnique({
			where: { id: updatedRecipe!.id },
			include: { urls: true }
		});
		expect(dbRecipe).toBeDefined();
		expect(dbRecipe?.title).toBe('Updated Recipe');
		expect(dbRecipe?.urls).toHaveLength(1);
		expect(dbRecipe?.urls[0].url).toBe('https://updated.com'); // La URL antigua fue reemplazada
	});
});
describe('recipeService.findPaginated', () => {
	beforeEach(async () => {
		// Creación de datos de prueba
		const pollo = await prisma.customIngredient.create({
			data: { name: 'Pollo', normalizedName: 'pollo', calories: 165, protein: 31, fat: 3.6, carbs: 0 }
		});
		const arroz = await prisma.customIngredient.create({
			data: { name: 'Arroz', normalizedName: 'arroz', calories: 130, protein: 2.7, fat: 0.3, carbs: 28 }
		});
		const lentejas = await prisma.customIngredient.create({
			data: {
				name: 'Lentejas',
				normalizedName: 'lentejas',
				calories: 116,
				protein: 9,
				fat: 0.4,
				carbs: 20
			}
		});
		// Receta 1: Pollo con Arroz
		await prisma.recipe.create({
			data: {
				title: 'Pollo con Arroz',
				normalizedTitle: 'pollo con arroz',
				steps: '...',
				ingredients: {
					create: [
						{ customIngredientId: pollo.id, quantity: 200 },
						{ customIngredientId: arroz.id, quantity: 150 }
					]
				}
			}
		});
		// Receta 2: Lentejas Estofadas
		await prisma.recipe.create({
			data: {
				title: 'Lentejas Estofadas',
				normalizedTitle: 'lentejas estofadas',
				steps: '...',
				ingredients: { create: [{ customIngredientId: lentejas.id, quantity: 300 }] }
			}
		});
		// Receta 3: Arroz con Pollo (variación)
		await prisma.recipe.create({
			data: {
				title: 'Arroz con Pollo',
				normalizedTitle: 'arroz con pollo',
				steps: '...',
				ingredients: {
					create: [
						{ customIngredientId: arroz.id, quantity: 200 },
						{ customIngredientId: pollo.id, quantity: 150 }
					]
				}
			}
		});
	});
	it('should return all recipes paginated when search term is null', async () => {
		const recipes = await recipeService.findPaginated(null, 2, 0);
		expect(recipes).toHaveLength(2);
		expect(recipes[0].title).toBe('Arroz con Pollo'); // Ordenado alfabéticamente
		expect(recipes[1].title).toBe('Lentejas Estofadas');
		const nextPage = await recipeService.findPaginated(null, 2, 2);
		expect(nextPage).toHaveLength(1);
		expect(nextPage[0].title).toBe('Pollo con Arroz');
	});
	it('should filter recipes by title', async () => {
		const recipes = await recipeService.findPaginated('lentejas', 5, 0);
		expect(recipes).toHaveLength(1);
		expect(recipes[0].title).toBe('Lentejas Estofadas');
	});
	it('should filter recipes by ingredient name', async () => {
		const recipes = await recipeService.findPaginated('pollo', 5, 0);
		expect(recipes).toHaveLength(2); // "Pollo con Arroz" y "Arroz con Pollo"
		const titles = recipes.map((r) => r.title).sort();
		expect(titles).toEqual(['Arroz con Pollo', 'Pollo con Arroz']);
	});
	it('should return an empty array if no recipe matches the search term', async () => {
		const recipes = await recipeService.findPaginated('pescado', 5, 0);
		expect(recipes).toHaveLength(0);
	});
});

// --- Ruta: src/lib/server/services/productService.ts ---
// Ruta: src/lib/server/services/productService.ts
import prisma from '$lib/server/prisma';
import type { Prisma } from '@prisma/client';
import ky from 'ky';
import { normalizeText } from '$lib/utils';
// Definición de tipos para la respuesta de la API de Open Food Facts
type OpenFoodFactsProduct = {
	code: string;
	product_name: string;
	brands?: string;
	image_url?: string;
	nutriments: {
		'energy-kcal_100g'?: number; // Variante con guion
		energy_kcal_100g?: number; // Variante con guion bajo
		fat_100g?: number;
		proteins_100g?: number;
		carbohydrates_100g?: number;
	};
};
type OpenFoodFactsResponse = {
	status: number;
	product?: OpenFoodFactsProduct;
};
// Justificación: La capa de servicio abstrae la lógica de negocio y el acceso a datos.
// Para este servicio, se coordinará la consulta a la caché local (Prisma) y
// la llamada a la API externa (Open Food Facts) si es necesario.
export const productService = {
	/**
	 * Busca un producto por su código de barras.
	 * Primero intenta encontrarlo en la caché local (tabla Product).
	 * Si no lo encuentra, lo busca en la API de Open Food Facts,
	 * lo guarda en la caché y luego lo devuelve.
	 * @param barcode - El código de barras del producto a buscar.
	 */
	async findByBarcode(barcode: string) {
		const cachedProduct = await prisma.product.findUnique({
			where: { id: barcode }
		});
		if (cachedProduct) {
			console.log(`[Cache] HIT for barcode: ${barcode}`);
			return cachedProduct;
		}
		console.log(`[Cache] MISS for barcode: ${barcode}. Fetching from OFF.`);
		const url = `https://world.openfoodfacts.org/api/v2/product/${barcode}.json`;
		try {
			const response = await ky.get(url).json<OpenFoodFactsResponse>();
			if (response.status === 0 || !response.product) {
				return null; // Producto no encontrado en OFF
			}
			const productFromApi = response.product;
			const calories =
				productFromApi.nutriments['energy-kcal_100g'] ??
				productFromApi.nutriments.energy_kcal_100g;
			// 1. Normalizar datos de la API a nuestro esquema
			const normalizedProduct = {
				id: productFromApi.code,
				name: productFromApi.product_name,
				// Justificación: Se genera el nombre normalizado para la búsqueda.
				normalizedName: normalizeText(productFromApi.product_name),
				brand: productFromApi.brands,
				imageUrl: productFromApi.image_url,
				calories: calories,
				fat: productFromApi.nutriments.fat_100g,
				protein: productFromApi.nutriments.proteins_100g,
				carbs: productFromApi.nutriments.carbohydrates_100g,
				// Justificación (Prisma.InputJsonValue): Hacemos un type casting a `InputJsonValue`
				// para asegurar a TypeScript que la estructura del objeto de la API
				// es compatible con el tipo `Json` que Prisma espera.
				fullPayload: productFromApi as Prisma.InputJsonValue
			};
			// 2. Guardar en caché para futuras peticiones
			console.log(`[Cache] WRITING product: ${normalizedProduct.name}`);
			const newCachedProduct = await prisma.product.create({
				data: normalizedProduct
			});
			// 3. Devolver el producto recién cacheado
			return newCachedProduct;
		} catch (error) {
			console.error(`[OFF] Error fetching product ${barcode}:`, error);
			return null;
		}
	},
	/**
	 * Elimina un producto de la caché por su ID (código de barras).
	 * @param barcode - El ID del producto a eliminar.
	 */
	async deleteById(barcode: string) {
		return await prisma.product.delete({
			where: { id: barcode }
		});
	}
};

// --- Ruta: src/lib/server/services/productService.spec.ts ---
// Ruta: src/lib/server/services/productService.spec.ts
import { describe, it, expect, vi, beforeEach, afterEach, type Mock } from 'vitest';
import prisma from '$lib/server/prisma';
import ky from 'ky';
import { productService } from './productService';
import type { Prisma, Product } from '@prisma/client';
import { normalizeText } from '$lib/utils';
// Justificación: Mockeamos los módulos externos para aislar nuestro servicio.
vi.mock('$lib/server/prisma', () => ({
	default: {
		product: {
			findUnique: vi.fn(),
			create: vi.fn()
		}
	}
}));
vi.mock('ky', () => ({
	default: {
		get: vi.fn()
	}
}));
vi.mock('$lib/utils', () => ({
	normalizeText: vi.fn((text) => text.toLowerCase())
}));
const mockedPrisma = prisma;
const mockedKy = ky;
const mockedNormalizeText = normalizeText as Mock;
// Definimos los tipos aquí para que el test sea autocontenido.
type OpenFoodFactsProduct = {
	code: string;
	product_name: string;
	brands?: string;
	image_url?: string;
	nutriments: {
		energy_kcal_100g?: number;
		fat_100g?: number;
		proteins_100g?: number;
		carbohydrates_100g?: number;
	};
};
type OpenFoodFactsResponse = {
	status: number;
	product?: OpenFoodFactsProduct;
};
describe('productService', () => {
	beforeEach(() => {
		vi.resetAllMocks();
		// Justificación: Silenciamos console.log para mantener la salida del test limpia.
		vi.spyOn(console, 'log').mockImplementation(() => {});
	});
	afterEach(() => {
		vi.mocked(console.log).mockRestore();
	});
	const barcode = '123456789';
	const cachedProduct: Product = {
		id: barcode,
		name: 'Producto en Caché',
		normalizedName: 'producto en caché',
		brand: 'Marca Caché',
		imageUrl: 'http://cache.com/img.png',
		calories: 100,
		fat: 10,
		protein: 5,
		carbs: 20,
		fullPayload: {} as Prisma.JsonValue,
		createdAt: new Date(),
		updatedAt: new Date()
	};
	const productFromApi: OpenFoodFactsProduct = {
		code: barcode,
		product_name: 'Producto de API',
		brands: 'Marca API',
		image_url: 'http://api.com/img.png',
		nutriments: {
			energy_kcal_100g: 200,
			fat_100g: 20,
			proteins_100g: 10,
			carbohydrates_100g: 40
		}
	};
	const apiProductResponse: OpenFoodFactsResponse = {
		status: 1,
		product: productFromApi
	};
	it('debería devolver un producto de la caché si existe (Cache Hit)', async () => {
		// Arrange
		(mockedPrisma.product.findUnique as Mock).mockResolvedValue(cachedProduct);
		// Act
		const result = await productService.findByBarcode(barcode);
		// Assert
		expect(result).toEqual(cachedProduct);
		expect(mockedPrisma.product.findUnique).toHaveBeenCalledTimes(1);
		expect(mockedKy.get).not.toHaveBeenCalled();
	});
	it('debería obtener el producto de la API y guardarlo en caché si no existe (Cache Miss)', async () => {
		// Arrange
		(mockedPrisma.product.findUnique as Mock).mockResolvedValue(null);
		(mockedKy.get as Mock).mockReturnValue({
			json: vi.fn().mockResolvedValue(apiProductResponse)
		});
		const expectedDataToCreate = {
			id: productFromApi.code,
			name: productFromApi.product_name,
			normalizedName: 'producto de api',
			brand: productFromApi.brands,
			imageUrl: productFromApi.image_url,
			calories: productFromApi.nutriments.energy_kcal_100g,
			fat: productFromApi.nutriments.fat_100g,
			protein: productFromApi.nutriments.proteins_100g,
			carbs: productFromApi.nutriments.carbohydrates_100g,
			fullPayload: productFromApi as unknown as Prisma.JsonValue
		};
		(mockedPrisma.product.create as Mock).mockResolvedValue({
			...expectedDataToCreate,
			createdAt: new Date(),
			updatedAt: new Date()
		});
		mockedNormalizeText.mockReturnValue('producto de api');
		// Act
		await productService.findByBarcode(barcode);
		// Assert
		expect(mockedPrisma.product.findUnique).toHaveBeenCalledTimes(1);
		expect(mockedKy.get).toHaveBeenCalledTimes(1);
		expect(mockedPrisma.product.create).toHaveBeenCalledTimes(1);
		expect(mockedPrisma.product.create).toHaveBeenCalledWith({
			data: expectedDataToCreate
		});
	});
	it('debería devolver null si el producto no se encuentra ni en caché ni en la API', async () => {
		// Arrange
		(mockedPrisma.product.findUnique as Mock).mockResolvedValue(null);
		(mockedKy.get as Mock).mockReturnValue({
			json: vi.fn().mockResolvedValue({ status: 0 }) // Simula producto no encontrado en OFF
		});
		// Act
		const result = await productService.findByBarcode(barcode);
		// Assert
		expect(result).toBeNull();
		expect(mockedPrisma.product.create).not.toHaveBeenCalled();
	});
});

// --- Ruta: src/lib/server/services/ingredientService.ts ---
// Ruta: src/lib/server/services/ingredientService.ts
import type { CustomIngredient, Product } from '@prisma/client';
import prisma from '$lib/server/prisma';
// Justificación: Importamos el 'const' IngredientSchema para la validación en tiempo de ejecución
// y el 'type' Ingredient para las anotaciones de tipo estáticas, cumpliendo con verbatimModuleSyntax.
import { type Ingredient } from '$lib/schemas/ingredientSchema';
import { normalizeText } from '$lib/utils';
// Justificación: La capa de servicio abstrae la lógica de negocio y el acceso a datos.
// Esto mantiene los endpoints de la API (controladores) limpios y centrados en manejar
// la petición y la respuesta, mientras que la lógica real reside aquí.
export const ingredientService = {
	/**
	 * Busca ingredientes por nombre en la base de datos local (custom y cacheados).
	 * @param query - El término de búsqueda.
	 */
	async searchByName(query: string): Promise<{ customIngredients: CustomIngredient[], cachedProducts: Product[] }> {
		const normalizedQuery = normalizeText(query);
		// --- INICIO DE CÓDIGO DE DEPURACIÓN ---
		console.log(`[DEBUG] Buscando ingredientes con query normalizado: "${normalizedQuery}"`);
		// --- FIN DE CÓDIGO DE DEPURACIÓN ---
		const customIngredients = await prisma.customIngredient.findMany({
			where: {
				normalizedName: {
					contains: normalizedQuery
				}
			}
		});
		const cachedProducts = await prisma.product.findMany({
			where: {
				normalizedName: {
					contains: normalizedQuery
				}
			}
		});
		// --- INICIO DE CÓDIGO DE DEPURACIÓN ---
		console.log(`[DEBUG] Encontrados ${customIngredients.length} ingredientes custom.`);
		console.log(`[DEBUG] Encontrados ${cachedProducts.length} productos en caché.`);
		// --- FIN DE CÓDIGO DE DEPURACIÓN ---
		return {
			customIngredients,
			cachedProducts
		};
	},
	/**
	 * Obtiene todos los ingredientes personalizados.
	 */
	async getAll() {
		return await prisma.customIngredient.findMany({
			orderBy: { name: 'asc' }
		});
	},
	/**
	 * Obtiene todos los ingredientes (personalizados y cacheados) en una lista unificada.
	 */
	async getAllUnified() {
		const customIngredients = await prisma.customIngredient.findMany({
			orderBy: { name: 'asc' }
		});
		const cachedProducts = await prisma.product.findMany({
			orderBy: { name: 'asc' }
		});
		const unifiedList = [
			...customIngredients.map((i) => ({ ...i, source: 'custom' as const })),
			...cachedProducts.map((p) => ({ ...p, source: 'product' as const }))
		];
		return unifiedList.sort((a, b) => a.name.localeCompare(b.name));
	},
	/**
	 * Crea un nuevo ingrediente personalizado.
	 * @param data - Datos validados por Zod.
	 */
	async create(data: Ingredient) {
		// Justificación: Se genera el nombre normalizado antes de la inserción
		// para asegurar que la búsqueda insensible a acentos funcione correctamente.
		const normalizedName = normalizeText(data.name);
		return await prisma.customIngredient.create({
			data: {
				name: data.name,
				calories: data.calories,
				fat: data.fat,
				protein: data.protein,
				carbs: data.carbs,
				normalizedName
			}
		});
	},
	/**
	 * Actualiza un ingrediente personalizado existente.
	 * @param id - El ID del ingrediente a actualizar.
	 * @param data - Datos validados por Zod.
	 */
	async update(id: string, data: Ingredient) {
		// Justificación: Se actualiza el nombre normalizado junto con el nombre
		// para mantener la consistencia de los datos para la búsqueda.
		const normalizedName = normalizeText(data.name);
		return await prisma.customIngredient.update({
			where: { id },
			data: {
				...data,
				normalizedName
			}
		});
	},
	/**
	 * Elimina un ingrediente personalizado.
	 * @param id - El ID del ingrediente a eliminar.
	 */
	async deleteById(id: string) {
		return await prisma.customIngredient.delete({
			where: { id }
		});
	},
	/**
	 * Sincroniza los ingredientes de la base de datos local que provienen de Open Food Facts (OFF).
	 * Compara los datos locales con los de la API de OFF y actualiza si hay diferencias.
	 * Incluye un retardo para no sobrecargar la API y maneja errores por ingrediente.
	 */
	async syncWithOpenFoodFacts(): Promise<{
		updatedIngredients: string[];
		failedIngredients: { id: string; name: string; reason: string }[];
	}> {
		const updatedIngredients: string[] = [];
		const failedIngredients: { id: string; name: string; reason: string }[] = [];
		const API_DELAY_MS = 300; // Justificación: Retardo para ser respetuosos con la API de OFF.
		// Justificación: Obtenemos solo los productos cacheados, que son los que provienen de OFF.
		const productsToSync = await prisma.product.findMany();
		for (const product of productsToSync) {
			try {
				const response = await fetch(`https://world.openfoodfacts.org/api/v2/product/${product.id}.json`);
				// Justificación: Pausa para evitar rate-limiting.
				await new Promise((resolve) => setTimeout(resolve, API_DELAY_MS));
				if (!response.ok) {
					failedIngredients.push({
						id: product.id,
						name: product.name,
						reason: `Error ${response.status}: ${response.statusText}`
					});
					continue; // Salta al siguiente ingrediente
				}
				const offData = await response.json();
				if (offData.status !== 1 || !offData.product) {
					failedIngredients.push({
						id: product.id,
						name: product.name,
						reason: 'Producto no encontrado en Open Food Facts'
					});
					continue;
				}
				const offProduct = offData.product;
				// Justificación: Mapeamos los datos de OFF a nuestra estructura de Product.
				// Usamos el operador de encadenamiento opcional y el de anulación (??)
				// para manejar de forma segura la posible ausencia de datos en la respuesta de la API.
				const newProductData = {
					name: offProduct.product_name || product.name,
					normalizedName: normalizeText(offProduct.product_name || product.name),
					brand: offProduct.brands || product.brand,
					imageUrl: offProduct.image_url || product.imageUrl,
					calories: offProduct.nutriments?.['energy-kcal_100g'] ?? product.calories,
					fat: offProduct.nutriments?.fat_100g ?? product.fat,
					protein: offProduct.nutriments?.proteins_100g ?? product.protein,
					carbs: offProduct.nutriments?.carbohydrates_100g ?? product.carbs,
					fullPayload: offProduct
				};
				// Justificación: Comparamos los campos relevantes para ver si es necesaria una actualización.
				// Se comparan los valores primitivos y el payload JSON completo para detectar cualquier cambio.
				const isDifferent =
					newProductData.name !== product.name ||
					newProductData.brand !== product.brand ||
					newProductData.imageUrl !== product.imageUrl ||
					newProductData.calories !== product.calories ||
					newProductData.fat !== product.fat ||
					newProductData.protein !== product.protein ||
					newProductData.carbs !== product.carbs;
				if (isDifferent) {
					await prisma.product.update({
						where: { id: product.id },
						data: newProductData
					});
					updatedIngredients.push(product.name);
				}
			} catch (error) {
				failedIngredients.push({
					id: product.id,
					name: product.name,
					reason: error instanceof Error ? error.message : 'Error desconocido'
				});
			}
		}
		return { updatedIngredients, failedIngredients };
	},
	/**
	 * Obtiene los detalles completos de una lista de ingredientes por sus IDs.
	 * @param ids - Un array de IDs, con prefijo 'product-' o 'custom-'.
	 */
	async getByIds(ids: string[]) {
		const productIds = ids
			.filter((id) => id.startsWith('product-'))
			.map((id) => id.replace('product-', ''));
		const customIngredientIds = ids
			.filter((id) => id.startsWith('custom-'))
			.map((id) => id.replace('custom-', ''));
		const [products, customIngredients] = await prisma.$transaction([
			prisma.product.findMany({ where: { id: { in: productIds } } }),
			prisma.customIngredient.findMany({ where: { id: { in: customIngredientIds } } })
		]);
		const combined = [
			...products.map((p) => ({
				...p,
				id: `product-${p.id}`,
				type: 'product' as const,
				source: 'off' as const
			})),
			...customIngredients.map((ci) => ({
				...ci,
				id: `custom-${ci.id}`,
				type: 'custom' as const,
				source: 'local' as const,
				imageUrl: null
			}))
		];
		return combined;
	}
};

// --- Ruta: src/lib/server/services/ingredientService.spec.ts ---
// Ruta: src/lib/server/services/ingredientService.spec.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import prisma from '$lib/server/prisma';
import { ingredientService } from './ingredientService';
import type { Ingredient } from '$lib/schemas/ingredientSchema';
import { normalizeText } from '$lib/utils';
// Justificación: Mockeamos el módulo de Prisma para aislar el servicio de la base de datos.
// `vi.mock` reemplaza las exportaciones del módulo con mocks, permitiéndonos controlar
// el comportamiento de `prisma.customIngredient.create` y otras funciones de Prisma durante el test.
vi.mock('$lib/server/prisma', () => {
	return {
		default: {
			customIngredient: {
				findMany: vi.fn(),
				create: vi.fn(),
				update: vi.fn(),
				delete: vi.fn()
			},
			product: {
				findMany: vi.fn(),
				update: vi.fn()
			}
		}
	};
});
// Mockeamos fetch globalmente para interceptar las llamadas a la API de OFF
global.fetch = vi.fn();
describe('ingredientService', () => {
	// Limpiamos los mocks antes de cada test para asegurar que no haya interferencias entre pruebas.
	beforeEach(() => {
		vi.clearAllMocks();
	});
	afterEach(() => {
		vi.useRealTimers(); // Restauramos los temporizadores reales después de cada test
	});
	it('debería llamar a prisma.customIngredient.create con los datos correctos', async () => {
		// 1. Arrange (Preparación)
		const newIngredientData: Ingredient = {
			name: 'Harina de Almendras',
			calories: 579,
			protein: 21.1,
			fat: 49.9,
			carbs: 21.6
		};
		const expectedResult = {
			id: 'clxmjm8om0000v9a1b2c3d4e5',
			...newIngredientData
		};
		// Configuramos el mock para que devuelva un valor específico cuando se llame.
		vi.mocked(prisma.customIngredient.create).mockResolvedValue(expectedResult);
		// 2. Act (Actuación)
		const result = await ingredientService.create(newIngredientData);
		// 3. Assert (Verificación)
		// Verificamos que la función 'create' de prisma fue llamada exactamente una vez.
		expect(prisma.customIngredient.create).toHaveBeenCalledTimes(1);
		// Verificamos que la función 'create' de prisma fue llamada con el objeto de datos correcto.
		expect(prisma.customIngredient.create).toHaveBeenCalledWith({
			data: {
				...newIngredientData,
				normalizedName: 'harina de almendras' // Justificación: Añadimos el campo esperado.
			}
		});
		// Verificamos que el resultado de nuestro servicio es el que esperábamos.
		expect(result).toEqual(expectedResult);
	});
	describe('syncWithOpenFoodFacts', () => {
		beforeEach(() => {
			vi.useFakeTimers();
		});
		afterEach(() => {
			vi.useRealTimers();
		});
		it('debería actualizar un producto cuando los datos de OFF son diferentes', async () => {
			// Arrange
			const mockProduct = {
				id: '12345',
				name: 'Old Name',
				brand: 'Old Brand',
				calories: 100,
				fat: 10,
				protein: 10,
				carbs: 10,
				imageUrl: 'old_url',
				normalizedName: 'old name',
				fullPayload: {}
			};
			vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct]);
			const offApiResponse = {
				status: 1,
				product: {
					product_name: 'New Name',
					brands: 'New Brand',
					nutriments: {
						'energy-kcal_100g': 200,
						fat_100g: 20,
						proteins_100g: 20,
						carbohydrates_100g: 20
					},
					image_url: 'new_url'
				}
			};
			vi.mocked(fetch).mockResolvedValue({
				ok: true,
				json: async () => offApiResponse
			} as Response);
			// Act
			const promise = ingredientService.syncWithOpenFoodFacts();
			await vi.runAllTimersAsync();
			const result = await promise;
			// Assert
			expect(prisma.product.update).toHaveBeenCalledTimes(1);
			expect(prisma.product.update).toHaveBeenCalledWith({
				where: { id: '12345' },
				data: {
					name: 'New Name',
					normalizedName: 'new name',
					brand: 'New Brand',
					imageUrl: 'new_url',
					calories: 200,
					fat: 20,
					protein: 20,
					carbs: 20,
					fullPayload: offApiResponse.product
				}
			});
			expect(result.updatedIngredients).toEqual(['Old Name']);
			expect(result.failedIngredients).toEqual([]);
		});
		it('NO debería actualizar un producto si los datos son idénticos', async () => {
			// Arrange
			const mockProduct = {
				id: '12345',
				name: 'Same Name',
				brand: 'Same Brand',
				calories: 100,
				fat: 10,
				protein: 10,
				carbs: 10,
				imageUrl: 'same_url',
				normalizedName: 'same name',
				fullPayload: {}
			};
			vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct]);
			const offApiResponse = {
				status: 1,
				product: {
					product_name: 'Same Name',
					brands: 'Same Brand',
					nutriments: {
						'energy-kcal_100g': 100,
						fat_100g: 10,
						proteins_100g: 10,
						carbohydrates_100g: 10
					},
					image_url: 'same_url'
				}
			};
			vi.mocked(fetch).mockResolvedValue({
				ok: true,
				json: async () => offApiResponse
			} as Response);
			// Act
			const promise = ingredientService.syncWithOpenFoodFacts();
			await vi.runAllTimersAsync();
			const result = await promise;
			// Assert
			expect(prisma.product.update).not.toHaveBeenCalled();
			expect(result.updatedIngredients).toEqual([]);
			expect(result.failedIngredients).toEqual([]);
		});
		it('debería registrar un fallo si la API de OFF devuelve un error', async () => {
			// Arrange
			const mockProduct = { id: '12345', name: 'Failing Product' };
			vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct as any]);
			vi.mocked(fetch).mockResolvedValue({
				ok: false,
				status: 500,
				statusText: 'Internal Server Error'
			} as Response);
			// Act
			const promise = ingredientService.syncWithOpenFoodFacts();
			await vi.runAllTimersAsync();
			const result = await promise;
			// Assert
			expect(prisma.product.update).not.toHaveBeenCalled();
			expect(result.updatedIngredients).toEqual([]);
			expect(result.failedIngredients).toEqual([
				{ id: '12345', name: 'Failing Product', reason: 'Error 500: Internal Server Error' }
			]);
		});
		it('debería registrar un fallo si el producto no se encuentra en OFF', async () => {
			// Arrange
			const mockProduct = { id: '12345', name: 'Not Found Product' };
			vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct as any]);
			vi.mocked(fetch).mockResolvedValue({
				ok: true,
				json: async () => ({ status: 0 }) // status: 0 indica no encontrado
			} as Response);
			// Act
			const promise = ingredientService.syncWithOpenFoodFacts();
			await vi.runAllTimersAsync();
			const result = await promise;
			// Assert
			expect(result.failedIngredients).toEqual([
				{
					id: '12345',
					name: 'Not Found Product',
					reason: 'Producto no encontrado en Open Food Facts'
				}
			]);
		});
	});
});

// --- Ruta: src/lib/server/services/imageService.ts ---
// Justificación (Paso 2.2):
// Este servicio encapsula la lógica para obtener y procesar imágenes desde URLs.
// Utiliza 'cheerio' para parsear el HTML y 'sharp' para la optimización de imágenes,
// siguiendo las directrices del plan de implementación.
import sharp from 'sharp';
import * as cheerio from 'cheerio';
const MAX_IMAGE_WIDTH = 768; // Ancho máximo para las imágenes de receta
/**
 * Extrae la URL de la imagen principal (thumbnail) de una página web.
 * Busca en las metaetiquetas 'og:image' y 'twitter:image'.
 * @param url La URL de la página web.
 * @returns La URL de la imagen o null si no se encuentra.
 */
async function getImageUrlFromPage(url: string): Promise<string | null> {
	try {
		const response = await fetch(url, {
			headers: {
				'User-Agent':
					'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
			}
		});
		if (!response.ok) {
			console.error(`Error fetching page ${url}: ${response.statusText}`);
			return null;
		}
		const html = await response.text();
		const $ = cheerio.load(html);
		// Priorizamos la etiqueta 'og:image' ya que es el estándar más común.
		const ogImage = $('meta[property="og:image"]').attr('content');
		if (ogImage) return ogImage;
		const twitterImage = $('meta[name="twitter:image"]').attr('content');
		if (twitterImage) return twitterImage;
		return null;
	} catch (error) {
		console.error(`Failed to fetch or parse page at ${url}`, error);
		return null;
	}
}
/**
 * Descarga, optimiza y convierte una imagen a formato WebP en Base64.
 * @param imageUrl La URL de la imagen a procesar.
 * @returns La imagen en formato Base64 con el prefijo de datos, o null si falla.
 */
async function processImage(imageUrl: string): Promise<string | null> {
	try {
		const imageResponse = await fetch(imageUrl);
		if (!imageResponse.ok) {
			console.error(`Error fetching image ${imageUrl}: ${imageResponse.statusText}`);
			return null;
		}
		const imageBuffer = await imageResponse.arrayBuffer();
		// Justificación (Paso 2.2):
		// Usamos 'sharp' para redimensionar la imagen a un ancho máximo y convertirla a WebP.
		// WebP ofrece una compresión superior con buena calidad, reduciendo el tamaño
		// de almacenamiento en la base de datos y mejorando los tiempos de carga.
		const optimizedImageBuffer = await sharp(Buffer.from(imageBuffer))
			.resize(MAX_IMAGE_WIDTH, null, { withoutEnlargement: true })
			.webp({ quality: 60 })
			.toBuffer();
		const base64Image = optimizedImageBuffer.toString('base64');
		return `data:image/webp;base64,${base64Image}`;
	} catch (error) {
		console.error(`Failed to process image at ${imageUrl}`, error);
		return null;
	}
}
export const imageService = {
	/**
	 * Orquesta el proceso completo: obtiene la URL de la imagen de una página
	 * y luego la procesa.
	 * @param pageUrl La URL de la página de referencia de la receta.
	 * @returns La imagen procesada en Base64 o null si cualquier paso falla.
	 */
	getImageFromUrl: async (pageUrl: string): Promise<string | null> => {
		const imageUrl = await getImageUrlFromPage(pageUrl);
		if (!imageUrl) {
			return null;
		}
		return processImage(imageUrl);
	}
};

// --- Ruta: src/lib/server/services/imageService.spec.ts ---
// Ruta: src/lib/server/services/imageService.spec.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { imageService } from './imageService';
// Mock de 'sharp'
vi.mock('sharp', () => {
	const chainable = {
		resize: vi.fn().mockReturnThis(),
		webp: vi.fn().mockReturnThis(),
		toBuffer: vi.fn().mockResolvedValue(Buffer.from('optimized-image-buffer'))
	};
	return {
		default: vi.fn(() => chainable)
	};
});
// Mock global de 'fetch'
global.fetch = vi.fn();
const mockedFetch = vi.mocked(global.fetch);
describe('imageService', () => {
	beforeEach(() => {
		// Limpiamos las llamadas y restauramos las implementaciones por defecto si las hubiera
		vi.clearAllMocks();
		// Justificación: Silenciamos console.error para evitar el ruido en los tests de error.
		vi.spyOn(console, 'error').mockImplementation(() => {});
	});
	afterEach(() => {
		// Restauramos la implementación original de console.error después de cada test.
		vi.mocked(console.error).mockRestore();
	});
	describe('getImageFromUrl', () => {
		it('should return a processed image from an og:image meta tag', async () => {
			const mockPageUrl = 'https://example.com/og-page';
			const mockImageUrl = 'https://example.com/og-image.jpg';
			const mockHtml = `<html><head><meta property="og:image" content="${mockImageUrl}" /></head></html>`;
			// Justificación: Usamos mockImplementation para un mock de fetch más robusto,
			// que no depende del orden de las llamadas.
			mockedFetch.mockImplementation(async (url): Promise<Response> => {
				if (url === mockPageUrl) {
					return new Response(mockHtml);
				}
				if (url === mockImageUrl) {
					return new Response(Buffer.from('image-data'));
				}
				throw new Error(`Unexpected fetch call to ${url}`);
			});
			const result = await imageService.getImageFromUrl(mockPageUrl);
			expect(result).toBe('data:image/webp;base64,b3B0aW1pemVkLWltYWdlLWJ1ZmZlcg==');
			expect(mockedFetch).toHaveBeenCalledWith(mockPageUrl, expect.any(Object));
			expect(mockedFetch).toHaveBeenCalledWith(mockImageUrl);
		});
		it('should return a processed image from a twitter:image meta tag if og:image is not present', async () => {
			const mockPageUrl = 'https://example.com/twitter-page';
			const mockImageUrl = 'https://example.com/twitter-image.jpg';
			const mockHtml = `<html><head><meta name="twitter:image" content="${mockImageUrl}" /></head></html>`;
			mockedFetch.mockImplementation(async (url): Promise<Response> => {
				if (url === mockPageUrl) {
					return new Response(mockHtml);
				}
				if (url === mockImageUrl) {
					return new Response(Buffer.from('image-data'));
				}
				throw new Error(`Unexpected fetch call to ${url}`);
			});
			const result = await imageService.getImageFromUrl(mockPageUrl);
			expect(result).toContain('data:image/webp;base64,');
			expect(mockedFetch).toHaveBeenCalledWith(mockImageUrl);
		});
		it('should return null if no image meta tags are found', async () => {
			const mockPageUrl = 'https://example.com/no-tags';
			const mockHtml = '<html><head></head></html>';
			mockedFetch.mockResolvedValue(new Response(mockHtml));
			const result = await imageService.getImageFromUrl(mockPageUrl);
			expect(result).toBeNull();
			expect(mockedFetch).toHaveBeenCalledOnce();
		});
		it('should return null if fetching the page fails', async () => {
			const mockPageUrl = 'https://example.com/fails';
			mockedFetch.mockRejectedValue(new Error('Network error'));
			const result = await imageService.getImageFromUrl(mockPageUrl);
			expect(result).toBeNull();
		});
		it('should return null if fetching the image fails', async () => {
			const mockPageUrl = 'https://example.com/image-fails';
			const mockImageUrl = 'https://example.com/image.jpg';
			const mockHtml = `<html><head><meta property="og:image" content="${mockImageUrl}" /></head></html>`;
			mockedFetch.mockImplementation(async (url): Promise<Response> => {
				if (url === mockPageUrl) {
					return new Response(mockHtml);
				}
				if (url === mockImageUrl) {
					throw new Error('Image not found');
				}
				throw new Error(`Unexpected fetch call to ${url}`);
			});
			const result = await imageService.getImageFromUrl(mockPageUrl);
			expect(result).toBeNull();
		});
	});
});

// --- Ruta: src/lib/components/recipes/UrlImageFetcher.svelte ---
<!-- Ruta: src/lib/components/recipes/UrlImageFetcher.svelte -->
<script lang="ts">
	import { Input } from '$lib/components/ui/input';
	import { Button } from '$lib/components/ui/button';
	import { Trash2, Loader, BadgeCheck, TriangleAlert } from 'lucide-svelte';
	type $Props = {
		urls: string[];
		imageUrl: string;
	};
	let { urls = $bindable(), imageUrl = $bindable() }: $Props = $props();
	// Estado para cada URL individual
	let urlStates = $state(
		urls.map(() => ({
			status: 'idle' as 'idle' | 'loading' | 'success' | 'error',
			message: ''
		}))
	);
	function addUrlField() {
		urls.push('');
		urlStates.push({ status: 'idle', message: '' });
	}
	function removeUrlField(index: number) {
		urls.splice(index, 1);
		urlStates.splice(index, 1);
	}
	// Justificación (Paso 3): Esta función se dispara cuando el usuario deja de editar
	// un campo de URL. Llama a nuestro endpoint de scraping y actualiza el estado
	// de esa URL específica para mostrar feedback (spinner, tick, error).
	async function handleUrlBlur(index: number) {
		const url = urls[index];
		if (!url || !url.startsWith('http')) {
			urlStates[index] = { status: 'idle', message: '' };
			return;
		}
		// Solo buscamos imagen si no hay ya una imagen principal definida.
		if (imageUrl) return;
		urlStates[index] = { status: 'loading', message: '' };
		try {
			const response = await fetch('/api/scrape-image', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ url })
			});
			if (!response.ok) {
				const errorData = await response.json();
				throw new Error(errorData.message || 'Error desconocido');
			}
			const data = await response.json();
			imageUrl = data.imageUrl; // Actualizamos la imagen principal de la receta
			urlStates[index] = { status: 'success', message: 'Imagen encontrada' };
		} catch (error) {
			urlStates[index] = {
				status: 'error',
				message: error instanceof Error ? error.message : 'No se pudo obtener la imagen'
			};
		}
	}
</script>
<div class="space-y-2">
	{#each urls as _, i}
		<div class="flex items-center gap-2">
			<div class="relative flex-grow">
				<Input
					type="url"
					placeholder="https://ejemplo.com/receta"
					bind:value={urls[i]}
					onblur={() => handleUrlBlur(i)}
					class="pr-10"
				/>
				<div class="absolute inset-y-0 right-0 flex items-center pr-3">
					{#if urlStates[i]?.status === 'loading'}
						<Loader class="h-5 w-5 animate-spin text-gray-400" />
					{:else if urlStates[i]?.status === 'success'}
						<BadgeCheck class="h-5 w-5 text-green-500" />
					{:else if urlStates[i]?.status === 'error'}
						<TriangleAlert class="h-5 w-5 text-red-500" />
					{/if}
				</div>
			</div>
			<Button type="button" variant="ghost" size="icon" onclick={() => removeUrlField(i)}>
				<Trash2 class="h-4 w-4" />
			</Button>
		</div>
		{#if urlStates[i]?.status === 'error'}
			<p class="text-sm text-red-500 ml-1">{urlStates[i].message}</p>
		{/if}
	{/each}
	<Button type="button" variant="outline" size="sm" onclick={addUrlField}>
		Añadir URL
	</Button>
</div>

// --- Ruta: src/lib/components/recipes/RecipeCard.svelte ---
<!--
// Fichero: src/lib/components/recipes/RecipeCard.svelte
// Este componente representa una única tarjeta de receta en la vista principal.
// --- VERSIÓN CORREGIDA (5) PARA SVELTE 5 ---
-->
<script lang="ts">
	import { calculateNutritionalInfo } from '$lib/recipeCalculator';
	import type { CalculableIngredient } from '$lib/recipeCalculator';
	import * as Card from '$lib/components/ui/card/index.js';
	import {
		DropdownMenu,
		DropdownMenuContent,
		DropdownMenuItem,
		DropdownMenuSeparator,
		DropdownMenuTrigger
	} from '$lib/components/ui/dropdown-menu';
	import { Button } from '$lib/components/ui/button/index.js';
	import MoreVertical from 'lucide-svelte/icons/more-vertical';
	// Justificación: El tipo ahora usa `title` para coincidir con el esquema de Prisma.
	type Recipe = {
		id: string;
		slug: string;
		title: string;
		imageUrl: string | null;
		ingredients: {
			quantity: number;
			product: {
				calories: number | null;
				protein: number | null;
				fat: number | null;
				carbs: number | null;
			} | null;
			customIngredient: {
				calories: number | null;
				protein: number | null;
				fat: number | null;
				carbs: number | null;
			} | null;
		}[];
	};
	// --- PROPS (Svelte 5) ---
	let { recipe, isAdmin, onEditQuantities, onDelete }: {
		recipe: Recipe;
		isAdmin: boolean;
		onEditQuantities: (recipe: Recipe) => void;
		onDelete: (recipe: Recipe) => void;
	} = $props();
	// --- LÓGICA DE CÁLCULO ---
	const calculableIngredients = $derived(
		recipe.ingredients.map((ing) => {
			const source = ing.product || ing.customIngredient;
			return {
				quantity: ing.quantity,
				calories: source?.calories,
				protein: source?.protein,
				fat: source?.fat,
				carbs: source?.carbs
			} as CalculableIngredient;
		})
	);
	const totals = $derived(calculateNutritionalInfo(calculableIngredients));
	const totalGrams = $derived(totals.totalProtein + totals.totalCarbs + totals.totalFat);
	const proteinPercentage = $derived(totalGrams > 0 ? (totals.totalProtein / totalGrams) * 100 : 0);
	const carbsPercentage = $derived(totalGrams > 0 ? (totals.totalCarbs / totalGrams) * 100 : 0);
	const fatPercentage = $derived(totalGrams > 0 ? (totals.totalFat / totalGrams) * 100 : 0);
	function handleEditQuantities(event: MouseEvent) {
		event.preventDefault();
		onEditQuantities(recipe);
	}
	function handleDelete(event: MouseEvent) {
		event.preventDefault();
		onDelete(recipe);
	}
</script>
<Card.Root class="flex flex-col break-inside-avoid">
	<a href="/recetas/{recipe.slug}" class="flex flex-col h-full" aria-label="Ver receta: {recipe.title}">
		<div class="relative">
			{#if recipe.imageUrl}
				<img
					src={recipe.imageUrl}
					alt="Imagen de {recipe.title}"
					class="aspect-video w-full rounded-t-lg object-cover"
				/>
			{/if}
			{#if isAdmin}
				<div class="absolute top-2 right-2">
					<DropdownMenu>
						<DropdownMenuTrigger
							class="bg-background/60 hover:bg-background/80 backdrop-blur-sm rounded-full h-8 w-8 inline-flex items-center justify-center"
							onclick={(e: MouseEvent) => {
								e.stopPropagation();
								e.preventDefault();
							}}
							aria-label="Abrir menú de acciones para {recipe.title}"
						>
							<MoreVertical class="h-4 w-4" />
						</DropdownMenuTrigger>
						<DropdownMenuContent
							class="w-48"
							align="end"
							onclick={(e: MouseEvent) => e.stopPropagation()}
						>
							<DropdownMenuItem onclick={handleEditQuantities}>
								Editar cantidades
							</DropdownMenuItem>
							<DropdownMenuItem>
								<a href="/recetas/{recipe.slug}/editar" class="w-full">Editar receta</a>
							</DropdownMenuItem>
							<DropdownMenuSeparator />
							<DropdownMenuItem onclick={handleDelete} class="text-destructive focus:text-destructive">
								Eliminar
							</DropdownMenuItem>
						</DropdownMenuContent>
					</DropdownMenu>
				</div>
			{/if}
		</div>
		<Card.Header>
			<Card.Title class="text-lg pt-2">{recipe.title}</Card.Title>
			<Card.Description class="py-2">{totals.totalCalories.toFixed(0)} kcal</Card.Description>
		</Card.Header>
		<Card.Content class="flex-grow">
			<div class="flex h-2 w-full overflow-hidden rounded-full bg-muted">
				<div
					class="bg-blue-500"
					style="width: {proteinPercentage}%"
					title="Proteínas: {totals.totalProtein.toFixed(1)}g"
				></div>
				<div
					class="bg-green-500"
					style="width: {carbsPercentage}%"
					title="Carbohidratos: {totals.totalCarbs.toFixed(1)}g"
				></div>
				<div
					class="bg-red-500"
					style="width: {fatPercentage}%"
					title="Grasas: {totals.totalFat.toFixed(1)}g"
				></div>
			</div>
			<div class="mt-2 flex justify-between text-xs text-muted-foreground">
				<span class="flex items-center">
					<span class="mr-1.5 h-2 w-2 rounded-full bg-blue-500"></span>
					P ({totals.totalProtein.toFixed(1)})
				</span>
				<span class="flex items-center">
					<span class="mr-1.5 h-2 w-2 rounded-full bg-green-500"></span>
					C ({totals.totalCarbs.toFixed(1)})
				</span>
				<span class="flex items-center">
					<span class="mr-1.5 h-2 w-2 rounded-full bg-red-500"></span>
					G ({totals.totalFat.toFixed(1)})
				</span>
			</div>
		</Card.Content>
	</a>
</Card.Root>

// --- Ruta: src/lib/components/recipes/MacroFilters.svelte ---
<script lang="ts">
	import { Input } from '$lib/components/ui/input/index.js';
	import { Label } from '$lib/components/ui/label/index.js';
	import { Button } from '$lib/components/ui/button/index.js';
	import Trash2 from 'lucide-svelte/icons/trash-2';
	// --- Tipos ---
	type RangeFilter = { min?: number; max?: number };
	export type GramFilters = {
		calories: RangeFilter;
		protein: RangeFilter;
		carbs: RangeFilter;
		fat: RangeFilter;
	};
	export type PercentFilters = {
		protein: RangeFilter;
		carbs: RangeFilter;
		fat: RangeFilter;
	};
	// --- Props (Svelte 5) ---
	let {
		gramFilters,
		percentFilters,
		onGramsChange,
		onPercentChange,
		onClear
	}: {
		gramFilters: GramFilters;
		percentFilters: PercentFilters;
		onGramsChange: (macro: keyof GramFilters, key: 'min' | 'max', value: number | undefined) => void;
		onPercentChange: (macro: keyof PercentFilters, key: 'min' | 'max', value: number | undefined) => void;
		onClear: () => void;
	} = $props();
	// Justificación: Los manejadores de eventos ahora invocan los callbacks
	// pasados por el padre en lugar de mutar props. Esto respeta la propiedad
	// del estado y sigue el flujo de datos unidireccional de Svelte 5.
	function handleGramsInput(macro: keyof GramFilters, key: 'min' | 'max', e: Event) {
		const target = e.currentTarget as HTMLInputElement;
		const value = target.valueAsNumber;
		onGramsChange(macro, key, isNaN(value) ? undefined : value);
	}
	function handlePercentInput(macro: keyof PercentFilters, key: 'min' | 'max', e: Event) {
		const target = e.currentTarget as HTMLInputElement;
		const value = target.valueAsNumber;
		onPercentChange(macro, key, isNaN(value) ? undefined : value);
	}
</script>
<div class="space-y-4">
	<div class="flex items-center justify-between">
		<h3 class="text-lg font-semibold">Macronutrientes</h3>
		<Button onclick={onClear} variant="ghost" size="icon" aria-label="Limpiar filtros de macros">
			<Trash2 class="h-4 w-4" />
		</Button>
	</div>
	<!-- Filtros de Gramos y Calorías -->
	<div class="space-y-4">
		<div class="space-y-2">
			<Label for="calories-min">Calorías (kcal)</Label>
			<div class="flex gap-2">
				<Input id="calories-min" type="number" placeholder="Min" value={gramFilters.calories.min ?? ''} oninput={(e) => handleGramsInput('calories', 'min', e)} />
				<Input id="calories-max" type="number" placeholder="Max" value={gramFilters.calories.max ?? ''} oninput={(e) => handleGramsInput('calories', 'max', e)} />
			</div>
		</div>
		<div class="space-y-2">
			<Label for="protein-grams-min">Proteínas (g)</Label>
			<div class="flex gap-2">
				<Input id="protein-grams-min" type="number" placeholder="Min" value={gramFilters.protein.min ?? ''} oninput={(e) => handleGramsInput('protein', 'min', e)} />
				<Input id="protein-grams-max" type="number" placeholder="Max" value={gramFilters.protein.max ?? ''} oninput={(e) => handleGramsInput('protein', 'max', e)} />
			</div>
		</div>
		<div class="space-y-2">
			<Label for="carbs-grams-min">Carbohidratos (g)</Label>
			<div class="flex gap-2">
				<Input id="carbs-grams-min" type="number" placeholder="Min" value={gramFilters.carbs.min ?? ''} oninput={(e) => handleGramsInput('carbs', 'min', e)} />
				<Input id="carbs-grams-max" type="number" placeholder="Max" value={gramFilters.carbs.max ?? ''} oninput={(e) => handleGramsInput('carbs', 'max', e)} />
			</div>
		</div>
		<div class="space-y-2">
			<Label for="fat-grams-min">Grasas (g)</Label>
			<div class="flex gap-2">
				<Input id="fat-grams-min" type="number" placeholder="Min" value={gramFilters.fat.min ?? ''} oninput={(e) => handleGramsInput('fat', 'min', e)} />
				<Input id="fat-grams-max" type="number" placeholder="Max" value={gramFilters.fat.max ?? ''} oninput={(e) => handleGramsInput('fat', 'max', e)} />
			</div>
		</div>
	</div>
	<hr/>
	<!-- Filtros de Porcentaje -->
	<div class="space-y-4">
		<div class="space-y-2">
			<Label for="protein-percent-min">Proteínas (%)</Label>
			<div class="flex gap-2">
				<Input id="protein-percent-min" type="number" placeholder="Min" value={percentFilters.protein.min ?? ''} oninput={(e) => handlePercentInput('protein', 'min', e)} />
				<Input id="protein-percent-max" type="number" placeholder="Max" value={percentFilters.protein.max ?? ''} oninput={(e) => handlePercentInput('protein', 'max', e)} />
			</div>
		</div>
		<div class="space-y-2">
			<Label for="carbs-percent-min">Carbohidratos (%)</Label>
			<div class="flex gap-2">
				<Input id="carbs-percent-min" type="number" placeholder="Min" value={percentFilters.carbs.min ?? ''} oninput={(e) => handlePercentInput('carbs', 'min', e)} />
				<Input id="carbs-percent-max" type="number" placeholder="Max" value={percentFilters.carbs.max ?? ''} oninput={(e) => handlePercentInput('carbs', 'max', e)} />
			</div>
		</div>
		<div class="space-y-2">
			<Label for="fat-percent-min">Grasas (%)</Label>
			<div class="flex gap-2">
				<Input id="fat-percent-min" type="number" placeholder="Min" value={percentFilters.fat.min ?? ''} oninput={(e) => handlePercentInput('fat', 'min', e)} />
				<Input id="fat-percent-max" type="number" placeholder="Max" value={percentFilters.fat.max ?? ''} oninput={(e) => handlePercentInput('fat', 'max', e)} />
			</div>
		</div>
	</div>
</div>

// --- Ruta: src/lib/components/recipes/IngredientCombobox.svelte ---
<!--
// Fichero: src/lib/components/recipes/IngredientCombobox.svelte
// --- VERSIÓN FINAL CON BOTÓN DE LIMPIAR ---
-->
<script lang="ts">
	import { Button } from '$lib/components/ui/button/index.js';
	import * as Popover from '$lib/components/ui/popover/index.js';
	import * as Command from '$lib/components/ui/command/index.js';
	import ChevronsUpDown from 'lucide-svelte/icons/chevrons-up-down';
	import Trash2 from 'lucide-svelte/icons/trash-2';
	type Ingredient = {
		id: string;
		name: string;
		type: 'product' | 'custom';
		source: 'local' | 'off';
		imageUrl: string | null;
	};
	// Justificación: Se añade la prop `onClear` para recibir la función de limpieza
	// desde el componente padre, completando el patrón de comunicación de eventos.
	let { onSelect, selectedIds = [], onClear }: {
		onSelect: (ingredient: Ingredient) => void;
		selectedIds: string[];
		onClear: () => void;
	} = $props();
	let open = $state(false);
	let searchValue = $state('');
	let searchResults = $state<Ingredient[]>([]);
	let isLoading = $state(false);
	let controller: AbortController;
	$effect(() => {
		controller?.abort();
		const query = searchValue;
		if (query.length < 2 || !open) {
			searchResults = [];
			isLoading = false;
			return;
		}
		controller = new AbortController();
		async function search() {
			isLoading = true;
			try {
				const response = await fetch(`/api/ingredients/autocomplete?q=${encodeURIComponent(query)}`, {
					signal: controller.signal
				});
				const allResults: Ingredient[] = await response.json();
				searchResults.length = 0;
				searchResults.push(...allResults.filter((r) => !selectedIds.includes(r.id)));
			} catch (e) {
				if (e instanceof DOMException && e.name === 'AbortError') {
					return;
				}
				console.error('Failed to search ingredients', e);
				searchResults = [];
			} finally {
				isLoading = false;
			}
		}
		search();
	});
	function handleSelect(ingredient: Ingredient) {
		onSelect(ingredient);
		searchValue = '';
		open = false;
	}
</script>
<div class="flex items-center gap-2">
	<Popover.Root bind:open>
		<Popover.Trigger
			role="combobox"
			class="flex h-10 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 hover:bg-accent hover:text-accent-foreground"
		>
			Seleccionar ingrediente...
			<ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" />
		</Popover.Trigger>
		<Popover.Content class="w-[--radix-popover-trigger-width] p-0">
			{#key searchValue}
				<Command.Root>
					<Command.Input bind:value={searchValue} placeholder="Buscar ingrediente..." />
					<Command.Empty>
						{#if isLoading}
							Buscando...
						{:else if searchValue.length < 2}
							Escribe al menos 2 letras.
						{:else}
							No se encontraron ingredientes.
						{/if}
					</Command.Empty>
					<Command.Group>
						{#each searchResults as ingredient (ingredient.id)}
							<Command.Item onSelect={() => handleSelect(ingredient)}>
								{ingredient.name}
							</Command.Item>
						{/each}
					</Command.Group>
				</Command.Root>
			{/key}
		</Popover.Content>
	</Popover.Root>
	{#if selectedIds.length > 0}
		<Button onclick={onClear} variant="ghost" size="icon" aria-label="Limpiar ingredientes seleccionados">
			<Trash2 class="h-4 w-4" />
		</Button>
	{/if}
</div>

// --- Ruta: src/lib/components/recipes/EditQuantitiesDialog.svelte ---
<!--
// Fichero: src/lib/components/recipes/EditQuantitiesDialog.svelte
// --- VERSIÓN CORREGIDA (3) PARA SVELTE 5 ---
-->
<script lang="ts">
	import { calculateNutritionalInfo, type CalculableIngredient } from '$lib/recipeCalculator';
	import * as Dialog from '$lib/components/ui/dialog/index.js';
	import { Input } from '$lib/components/ui/input/index.js';
	import { Label } from '$lib/components/ui/label/index.js';
	import { Button } from '$lib/components/ui/button/index.js';
	type Recipe = {
		id: string;
		title: string;
		ingredients: {
			quantity: number;
			product: {
				id: string;
				name: string;
				calories: number | null;
				protein: number | null;
				fat: number | null;
				carbs: number | null;
			} | null;
			customIngredient: {
				id: string;
				name: string;
				calories: number | null;
				protein: number | null;
				fat: number | null;
				carbs: number | null;
			} | null;
		}[];
	};
	let { recipe, open = $bindable(), onOpenChange }: {
		recipe: Recipe | null;
		open?: boolean;
		onOpenChange: (isOpen: boolean) => void;
	} = $props();
	let editableIngredients = $state<
		{
			id: string;
			name: string;
			quantity: number;
			baseValues: Omit<CalculableIngredient, 'quantity'>;
		}[]
	>([]);
	$effect(() => {
		if (open && recipe) {
			editableIngredients = recipe.ingredients.map((ing) => {
				const source = ing.product || ing.customIngredient;
				const id = ing.product?.id || ing.customIngredient?.id || '';
				const name = ing.product?.name || ing.customIngredient?.name || 'Ingrediente desconocido';
				return {
					id,
					name,
					quantity: ing.quantity,
					baseValues: {
						calories: source?.calories,
						protein: source?.protein,
						fat: source?.fat,
						carbs: source?.carbs
					}
				};
			});
		} else {
			editableIngredients = [];
		}
	});
	const originalTotals = $derived(
		recipe ? calculateNutritionalInfo(recipe.ingredients.map(ing => {
			const source = ing.product || ing.customIngredient;
			return {
				quantity: ing.quantity,
				calories: source?.calories,
				protein: source?.protein,
				fat: source?.fat,
				carbs: source?.carbs
			}
		})) : null
	);
	const newTotals = $derived(
		calculateNutritionalInfo(
			editableIngredients.map((ing) => ({
				...ing.baseValues,
				quantity: Number(ing.quantity) || 0
			}))
		)
	);
</script>
<Dialog.Root bind:open onOpenChange={onOpenChange}>
	<Dialog.Content class="sm:max-w-[600px]">
		<Dialog.Header>
			<Dialog.Title>Editar Cantidades: {recipe?.title}</Dialog.Title>
			<Dialog.Description>
				Ajusta las cantidades en gramos para esta preparación específica. Los cambios no afectarán a
				la receta original.
			</Dialog.Description>
		</Dialog.Header>
		<div class="grid gap-4 py-4">
			{#each editableIngredients as ingredient (ingredient.id)}
				<div class="grid grid-cols-4 items-center gap-4">
					<Label for={ingredient.id} class="text-right col-span-2">{ingredient.name}</Label>
					<Input
						id={ingredient.id}
						type="number"
						bind:value={ingredient.quantity}
						class="col-span-2"
					/>
				</div>
			{/each}
		</div>
		<hr />
		<!-- Justificación: Se añade un data-testid al contenedor para poder seleccionarlo
		     de forma inequívoca en los tests. -->
		<div data-testid="comparison-section" class="grid grid-cols-2 gap-x-8 gap-y-2 mt-4 text-sm">
			<h3 class="font-semibold col-span-2">Comparativa Nutricional</h3>
			<div class="font-medium text-muted-foreground">Original</div>
			<div class="font-medium text-muted-foreground">Recalculado</div>
			<div>Calorías: {originalTotals?.totalCalories.toFixed(0) ?? 0} kcal</div>
			<div class="font-semibold">Calorías: {newTotals.totalCalories.toFixed(0)} kcal</div>
			<div>Proteínas: {originalTotals?.totalProtein.toFixed(1) ?? 0} g</div>
			<div class="font-semibold">Proteínas: {newTotals.totalProtein.toFixed(1)} g</div>
			<div>Grasas: {originalTotals?.totalFat.toFixed(1) ?? 0} g</div>
			<div class="font-semibold">Grasas: {newTotals.totalFat.toFixed(1)} g</div>
			<div>Carbohidratos: {originalTotals?.totalCarbs.toFixed(1) ?? 0} g</div>
			<div class="font-semibold">Carbohidratos: {newTotals.totalCarbs.toFixed(1)} g</div>
		</div>
		<Dialog.Footer>
			<!-- Justificación: Se añade un data-testid al botón para seleccionarlo sin ambigüedad. -->
			<Button data-testid="dialog-close-button" onclick={() => onOpenChange(false)}>Cerrar</Button>
		</Dialog.Footer>
	</Dialog.Content>
</Dialog.Root>

// --- Ruta: src/lib/components/recipes/EditQuantitiesDialog.spec.ts ---
// Fichero: src/lib/components/recipes/EditQuantitiesDialog.spec.ts
import { describe, it, expect, vi, afterEach } from 'vitest';
import { render, fireEvent, screen, within, cleanup } from '@testing-library/svelte';
import EditQuantitiesDialog from './EditQuantitiesDialog.svelte';
const mockRecipe = {
	id: 'recipe-1',
	title: 'Pollo con Arroz',
	ingredients: [
		{
			quantity: 200,
			product: {
				id: 'product-1',
				name: 'Pechuga de Pollo',
				calories: 165,
				protein: 31,
				fat: 3.6,
				carbs: 0
			},
			customIngredient: null
		},
		{
			quantity: 150,
			product: null,
			customIngredient: {
				id: 'custom-1',
				name: 'Arroz Blanco',
				calories: 130,
				protein: 2.7,
				fat: 0.3,
				carbs: 28
			}
		}
	]
};
describe('EditQuantitiesDialog.svelte', () => {
	// Justificación: Se llama a `cleanup` después de cada test para desmontar
	// el componente y asegurar que el DOM esté limpio para la siguiente prueba.
	// Esto previene errores de "elementos múltiples encontrados".
	afterEach(() => cleanup());
	it('should render initial data and original totals correctly', async () => {
		render(EditQuantitiesDialog, {
			props: {
				recipe: mockRecipe,
				open: true,
				onOpenChange: () => {}
			}
		});
		expect(screen.getByText('Editar Cantidades: Pollo con Arroz')).toBeTruthy();
		const comparisonSection = screen.getByTestId('comparison-section');
		const initialCalories = within(comparisonSection).getAllByText(/Calorías: 525 kcal/i);
		expect(initialCalories).toHaveLength(2);
	});
	it('should recalculate totals in real-time when an ingredient quantity changes', async () => {
		render(EditQuantitiesDialog, {
			props: {
				recipe: mockRecipe,
				open: true,
				onOpenChange: () => {}
			}
		});
		const polloInput = screen.getByLabelText('Pechuga de Pollo');
		await fireEvent.input(polloInput, { target: { value: '100' } });
		const comparisonSection = screen.getByTestId('comparison-section');
		const originalCalories = within(comparisonSection).getByText(/Calorías: 525 kcal/i);
		const recalculatedCalories = within(comparisonSection).getByText(/Calorías: 360 kcal/i);
		expect(originalCalories).toBeTruthy();
		expect(recalculatedCalories).toBeTruthy();
	});
	it('should call onOpenChange with false when the close button is clicked', async () => {
		const onOpenChangeMock = vi.fn();
		render(EditQuantitiesDialog, {
			props: {
				recipe: mockRecipe,
				open: true,
				onOpenChange: onOpenChangeMock
			}
		});
		const closeButton = screen.getByTestId('dialog-close-button');
		await fireEvent.click(closeButton);
		expect(onOpenChangeMock).toHaveBeenCalledWith(false);
		expect(onOpenChangeMock).toHaveBeenCalledOnce();
	});
});

// --- Ruta: src/lib/components/recipes/DeleteRecipeDialog.svelte ---
<!--
// Fichero: src/lib/components/recipes/DeleteRecipeDialog.svelte
// Componente para un diálogo de confirmación de borrado seguro.
// --- VERSIÓN CORREGIDA (2) PARA SVELTE 5 ---
-->
<script lang="ts">
	import { enhance } from '$app/forms';
	import * as AlertDialog from '$lib/components/ui/alert-dialog/index.js';
	import { Button } from '$lib/components/ui/button/index.js';
	// Justificación: El tipo ahora usa `title` para coincidir con el esquema de Prisma.
	type Recipe = {
		id: string;
		title: string;
	};
	// --- PROPS (Svelte 5) ---
	// Justificación: `open` se declara con `$bindable()` para permitir el enlace
	// bidireccional desde el componente padre, como exige Svelte 5.
	let { recipe, open = $bindable(), onOpenChange }: {
		recipe: Recipe | null;
		open?: boolean;
		onOpenChange: (isOpen: boolean) => void;
	} = $props();
	let formElement: HTMLFormElement;
	function handleConfirmClick() {
		if (formElement) {
			formElement.requestSubmit();
		}
	}
</script>
<AlertDialog.Root bind:open onOpenChange={onOpenChange}>
	<AlertDialog.Content>
		<AlertDialog.Header>
			<AlertDialog.Title>¿Estás absolutely seguro?</AlertDialog.Title>
			<AlertDialog.Description>
				Esta acción no se puede deshacer. Esto eliminará permanentemente la receta de
				<strong>{@html recipe?.title ?? 'seleccionada'}</strong>.
			</AlertDialog.Description>
		</AlertDialog.Header>
		<form
			method="POST"
			action="?/delete"
			bind:this={formElement}
			use:enhance={() => {
				onOpenChange(false);
				return async ({ update }) => {
					await update();
				};
			}}
		>
			<input type="hidden" name="id" value={recipe?.id} />
		</form>
		<AlertDialog.Footer>
			<AlertDialog.Cancel>Cancelar</AlertDialog.Cancel>
			<AlertDialog.Action onclick={handleConfirmClick}>
				<Button variant="destructive">Eliminar</Button>
			</AlertDialog.Action>
		</AlertDialog.Footer>
	</AlertDialog.Content>
</AlertDialog.Root>

// --- Ruta: src/lib/components/admin/SyncDialog.svelte ---
<!-- Ruta: src/lib/components/admin/SyncDialog.svelte -->
<script lang="ts">
	import { Button, buttonVariants } from '$lib/components/ui/button';
	import * as Dialog from '$lib/components/ui/dialog';
	import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table';
	import { CircleDashed } from 'lucide-svelte';
	// Justificación: Este componente ahora solo se encarga de mostrar el *contenido* del diálogo.
	// El control de apertura/cierre y el disparador se gestionan en la página padre,
	// siguiendo las convenciones del proyecto y de Svelte 5.
	type $Props = {
		state: 'idle' | 'loading' | 'success' | 'error';
		result: {
			updatedIngredients: string[];
			failedIngredients: { id: string; name: string; reason: string }[];
		} | null;
	};
	let { state, result }: $Props = $props();
</script>
<Dialog.Content class="sm:max-w-[625px]">
	{#if state === 'loading'}
		<div class="flex flex-col items-center justify-center p-8">
			<CircleDashed class="h-12 w-12 animate-spin text-primary" />
			<p class="mt-4 text-lg text-muted-foreground">Sincronizando ingredientes...</p>
			<p class="text-sm text-muted-foreground">
				Este proceso puede tardar varios minutos. Por favor, no cierres esta ventana.
			</p>
		</div>
	{:else if state === 'success' && result}
		<Dialog.Header>
			<Dialog.Title>Sincronización Completada</Dialog.Title>
			<Dialog.Description>
				Se actualizaron <strong>{result.updatedIngredients.length}</strong> ingredientes.
				{#if result.failedIngredients.length > 0}
					Hubo <strong>{result.failedIngredients.length}</strong> errores.
				{/if}
			</Dialog.Description>
		</Dialog.Header>
		<div class="max-h-[400px] overflow-y-auto">
			{#if result.updatedIngredients.length > 0}
				<h3 class="mb-2 font-semibold">Ingredientes Actualizados</h3>
				<Table>
					<TableHeader>
						<TableRow>
							<TableHead>Nombre</TableHead>
						</TableRow>
					</TableHeader>
					<TableBody>
						{#each result.updatedIngredients as name}
							<TableRow>
								<TableCell>{name}</TableCell>
							</TableRow>
						{/each}
					</TableBody>
				</Table>
			{/if}
			{#if result.failedIngredients.length > 0}
				<h3 class="mb-2 mt-4 font-semibold">Ingredientes con Errores</h3>
				<Table>
					<TableHeader>
						<TableRow>
							<TableHead>Nombre</TableHead>
							<TableHead>Motivo del Error</TableHead>
						</TableRow>
					</TableHeader>
					<TableBody>
						{#each result.failedIngredients as failure}
							<TableRow>
								<TableCell>{failure.name} ({failure.id})</TableCell>
								<TableCell>{failure.reason}</TableCell>
							</TableRow>
						{/each}
					</TableBody>
				</Table>
			{/if}
		</div>
		<Dialog.Footer>
			<!-- Justificación: Se usa Dialog.Close directamente estilizado como un botón,
			     evitando la complejidad y errores de 'asChild'. -->
			<Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cerrar</Dialog.Close>
		</Dialog.Footer>
	{:else if state === 'error'}
		<Dialog.Header>
			<Dialog.Title>Error en la Sincronización</Dialog.Title>
			<Dialog.Description>
				Ocurrió un error inesperado al intentar sincronizar los ingredientes. Por favor, inténtalo
				de nuevo más tarde.
			</Dialog.Description>
		</Dialog.Header>
		<Dialog.Footer>
			<Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cerrar</Dialog.Close>
		</Dialog.Footer>
	{/if}
</Dialog.Content>

// --- Ruta: src/routes/recetas/[slug]/editar/+page.svelte ---
<!-- Ruta: src/routes/recetas/[id]/editar/+page.svelte -->
<script lang="ts">
	import { goto } from '$app/navigation';
	import { Button } from '$lib/components/ui/button';
	import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card';
	import { Input } from '$lib/components/ui/input';
	import { Label } from '$lib/components/ui/label';
	import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table';
	import { Textarea } from '$lib/components/ui/textarea';
	import { calculateNutritionalInfo, type CalculableIngredient } from '$lib/recipeCalculator';
	import type { RecipeIngredient } from '$lib/schemas/recipeSchema';
	import * as Popover from '$lib/components/ui/popover';
	import * as Command from '$lib/components/ui/command';
	import { ChevronsUpDown, Trash2 } from 'lucide-svelte';
	import type { PageData, ActionData } from './$types';
	import { enhance } from '$app/forms';
	import UrlImageFetcher from '$lib/components/recipes/UrlImageFetcher.svelte';
	import { browser } from '$app/environment';
	let { data, form }: { data: PageData; form: ActionData } = $props();
	// Función robusta para parsear los pasos, que ya vienen como array desde el servidor
	const getRecipeSteps = (stepsData: unknown): string[] => {
		if (Array.isArray(stepsData)) {
			return stepsData.map(String);
		}
		// Fallback por si en el cliente llega como string JSON
		if (browser && typeof stepsData === 'string') {
			try {
				const parsed = JSON.parse(stepsData);
				return Array.isArray(parsed) ? parsed.map(String) : [String(stepsData)];
			} catch (e) {
				return [String(stepsData)]; // No era JSON, tratar como texto plano
			}
		}
		return [];
	};
	type IngredientWithDetails = RecipeIngredient & CalculableIngredient & { name: string; imageUrl: string | null };
	type SearchResult = {
		id: string;
		name: string;
		source: 'local' | 'off';
		type: 'custom' | 'product';
		imageUrl: string | null;
	};
	// --- Estado del formulario ---
	let title = $state(data.recipe.title);
	let steps = $state(getRecipeSteps(data.recipe.steps));
	let imageUrl = $state(data.recipe.imageUrl ?? '');
	let urls = $state(data.recipe.urls.map((u) => u.url) ?? []);
	const initialIngredients = data.recipe.ingredients
		.map((ing): IngredientWithDetails | null => {
			const quantity = ing.quantity;
			if (ing.customIngredient) {
				return {
					id: ing.customIngredient.id,
					type: 'custom',
					quantity,
					name: ing.customIngredient.name,
					calories: ing.customIngredient.calories ?? 0,
					protein: ing.customIngredient.protein ?? 0,
					fat: ing.customIngredient.fat ?? 0,
					carbs: ing.customIngredient.carbs ?? 0,
					imageUrl: null
				};
			}
			if (ing.product) {
				return {
					id: ing.product.id,
					type: 'product',
					quantity,
					name: ing.product.name,
					calories: ing.product.calories ?? 0,
					protein: ing.product.protein ?? 0,
					fat: ing.product.fat ?? 0,
					carbs: ing.product.carbs ?? 0,
					imageUrl: ing.product.imageUrl
				};
			}
			return null;
		})
		.filter((ing): ing is IngredientWithDetails => ing !== null);
	let ingredients = $state<IngredientWithDetails[]>(initialIngredients);
	// --- Estado del buscador de ingredientes ---
	let searchResults = $state<SearchResult[]>([]);
	let isSearching = $state(false);
	let open = $state(false);
	let inputValue = $state('');
	let searchTerm = $state('');
	$effect(() => {
		let eventSource: EventSource | null = null;
		if (searchTerm.length < 3) {
			searchResults = [];
			isSearching = false;
		} else {
			isSearching = true;
			searchResults = [];
			eventSource = new EventSource(`/api/ingredients/search?q=${encodeURIComponent(searchTerm)}`);
			eventSource.addEventListener('message', (e) => {
				const newResults = JSON.parse(e.data);
				searchResults = [...searchResults, ...newResults];
			});
			eventSource.addEventListener('stream_error', (e) => {
				const errorData = JSON.parse((e as MessageEvent).data);
				console.error('Error de stream recibido:', errorData);
			});
			eventSource.onerror = (err) => {
				console.error('Error en la conexión de EventSource:', err);
				isSearching = false;
				eventSource?.close();
			};
			eventSource.addEventListener('close', () => {
				isSearching = false;
				eventSource?.close();
			});
		}
		return () => {
			eventSource?.close();
		};
	});
	async function addIngredient(result: SearchResult) {
		if (ingredients.some((ing) => ing.id === result.id && ing.type === result.type)) return;
		try {
			const response = await fetch(`/api/ingredients/details/${result.id}?type=${result.type}`);
			if (!response.ok) throw new Error('Failed to fetch ingredient details');
			const details: CalculableIngredient = await response.json();
			ingredients.push({
				...result,
				quantity: 100,
				calories: details.calories,
				protein: details.protein,
				fat: details.fat,
				carbs: details.carbs
			});
		} catch (error) {
			console.error('Error adding ingredient:', error);
		} finally {
			open = false;
			searchResults = [];
			searchTerm = '';
			inputValue = '';
		}
	}
	function removeIngredient(index: number) {
		ingredients.splice(index, 1);
	}
	// --- Cálculos y envío ---
	let nutritionalInfo = $derived(calculateNutritionalInfo(ingredients));
	let isSubmitting = $state(false);
</script>
<Card class="max-w-4xl mx-auto my-8">
	<CardHeader>
		<CardTitle>Editar Receta</CardTitle>
	</CardHeader>
	<CardContent>
		<form
			method="POST"
			use:enhance={() => {
				isSubmitting = true;
				return async ({ result }) => {
					if (result.type === 'success') {
						await goto(`/recetas/${data.recipe.id}`);
					}
					isSubmitting = false;
				};
			}}
			class="space-y-6"
		>
			<!-- Campos ocultos para enviar datos complejos -->
			<input
				type="hidden"
				name="ingredients"
				value={JSON.stringify(ingredients.map(({ id, quantity, type }) => ({ id, quantity, type })))}
			/>
			<input type="hidden" name="urls" value={JSON.stringify(urls.filter((u) => u.trim() !== ''))} />
			<input
				type="hidden"
				name="steps"
				value={JSON.stringify(steps.filter((s) => s.trim() !== ''))}
			/>
			<input type="hidden" name="imageUrl" value={imageUrl} />
			<!-- Campos del formulario -->
			<div class="space-y-2">
				<Label for="title">Título</Label>
				<Input id="title" name="title" bind:value={title} required />
				{#if form?.errors?.title}
					<p class="text-sm text-red-500">{form.errors.title}</p>
				{/if}
			</div>
			<div class="space-y-2">
				<Label for="image">Imagen de la Receta</Label>
				<div class="flex items-center gap-4">
					{#if imageUrl}
						<img
							src={imageUrl}
							alt="Previsualización de la receta"
							class="h-24 w-24 rounded-md object-cover"
						/>
					{/if}
					<Input id="image" type="file" accept="image/*" />
				</div>
				<p class="text-sm text-gray-500">
					Sube una imagen o deja el campo vacío para intentar usar la de la primera URL de
					referencia.
				</p>
			</div>
			<div class="space-y-2">
				<Label>URLs de Referencia</Label>
				<UrlImageFetcher bind:urls bind:imageUrl />
				{#if form?.errors?.urls}
					<p class="text-sm text-red-500">{form.errors.urls}</p>
				{/if}
			</div>
			<div class="space-y-4">
				<Label class="text-lg font-medium">Pasos de la Receta</Label>
				{#each steps as step, i}
					<div class="flex items-start gap-2">
						<div class="flex-1 space-y-1">
							<Label for={`step-${i}`} class="text-sm font-normal text-gray-600">Paso {i + 1}</Label>
							<Textarea
								id={`step-${i}`}
								name={`step-${i}`}
								bind:value={steps[i]}
								rows={3}
								placeholder="Describe este paso... (soporta Markdown)"
							/>
						</div>
						<Button
							type="button"
							variant="ghost"
							size="icon"
							onclick={() => steps.splice(i, 1)}
							class="mt-6"
							aria-label="Eliminar paso"
						>
							<Trash2 class="h-4 w-4" />
						</Button>
					</div>
				{/each}
				<Button type="button" variant="outline" onclick={() => steps.push('')}>Añadir Paso</Button>
				{#if form?.errors?.steps}
					<p class="text-sm text-red-500">{form.errors.steps}</p>
				{/if}
			</div>
			<!-- Buscador y tabla de ingredientes -->
			<div class="space-y-2">
				<Label>Añadir Ingrediente</Label>
				<Popover.Root bind:open>
					<Popover.Trigger
						class="inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border w-full justify-between h-9 px-4 py-2"
						role="combobox"
						aria-expanded={open}
					>
						<div class="flex items-center justify-between w-full">
							{inputValue || 'Seleccionar ingrediente...'}
							<ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" />
						</div>
					</Popover.Trigger>
					<Popover.Content class="w-[--trigger-width] p-0">
						<Command.Root filter={() => 1}>
							<Command.Input bind:value={searchTerm} placeholder="Buscar ingrediente..." />
							<Command.List>
								{#if searchResults.length > 0}
									{#each searchResults as result (result.id + result.type)}
										<Command.Item
											value={result.name}
											onSelect={() => {
												inputValue = result.name;
												addIngredient(result);
											}}
											class={`flex items-center gap-2 ${result.source === 'local' ? 'ring-1 ring-green-500 rounded-sm' : ''}`}
										>
											<img
												src={result.imageUrl || 'https://placehold.co/40x40?text=N/A'}
												alt={result.name}
												class="h-8 w-8 rounded-sm object-cover"
											/>
											<span>{result.name}</span>
										</Command.Item>
									{/each}
								{:else}
									<div class="p-4 text-sm text-center text-gray-500">
										{#if isSearching}
											Buscando...
										{:else if searchTerm.length < 3}
											Escribe al menos 3 caracteres para buscar...
										{:else}
											No se encontraron resultados.
										{/if}
									</div>
								{/if}
							</Command.List>
						</Command.Root>
					</Popover.Content>
				</Popover.Root>
			</div>
			<div class="space-y-2">
				<h3 class="text-lg font-medium">Ingredientes de la Receta</h3>
				<Table>
					<TableHeader>
						<TableRow>
							<TableHead>Nombre</TableHead>
							<TableHead class="w-[150px]">Cantidad (g)</TableHead>
							<TableHead class="w-[100px] text-right">Acciones</TableHead>
						</TableRow>
					</TableHeader>
					<TableBody>
						{#each ingredients as ingredient, i}
							<TableRow>
								<TableCell>{ingredient.name}</TableCell>
								<TableCell>
									<Input type="number" bind:value={ingredient.quantity} min="1" class="w-full" />
								</TableCell>
								<TableCell class="text-right">
									<Button
										type="button"
										variant="destructive"
										size="sm"
										onclick={() => removeIngredient(i)}
									>
										Quitar
									</Button>
								</TableCell>
							</TableRow>
						{/each}
						{#if ingredients.length === 0}
							<TableRow>
								<TableCell colspan={3} class="text-center text-gray-500">
									Añade ingredientes usando el buscador.
								</TableCell>
							</TableRow>
						{/if}
					</TableBody>
				</Table>
				{#if form?.errors?.ingredients}
					<p class="text-sm text-red-500">{form.errors.ingredients}</p>
				{/if}
			</div>
			<!-- Información nutricional -->
			<div class="space-y-2 p-4 border rounded-lg bg-gray-50">
				<h3 class="text-lg font-medium">Información Nutricional (Total)</h3>
				<div class="grid grid-cols-2 md:grid-cols-4 gap-4">
					<div>
						<p class="font-bold text-xl">{nutritionalInfo.totalCalories.toFixed(2)}</p>
						<p class="text-sm text-gray-600">Calorías (kcal)</p>
					</div>
					<div>
						<p class="font-bold text-xl">{nutritionalInfo.totalProtein.toFixed(2)} g</p>
						<p class="text-sm text-gray-600">Proteínas</p>
					</div>
					<div>
						<p class="font-bold text-xl">{nutritionalInfo.totalFat.toFixed(2)} g</p>
						<p class="text-sm text-gray-600">Grasas</p>
					</div>
					<div>
						<p class="font-bold text-xl">{nutritionalInfo.totalCarbs.toFixed(2)} g</p>
						<p class="text-sm text-gray-600">Carbohidratos</p>
					</div>
				</div>
			</div>
			<div class="flex justify-end">
				<Button type="submit" disabled={isSubmitting}>
					{isSubmitting ? 'Guardando...' : 'Guardar Cambios'}
				</Button>
			</div>
			{#if form?.message}
				<p class="text-sm text-red-500 text-right">{form.message}</p>
			{/if}
		</form>
	</CardContent>
</Card>

// --- Ruta: src/routes/recetas/[slug]/editar/+page.server.ts ---
// Ruta: src/routes/recetas/[id]/editar/+page.server.ts
import { error, fail } from '@sveltejs/kit';
import { recipeService } from '$lib/server/services/recipeService';
import type { PageServerLoad, Actions } from './$types';
import { RecipeSchema } from '$lib/schemas/recipeSchema';
// Justificación: Se importa la nueva utilidad unificada para crear respuestas de error.
import { createFailResponse } from '$lib/server/zodErrors';
export const load: PageServerLoad = async ({ params }) => {
	const recipe = await recipeService.getById(params.id);
	if (!recipe) {
		throw error(404, 'Receta no encontrada');
	}
	return {
		recipe
	};
};
export const actions: Actions = {
	default: async ({ request, params }) => {
		const formData = await request.formData();
		const data = Object.fromEntries(formData.entries());
		const dataToValidate = {
			...data,
			ingredients: JSON.parse(data.ingredients as string),
			urls: JSON.parse(data.urls as string),
			steps: JSON.parse(data.steps as string)
		};
		const validation = RecipeSchema.safeParse(dataToValidate);
		if (!validation.success) {
			// Justificación: Se usa la nueva utilidad para el fallo de validación.
			const response = createFailResponse('La validación falló. Revisa los campos.', validation.error);
			return fail(400, response);
		}
		try {
			const updatedRecipe = await recipeService.update(params.id, validation.data);
			return {
				status: 200,
				body: {
					recipe: updatedRecipe
				}
			};
		} catch (err) {
			console.error(err);
			// Justificación: Se usa la misma utilidad para el fallo del servidor,
			// garantizando una estructura de respuesta 100% consistente.
			const response = createFailResponse('No se pudo actualizar la receta.');
			return fail(500, response);
		}
	}
};

// --- Ruta: src/routes/api/products/[id]/+server.ts ---
// Ruta: src/routes/api/products/[id]/+server.ts
import { json, type RequestHandler } from '@sveltejs/kit';
import { productService } from '$lib/server/services/productService';
export const DELETE: RequestHandler = async ({ params }) => {
	const { id } = params;
	if (!id) {
		return json({ message: 'El ID del producto es requerido.' }, { status: 400 });
	}
	try {
		await productService.deleteById(id);
		return new Response(null, { status: 204 }); // No Content
	} catch (error) {
		console.error(`Error deleting product ${id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/api/recipes/[id]/+server.ts ---
// Ruta: src/routes/api/recipes/[id]/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { recipeService } from '$lib/server/services/recipeService';
import { RecipeSchema } from '$lib/schemas/recipeSchema';
import { ZodError } from 'zod';
// Justificación: Se importa la nueva utilidad unificada.
import { createFailResponse } from '$lib/server/zodErrors';
/**
 * Maneja las peticiones GET para obtener una receta por su ID.
 */
export const GET: RequestHandler = async ({ params }) => {
	try {
		const recipe = await recipeService.getById(params.id);
		if (!recipe) {
			return json(createFailResponse('Receta no encontrada'), { status: 404 });
		}
		return json(recipe);
	} catch (error) {
		console.error(`Error fetching recipe ${params.id}:`, error);
		return json(createFailResponse('Error interno del servidor'), { status: 500 });
	}
};
/**
 * Maneja las peticiones PUT para actualizar una receta.
 */
export const PUT: RequestHandler = async ({ request, params }) => {
	try {
		const body = await request.json();
		const validatedData = RecipeSchema.parse(body);
		const updatedRecipe = await recipeService.update(params.id, validatedData);
		if (!updatedRecipe) {
			return json(createFailResponse('Receta no encontrada para actualizar'), { status: 404 });
		}
		return json(updatedRecipe);
	} catch (error) {
		if (error instanceof ZodError) {
			return json(createFailResponse('La validación falló', error), { status: 400 });
		}
		console.error(`Error updating recipe ${params.id}:`, error);
		return json(createFailResponse('Error interno del servidor'), { status: 500 });
	}
};
/**
 * Maneja las peticiones DELETE para eliminar una receta.
 */
export const DELETE: RequestHandler = async ({ params }) => {
	try {
		await recipeService.deleteById(params.id);
		return new Response(null, { status: 204 }); // 204 No Content
	} catch (error) {
		console.error(`Error deleting recipe ${params.id}:`, error);
		return json(createFailResponse('Error interno del servidor'), { status: 500 });
	}
};

// --- Ruta: src/routes/api/recipes/search/+server.ts ---
// Fichero: src/routes/api/recipes/search/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { recipeService } from '$lib/server/services/recipeService';
import { SearchFiltersSchema } from '$lib/schemas/searchSchema';
import { ZodError } from 'zod';
const RECIPES_PER_PAGE = 50;
/**
 * Endpoint POST para la búsqueda avanzada de recetas.
 * Acepta un cuerpo JSON con filtros estructurados.
 */
export const POST: RequestHandler = async ({ request }) => {
	// --- LOGGING: ID único para la petición ---
	const requestId = `req_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;
	console.log(`\n--- [${requestId}] INICIO: Petición de búsqueda recibida ---`);
	try {
		const body = await request.json();
		// --- LOGGING: Cuerpo de la petición recibido ---
		console.log(`[${requestId}] BODY RECIBIDO:`, JSON.stringify(body, null, 2));
		const filters = SearchFiltersSchema.parse(body);
		// --- LOGGING: Filtros validados por Zod ---
		console.log(`[${requestId}] FILTROS VALIDADOS:`, JSON.stringify(filters, null, 2));
		const queryOptions = {
			...filters,
			limit: RECIPES_PER_PAGE + 1
		};
		// --- LOGGING: Opciones de consulta a la base de datos ---
		// Esto es lo que se pasará a Prisma
		console.log(`[${requestId}] QUERY OPTIONS (para recipeService):`, JSON.stringify(queryOptions, null, 2));
		const recipesPlusOne = await recipeService.findAdvanced(queryOptions);
		const hasMore = recipesPlusOne.length > RECIPES_PER_PAGE;
		const recipes = recipesPlusOne.slice(0, RECIPES_PER_PAGE);
		// --- LOGGING: Resultado de la operación ---
		console.log(`[${requestId}] RESULTADO: ${recipes.length} recetas encontradas. ¿Hay más?: ${hasMore}`);
		console.log(`--- [${requestId}] FIN: Petición completada exitosamente ---`);
		return json({
			recipes,
			hasMore
		});
	} catch (error) {
		// --- LOGGING: Error en el proceso ---
		console.error(`--- [${requestId}] ERROR: Ha ocurrido un error en el endpoint ---`, error);
		if (error instanceof ZodError) {
			return json({ message: 'Datos de búsqueda inválidos', errors: error.flatten() }, { status: 400 });
		}
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/admin/ingredientes/off/+page.svelte ---
<script lang="ts">
	import { Button, buttonVariants } from '$lib/components/ui/button';
	import { Input } from '$lib/components/ui/input';
	import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '$lib/components/ui/card';
	type SearchResult = {
		id: string;
		name: string;
		source: 'local' | 'off';
		imageUrl: string | null;
	};
	let searchTerm = '';
	let results: SearchResult[] = [];
	let isLoading = false;
	let searchAttempted = false; // Para mostrar el mensaje de "no resultados"
	let eventSource: EventSource | null = null;
	function handleSearch() {
		if (searchTerm.length < 3) {
			results = [];
			searchAttempted = false;
			return;
		}
		results = [];
		isLoading = true;
		searchAttempted = true;
		if (eventSource) {
			eventSource.close();
		}
		eventSource = new EventSource(`/api/ingredients/search?q=${encodeURIComponent(searchTerm)}`);
		eventSource.addEventListener('message', (event) => {
			const newResults = JSON.parse(event.data);
			results = [...results, ...newResults];
		});
		// Escucha los errores de aplicación enviados explícitamente por el servidor
		eventSource.addEventListener('stream_error', (event) => {
			// Este es un MessageEvent, por lo que podemos castearlo y leer `data`
			const errorData = JSON.parse((event as MessageEvent).data);
			console.error('Error de stream recibido:', errorData);
		});
		// Escucha los errores de conexión genéricos
		eventSource.onerror = (err) => {
			// Este es un Event genérico, no tiene `data`. Solo indica fallo en la conexión.
			console.error('Error en la conexión de EventSource. La conexión se ha cerrado.', err);
			isLoading = false;
			eventSource?.close();
		};
		eventSource.addEventListener('close', () => {
			isLoading = false;
			eventSource?.close();
		});
	}
</script>
<div class="space-y-8 p-4 md:p-8">
	<div class="flex justify-between items-center">
		<h1 class="text-2xl font-bold">Añadir Ingredientes desde Open Food Facts</h1>
		<a href="/admin/ingredientes" class={buttonVariants({ variant: 'outline' })}>
			Volver al listado
		</a>
	</div>
	<form on:submit|preventDefault={handleSearch} class="flex items-center gap-2">
		<Input
		bind:value={searchTerm}
		placeholder="Buscar por nombre (ej. tomate frito)..."
		class="flex-grow"
		/>
		<Button type="submit" disabled={isLoading}>
			{#if isLoading}Buscando...{:else}Buscar{/if}
		</Button>
	</form>
	{#if results.length > 0}
	<div class="grid grid-cols-2 gap-4 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6">
		{#each results as result (result.id)}
		<Card class={result.source === 'local' ? 'ring-2 ring-green-500' : ''}>
			<CardHeader>
				<img
				src={result.imageUrl || 'https://placehold.co/400x400?text=Sin+Imagen'}
				alt={result.name}
				class="aspect-square w-full rounded-md object-cover"
				/>
			</CardHeader>
			<CardContent class="flex flex-col justify-between space-y-4">
				<CardTitle class="text-sm">{result.name}</CardTitle>
				{#if result.source === 'off'}
				<form method="POST" action="?/add">
					<input type="hidden" name="productId" value={result.id} />
					<Button type="submit" class="w-full">Añadir a la Base de Datos</Button>
				</form>
				{:else}
				<Button class="w-full" disabled>Ya está en la Base de Datos</Button>
				{/if}
			</CardContent>
		</Card>
		{/each}
	</div>
	{:else if !isLoading && searchAttempted}
	<div class="text-center text-gray-500 py-8">
		<p>No se encontraron resultados para tu búsqueda.</p>
	</div>
	{/if}
</div>

// --- Ruta: src/routes/admin/ingredientes/off/+page.server.ts ---
import { productService } from '$lib/server/services/productService';
import { fail } from '@sveltejs/kit';
import type { Actions } from './$types';
export const actions: Actions = {
	// Acción para añadir un producto de OFF a nuestra base de datos
	add: async ({ request }) => {
		const data = await request.formData();
		const productId = data.get('productId') as string;
		if (!productId) {
			return fail(400, { success: false, error: 'Product ID no proporcionado' });
		}
		try {
			const product = await productService.findByBarcode(productId);
			if (!product) {
				return fail(404, {
					success: false,
					error: `Producto con ID ${productId} no encontrado en Open Food Facts.`
				});
			}
			return { success: true, product };
		} catch (error) {
			console.error(error);
			return fail(500, {
				success: false,
				error: 'Error interno del servidor al intentar cachear el producto.'
			});
		}
	}
};

// --- Ruta: src/routes/api/ingredients/sync/+server.ts ---
// Ruta: src/routes/api/ingredients/sync/+server.ts
import { json, type RequestHandler } from '@sveltejs/kit';
import { ingredientService } from '$lib/server/services/ingredientService';
import { verifySessionToken } from '$lib/server/auth';
/**
 * @description Endpoint para sincronizar los ingredientes con Open Food Facts
 * @returns {Response}
 */
export const POST: RequestHandler = async ({ cookies }) => {
	// Justificación: Se protege el endpoint verificando el token de autenticación
	// del usuario. Esto asegura que solo usuarios logueados puedan iniciar un proceso
	// que consume recursos como es la sincronización.
	const token = cookies.get('session'); // CORREGIDO: El nombre de la cookie es 'session'
	if (!token || !(await verifySessionToken(token))) {
		return json({ message: 'No autorizado' }, { status: 401 });
	}
	try {
		// Justificación: Se invoca la lógica de negocio desde el servicio correspondiente.
		// El controlador (este archivo) se mantiene simple, delegando la complejidad
		// al `ingredientService`, lo que facilita el mantenimiento y las pruebas.
		const result = await ingredientService.syncWithOpenFoodFacts();
		return json(result, { status: 200 });
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : 'Error desconocido en el servidor';
		return json({ message: errorMessage }, { status: 500 });
	}
};

// --- Ruta: src/routes/api/ingredients/details/+server.ts ---
// src/routes/api/ingredients/details/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { ingredientService } from '$lib/server/services/ingredientService';
export const GET: RequestHandler = async ({ url }) => {
	const idsParam = url.searchParams.get('ids');
	if (!idsParam) {
		return json({ message: 'Missing "ids" query parameter' }, { status: 400 });
	}
	const ids = idsParam.split(',');
	if (ids.length === 0) {
		return json([]);
	}
	try {
		const ingredients = await ingredientService.getByIds(ids);
		return json(ingredients);
	} catch (error) {
		console.error('Failed to fetch ingredient details:', error);
		return json({ message: 'An error occurred while fetching ingredient details.' }, { status: 500 });
	}
};

// --- Ruta: src/routes/api/ingredients/search/api.spec.ts ---
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { GET } from './+server';
import { ingredientService } from '$lib/server/services/ingredientService';
// Mockear los módulos externos
vi.mock('$lib/server/services/ingredientService', () => ({
	ingredientService: {
		searchByName: vi.fn()
	}
}));
vi.mock('@sveltejs/kit', async (importOriginal) => {
	const original = await importOriginal<typeof import('@sveltejs/kit')>();
	return {
		...original,
		json: vi.fn((data, init) => new Response(JSON.stringify(data), init))
	};
});
type ApiEvent = Parameters<typeof GET>[0];
// Helper para consumir el stream y obtener los resultados como un array
async function consumeStream(stream: ReadableStream | null) {
	if (!stream) return [];
	const reader = stream.getReader();
	const results = [];
	while (true) {
		const { done, value } = await reader.read();
		if (done) break;
		// Justificación: En el entorno de test de Node.js, el valor del stream
		// ya es un string. Se elimina el TextDecoder para evitar el error de tipo,
		// tratando el chunk directamente como texto.
		const chunk = value.toString();
		const lines = chunk.split('\n\n').filter(Boolean);
		for (const line of lines) {
			if (line.startsWith('event: message')) {
				const data = JSON.parse(line.split('data: ')[1]);
				results.push(...data);
			}
		}
	}
	return results;
}
describe('API Endpoint: /api/ingredients/search', () => {
	const mockSearchByName = vi.mocked(ingredientService.searchByName);
	beforeEach(() => {
		vi.resetAllMocks();
	});
	it('debe devolver resultados locales del ingredientService', async () => {
		const mockLocalResults = {
			customIngredients: [
				{
					id: 'custom1',
					name: 'Tomate de la huerta',
					normalizedName: 'tomate de la huerta',
					calories: 22,
					fat: 0.2,
					protein: 0.9,
					carbs: 3.9
				}
			],
			cachedProducts: [
				{
					id: 'prod1',
					name: 'Tomate Frito (Mercadona)',
					normalizedName: 'tomate frito (mercadona)',
					brand: 'Hacendado',
					imageUrl: 'url_image',
					calories: 77,
					fat: 3.5,
					protein: 1.5,
					carbs: 8.5,
					fullPayload: {},
					createdAt: new Date(),
					updatedAt: new Date()
				}
			]
		};
		mockSearchByName.mockResolvedValue(mockLocalResults);
		const mockFetch = vi.fn().mockResolvedValue({
			ok: true,
			json: () => Promise.resolve({ products: [] })
		});
		const url = new URL('http://localhost/api/ingredients/search?q=tomate');
		const response = await GET({ url, fetch: mockFetch } as unknown as ApiEvent);
		const result = await consumeStream(response.body as ReadableStream);
		expect(mockSearchByName).toHaveBeenCalledWith('tomate');
		expect(result).toContainEqual({
			id: 'custom1',
			name: 'Tomate de la huerta',
			source: 'local',
			type: 'custom',
			imageUrl: null
		});
		expect(result).toContainEqual({
			id: 'prod1',
			name: 'Tomate Frito (Mercadona)',
			source: 'local',
			type: 'product',
			imageUrl: 'url_image'
		});
	});
	it('debe llamar a la API de Open Food Facts con "Hacendado" y "Mercadona" añadido a la query', async () => {
		mockSearchByName.mockResolvedValue({ customIngredients: [], cachedProducts: [] });
		const mockFetch = vi.fn().mockResolvedValue({
			ok: true,
			json: () => Promise.resolve({ products: [] })
		});
		const url = new URL('http://localhost/api/ingredients/search?q=queso');
		const response = await GET({ url, fetch: mockFetch } as unknown as ApiEvent);
		await consumeStream(response.body as ReadableStream);
		expect(mockFetch).toHaveBeenCalledTimes(2);
		const fetchUrl1 = mockFetch.mock.calls[0][0] as string;
		const fetchUrl2 = mockFetch.mock.calls[1][0] as string;
		expect(fetchUrl1).toContain('search_terms=queso%20Hacendado');
		expect(fetchUrl2).toContain('search_terms=queso%20Mercadona');
	});
	it('debe unificar resultados y eliminar duplicados dando prioridad a los locales', async () => {
		const mockLocalResults = {
			customIngredients: [],
			cachedProducts: [
				{
					id: '12345',
					name: 'Producto Local Repetido',
					normalizedName: 'producto local repetido',
					brand: 'Local',
					imageUrl: null,
					calories: 1,
					fat: 1,
					protein: 1,
					carbs: 1,
					fullPayload: {},
					createdAt: new Date(),
					updatedAt: new Date()
				}
			]
		};
		mockSearchByName.mockResolvedValue(mockLocalResults);
		const mockOffResponse = {
			products: [
				{ code: '12345', product_name: 'Producto OFF Repetido', image_front_small_url: 'url1' },
				{ code: '67890', product_name: 'Producto OFF Único', image_front_small_url: 'url2' }
			]
		};
		const mockFetch = vi.fn().mockResolvedValue({
			ok: true,
			json: () => Promise.resolve(mockOffResponse)
		});
		const url = new URL('http://localhost/api/ingredients/search?q=producto');
		const response = await GET({ url, fetch: mockFetch } as unknown as ApiEvent);
		const result = await consumeStream(response.body as ReadableStream);
		expect(result).toHaveLength(2);
		expect(result).toContainEqual({
			id: '12345',
			name: 'Producto Local Repetido',
			source: 'local',
			type: 'product',
			imageUrl: null
		});
		expect(result).toContainEqual({
			id: '67890',
			name: 'Producto OFF Único',
			source: 'off',
			type: 'product',
			imageUrl: 'url2'
		});
	});
	it('debe devolver un error 400 si no se proporciona el parámetro "q"', async () => {
		const url = new URL('http://localhost/api/ingredients/search');
		const mockFetch = vi.fn();
		const response = await GET({ url, fetch: mockFetch } as unknown as ApiEvent);
		expect(response.status).toBe(400);
		const body = await response.json();
		expect(body.error).toBe('Query parameter "q" is required');
	});
});

// --- Ruta: src/routes/api/ingredients/search/+server.ts ---
import { ingredientService } from '$lib/server/services/ingredientService';
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
// Definimos un tipo para la respuesta de OFF para mejorar la legibilidad
type OffProduct = {
	code: string;
	product_name: string;
	image_front_small_url?: string;
};
export const GET: RequestHandler = ({ url, fetch }) => {
	const query = url.searchParams.get('q');
	if (!query) {
		return json({ error: 'Query parameter "q" is required' }, { status: 400 });
	}
	const stream = new ReadableStream({
		async start(controller) {
			const localIds = new Set<string>();
			type SearchResult = {
				id: string;
				name: string;
				source: 'local' | 'off';
				type: 'custom' | 'product';
				imageUrl: string | null;
			};
			// Función para enviar eventos con nombre al stream
			const sendEvent = (event: string, data: object) => {
				controller.enqueue(`event: ${event}\ndata: ${JSON.stringify(data)}\n\n`);
			};
			try {
				// 1. Búsqueda local (rápida)
				const { customIngredients, cachedProducts } = await ingredientService.searchByName(query);
				const localResults: SearchResult[] = [
					...customIngredients.map(
						(i) =>
							({
								id: i.id,
								name: i.name,
								source: 'local',
								type: 'custom',
								imageUrl: null
							}) as const
					),
					...cachedProducts.map(
						(p) =>
							({
								id: p.id,
								name: p.name,
								source: 'local',
								type: 'product',
								imageUrl: p.imageUrl
							}) as const
					)
				];
				if (localResults.length > 0) {
					localResults.forEach((r) => localIds.add(r.id));
					sendEvent('message', localResults);
				}
				// 2. Búsquedas externas (lentas)
				const brands = ['Hacendado', 'Mercadona'];
				const offSearchPromises = brands.map((brand) => {
					const offQuery = `${query} ${brand}`;
					const offUrl = `https://world.openfoodfacts.org/cgi/search.pl?search_terms=${encodeURIComponent(
						offQuery
					)}&search_simple=1&action=process&json=1&page_size=10`;
					return fetch(offUrl)
						.then(async (res) => {
							if (!res.ok) throw new Error(`API returned status ${res.status}`);
							return res.json() as Promise<{ products: OffProduct[] }>;
						})
						.then((response) => {
							const offProducts = response.products || [];
							const uniqueOffProducts: SearchResult[] = offProducts
								.filter((p) => p.code && !localIds.has(p.code))
								.map((p) => {
									localIds.add(p.code);
									return {
										id: p.code,
										name: p.product_name,
										source: 'off' as const,
										type: 'product' as const,
										imageUrl: p.image_front_small_url || null
									};
								});
							if (uniqueOffProducts.length > 0) {
								sendEvent('message', uniqueOffProducts);
							}
						})
						.catch((err) => {
							// Lanzar el error para que Promise.allSettled lo capture
							throw new Error(`Failed to fetch from ${brand}: ${err.message}`);
						});
				});
				const results = await Promise.allSettled(offSearchPromises);
				results.forEach((result) => {
					if (result.status === 'rejected') {
						console.error('A fetch promise was rejected:', result.reason);
						sendEvent('stream_error', { source: 'off-api', message: result.reason.message });
					}
				});
			} catch (error) {
				console.error('[Search Stream Error]', error);
				const errorMessage = error instanceof Error ? error.message : 'Unknown stream error';
				sendEvent('stream_error', { source: 'server', message: errorMessage });
			} finally {
				// Notificar al cliente que el stream ha finalizado
				sendEvent('close', { message: 'Stream closed' });
				controller.close();
			}
		}
	});
	return new Response(stream, {
		headers: {
			'Content-Type': 'text/event-stream',
			'Cache-Control': 'no-cache',
			'Connection': 'keep-alive'
		}
	});
};

// --- Ruta: src/routes/api/ingredients/autocomplete/+server.ts ---
// Fichero: src/routes/api/ingredients/autocomplete/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { ingredientService } from '$lib/server/services/ingredientService';
/**
 * Endpoint GET para el autocompletado de ingredientes.
 * Devuelve una lista plana de ingredientes en formato JSON.
 */
export const GET: RequestHandler = async ({ url }) => {
	const query = url.searchParams.get('q');
	if (!query) {
		return json({ error: 'Query parameter "q" is required' }, { status: 400 });
	}
	try {
		const { customIngredients, cachedProducts } = await ingredientService.searchByName(query);
		// Justificación: Se aplanan los resultados de ambas fuentes (custom y productos)
		// en un único array, que es el formato que espera el componente combobox.
		const results = [
			...customIngredients.map((ing) => ({
				id: ing.id,
				name: ing.name,
				type: 'custom',
				source: 'local',
				imageUrl: null
			})),
			...cachedProducts.map((prod) => ({
				id: prod.id,
				name: prod.name,
				type: 'product',
				source: 'local',
				imageUrl: prod.imageUrl
			}))
		];
		return json(results);
	} catch (error) {
		console.error('Error en el endpoint de autocompletado de ingredientes:', error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/api/ingredients/[id]/+server.ts ---
// Ruta: src/routes/api/ingredients/[id]/+server.ts
import { json, type RequestHandler } from '@sveltejs/kit';
import { ingredientService } from '$lib/server/services/ingredientService';
import { IngredientSchema } from '$lib/schemas/ingredientSchema';
import { ZodError } from 'zod';
// Justificación: Se importa la nueva utilidad unificada.
import { createFailResponse } from '$lib/server/zodErrors';
export const PUT: RequestHandler = async ({ request, params }) => {
	const { id } = params;
	if (!id) {
		return json(createFailResponse('ID de ingrediente es requerido'), { status: 400 });
	}
	try {
		const body = await request.json();
		const validatedData = IngredientSchema.parse(body);
		const updatedIngredient = await ingredientService.update(id, validatedData);
		return json(updatedIngredient);
	} catch (error) {
		if (error instanceof ZodError) {
			return json(createFailResponse('La validación falló', error), { status: 400 });
		}
		console.error(`Error updating ingredient with id ${id}:`, error);
		return json(createFailResponse('Error interno del servidor'), { status: 500 });
	}
};
export const DELETE: RequestHandler = async ({ params }) => {
	const { id } = params;
	if (!id) {
		return json(createFailResponse('ID de ingrediente es requerido'), { status: 400 });
	}
	try {
		await ingredientService.deleteById(id);
		return new Response(null, { status: 204 }); // 204 No Content
	} catch (error) {
		console.error(`Error deleting ingredient ${id}:`, error);
		return json(createFailResponse('Error interno del servidor'), { status: 500 });
	}
};

// --- Ruta: src/lib/components/ui/textarea/textarea.svelte ---
<script lang="ts">
	import { cn, type WithElementRef, type WithoutChildren } from "$lib/utils.js";
	import type { HTMLTextareaAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		value = $bindable(),
		class: className,
		...restProps
	}: WithoutChildren<WithElementRef<HTMLTextareaAttributes>> = $props();
</script>
<textarea
	bind:this={ref}
	data-slot="textarea"
	class={cn(
		"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 field-sizing-content shadow-xs flex min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base outline-none transition-[color,box-shadow] focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
		className
	)}
	bind:value
	{...restProps}
></textarea>

// --- Ruta: src/lib/components/ui/textarea/index.ts ---
import Root from "./textarea.svelte";
export {
	Root,
	//
	Root as Textarea,
};

// --- Ruta: src/lib/components/ui/table/table.svelte ---
<script lang="ts">
	import type { HTMLTableAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLTableAttributes> = $props();
</script>
<div data-slot="table-container" class="relative w-full overflow-x-auto">
	<table
		bind:this={ref}
		data-slot="table"
		class={cn("w-full caption-bottom text-sm", className)}
		{...restProps}
	>
		{@render children?.()}
	</table>
</div>

// --- Ruta: src/lib/components/ui/table/table-row.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLTableRowElement>> = $props();
</script>
<tr
	bind:this={ref}
	data-slot="table-row"
	class={cn(
		"hover:[&,&>svelte-css-wrapper]:[&>th,td]:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</tr>

// --- Ruta: src/lib/components/ui/table/table-header.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props();
</script>
<thead
	bind:this={ref}
	data-slot="table-header"
	class={cn("[&_tr]:border-b", className)}
	{...restProps}
>
	{@render children?.()}
</thead>

// --- Ruta: src/lib/components/ui/table/table-head.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLThAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLThAttributes> = $props();
</script>
<th
	bind:this={ref}
	data-slot="table-head"
	class={cn(
		"text-foreground h-10 whitespace-nowrap bg-clip-padding px-2 text-left align-middle font-medium [&:has([role=checkbox])]:pr-0",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</th>

// --- Ruta: src/lib/components/ui/table/table-footer.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props();
</script>
<tfoot
	bind:this={ref}
	data-slot="table-footer"
	class={cn("bg-muted/50 border-t font-medium [&>tr]:last:border-b-0", className)}
	{...restProps}
>
	{@render children?.()}
</tfoot>

// --- Ruta: src/lib/components/ui/table/table-cell.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLTdAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLTdAttributes> = $props();
</script>
<td
	bind:this={ref}
	data-slot="table-cell"
	class={cn(
		"whitespace-nowrap bg-clip-padding p-2 align-middle [&:has([role=checkbox])]:pr-0",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</td>

// --- Ruta: src/lib/components/ui/table/table-caption.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLElement>> = $props();
</script>
<caption
	bind:this={ref}
	data-slot="table-caption"
	class={cn("text-muted-foreground mt-4 text-sm", className)}
	{...restProps}
>
	{@render children?.()}
</caption>

// --- Ruta: src/lib/components/ui/table/table-body.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props();
</script>
<tbody
	bind:this={ref}
	data-slot="table-body"
	class={cn("[&_tr:last-child]:border-0", className)}
	{...restProps}
>
	{@render children?.()}
</tbody>

// --- Ruta: src/lib/components/ui/table/index.ts ---
import Root from "./table.svelte";
import Body from "./table-body.svelte";
import Caption from "./table-caption.svelte";
import Cell from "./table-cell.svelte";
import Footer from "./table-footer.svelte";
import Head from "./table-head.svelte";
import Header from "./table-header.svelte";
import Row from "./table-row.svelte";
export {
	Root,
	Body,
	Caption,
	Cell,
	Footer,
	Head,
	Header,
	Row,
	//
	Root as Table,
	Body as TableBody,
	Caption as TableCaption,
	Cell as TableCell,
	Footer as TableFooter,
	Head as TableHead,
	Header as TableHeader,
	Row as TableRow,
};

// --- Ruta: src/lib/components/ui/switch/switch.svelte ---
<script lang="ts">
	import { Switch as SwitchPrimitive } from "bits-ui";
	import { cn, type WithoutChildrenOrChild } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		checked = $bindable(false),
		...restProps
	}: WithoutChildrenOrChild<SwitchPrimitive.RootProps> = $props();
</script>
<SwitchPrimitive.Root
	bind:ref
	bind:checked
	data-slot="switch"
	class={cn(
		"data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 shadow-xs peer inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent outline-none transition-all focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
		className
	)}
	{...restProps}
>
	<SwitchPrimitive.Thumb
		data-slot="switch-thumb"
		class={cn(
			"bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
		)}
	/>
</SwitchPrimitive.Root>

// --- Ruta: src/lib/components/ui/switch/index.ts ---
import Root from "./switch.svelte";
export {
	Root,
	//
	Root as Switch,
};

// --- Ruta: src/lib/components/ui/popover/popover-trigger.svelte ---
<script lang="ts">
	import { cn } from "$lib/utils.js";
	import { Popover as PopoverPrimitive } from "bits-ui";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: PopoverPrimitive.TriggerProps = $props();
</script>
<PopoverPrimitive.Trigger
	bind:ref
	data-slot="popover-trigger"
	class={cn("", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/popover/popover-content.svelte ---
<script lang="ts">
	import { cn } from "$lib/utils.js";
	import { Popover as PopoverPrimitive } from "bits-ui";
	let {
		ref = $bindable(null),
		class: className,
		sideOffset = 4,
		align = "center",
		portalProps,
		...restProps
	}: PopoverPrimitive.ContentProps & {
		portalProps?: PopoverPrimitive.PortalProps;
	} = $props();
</script>
<PopoverPrimitive.Portal {...portalProps}>
	<PopoverPrimitive.Content
		bind:ref
		data-slot="popover-content"
		{sideOffset}
		{align}
		class={cn(
			"bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-popover-content-transform-origin) outline-hidden z-50 w-72 rounded-md border p-4 shadow-md",
			className
		)}
		{...restProps}
	/>
</PopoverPrimitive.Portal>

// --- Ruta: src/lib/components/ui/popover/index.ts ---
import { Popover as PopoverPrimitive } from "bits-ui";
import Content from "./popover-content.svelte";
import Trigger from "./popover-trigger.svelte";
const Root = PopoverPrimitive.Root;
const Close = PopoverPrimitive.Close;
export {
	Root,
	Content,
	Trigger,
	Close,
	//
	Root as Popover,
	Content as PopoverContent,
	Trigger as PopoverTrigger,
	Close as PopoverClose,
};

// --- Ruta: src/lib/components/ui/label/label.svelte ---
<script lang="ts">
	import { Label as LabelPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: LabelPrimitive.RootProps = $props();
</script>
<LabelPrimitive.Root
	bind:ref
	data-slot="label"
	class={cn(
		"flex select-none items-center gap-2 text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-50 group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/label/index.ts ---
import Root from "./label.svelte";
export {
	Root,
	//
	Root as Label,
};

// --- Ruta: src/lib/components/ui/input/input.svelte ---
<script lang="ts">
	import type { HTMLInputAttributes, HTMLInputTypeAttribute } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	type InputType = Exclude<HTMLInputTypeAttribute, "file">;
	type Props = WithElementRef<
		Omit<HTMLInputAttributes, "type"> &
			({ type: "file"; files?: FileList } | { type?: InputType; files?: undefined })
	>;
	let {
		ref = $bindable(null),
		value = $bindable(),
		type,
		files = $bindable(),
		class: className,
		...restProps
	}: Props = $props();
</script>
{#if type === "file"}
	<input
		bind:this={ref}
		data-slot="input"
		class={cn(
			"selection:bg-primary dark:bg-input/30 selection:text-primary-foreground border-input ring-offset-background placeholder:text-muted-foreground shadow-xs flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 pt-1.5 text-sm font-medium outline-none transition-[color,box-shadow] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
			"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
			"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
			className
		)}
		type="file"
		bind:files
		bind:value
		{...restProps}
	/>
{:else}
	<input
		bind:this={ref}
		data-slot="input"
		class={cn(
			"border-input bg-background selection:bg-primary dark:bg-input/30 selection:text-primary-foreground ring-offset-background placeholder:text-muted-foreground shadow-xs flex h-9 w-full min-w-0 rounded-md border px-3 py-1 text-base outline-none transition-[color,box-shadow] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
			"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
			"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
			className
		)}
		{type}
		bind:value
		{...restProps}
	/>
{/if}

// --- Ruta: src/lib/components/ui/input/index.ts ---
import Root from "./input.svelte";
export {
	Root,
	//
	Root as Input,
};

// --- Ruta: src/lib/components/ui/dropdown-menu/index.ts ---
import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
import CheckboxItem from "./dropdown-menu-checkbox-item.svelte";
import Content from "./dropdown-menu-content.svelte";
import Group from "./dropdown-menu-group.svelte";
import Item from "./dropdown-menu-item.svelte";
import Label from "./dropdown-menu-label.svelte";
import RadioGroup from "./dropdown-menu-radio-group.svelte";
import RadioItem from "./dropdown-menu-radio-item.svelte";
import Separator from "./dropdown-menu-separator.svelte";
import Shortcut from "./dropdown-menu-shortcut.svelte";
import Trigger from "./dropdown-menu-trigger.svelte";
import SubContent from "./dropdown-menu-sub-content.svelte";
import SubTrigger from "./dropdown-menu-sub-trigger.svelte";
import GroupHeading from "./dropdown-menu-group-heading.svelte";
const Sub = DropdownMenuPrimitive.Sub;
const Root = DropdownMenuPrimitive.Root;
export {
	CheckboxItem,
	Content,
	Root as DropdownMenu,
	CheckboxItem as DropdownMenuCheckboxItem,
	Content as DropdownMenuContent,
	Group as DropdownMenuGroup,
	Item as DropdownMenuItem,
	Label as DropdownMenuLabel,
	RadioGroup as DropdownMenuRadioGroup,
	RadioItem as DropdownMenuRadioItem,
	Separator as DropdownMenuSeparator,
	Shortcut as DropdownMenuShortcut,
	Sub as DropdownMenuSub,
	SubContent as DropdownMenuSubContent,
	SubTrigger as DropdownMenuSubTrigger,
	Trigger as DropdownMenuTrigger,
	GroupHeading as DropdownMenuGroupHeading,
	Group,
	GroupHeading,
	Item,
	Label,
	RadioGroup,
	RadioItem,
	Root,
	Separator,
	Shortcut,
	Sub,
	SubContent,
	SubTrigger,
	Trigger,
};

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-trigger.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	let { ref = $bindable(null), ...restProps }: DropdownMenuPrimitive.TriggerProps = $props();
</script>
<DropdownMenuPrimitive.Trigger bind:ref data-slot="dropdown-menu-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-sub-trigger.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	import ChevronRightIcon from "@lucide/svelte/icons/chevron-right";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		inset,
		children,
		...restProps
	}: DropdownMenuPrimitive.SubTriggerProps & {
		inset?: boolean;
	} = $props();
</script>
<DropdownMenuPrimitive.SubTrigger
	bind:ref
	data-slot="dropdown-menu-sub-trigger"
	data-inset={inset}
	class={cn(
		"data-highlighted:bg-accent data-highlighted:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground outline-hidden [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		className
	)}
	{...restProps}
>
	{@render children?.()}
	<ChevronRightIcon class="ml-auto size-4" />
</DropdownMenuPrimitive.SubTrigger>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-sub-content.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: DropdownMenuPrimitive.SubContentProps = $props();
</script>
<DropdownMenuPrimitive.SubContent
	bind:ref
	data-slot="dropdown-menu-sub-content"
	class={cn(
		"bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-dropdown-menu-content-transform-origin) z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-shortcut.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLSpanElement>> = $props();
</script>
<span
	bind:this={ref}
	data-slot="dropdown-menu-shortcut"
	class={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)}
	{...restProps}
>
	{@render children?.()}
</span>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-separator.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: DropdownMenuPrimitive.SeparatorProps = $props();
</script>
<DropdownMenuPrimitive.Separator
	bind:ref
	data-slot="dropdown-menu-separator"
	class={cn("bg-border -mx-1 my-1 h-px", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-radio-item.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	import CircleIcon from "@lucide/svelte/icons/circle";
	import { cn, type WithoutChild } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children: childrenProp,
		...restProps
	}: WithoutChild<DropdownMenuPrimitive.RadioItemProps> = $props();
</script>
<DropdownMenuPrimitive.RadioItem
	bind:ref
	data-slot="dropdown-menu-radio-item"
	class={cn(
		"focus:bg-accent focus:text-accent-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-8 pr-2 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		className
	)}
	{...restProps}
>
	{#snippet children({ checked })}
		<span class="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
			{#if checked}
				<CircleIcon class="size-2 fill-current" />
			{/if}
		</span>
		{@render childrenProp?.({ checked })}
	{/snippet}
</DropdownMenuPrimitive.RadioItem>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-radio-group.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	let {
		ref = $bindable(null),
		value = $bindable(),
		...restProps
	}: DropdownMenuPrimitive.RadioGroupProps = $props();
</script>
<DropdownMenuPrimitive.RadioGroup
	bind:ref
	bind:value
	data-slot="dropdown-menu-radio-group"
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-label.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		inset,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> & {
		inset?: boolean;
	} = $props();
</script>
<div
	bind:this={ref}
	data-slot="dropdown-menu-label"
	data-inset={inset}
	class={cn("px-2 py-1.5 text-sm font-semibold data-[inset]:pl-8", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-item.svelte ---
<script lang="ts">
	import { cn } from "$lib/utils.js";
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	let {
		ref = $bindable(null),
		class: className,
		inset,
		variant = "default",
		...restProps
	}: DropdownMenuPrimitive.ItemProps & {
		inset?: boolean;
		variant?: "default" | "destructive";
	} = $props();
</script>
<DropdownMenuPrimitive.Item
	bind:ref
	data-slot="dropdown-menu-item"
	data-inset={inset}
	data-variant={variant}
	class={cn(
		"data-highlighted:bg-accent data-highlighted:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:data-highlighted:bg-destructive/10 dark:data-[variant=destructive]:data-highlighted:bg-destructive/20 data-[variant=destructive]:data-highlighted:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-group.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	let { ref = $bindable(null), ...restProps }: DropdownMenuPrimitive.GroupProps = $props();
</script>
<DropdownMenuPrimitive.Group bind:ref data-slot="dropdown-menu-group" {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-group-heading.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	import type { ComponentProps } from "svelte";
	let {
		ref = $bindable(null),
		class: className,
		inset,
		...restProps
	}: ComponentProps<typeof DropdownMenuPrimitive.GroupHeading> & {
		inset?: boolean;
	} = $props();
</script>
<DropdownMenuPrimitive.GroupHeading
	bind:ref
	data-slot="dropdown-menu-group-heading"
	data-inset={inset}
	class={cn("px-2 py-1.5 text-sm font-semibold data-[inset]:pl-8", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-content.svelte ---
<script lang="ts">
	import { cn } from "$lib/utils.js";
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	let {
		ref = $bindable(null),
		sideOffset = 4,
		portalProps,
		class: className,
		...restProps
	}: DropdownMenuPrimitive.ContentProps & {
		portalProps?: DropdownMenuPrimitive.PortalProps;
	} = $props();
</script>
<DropdownMenuPrimitive.Portal {...portalProps}>
	<DropdownMenuPrimitive.Content
		bind:ref
		data-slot="dropdown-menu-content"
		{sideOffset}
		class={cn(
			"bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 max-h-(--bits-dropdown-menu-content-available-height) origin-(--bits-dropdown-menu-content-transform-origin) z-50 min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border p-1 shadow-md outline-none",
			className
		)}
		{...restProps}
	/>
</DropdownMenuPrimitive.Portal>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-checkbox-item.svelte ---
<script lang="ts">
	import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
	import CheckIcon from "@lucide/svelte/icons/check";
	import MinusIcon from "@lucide/svelte/icons/minus";
	import { cn, type WithoutChildrenOrChild } from "$lib/utils.js";
	import type { Snippet } from "svelte";
	let {
		ref = $bindable(null),
		checked = $bindable(false),
		indeterminate = $bindable(false),
		class: className,
		children: childrenProp,
		...restProps
	}: WithoutChildrenOrChild<DropdownMenuPrimitive.CheckboxItemProps> & {
		children?: Snippet;
	} = $props();
</script>
<DropdownMenuPrimitive.CheckboxItem
	bind:ref
	bind:checked
	bind:indeterminate
	data-slot="dropdown-menu-checkbox-item"
	class={cn(
		"focus:bg-accent focus:text-accent-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-8 pr-2 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		className
	)}
	{...restProps}
>
	{#snippet children({ checked, indeterminate })}
		<span class="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
			{#if indeterminate}
				<MinusIcon class="size-4" />
			{:else}
				<CheckIcon class={cn("size-4", !checked && "text-transparent")} />
			{/if}
		</span>
		{@render childrenProp?.()}
	{/snippet}
</DropdownMenuPrimitive.CheckboxItem>

// --- Ruta: src/lib/components/ui/dialog/index.ts ---
import * as DialogPrimitive from "bits-ui";
import Title from "./dialog-title.svelte";
import Footer from "./dialog-footer.svelte";
import Header from "./dialog-header.svelte";
import Overlay from "./dialog-overlay.svelte";
import Content from "./dialog-content.svelte";
import Description from "./dialog-description.svelte";
import Trigger from "./dialog-trigger.svelte";
import Close from "./dialog-close.svelte";
const Root = DialogPrimitive.Dialog.Root;
const Portal = DialogPrimitive.Dialog.Portal;
export {
	Root,
	Title,
	Portal,
	Footer,
	Header,
	Trigger,
	Overlay,
	Content,
	Description,
	Close,
	//
	Root as Dialog,
	Title as DialogTitle,
	Portal as DialogPortal,
	Footer as DialogFooter,
	Header as DialogHeader,
	Trigger as DialogTrigger,
	Overlay as DialogOverlay,
	Content as DialogContent,
	Description as DialogDescription,
	Close as DialogClose,
};

// --- Ruta: src/lib/components/ui/dialog/dialog-trigger.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	let { ref = $bindable(null), ...restProps }: DialogPrimitive.TriggerProps = $props();
</script>
<DialogPrimitive.Trigger bind:ref data-slot="dialog-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-title.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: DialogPrimitive.TitleProps = $props();
</script>
<DialogPrimitive.Title
	bind:ref
	data-slot="dialog-title"
	class={cn("text-lg font-semibold leading-none", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dialog/dialog-overlay.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: DialogPrimitive.OverlayProps = $props();
</script>
<DialogPrimitive.Overlay
	bind:ref
	data-slot="dialog-overlay"
	class={cn(
		"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dialog/dialog-header.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="dialog-header"
	class={cn("flex flex-col gap-2 text-center sm:text-left", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/dialog/dialog-footer.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="dialog-footer"
	class={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/dialog/dialog-description.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: DialogPrimitive.DescriptionProps = $props();
</script>
<DialogPrimitive.Description
	bind:ref
	data-slot="dialog-description"
	class={cn("text-muted-foreground text-sm", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dialog/dialog-content.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import XIcon from "@lucide/svelte/icons/x";
	import type { Snippet } from "svelte";
	import * as Dialog from "./index.js";
	import { cn, type WithoutChildrenOrChild } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		portalProps,
		children,
		showCloseButton = true,
		...restProps
	}: WithoutChildrenOrChild<DialogPrimitive.ContentProps> & {
		portalProps?: DialogPrimitive.PortalProps;
		children: Snippet;
		showCloseButton?: boolean;
	} = $props();
</script>
<Dialog.Portal {...portalProps}>
	<Dialog.Overlay />
	<DialogPrimitive.Content
		bind:ref
		data-slot="dialog-content"
		class={cn(
			"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
			className
		)}
		{...restProps}
	>
		{@render children?.()}
		{#if showCloseButton}
			<DialogPrimitive.Close
				class="ring-offset-background focus:ring-ring rounded-xs focus:outline-hidden absolute right-4 top-4 opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 disabled:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0"
			>
				<XIcon />
				<span class="sr-only">Close</span>
			</DialogPrimitive.Close>
		{/if}
	</DialogPrimitive.Content>
</Dialog.Portal>

// --- Ruta: src/lib/components/ui/dialog/dialog-close.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	let { ref = $bindable(null), ...restProps }: DialogPrimitive.CloseProps = $props();
</script>
<DialogPrimitive.Close bind:ref data-slot="dialog-close" {...restProps} />

// --- Ruta: src/lib/components/ui/command/index.ts ---
import { Command as CommandPrimitive } from "bits-ui";
import Root from "./command.svelte";
import Dialog from "./command-dialog.svelte";
import Empty from "./command-empty.svelte";
import Group from "./command-group.svelte";
import Item from "./command-item.svelte";
import Input from "./command-input.svelte";
import List from "./command-list.svelte";
import Separator from "./command-separator.svelte";
import Shortcut from "./command-shortcut.svelte";
import LinkItem from "./command-link-item.svelte";
const Loading = CommandPrimitive.Loading;
export {
	Root,
	Dialog,
	Empty,
	Group,
	Item,
	LinkItem,
	Input,
	List,
	Separator,
	Shortcut,
	Loading,
	//
	Root as Command,
	Dialog as CommandDialog,
	Empty as CommandEmpty,
	Group as CommandGroup,
	Item as CommandItem,
	LinkItem as CommandLinkItem,
	Input as CommandInput,
	List as CommandList,
	Separator as CommandSeparator,
	Shortcut as CommandShortcut,
	Loading as CommandLoading,
};

// --- Ruta: src/lib/components/ui/command/command.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		value = $bindable(""),
		class: className,
		...restProps
	}: CommandPrimitive.RootProps = $props();
</script>
<CommandPrimitive.Root
	bind:value
	bind:ref
	data-slot="command"
	class={cn(
		"bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-shortcut.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLSpanElement>> = $props();
</script>
<span
	bind:this={ref}
	data-slot="command-shortcut"
	class={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)}
	{...restProps}
>
	{@render children?.()}
</span>

// --- Ruta: src/lib/components/ui/command/command-separator.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.SeparatorProps = $props();
</script>
<CommandPrimitive.Separator
	bind:ref
	data-slot="command-separator"
	class={cn("bg-border -mx-1 h-px", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-list.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.ListProps = $props();
</script>
<CommandPrimitive.List
	bind:ref
	data-slot="command-list"
	class={cn("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-link-item.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.LinkItemProps = $props();
</script>
<CommandPrimitive.LinkItem
	bind:ref
	data-slot="command-item"
	class={cn(
		"aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-item.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.ItemProps = $props();
</script>
<CommandPrimitive.Item
	bind:ref
	data-slot="command-item"
	class={cn(
		"aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-input.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import SearchIcon from "@lucide/svelte/icons/search";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		value = $bindable(""),
		...restProps
	}: CommandPrimitive.InputProps = $props();
</script>
<div class="flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper">
	<SearchIcon class="size-4 shrink-0 opacity-50" />
	<CommandPrimitive.Input
		data-slot="command-input"
		class={cn(
			"placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50",
			className
		)}
		bind:ref
		{...restProps}
		bind:value
	/>
</div>

// --- Ruta: src/lib/components/ui/command/command-group.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive, useId } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		heading,
		value,
		...restProps
	}: CommandPrimitive.GroupProps & {
		heading?: string;
	} = $props();
</script>
<CommandPrimitive.Group
	bind:ref
	data-slot="command-group"
	class={cn("text-foreground overflow-hidden p-1", className)}
	value={value ?? heading ?? `----${useId()}`}
	{...restProps}
>
	{#if heading}
		<CommandPrimitive.GroupHeading
			class="text-muted-foreground px-2 py-1.5 text-xs font-medium"
		>
			{heading}
		</CommandPrimitive.GroupHeading>
	{/if}
	<CommandPrimitive.GroupItems {children} />
</CommandPrimitive.Group>

// --- Ruta: src/lib/components/ui/command/command-empty.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.EmptyProps = $props();
</script>
<CommandPrimitive.Empty
	bind:ref
	data-slot="command-empty"
	class={cn("py-6 text-center text-sm", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-dialog.svelte ---
<script lang="ts">
	import type { Command as CommandPrimitive, Dialog as DialogPrimitive } from "bits-ui";
	import type { Snippet } from "svelte";
	import Command from "./command.svelte";
	import * as Dialog from "$lib/components/ui/dialog/index.js";
	import type { WithoutChildrenOrChild } from "$lib/utils.js";
	let {
		open = $bindable(false),
		ref = $bindable(null),
		value = $bindable(""),
		title = "Command Palette",
		description = "Search for a command to run",
		portalProps,
		children,
		...restProps
	}: WithoutChildrenOrChild<DialogPrimitive.RootProps> &
		WithoutChildrenOrChild<CommandPrimitive.RootProps> & {
			portalProps?: DialogPrimitive.PortalProps;
			children: Snippet;
			title?: string;
			description?: string;
		} = $props();
</script>
<Dialog.Root bind:open {...restProps}>
	<Dialog.Header class="sr-only">
		<Dialog.Title>{title}</Dialog.Title>
		<Dialog.Description>{description}</Dialog.Description>
	</Dialog.Header>
	<Dialog.Content class="overflow-hidden p-0" {portalProps}>
		<Command
			class="**:data-[slot=command-input-wrapper]:h-12 [&_[data-command-group]:not([hidden])_~[data-command-group]]:pt-0 [&_[data-command-group]]:px-2 [&_[data-command-input-wrapper]_svg]:h-5 [&_[data-command-input-wrapper]_svg]:w-5 [&_[data-command-input]]:h-12 [&_[data-command-item]]:px-2 [&_[data-command-item]]:py-3 [&_[data-command-item]_svg]:h-5 [&_[data-command-item]_svg]:w-5"
			{...restProps}
			bind:value
			bind:ref
			{children}
		/>
	</Dialog.Content>
</Dialog.Root>

// --- Ruta: src/lib/components/ui/button/index.ts ---
import Root, {
	type ButtonProps,
	type ButtonSize,
	type ButtonVariant,
	buttonVariants,
} from "./button.svelte";
export {
	Root,
	type ButtonProps as Props,
	//
	Root as Button,
	buttonVariants,
	type ButtonProps,
	type ButtonSize,
	type ButtonVariant,
};

// --- Ruta: src/lib/components/ui/button/button.svelte ---
<script lang="ts" module>
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAnchorAttributes, HTMLButtonAttributes } from "svelte/elements";
	import { type VariantProps, tv } from "tailwind-variants";
	export const buttonVariants = tv({
		base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
				destructive:
					"bg-destructive shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white",
				outline:
					"bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border",
				secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-9 px-4 py-2 has-[>svg]:px-3",
				sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
				lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
				icon: "size-9",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	});
	export type ButtonVariant = VariantProps<typeof buttonVariants>["variant"];
	export type ButtonSize = VariantProps<typeof buttonVariants>["size"];
	export type ButtonProps = WithElementRef<HTMLButtonAttributes> &
		WithElementRef<HTMLAnchorAttributes> & {
			variant?: ButtonVariant;
			size?: ButtonSize;
		};
</script>
<script lang="ts">
	let {
		class: className,
		variant = "default",
		size = "default",
		ref = $bindable(null),
		href = undefined,
		type = "button",
		disabled,
		children,
		...restProps
	}: ButtonProps = $props();
</script>
{#if href}
	<a
		bind:this={ref}
		data-slot="button"
		class={cn(buttonVariants({ variant, size }), className)}
		href={disabled ? undefined : href}
		aria-disabled={disabled}
		role={disabled ? "link" : undefined}
		tabindex={disabled ? -1 : undefined}
		{...restProps}
	>
		{@render children?.()}
	</a>
{:else}
	<button
		bind:this={ref}
		data-slot="button"
		class={cn(buttonVariants({ variant, size }), className)}
		{type}
		{disabled}
		{...restProps}
	>
		{@render children?.()}
	</button>
{/if}

// --- Ruta: src/lib/components/ui/card/index.ts ---
import Root from "./card.svelte";
import Content from "./card-content.svelte";
import Description from "./card-description.svelte";
import Footer from "./card-footer.svelte";
import Header from "./card-header.svelte";
import Title from "./card-title.svelte";
import Action from "./card-action.svelte";
export {
	Root,
	Content,
	Description,
	Footer,
	Header,
	Title,
	Action,
	//
	Root as Card,
	Content as CardContent,
	Description as CardDescription,
	Footer as CardFooter,
	Header as CardHeader,
	Title as CardTitle,
	Action as CardAction,
};

// --- Ruta: src/lib/components/ui/card/card.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card"
	class={cn(
		"bg-card text-card-foreground flex flex-col gap-6 pb-6 rounded-xl border shadow-sm",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-title.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card-title"
	class={cn("font-semibold leading-none", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-header.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card-header"
	class={cn(
		"@container/card-header has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6 grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-footer.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card-footer"
	class={cn("[.border-t]:pt-6 flex items-center px-6", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-description.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLParagraphElement>> = $props();
</script>
<p
	bind:this={ref}
	data-slot="card-description"
	class={cn("text-muted-foreground text-sm", className)}
	{...restProps}
>
	{@render children?.()}
</p>

// --- Ruta: src/lib/components/ui/card/card-content.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div bind:this={ref} data-slot="card-content" class={cn("px-6", className)} {...restProps}>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-action.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card-action"
	class={cn("col-start-2 row-span-2 row-start-1 self-start justify-self-end", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/badge/index.ts ---
export { default as Badge } from "./badge.svelte";
export { badgeVariants, type BadgeVariant } from "./badge.svelte";

// --- Ruta: src/lib/components/ui/badge/badge.svelte ---
<script lang="ts" module>
	import { type VariantProps, tv } from "tailwind-variants";
	export const badgeVariants = tv({
		base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex w-fit shrink-0 items-center justify-center gap-1 overflow-hidden whitespace-nowrap rounded-md border px-2 py-0.5 text-xs font-medium transition-[color,box-shadow] focus-visible:ring-[3px] [&>svg]:pointer-events-none [&>svg]:size-3",
		variants: {
			variant: {
				default:
					"bg-primary text-primary-foreground [a&]:hover:bg-primary/90 border-transparent",
				secondary:
					"bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90 border-transparent",
				destructive:
					"bg-destructive [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/70 border-transparent text-white",
				outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	});
	export type BadgeVariant = VariantProps<typeof badgeVariants>["variant"];
</script>
<script lang="ts">
	import type { HTMLAnchorAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		href,
		class: className,
		variant = "default",
		children,
		...restProps
	}: WithElementRef<HTMLAnchorAttributes> & {
		variant?: BadgeVariant;
	} = $props();
</script>
<svelte:element
	this={href ? "a" : "span"}
	bind:this={ref}
	data-slot="badge"
	{href}
	class={cn(badgeVariants({ variant }), className)}
	{...restProps}
>
	{@render children?.()}
</svelte:element>

// --- Ruta: src/lib/components/ui/alert-dialog/index.ts ---
import { AlertDialog as AlertDialogPrimitive } from "bits-ui";
import Trigger from "./alert-dialog-trigger.svelte";
import Title from "./alert-dialog-title.svelte";
import Action from "./alert-dialog-action.svelte";
import Cancel from "./alert-dialog-cancel.svelte";
import Footer from "./alert-dialog-footer.svelte";
import Header from "./alert-dialog-header.svelte";
import Overlay from "./alert-dialog-overlay.svelte";
import Content from "./alert-dialog-content.svelte";
import Description from "./alert-dialog-description.svelte";
const Root = AlertDialogPrimitive.Root;
const Portal = AlertDialogPrimitive.Portal;
export {
	Root,
	Title,
	Action,
	Cancel,
	Portal,
	Footer,
	Header,
	Trigger,
	Overlay,
	Content,
	Description,
	//
	Root as AlertDialog,
	Title as AlertDialogTitle,
	Action as AlertDialogAction,
	Cancel as AlertDialogCancel,
	Portal as AlertDialogPortal,
	Footer as AlertDialogFooter,
	Header as AlertDialogHeader,
	Trigger as AlertDialogTrigger,
	Overlay as AlertDialogOverlay,
	Content as AlertDialogContent,
	Description as AlertDialogDescription,
};

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-trigger.svelte ---
<script lang="ts">
	import { AlertDialog as AlertDialogPrimitive } from "bits-ui";
	let { ref = $bindable(null), ...restProps }: AlertDialogPrimitive.TriggerProps = $props();
</script>
<AlertDialogPrimitive.Trigger bind:ref data-slot="alert-dialog-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-title.svelte ---
<script lang="ts">
	import { AlertDialog as AlertDialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: AlertDialogPrimitive.TitleProps = $props();
</script>
<AlertDialogPrimitive.Title
	bind:ref
	data-slot="alert-dialog-title"
	class={cn("text-lg font-semibold", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-overlay.svelte ---
<script lang="ts">
	import { AlertDialog as AlertDialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: AlertDialogPrimitive.OverlayProps = $props();
</script>
<AlertDialogPrimitive.Overlay
	bind:ref
	data-slot="alert-dialog-overlay"
	class={cn(
		"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-header.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="alert-dialog-header"
	class={cn("flex flex-col gap-2 text-center sm:text-left", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-footer.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="alert-dialog-footer"
	class={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-description.svelte ---
<script lang="ts">
	import { AlertDialog as AlertDialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: AlertDialogPrimitive.DescriptionProps = $props();
</script>
<AlertDialogPrimitive.Description
	bind:ref
	data-slot="alert-dialog-description"
	class={cn("text-muted-foreground text-sm", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-content.svelte ---
<script lang="ts">
	import { AlertDialog as AlertDialogPrimitive } from "bits-ui";
	import AlertDialogOverlay from "./alert-dialog-overlay.svelte";
	import { cn, type WithoutChild, type WithoutChildrenOrChild } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		portalProps,
		...restProps
	}: WithoutChild<AlertDialogPrimitive.ContentProps> & {
		portalProps?: WithoutChildrenOrChild<AlertDialogPrimitive.PortalProps>;
	} = $props();
</script>
<AlertDialogPrimitive.Portal {...portalProps}>
	<AlertDialogOverlay />
	<AlertDialogPrimitive.Content
		bind:ref
		data-slot="alert-dialog-content"
		class={cn(
			"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
			className
		)}
		{...restProps}
	/>
</AlertDialogPrimitive.Portal>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-cancel.svelte ---
<script lang="ts">
	import { AlertDialog as AlertDialogPrimitive } from "bits-ui";
	import { buttonVariants } from "$lib/components/ui/button/index.js";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: AlertDialogPrimitive.CancelProps = $props();
</script>
<AlertDialogPrimitive.Cancel
	bind:ref
	data-slot="alert-dialog-cancel"
	class={cn(buttonVariants({ variant: "outline" }), className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-action.svelte ---
<script lang="ts">
	import { AlertDialog as AlertDialogPrimitive } from "bits-ui";
	import { buttonVariants } from "$lib/components/ui/button/index.js";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: AlertDialogPrimitive.ActionProps = $props();
</script>
<AlertDialogPrimitive.Action
	bind:ref
	data-slot="alert-dialog-action"
	class={cn(buttonVariants(), className)}
	{...restProps}
/>

// --- Ruta: src/routes/api/products/search/[barcode]/+server.ts ---
// Ruta: src/routes/api/products/search/[barcode]/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { productService } from '$lib/server/services/productService';
// Justificación: Expone el `productService` a través de una API RESTful.
// El endpoint recibe el código de barras como un parámetro de la ruta (`params.barcode`),
// lo que es una práctica estándar para identificar un recurso específico.
// Se importa `RequestHandler` desde `./$types` para obtener el tipado correcto de `params`.
export const GET: RequestHandler = async ({ params }) => {
	const { barcode } = params;
	if (!barcode) {
		return json({ message: 'El código de barras es requerido' }, { status: 400 });
	}
	try {
		const product = await productService.findByBarcode(barcode);
		if (!product) {
			// Si el producto no se encuentra ni en la caché ni en la API de OFF,
			// devolvemos un 404 Not Found, que es el código de estado HTTP correcto.
			return json({ message: 'Producto no encontrado' }, { status: 404 });
		}
		// Devolvemos el producto encontrado (ya sea de la caché o de la API).
		return json(product);
	} catch (error) {
		console.error(`Error searching for barcode ${barcode}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/api/ingredients/details/[id]/+server.ts ---
// Ruta: src/routes/api/ingredients/details/[id]/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import prisma from '$lib/server/prisma';
import { productService } from '$lib/server/services/productService';
// Justificación: Este endpoint centraliza la obtención de datos nutricionales
// para cualquier tipo de ingrediente. El frontend lo necesita para poder
// calcular la información nutricional en tiempo real al crear/editar una receta.
export const GET: RequestHandler = async ({ params, url }) => {
	const { id } = params;
	const type = url.searchParams.get('type');
	if (!type || (type !== 'custom' && type !== 'product')) {
		return json({ message: "El parámetro 'type' es requerido ('custom' o 'product')." }, { status: 400 });
	}
	try {
		let ingredientData = null;
		if (type === 'custom') {
			ingredientData = await prisma.customIngredient.findUnique({
				where: { id }
			});
		} else {
			// Para productos, el 'id' es el código de barras.
			// Usamos el productService que ya tiene la lógica de caché y fallback a OFF.
			ingredientData = await productService.findByBarcode(id);
		}
		if (!ingredientData) {
			return json({ message: 'Ingrediente no encontrado.' }, { status: 404 });
		}
		// Justificación: Devolvemos un objeto con una estructura consistente,
		// independientemente de la tabla de origen, para que el frontend
		// pueda procesarlo de forma sencilla.
		const response = {
			calories: ingredientData.calories,
			protein: ingredientData.protein,
			fat: ingredientData.fat,
			carbs: ingredientData.carbs
		};
		return json(response);
	} catch (error) {
		console.error(`Error fetching ingredient details for id ${id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

