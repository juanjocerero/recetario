/* --- Bundle de Código Generado ---
 * Modo: full
 * Ficheros Incluidos: 105
 * Fecha: 2025-08-01T14:53:18.370Z
 */

// --- Ruta: vitest.config.ts ---
import { defineConfig } from 'vitest/config';
import { svelte } from '@sveltejs/vite-plugin-svelte';
import path from 'path';
export default defineConfig({
	plugins: [svelte()],
	resolve: {
		alias: {
			$lib: path.resolve(__dirname, './src/lib')
		}
	},
	test: {
		environment: 'jsdom',
		globals: true,
		include: ['src/**/*.{test,spec}.{js,ts}'],
		exclude: ['e2e/**']
	}
});

// --- Ruta: vite.config.ts ---
import tailwindcss from '@tailwindcss/vite';
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';
export default defineConfig({
	plugins: [tailwindcss(), sveltekit()]
});

// --- Ruta: tsconfig.json ---
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}

// --- Ruta: tailwind.config.ts ---
// Ruta: tailwind.config.ts
import type { Config } from 'tailwindcss';
export default {
	content: ['./src/**/*.{html,js,svelte,ts}'],
	theme: {
		extend: {}
	},
	plugins: []
} satisfies Config;

// --- Ruta: svelte.config.js ---
import adapter from '@sveltejs/adapter-cloudflare';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';
/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: vitePreprocess(),
	kit: {
		// adapter-auto only supports some environments, see https://svelte.dev/docs/kit/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://svelte.dev/docs/kit/adapters for more information about adapters.
		adapter: adapter()
	}
};
export default config;

// --- Ruta: package.json ---
{
	"name": "recetario",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"prepare": "svelte-kit sync || echo ''",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"format": "prettier --write .",
		"lint": "prettier --check . && eslint .",
		"test:unit": "vitest",
		"test": "vitest run"
	},
	"devDependencies": {
		"@eslint/compat": "^1.2.5",
		"@eslint/js": "^9.18.0",
		"@internationalized/date": "^3.8.2",
		"@lucide/svelte": "^0.515.0",
		"@sveltejs/adapter-auto": "^6.0.0",
		"@sveltejs/adapter-cloudflare": "^4.4.0",
		"@sveltejs/kit": "^2.22.0",
		"@sveltejs/vite-plugin-svelte": "^6.0.0",
		"@tailwindcss/vite": "^4.1.11",
		"@types/bcryptjs": "^2.4.6",
		"@types/node": "^24.1.0",
		"autoprefixer": "^10.4.21",
		"bits-ui": "^2.8.13",
		"clsx": "^2.1.1",
		"eslint": "^9.18.0",
		"eslint-config-prettier": "^10.0.1",
		"eslint-plugin-svelte": "^3.0.0",
		"glob": "^11.0.3",
		"globals": "^16.0.0",
		"ignore": "^7.0.5",
		"jsdom": "^26.1.0",
		"postcss": "^8.5.6",
		"prettier": "^3.4.2",
		"prettier-plugin-svelte": "^3.3.3",
		"prettier-plugin-tailwindcss": "^0.6.5",
		"prisma": "^6.13.0",
		"shadcn-svelte": "^1.0.6",
		"svelte": "^5.0.0",
		"svelte-check": "^4.0.0",
		"tailwind-merge": "^3.3.1",
		"tailwind-variants": "^1.0.0",
		"tailwindcss": "^4.1.11",
		"tailwindcss-animate": "^1.0.7",
		"tw-animate-css": "^1.3.6",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.20.0",
		"vite": "^7.0.4",
		"vitest": "^3.2.3"
	},
	"optionalDependencies": {
		"@cloudflare/workerd-darwin-64": "^1.20250726.0",
		"@cloudflare/workerd-linux-64": "^1.20250726.0",
		"@cloudflare/workerd-win32-64": "^1.20250726.0"
	},
	"overrides": {
		"esbuild": "^0.20.2"
	},
	"dependencies": {
		"@prisma/adapter-d1": "^6.13.0",
		"@prisma/client": "^6.13.0",
		"bcryptjs": "^3.0.2",
		"jose": "^6.0.12",
		"ky": "^1.8.2",
		"lucide-svelte": "^0.535.0",
		"zod": "^4.0.14"
	}
}

// --- Ruta: eslint.config.js ---
import prettier from 'eslint-config-prettier';
import { includeIgnoreFile } from '@eslint/compat';
import js from '@eslint/js';
import svelte from 'eslint-plugin-svelte';
import globals from 'globals';
import { fileURLToPath } from 'node:url';
import ts from 'typescript-eslint';
import svelteConfig from './svelte.config.js';
const gitignorePath = fileURLToPath(new URL('./.gitignore', import.meta.url));
export default ts.config(
	includeIgnoreFile(gitignorePath),
	js.configs.recommended,
	...ts.configs.recommended,
	...svelte.configs.recommended,
	prettier,
	...svelte.configs.prettier,
	{
		languageOptions: {
			globals: { ...globals.browser, ...globals.node }
		},
		rules: {
			// typescript-eslint strongly recommend that you do not use the no-undef lint rule on TypeScript projects.
			// see: https://typescript-eslint.io/troubleshooting/faqs/eslint/#i-get-errors-from-the-no-undef-rule-about-global-variables-not-being-defined-even-though-there-are-no-typescript-errors
			'no-undef': 'off'
		}
	},
	{
		files: ['**/*.svelte', '**/*.svelte.ts', '**/*.svelte.js'],
		languageOptions: {
			parserOptions: {
				projectService: true,
				extraFileExtensions: ['.svelte'],
				parser: ts.parser,
				svelteConfig
			}
		}
	}
);

// --- Ruta: components.json ---
{
	"$schema": "https://shadcn-svelte.com/schema.json",
	"tailwind": {
		"css": "src/app.css",
		"baseColor": "slate"
	},
	"aliases": {
		"components": "$lib/components",
		"utils": "$lib/utils",
		"ui": "$lib/components/ui",
		"hooks": "$lib/hooks",
		"lib": "$lib"
	},
	"typescript": true,
	"registry": "https://shadcn-svelte.com/registry"
}

// --- Ruta: .prettierrc ---
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"],
	"overrides": [
		{
			"files": "*.svelte",
			"options": {
				"parser": "svelte"
			}
		}
	],
	"tailwindStylesheet": "./src/app.css"
}

// --- Ruta: .prettierignore ---
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
bun.lock
bun.lockb
# Miscellaneous
/static/

// --- Ruta: .npmrc ---
engine-strict=true

// --- Ruta: src/demo.spec.ts ---
import { describe, it, expect } from 'vitest';
describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});

// --- Ruta: src/app.html ---
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

// --- Ruta: src/app.d.ts ---
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}
export {};

// --- Ruta: scripts/hash-password.js ---
// Ruta: scripts/hash-password.js
// Uso: node scripts/hash-password.js 'tu_contraseña_aqui'
import { hash } from 'bcryptjs';
const password = process.argv[2];
if (!password) {
	console.error('Por favor, proporciona una contraseña como argumento.');
	process.exit(1);
}
const SALT_ROUNDS = 10;
hash(password, SALT_ROUNDS).then((hash) => {
	console.log('Contraseña:', password);
	console.log('Hash:', hash);
	console.log('\nCopia este hash en tu fichero .env como ADMIN_PASSWORD_HASH');
});

// --- Ruta: prisma/schema.prisma ---
// Ruta: prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}
datasource db {
  // Justificación: Se configura para SQLite para el desarrollo local,
  // como se especifica en el plan (M1.3, M2.2).
  provider = "sqlite"
  url      = "file:./dev.db"
}
model Product {
  id                String             @id // Código de barras
  name              String
  normalizedName    String // Para búsqueda case/accent-insensitive
  brand             String?
  imageUrl          String?
  calories          Float?             // Valor por 100g
  fat               Float?             // Valor por 100g
  protein           Float?             // Valor por 100g
  carbs             Float?             // Valor por 100g
  fullPayload       Json?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  recipeIngredients RecipeIngredient[]
}
model CustomIngredient {
  id                String             @id @default(cuid())
  name              String             @unique
  normalizedName    String // Para búsqueda case/accent-insensitive
  calories          Float
  fat               Float
  protein           Float
  carbs             Float
  recipeIngredients RecipeIngredient[]
}
model Recipe {
  id          String             @id @default(cuid())
  title       String
  description String?
  steps       String
  ingredients RecipeIngredient[]
}
model RecipeIngredient {
  id                 String            @id @default(cuid())
  recipe             Recipe            @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId           String
  // Se relaciona directamente con un Product o un CustomIngredient
  product            Product?          @relation(fields: [productId], references: [id])
  productId          String?
  customIngredient   CustomIngredient? @relation(fields: [customIngredientId], references: [id])
  customIngredientId String?
  quantity           Float             // En gramos
}

// --- Ruta: src/routes/+page.svelte ---
<h1>Welcome to SvelteKit</h1>
<p>Visit <a href="https://svelte.dev/docs/kit">svelte.dev/docs/kit</a> to read the documentation</p>

// --- Ruta: src/routes/+layout.svelte ---
<script>
	import '../app.css';
	let { children } = $props();
</script>
{@render children()}

// --- Ruta: src/lib/utils.ts ---
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
/**
 * Normaliza un texto para búsquedas: lo convierte a minúsculas y elimina los acentos.
 * Ejemplo: "Azúcar Moreno" -> "azucar moreno"
 * @param text - El texto a normalizar.
 * @returns El texto normalizado.
 */
export function normalizeText(text: string): string {
	return text
		.toLowerCase()
		.normalize('NFD') // Descompone los caracteres acentuados en base + diacrítico
		.replace(/[\u0300-\u036f]/g, ''); // Elimina los diacríticos
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type WithoutChild<T> = T extends { child?: any } ? Omit<T, "child"> : T;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type WithoutChildren<T> = T extends { children?: any } ? Omit<T, "children"> : T;
export type WithoutChildrenOrChild<T> = WithoutChildren<WithoutChild<T>>;
export type WithElementRef<T, U extends HTMLElement = HTMLElement> = T & { ref?: U | null };

// --- Ruta: src/lib/recipeCalculator.ts ---
// Ruta: src/lib/recipeCalculator.ts
// Justificación: Aislar la lógica de cálculo en funciones puras hace que el código
// sea más predecible, fácil de testear y reutilizable. Este módulo no tiene
// dependencias externas (como Prisma o APIs), solo recibe datos y devuelve un resultado.
// Definimos un tipo para los ingredientes que usará la calculadora.
// Esto nos desacopla de los modelos de Prisma.
export type CalculableIngredient = {
	quantity: number; // en gramos
	calories?: number | null; // por 100g
	protein?: number | null;
	fat?: number | null;
	carbs?: number | null;
};
export type NutritionalInfo = {
	totalCalories: number;
	totalProtein: number;
	totalFat: number;
	totalCarbs: number;
};
/**
 * Calcula la información nutricional total para una lista de ingredientes.
 * @param ingredients - Un array de ingredientes con su cantidad y valores nutricionales por 100g.
 * @returns Un objeto con los totales de calorías, proteínas, grasas y carbohidratos.
 */
export function calculateNutritionalInfo(ingredients: CalculableIngredient[]): NutritionalInfo {
	const totals: NutritionalInfo = {
		totalCalories: 0,
		totalProtein: 0,
		totalFat: 0,
		totalCarbs: 0
	};
	for (const ingredient of ingredients) {
		const factor = ingredient.quantity / 100;
		totals.totalCalories += (ingredient.calories || 0) * factor;
		totals.totalProtein += (ingredient.protein || 0) * factor;
		totals.totalFat += (ingredient.fat || 0) * factor;
		totals.totalCarbs += (ingredient.carbs || 0) * factor;
	}
	// Redondeamos a 2 decimales para una mejor presentación
	return {
		totalCalories: Math.round(totals.totalCalories * 100) / 100,
		totalProtein: Math.round(totals.totalProtein * 100) / 100,
		totalFat: Math.round(totals.totalFat * 100) / 100,
		totalCarbs: Math.round(totals.totalCarbs * 100) / 100
	};
}

// --- Ruta: src/lib/recipeCalculator.spec.ts ---
// Ruta: src/lib/recipeCalculator.spec.ts
import { describe, it, expect } from 'vitest';
import { calculateNutritionalInfo, type CalculableIngredient } from './recipeCalculator';
// Justificación: Se testea la función `calculateNutritionalInfo` de forma aislada (test unitario).
// Al ser una función pura, podemos pasarle datos de entrada controlados y verificar
// que la salida sea predecible y correcta, garantizando la fiabilidad del cálculo.
describe('calculateNutritionalInfo', () => {
	it('should calculate the total nutritional info for a list of ingredients correctly', () => {
		const ingredients: CalculableIngredient[] = [
			{ quantity: 200, calories: 100, protein: 10, fat: 5, carbs: 20 }, // Pollo
			{ quantity: 150, calories: 50, protein: 2, fat: 1, carbs: 10 } // Arroz
		];
		const result = calculateNutritionalInfo(ingredients);
		// 200g de Pollo: 200 cal, 20p, 10g, 40c
		// 150g de Arroz: 75 cal, 3p, 1.5g, 15c
		// Total: 275 cal, 23p, 11.5g, 55c
		expect(result.totalCalories).toBe(275);
		expect(result.totalProtein).toBe(23);
		expect(result.totalFat).toBe(11.5);
		expect(result.totalCarbs).toBe(55);
	});
	it('should return all zeros if the ingredient list is empty', () => {
		const ingredients: CalculableIngredient[] = [];
		const result = calculateNutritionalInfo(ingredients);
		expect(result.totalCalories).toBe(0);
		expect(result.totalProtein).toBe(0);
		expect(result.totalFat).toBe(0);
		expect(result.totalCarbs).toBe(0);
	});
	it('should handle ingredients with null or missing nutritional values gracefully', () => {
		const ingredients: CalculableIngredient[] = [
			{ quantity: 100, calories: 300, protein: 20, fat: 10, carbs: 5 },
			{ quantity: 50, calories: null, protein: 5, fat: undefined, carbs: 25 } // Ingrediente con datos incompletos
		];
		const result = calculateNutritionalInfo(ingredients);
		// 100g de Ing1: 300 cal, 20p, 10g, 5c
		// 50g de Ing2: 0 cal, 2.5p, 0g, 12.5c
		// Total: 300 cal, 22.5p, 10g, 17.5c
		expect(result.totalCalories).toBe(300);
		expect(result.totalProtein).toBe(22.5);
		expect(result.totalFat).toBe(10);
		expect(result.totalCarbs).toBe(17.5);
	});
	it('should handle rounding correctly to two decimal places', () => {
		const ingredients: CalculableIngredient[] = [
			{ quantity: 33, calories: 123, protein: 11.11, fat: 5.55, carbs: 22.22 }
		];
		const result = calculateNutritionalInfo(ingredients);
		// 33g de Ing1: 40.59 cal, 3.6663p, 1.8315g, 7.3326c
		// Redondeado: 40.59 cal, 3.67p, 1.83g, 7.33c
		expect(result.totalCalories).toBe(40.59);
		expect(result.totalProtein).toBe(3.67);
		expect(result.totalFat).toBe(1.83);
		expect(result.totalCarbs).toBe(7.33);
	});
});

// --- Ruta: src/lib/index.ts ---
// place files you want to import through the `$lib` alias in this folder.

// --- Ruta: prisma/migrations/migration_lock.toml ---
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "sqlite"

// --- Ruta: src/routes/login/+page.svelte ---
<!-- Ruta: src/routes/login/+page.svelte -->
<script lang="ts">
	import { enhance } from '$app/forms';
	import type { ActionData } from './$types';
	import * as Card from '$lib/components/ui/card';
	import { Button } from '$lib/components/ui/button';
	import { Input } from '$lib/components/ui/input';
	import { Label } from '$lib/components/ui/label';
	export let form: ActionData;
	let loading = false;
</script>
<div class="flex min-h-screen items-center justify-center bg-muted/40">
	<Card.Root class="w-full max-w-sm">
		<Card.Header class="space-y-1 text-center">
			<Card.Title class="text-2xl font-bold">Admin Login</Card.Title>
			<Card.Description>Introduce tus credenciales para acceder al panel</Card.Description>
		</Card.Header>
		<Card.Content>
			<!-- Justificación (form action y enhance): Se usa un <form> estándar con un `action`
			que apunta a la acción por defecto de esta misma página (`?/default`).
			`use:enhance` intercepta el envío, lo hace vía fetch, y maneja el resultado
			(actualizar `form`, redirigir, etc.) de forma automática y robusta. -->
			<form
				method="POST"
				action="?/login"
				use:enhance={() => {
					loading = true;
					return async ({ update }) => {
						await update();
						loading = false;
					};
				}}
				class="space-y-4"
			>
				<div class="space-y-2">
					<Label for="user">Usuario</Label>
					<Input id="user" name="user" type="text" placeholder="admin" required />
				</div>
				<div class="space-y-2">
					<Label for="password">Contraseña</Label>
					<Input id="password" name="password" type="password" required />
				</div>
				{#if form?.message}
					<p class="text-sm font-medium text-destructive">{form.message}</p>
				{/if}
				<Button type="submit" class="w-full" disabled={loading}>
					{loading ? 'Entrando...' : 'Entrar'}
				</Button>
			</form>
		</Card.Content>
	</Card.Root>
</div>

// --- Ruta: src/routes/login/+page.server.ts ---
// Ruta: src/routes/login/+page.server.ts
import { type Actions, fail, redirect } from '@sveltejs/kit';
import { comparePasswords, createSessionToken } from '$lib/server/auth';
import { env } from '$env/dynamic/private';
// Justificación: Se define una 'action' de SvelteKit en lugar de un endpoint de API.
// Esto integra el manejo del formulario directamente con el ciclo de vida de la página,
// lo que es más robusto y la forma idiomática de manejar envíos de formularios en SvelteKit.
export const actions: Actions = {
	login: async ({ request, cookies }) => {
		const data = await request.formData();
		const user = data.get('user');
		const password = data.get('password');
		// 1. Validación de entrada
		if (!user || !password || typeof user !== 'string' || typeof password !== 'string') {
			return fail(400, { message: 'Usuario y contraseña son requeridos' });
		}
		// 2. Verificación de credenciales
		if (!env.ADMIN_PASSWORD_HASH) {
			console.error('La variable de entorno ADMIN_PASSWORD_HASH no está configurada.');
			return fail(500, { message: 'Error de configuración en el servidor' });
		}
		const isAdminUser = user === 'admin';
		const isPasswordValid = await comparePasswords(password, env.ADMIN_PASSWORD_HASH);
		if (!isAdminUser || !isPasswordValid) {
			return fail(401, { message: 'Credenciales inválidas' });
		}
		// 3. Creación del token y establecimiento de la cookie
		const token = await createSessionToken({ sub: 'admin' });
		cookies.set('session', token, {
			path: '/',
			httpOnly: true,
			secure: process.env.NODE_ENV === 'production',
			sameSite: 'strict',
			maxAge: 60 * 60 * 24 // 1 día
		});
		// 4. Redirección
		// Justificación (redirect): En lugar de devolver un JSON, una 'action' exitosa
		// puede lanzar una redirección. SvelteKit la gestionará correctamente,
		// tanto en el lado del servidor como en el cliente (si se usa `enhance`).
		throw redirect(303, '/admin/ingredientes');
	}
};

// --- Ruta: src/lib/server/zodErrors.ts ---
// Ruta: src/lib/server/zodErrors.ts
import type { ZodError } from 'zod';
/**
 * Transforma un error de Zod en un objeto más simple,
 * mapeando los mensajes de error a cada campo que falló la validación.
 * @param error - El error de Zod.
 * @returns Un objeto donde cada clave es un campo y el valor es el primer mensaje de error para ese campo.
 */
export function formatZodError(error: ZodError) {
	const fieldErrors: Record<string, string | undefined> = {};
	for (const issue of error.issues) {
		if (issue.path.length > 0) {
			const field = issue.path.join('.');
			if (!fieldErrors[field]) {
				fieldErrors[field] = issue.message;
			}
		}
	}
	return {
		message: 'Validation failed',
		errors: fieldErrors
	};
}

// --- Ruta: src/lib/server/prisma.ts ---
// Ruta: src/lib/server/prisma.ts
import { PrismaClient } from '@prisma/client';
// Justificación: Se sigue el patrón singleton recomendado por Prisma
// para evitar crear múltiples conexiones a la base de datos en entornos
// serverless o durante el hot-reloading en desarrollo.
// La importación desde '@prisma/client' funciona porque `npx prisma generate`
// redirige este alias a la implementación generada en `node_modules/.prisma/client`.
const prisma = new PrismaClient();
export default prisma;

// --- Ruta: src/lib/server/auth.ts ---
// Ruta: src/lib/server/auth.ts
import { SignJWT, jwtVerify } from 'jose';
import { hash, compare } from 'bcryptjs';
import { env } from '$env/dynamic/private';
// Justificación (bcrypt): Usamos bcrypt para hashear contraseñas. Es un algoritmo
// adaptativo y lento por diseño, lo que lo hace resistente a ataques de fuerza bruta.
const SALT_ROUNDS = 10; // Número de rondas de salting. 10 es un buen equilibrio.
export async function hashPassword(password: string) {
	return await hash(password, SALT_ROUNDS);
}
export async function comparePasswords(password: string, hash: string) {
	return await compare(password, hash);
}
// Justificación (JWT en Cookie): Usamos JSON Web Tokens (JWT) para gestionar sesiones.
// El token se firma en el servidor con un secreto y se envía al cliente en una cookie
// HttpOnly, lo que previene el acceso desde JavaScript (ataques XSS).
// Justificación: Se comprueba que la variable de entorno crítica exista al iniciar.
// Si no, es un error de configuración del servidor y la aplicación no debe arrancar.
if (!env.SESSION_SECRET) {
	throw new Error(
		'La variable de entorno SESSION_SECRET no está configurada. La aplicación no puede iniciarse de forma segura.'
	);
}
const secret = new TextEncoder().encode(env.SESSION_SECRET);
const algorithm = 'HS256'; // Algoritmo de firma
export async function createSessionToken(payload: { sub: string; [key: string]: unknown }) {
	return await new SignJWT(payload)
		.setProtectedHeader({ alg: algorithm })
		.setExpirationTime('24h') // El token expira en 24 horas
		.setIssuedAt()
		.setSubject(payload.sub)
		.sign(secret);
}
export async function verifySessionToken(token: string) {
	try {
		const { payload } = await jwtVerify(token, secret, {
			algorithms: [algorithm]
		});
		return payload;
	} catch (error) {
		return null; // El token es inválido o ha expirado
	}
}

// --- Ruta: src/lib/schemas/recipeSchema.ts ---
// Ruta: src/lib/schemas/recipeSchema.ts
import { z } from 'zod';
// Justificación: Este es el esquema para un único ingrediente DENTRO de una receta.
// Es el Data Transfer Object (DTO) que esperamos del frontend.
const RecipeIngredientSchema = z.object({
	id: z.string(), // ID del ProductCache o CustomIngredient
	type: z.enum(['product', 'custom']), // Para saber a qué tabla enlazar
	quantity: z.coerce.number().positive({ message: 'La cantidad debe ser mayor que cero.' })
});
// Justificación: Esquema principal para la creación y actualización de recetas.
// Valida la estructura completa del objeto que se enviará a la API.
export const RecipeSchema = z.object({
	title: z.string().min(1, { message: 'El título no puede estar vacío.' }),
	description: z.string().optional(),
	steps: z.string().min(1, { message: 'Debe haber al menos un paso.' }),
	ingredients: z
		.array(RecipeIngredientSchema)
		.min(1, { message: 'La receta debe tener al menos un ingrediente.' })
});
// Exportamos los tipos inferidos para usarlos en el código sin tener que
// depender directamente de Zod, mejorando el desacoplamiento.
export type RecipeIngredient = z.infer<typeof RecipeIngredientSchema>;
export type RecipeData = z.infer<typeof RecipeSchema>;

// --- Ruta: src/lib/schemas/ingredientSchema.ts ---
// Ruta: src/lib/schemas/ingredientSchema.ts
import { z } from 'zod';
// Justificación: Se exporta como 'const' para que sea un valor en tiempo de ejecución.
// Esto permite que otros módulos lo importen para usarlo en funciones como 'z.infer'
// y para la validación de datos. 'verbatimModuleSyntax' en tsconfig.json lo requiere.
export const IngredientSchema = z.object({
	name: z.string().min(1, { message: 'El nombre no puede estar vacío.' }),
	// Usamos z.coerce.number() para convertir la entrada (que puede ser string) a número.
	calories: z.coerce.number().min(0, { message: 'Las calorías no pueden ser negativas.' }),
	fat: z.coerce.number().min(0, { message: 'La grasa no puede ser negativa.' }),
	protein: z.coerce.number().min(0, { message: 'La proteína no puede ser negativa.' }),
	carbs: z.coerce.number().min(0, { message: 'Los carbohidratos no pueden ser negativos.' })
});
// Exportamos también el tipo inferido para usarlo en el frontend o donde se necesite
// la forma de los datos sin importar el validador.
export type Ingredient = z.infer<typeof IngredientSchema>;

// --- Ruta: prisma/migrations/20250731184218_add_normalized_names/migration.sql ---
-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_CustomIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "normalizedName" TEXT NOT NULL DEFAULT '',
    "calories" REAL NOT NULL,
    "fat" REAL NOT NULL,
    "protein" REAL NOT NULL,
    "carbs" REAL NOT NULL
);
INSERT INTO "new_CustomIngredient" ("calories", "carbs", "fat", "id", "name", "protein") SELECT "calories", "carbs", "fat", "id", "name", "protein" FROM "CustomIngredient";
DROP TABLE "CustomIngredient";
ALTER TABLE "new_CustomIngredient" RENAME TO "CustomIngredient";
CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name");
CREATE TABLE "new_ProductCache" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "productName" TEXT NOT NULL,
    "normalizedProductName" TEXT NOT NULL DEFAULT '',
    "brand" TEXT,
    "imageUrl" TEXT,
    "calories" REAL,
    "fat" REAL,
    "protein" REAL,
    "carbs" REAL,
    "fullPayload" JSONB,
    "updatedAt" DATETIME NOT NULL
);
INSERT INTO "new_ProductCache" ("brand", "calories", "carbs", "fat", "fullPayload", "id", "imageUrl", "productName", "protein", "updatedAt") SELECT "brand", "calories", "carbs", "fat", "fullPayload", "id", "imageUrl", "productName", "protein", "updatedAt" FROM "ProductCache";
DROP TABLE "ProductCache";
ALTER TABLE "new_ProductCache" RENAME TO "ProductCache";
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250730185406_init/migration.sql ---
-- CreateTable
CREATE TABLE "ProductCache" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "productName" TEXT NOT NULL,
    "brand" TEXT,
    "imageUrl" TEXT,
    "calories" REAL,
    "fat" REAL,
    "protein" REAL,
    "carbs" REAL,
    "fullPayload" JSONB,
    "updatedAt" DATETIME NOT NULL
);
-- CreateTable
CREATE TABLE "CustomIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "calories" REAL NOT NULL,
    "fat" REAL NOT NULL,
    "protein" REAL NOT NULL,
    "carbs" REAL NOT NULL
);
-- CreateTable
CREATE TABLE "Recipe" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "steps" TEXT NOT NULL
);
-- CreateTable
CREATE TABLE "RecipeIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "recipeId" TEXT NOT NULL,
    "productCacheId" TEXT,
    "customIngredientId" TEXT,
    "quantity" REAL NOT NULL,
    CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_productCacheId_fkey" FOREIGN KEY ("productCacheId") REFERENCES "ProductCache" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_customIngredientId_fkey" FOREIGN KEY ("customIngredientId") REFERENCES "CustomIngredient" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);
-- CreateIndex
CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name");

// --- Ruta: src/routes/recetas/nueva/+page.svelte ---
<!-- Ruta: src/routes/recetas/nueva/+page.svelte -->
<script lang="ts">
	import { goto } from '$app/navigation';
	import { Button } from '$lib/components/ui/button';
	import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card';
	import { Input } from '$lib/components/ui/input';
	import { Label } from '$lib/components/ui/label';
	import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table';
	import { Textarea } from '$lib/components/ui/textarea';
	import { calculateNutritionalInfo, type CalculableIngredient } from '$lib/recipeCalculator';
	import type { RecipeIngredient } from '$lib/schemas/recipeSchema';
	import * as Popover from '$lib/components/ui/popover';
	import * as Command from '$lib/components/ui/command';
	import { ChevronsUpDown } from 'lucide-svelte';
	type IngredientWithDetails = RecipeIngredient & CalculableIngredient & { name: string };
	type SearchResult = {
		id: string;
		name: string;
		source: 'local' | 'off';
		type: 'custom' | 'product';
		imageUrl: string | null;
	};
	let title = $state('');
	let description = $state('');
	let steps = $state('');
	let ingredients = $state<IngredientWithDetails[]>([]);
	let searchResults = $state<SearchResult[]>([]);
	let isSearching = $state(false);
	let open = $state(false);
	let inputValue = $state('');
	let searchTerm = $state('');
	$effect(() => {
		let eventSource: EventSource | null = null;
		if (searchTerm.length < 3) {
			searchResults = [];
			isSearching = false;
		} else {
			isSearching = true;
			searchResults = [];
			eventSource = new EventSource(`/api/ingredients/search?q=${encodeURIComponent(searchTerm)}`);
			eventSource.addEventListener('message', (e) => {
				const newResults = JSON.parse(e.data);
				searchResults = [...searchResults, ...newResults];
			});
			eventSource.addEventListener('stream_error', (e) => {
				const errorData = JSON.parse((e as MessageEvent).data);
				console.error('Error de stream recibido:', errorData);
			});
			eventSource.onerror = (err) => {
				console.error('Error en la conexión de EventSource:', err);
				isSearching = false;
				eventSource?.close();
			};
			eventSource.addEventListener('close', () => {
				isSearching = false;
				eventSource?.close();
			});
		}
		// Función de limpieza de $effect: se ejecuta cuando searchTerm cambia
		return () => {
			eventSource?.close();
		};
	});
	async function addIngredient(result: SearchResult) {
		if (ingredients.some((ing) => ing.id === result.id && ing.type === result.type)) return;
		try {
			const response = await fetch(`/api/ingredients/details/${result.id}?type=${result.type}`);
			if (!response.ok) throw new Error('Failed to fetch ingredient details');
			const details: CalculableIngredient = await response.json();
			ingredients.push({
				...result,
				quantity: 100,
				calories: details.calories,
				protein: details.protein,
				fat: details.fat,
				carbs: details.carbs
			});
		} catch (error) {
			console.error('Error adding ingredient:', error);
		} finally {
			open = false;
			searchResults = [];
			searchTerm = ''; // Limpiar el término de búsqueda
			inputValue = ''; // Limpiar el texto visible en el botón
		}
	}
	function removeIngredient(index: number) {
		ingredients.splice(index, 1);
	}
	let nutritionalInfo = $derived(calculateNutritionalInfo(ingredients));
	let isSubmitting = $state(false);
	let errors = $state<Record<string, any>>({});
	async function handleSubmit(event: SubmitEvent) {
		event.preventDefault();
		isSubmitting = true;
		errors = {};
		const payload = {
			title,
			description,
			steps,
			ingredients: ingredients.map(({ id, quantity, type }) => ({ id, quantity, type }))
		};
		try {
			const response = await fetch('/api/recipes', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload)
			});
			if (response.ok) {
				const newRecipe = await response.json();
				await goto(`/recetas/${newRecipe.id}`);
			} else {
				const errorData = await response.json();
				if (response.status === 400) {
					errors = errorData.errors;
				} else {
					errors.general = errorData.message || 'Ocurrió un error en el servidor.';
				}
			}
		} catch (err) {
			errors.general = 'No se pudo conectar con el servidor.';
		} finally {
			isSubmitting = false;
		}
	}
</script>
<Card class="max-w-4xl mx-auto my-8">
	<CardHeader>
		<CardTitle>Crear Nueva Receta</CardTitle>
	</CardHeader>
	<CardContent>
		<form onsubmit={handleSubmit} class="space-y-6">
			<div class="space-y-2">
				<Label for="title">Título</Label>
				<Input id="title" bind:value={title} required />
				{#if errors.title}
				<p class="text-sm text-red-500">{errors.title._errors[0]}</p>
				{/if}
			</div>
			<div class="space-y-2">
				<Label for="description">Descripción (Opcional)</Label>
				<Textarea id="description" bind:value={description} />
			</div>
			<div class="space-y-2">
				<Label for="steps">Pasos</Label>
				<Textarea id="steps" bind:value={steps} rows={8} required />
				{#if errors.steps}
				<p class="text-sm text-red-500">{errors.steps._errors[0]}</p>
				{/if}
			</div>
			<div class="space-y-2">
				<Label>Añadir Ingrediente</Label>
				<Popover.Root bind:open>
					<Popover.Trigger
						class="inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border w-full justify-between h-9 px-4 py-2"
						role="combobox"
						aria-expanded={open}
					>
						<div class="flex items-center justify-between w-full">
							{inputValue || 'Seleccionar ingrediente...'}
							<ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" />
						</div>
					</Popover.Trigger>
					<Popover.Content class="w-[--trigger-width] p-0">
						<Command.Root filter={() => 1}>
							<Command.Input bind:value={searchTerm} placeholder="Buscar ingrediente..." />
							<Command.List>
								{#if searchResults.length > 0}
									{#each searchResults as result (result.id + result.type)}
										<Command.Item
											value={result.name}
											onSelect={() => {
												inputValue = result.name;
												addIngredient(result);
											}}
											class={`flex items-center gap-2 ${result.source === 'local' ? 'ring-1 ring-green-500 rounded-sm' : ''}`}
										>
											<img
												src={result.imageUrl || 'https://placehold.co/40x40?text=N/A'}
												alt={result.name}
												class="h-8 w-8 rounded-sm object-cover"
											/>
											<span>{result.name}</span>
										</Command.Item>
									{/each}
								{:else}
									<div class="p-4 text-sm text-center text-gray-500">
										{#if isSearching}
											Buscando...
										{:else if searchTerm.length < 3}
											Escribe al menos 3 caracteres para buscar...
										{:else}
											No se encontraron resultados.
										{/if}
									</div>
								{/if}
							</Command.List>
						</Command.Root>
				</Popover.Content>
			</Popover.Root>
		</div>
		<div class="space-y-2">
			<h3 class="text-lg font-medium">Ingredientes de la Receta</h3>
			<Table>
				<TableHeader>
					<TableRow>
						<TableHead>Nombre</TableHead>
						<TableHead class="w-[150px]">Cantidad (g)</TableHead>
						<TableHead class="w-[100px] text-right">Acciones</TableHead>
					</TableRow>
				</TableHeader>
				<TableBody>
					{#each ingredients as ingredient, i}
					<TableRow>
						<TableCell>{ingredient.name}</TableCell>
						<TableCell>
							<Input
							type="number"
							bind:value={ingredient.quantity}
							min="1"
							class="w-full"
							/>
						</TableCell>
						<TableCell class="text-right">
							<Button
							type="button"
							variant="destructive"
							size="sm"
							onclick={() => removeIngredient(i)}
							>
							Quitar
						</Button>
					</TableCell>
				</TableRow>
				{/each}
				{#if ingredients.length === 0}
				<TableRow>
					<TableCell colspan={3} class="text-center text-gray-500">
						Añade ingredientes usando el buscador.
					</TableCell>
				</TableRow>
				{/if}
			</TableBody>
		</Table>
	</div>
	<div class="space-y-2 p-4 border rounded-lg bg-gray-50">
		<h3 class="text-lg font-medium">Información Nutricional (Total)</h3>
		<div class="grid grid-cols-2 md:grid-cols-4 gap-4">
			<div>
				<p class="font-bold text-xl">{nutritionalInfo.totalCalories.toFixed(2)}</p>
				<p class="text-sm text-gray-600">Calorías (kcal)</p>
			</div>
			<div>
				<p class="font-bold text-xl">{nutritionalInfo.totalProtein.toFixed(2)} g</p>
				<p class="text-sm text-gray-600">Proteínas</p>
			</div>
			<div>
				<p class="font-bold text-xl">{nutritionalInfo.totalFat.toFixed(2)} g</p>
				<p class="text-sm text-gray-600">Grasas</p>
			</div>
			<div>
				<p class="font-bold text-xl">{nutritionalInfo.totalCarbs.toFixed(2)} g</p>
				<p class="text-sm text-gray-600">Carbohidratos</p>
			</div>
		</div>
	</div>
	<div class="flex justify-end">
		<Button type="submit" disabled={isSubmitting}>
			{isSubmitting ? 'Guardando...' : 'Guardar Receta'}
		</Button>
	</div>
	{#if errors.general}
	<p class="text-sm text-red-500 text-right">{errors.general}</p>
	{/if}
</form>
</CardContent>
</Card>

// --- Ruta: src/routes/api/recipes/+server.ts ---
// Ruta: src/routes/api/recipes/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { recipeService } from '$lib/server/services/recipeService';
import { RecipeSchema } from '$lib/schemas/recipeSchema';
import { ZodError } from 'zod';
import { formatZodError } from '$lib/server/zodErrors';
/**
 * Maneja las peticiones GET para obtener todas las recetas.
 */
export const GET: RequestHandler = async () => {
	try {
		const recipes = await recipeService.getAll();
		return json(recipes);
	} catch (error) {
		console.error('Error fetching recipes:', error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};
/**
 * Maneja las peticiones POST para crear una nueva receta.
 */
export const POST: RequestHandler = async ({ request }) => {
	try {
		const body = await request.json();
		// Validamos el cuerpo de la petición con nuestro esquema Zod.
		const validatedData = RecipeSchema.parse(body);
		const newRecipe = await recipeService.create(validatedData);
		return json(newRecipe, { status: 201 }); // 201 Created
	} catch (error) {
		if (error instanceof ZodError) {
			// Si la validación falla, devolvemos un error 400 claro y formateado.
			return json(formatZodError(error), { status: 400 });
		}
		console.error('Error creating recipe:', error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/recetas/[id]/+page.svelte ---
<!-- Ruta: src/routes/recetas/[id]/+page.svelte -->
<script lang="ts">
	import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '$lib/components/ui/card';
	import {
		Table,
		TableBody,
		TableCell,
		TableHead,
		TableHeader,
		TableRow
	} from '$lib/components/ui/table';
	import { calculateNutritionalInfo } from '$lib/recipeCalculator';
	import type { PageData } from './$types';
	const { data } = $props<PageData>();
	const { recipe } = data;
	// Justificación: Creamos una lista de ingredientes plana y consistente a partir
	// de los datos anidados del loader. Esto simplifica el resto del componente.
	const ingredientsList = $derived(
		recipe.ingredients
			.map((ing) => {
				const details = ing.product ?? ing.customIngredient;
				if (!details) return null;
				return {
					name: details.name,
					quantity: ing.quantity,
					calories: details.calories ?? 0,
					protein: details.protein ?? 0,
					fat: details.fat ?? 0,
					carbs: details.carbs ?? 0
				};
			})
			.filter((i): i is NonNullable<typeof i> => i !== null)
	);
	// La lógica de cálculo ahora recibe la lista limpia.
	const nutritionalInfo = $derived(calculateNutritionalInfo(ingredientsList));
</script>
<div class="max-w-4xl mx-auto my-8 space-y-8">
	<!-- Encabezado de la Receta -->
	<header class="space-y-2">
		<h1 class="text-4xl font-bold tracking-tight">{recipe.title}</h1>
		{#if recipe.description}
			<p class="text-lg text-gray-600">{recipe.description}</p>
		{/if}
	</header>
	<!-- Información Nutricional -->
	<Card>
		<CardHeader>
			<CardTitle>Información Nutricional</CardTitle>
			<CardDescription>Valores totales para la receta completa.</CardDescription>
		</CardHeader>
		<CardContent>
			<div class="grid grid-cols-2 md:grid-cols-4 gap-6 text-center">
				<div>
					<p class="font-bold text-2xl">{nutritionalInfo.totalCalories.toFixed(2)}</p>
					<p class="text-sm text-gray-600">Calorías (kcal)</p>
				</div>
				<div>
					<p class="font-bold text-2xl">{nutritionalInfo.totalProtein.toFixed(2)} g</p>
					<p class="text-sm text-gray-600">Proteínas</p>
				</div>
				<div>
					<p class="font-bold text-2xl">{nutritionalInfo.totalFat.toFixed(2)} g</p>
					<p class="text-sm text-gray-600">Grasas</p>
				</div>
				<div>
					<p class="font-bold text-2xl">{nutritionalInfo.totalCarbs.toFixed(2)} g</p>
					<p class="text-sm text-gray-600">Carbohidratos</p>
				</div>
			</div>
		</CardContent>
	</Card>
	<!-- Ingredientes -->
	<Card>
		<CardHeader>
			<CardTitle>Ingredientes</CardTitle>
		</CardHeader>
		<CardContent>
			<Table>
				<TableHeader>
					<TableRow>
						<TableHead>Nombre</TableHead>
						<TableHead class="w-[150px] text-right">Cantidad</TableHead>
					</TableRow>
				</TableHeader>
				<TableBody>
					{#each ingredientsList as ingredient}
						<TableRow>
							<TableCell>{ingredient.name}</TableCell>
							<TableCell class="text-right">{ingredient.quantity} g</TableCell>
						</TableRow>
					{/each}
				</TableBody>
			</Table>
		</CardContent>
	</Card>
	<!-- Pasos -->
	<Card>
		<CardHeader>
			<CardTitle>Preparación</CardTitle>
		</CardHeader>
		<CardContent>
			<div class="prose max-w-none whitespace-pre-wrap">
				{recipe.steps}
			</div>
		</CardContent>
	</Card>
</div>

// --- Ruta: src/routes/recetas/[id]/+page.server.ts ---
// Ruta: src/routes/recetas/[id]/+page.server.ts
import { error } from '@sveltejs/kit';
import { recipeService } from '$lib/server/services/recipeService';
import type { PageServerLoad } from './$types';
// Justificación: La función `load` del servidor es ideal para cargar los datos
// de una receta específica antes de que la página se renderice.
// Esto asegura que los datos estén disponibles inmediatamente y mejora el SEO.
export const load: PageServerLoad = async ({ params }) => {
	const recipe = await recipeService.getById(params.id);
	if (!recipe) {
		throw error(404, 'Receta no encontrada');
	}
	return {
		recipe
	};
};

// --- Ruta: src/routes/api/ingredients/+server.ts ---
// Ruta: src/routes/api/ingredients/+server.ts
import { json, type RequestHandler } from '@sveltejs/kit';
import { ingredientService } from '$lib/server/services/ingredientService';
import { IngredientSchema } from '$lib/schemas/ingredientSchema';
import { ZodError } from 'zod';
import { formatZodError } from '$lib/server/zodErrors';
export const GET: RequestHandler = async () => {
	try {
		const ingredients = await ingredientService.getAllUnified();
		return json(ingredients);
	} catch (error) {
		console.error('Error fetching ingredients:', error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};
export const POST: RequestHandler = async ({ request }) => {
	try {
		const body = await request.json();
		const validatedData = IngredientSchema.parse(body);
		const newIngredient = await ingredientService.create(validatedData);
		return json(newIngredient, { status: 201 });
	} catch (error) {
		if (error instanceof ZodError) {
			return json(formatZodError(error), { status: 400 });
		}
		console.error('Error creating ingredient:', error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/admin/ingredientes/+page.svelte ---
<!-- Ruta: src/routes/admin/ingredientes/+page.svelte -->
<script lang="ts">
	import { enhance } from '$app/forms';
	import { Button, buttonVariants } from '$lib/components/ui/button';
	import * as Dialog from '$lib/components/ui/dialog';
	import { Input } from '$lib/components/ui/input';
	import { Label } from '$lib/components/ui/label';
	import * as Table from '$lib/components/ui/table';
	import type { ActionData, PageData } from './$types';
	import SyncDialog from '$lib/components/admin/SyncDialog.svelte';
	import { invalidateAll } from '$app/navigation';
	let { data, form } = $props<{ data: PageData; form: ActionData }>();
	// --- Lógica para el diálogo de sincronización ---
	let isSyncDialogOpen = $state(false);
	let syncState = $state<'idle' | 'loading' | 'success' | 'error'>('idle');
	let syncResult = $state<any>(null);
	// Justificación: Esta función maneja el flujo de la sincronización en el cliente.
	// Llama al endpoint del backend, gestiona los estados de carga/éxito/error
	// y actualiza los datos de la página al finalizar para reflejar los cambios.
	async function handleSync() {
		syncState = 'loading';
		// isSyncDialogOpen se controla automáticamente por el Dialog.Trigger
		try {
			const response = await fetch('/api/ingredients/sync', {
				method: 'POST',
				credentials: 'include' // Justificación: Se incluye para enviar la cookie de sesión.
			});
			if (!response.ok) {
				throw new Error('Falló la petición de sincronización');
			}
			syncResult = await response.json();
			syncState = 'success';
			// Justificación: invalidamos los datos de la página actual para que SvelteKit
			// los vuelva a cargar del servidor, mostrando así los ingredientes actualizados.
			await invalidateAll();
		} catch (error) {
			console.error('Error durante la sincronización:', error);
			syncState = 'error';
		}
	}
</script>
<div class="container mx-auto py-10">
	<div class="flex justify-between items-center mb-6">
		<h1 class="text-2xl font-bold">Gestión de Ingredientes</h1>
		<div class="flex gap-2">
			<!-- Botón de Sincronización -->
			<Dialog.Root bind:open={isSyncDialogOpen}>
				<Dialog.Trigger class={buttonVariants({ variant: 'outline' })} onclick={handleSync}>
					Sincronizar con OFF
				</Dialog.Trigger>
				{#if isSyncDialogOpen}
					<SyncDialog state={syncState} result={syncResult} />
				{/if}
			</Dialog.Root>
			<a href="/admin/ingredientes/off" class={buttonVariants({ variant: 'outline' })}>
				Añadir desde Open Food Facts
			</a>
			<Dialog.Root>
				<Dialog.Trigger class={buttonVariants()}>Añadir Ingrediente Personalizado</Dialog.Trigger>
				<Dialog.Content class="sm:max-w-[425px]">
					<Dialog.Header>
						<Dialog.Title>Añadir Nuevo Ingrediente</Dialog.Title>
						<Dialog.Description>
							Completa los detalles del ingrediente personalizado. Todos los valores son por 100g.
						</Dialog.Description>
					</Dialog.Header>
					<form method="POST" action="?/create" use:enhance>
						<div class="grid gap-4 py-4">
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="name" class="text-right">Nombre</Label>
								<Input id="name" name="name" class="col-span-3" />
							</div>
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="calories" class="text-right">Calorías</Label>
								<Input id="calories" name="calories" type="number" step="0.1" class="col-span-3" />
							</div>
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="protein" class="text-right">Proteínas</Label>
								<Input id="protein" name="protein" type="number" step="0.1" class="col-span-3" />
							</div>
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="fat" class="text-right">Grasas</Label>
								<Input id="fat" name="fat" type="number" step="0.1" class="col-span-3" />
							</div>
							<div class="grid grid-cols-4 items-center gap-4">
								<Label for="carbs" class="text-right">Carbohidratos</Label>
								<Input id="carbs" name="carbs" type="number" step="0.1" class="col-span-3" />
							</div>
						</div>
						<Dialog.Footer>
							<Dialog.Close class={buttonVariants()} type="submit">Guardar Ingrediente</Dialog.Close>
						</Dialog.Footer>
					</form>
				</Dialog.Content>
			</Dialog.Root>
		</div>
	</div>
	<div class="rounded-md border">
		<Table.Root>
			<Table.Header>
				<Table.Row>
					<Table.Head>Nombre</Table.Head>
					<Table.Head>Origen</Table.Head>
					<Table.Head class="text-right">Calorías (por 100g)</Table.Head>
					<Table.Head class="text-right">Proteínas (g)</Table.Head>
					<Table.Head class="text-right">Grasas (g)</Table.Head>
					<Table.Head class="text-right">Carbs (g)</Table.Head>
					<Table.Head class="text-right">Acciones</Table.Head>
				</Table.Row>
			</Table.Header>
			<Table.Body>
				{#each data.ingredients as ingredient (ingredient.id)}
					<Table.Row>
						<Table.Cell class="font-medium">{ingredient.name}</Table.Cell>
						<Table.Cell>
							{#if ingredient.source === 'custom'}
								<span
									class="bg-blue-100 text-blue-800 text-xs font-medium me-2 px-2.5 py-0.5 rounded dark:bg-blue-900 dark:text-blue-300"
								>
									Personalizado
								</span>
							{:else}
								<span
									class="bg-green-100 text-green-800 text-xs font-medium me-2 px-2.5 py-0.5 rounded dark:bg-green-900 dark:text-green-300"
								>
									Caché de OFF
								</span>
							{/if}
						</Table.Cell>
						<Table.Cell class="text-right">{ingredient.calories?.toFixed(2) ?? 'N/A'}</Table.Cell>
						<Table.Cell class="text-right">{ingredient.protein?.toFixed(2) ?? 'N/A'}</Table.Cell>
						<Table.Cell class="text-right">{ingredient.fat?.toFixed(2) ?? 'N/A'}</Table.Cell>
						<Table.Cell class="text-right">{ingredient.carbs?.toFixed(2) ?? 'N/A'}</Table.Cell>
						<Table.Cell class="text-right">
							<Dialog.Root>
								<Button
									variant="outline"
									size="sm"
									disabled={ingredient.source !== 'custom'}
									onclick={(e) => {
										if (ingredient.source !== 'custom') e.preventDefault();
										// Lógica para abrir el diálogo si es necesario
									}}
								>
									Editar
								</Button>
								<Dialog.Content class="sm:max-w-[425px]">
									<Dialog.Header>
										<Dialog.Title>Editar Ingrediente</Dialog.Title>
									</Dialog.Header>
									<form method="POST" action="?/update" use:enhance>
										<input type="hidden" name="id" value={ingredient.id} />
										<div class="grid gap-4 py-4">
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="name-edit" class="text-right">Nombre</Label>
												<Input
													id="name-edit"
													name="name"
													value={ingredient.name}
													class="col-span-3"
												/>
											</div>
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="calories-edit" class="text-right">Calorías</Label>
												<Input
													id="calories-edit"
													name="calories"
													type="number"
													step="0.1"
													value={ingredient.calories}
													class="col-span-3"
												/>
											</div>
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="protein-edit" class="text-right">Proteínas</Label>
												<Input
													id="protein-edit"
													name="protein"
													type="number"
													step="0.1"
													value={ingredient.protein}
													class="col-span-3"
												/>
											</div>
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="fat-edit" class="text-right">Grasas</Label>
												<Input
													id="fat-edit"
													name="fat"
													type="number"
													step="0.1"
													value={ingredient.fat}
													class="col-span-3"
												/>
											</div>
											<div class="grid grid-cols-4 items-center gap-4">
												<Label for="carbs-edit" class="text-right">Carbohidratos</Label>
												<Input
													id="carbs-edit"
													name="carbs"
													type="number"
													step="0.1"
													value={ingredient.carbs}
													class="col-span-3"
												/>
											</div>
										</div>
										<Dialog.Footer>
											<Dialog.Close class={buttonVariants()} type="submit">Guardar Cambios</Dialog.Close>
										</Dialog.Footer>
									</form>
								</Dialog.Content>
							</Dialog.Root>
							<Dialog.Root>
								<Dialog.Trigger
									class={buttonVariants({ variant: 'destructive', size: 'sm' }) + ' ml-2'}
								>
									Eliminar
								</Dialog.Trigger>
								<Dialog.Content class="sm:max-w-[425px]">
									<Dialog.Header>
										<Dialog.Title>Confirmar Eliminación</Dialog.Title>
										<Dialog.Description>
											¿Estás seguro de que quieres eliminar el ingrediente "{ingredient.name}"? Esta
											acción no se puede deshacer.
										</Dialog.Description>
									</Dialog.Header>
									<form method="POST" action="?/delete" use:enhance>
										<input type="hidden" name="id" value={ingredient.id} />
										<input type="hidden" name="source" value={ingredient.source} />
										<Dialog.Footer>
											<Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cancelar</Dialog.Close>
											<Button variant="destructive" type="submit">Eliminar</Button>
										</Dialog.Footer>
									</form>
								</Dialog.Content>
							</Dialog.Root>
						</Table.Cell>
					</Table.Row>
				{:else}
					<Table.Row>
						<Table.Cell colspan={7} class="text-center">No hay ingredientes.</Table.Cell>
					</Table.Row>
				{/each}
			</Table.Body>
		</Table.Root>
	</div>
</div>

// --- Ruta: src/routes/admin/ingredientes/+page.server.ts ---
// Ruta: src/routes/admin/ingredientes/+page.server.ts
import { fail } from '@sveltejs/kit';
import type { PageServerLoad, Actions } from './$types';
// Justificación (load): La función `load` ahora llama al endpoint GET de la API usando `fetch`.
// Esto asegura que la página y la API están desacopladas. La página consume su propia API,
// una práctica conocida como "dogfooding", que garantiza que la API es robusta.
export const load: PageServerLoad = async ({ fetch }) => {
	const response = await fetch('/api/ingredients');
	if (!response.ok) {
		// En un caso real, podrías manejar el error de forma más elegante.
		return { ingredients: [] };
	}
	const ingredients = await response.json();
	return {
		ingredients
	};
};
// Justificación (actions): Las acciones ahora empaquetan los datos del formulario y los envían
// al endpoint de la API correspondiente usando `fetch`. La lógica de negocio y la validación
// residen únicamente en la API, y esta acción solo se encarga de la comunicación.
export const actions: Actions = {
	create: async ({ request, fetch }) => {
		const formData = await request.formData();
		const response = await fetch('/api/ingredients', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(Object.fromEntries(formData))
		});
		if (!response.ok) {
			const result = await response.json();
			return fail(response.status, {
				data: Object.fromEntries(formData),
				errors: result.errors
			});
		}
		return { success: true, message: 'Ingrediente creado con éxito' };
	},
	update: async ({ request, fetch }) => {
		const formData = await request.formData();
		const id = formData.get('id') as string;
		const response = await fetch(`/api/ingredients/${id}`,
		{
			method: 'PUT',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(Object.fromEntries(formData))
		});
		if (!response.ok) {
			const result = await response.json();
			return fail(response.status, {
				data: Object.fromEntries(formData),
				errors: result.errors,
				id
			});
		}
		return { success: true, message: 'Ingrediente actualizado con éxito' };
	},
	delete: async ({ request, fetch }) => {
		const formData = await request.formData();
		const id = formData.get('id') as string;
		const source = formData.get('source') as string;
		// Justificación: La lógica para determinar qué endpoint llamar ahora reside aquí,
		// basándose en el 'source' del ingrediente.
		const apiPath = source === 'custom' ? `/api/ingredients/${id}` : `/api/products/${id}`;
		const response = await fetch(apiPath, {
			method: 'DELETE'
		});
		if (!response.ok) {
			return fail(response.status, { message: 'Error al eliminar el ingrediente' });
		}
		return { success: true, message: 'Ingrediente eliminado con éxito' };
	}
};

// --- Ruta: src/lib/server/services/recipeService.ts ---
// Ruta: src/lib/server/services/recipeService.ts
import prisma from '$lib/server/prisma';
import type { RecipeData } from '$lib/schemas/recipeSchema';
import { productService } from './productService';
// Justificación: La capa de servicio para recetas abstrae toda la lógica de negocio
// y el acceso a la base de datos (Prisma) para las operaciones CRUD.
// Esto mantiene los endpoints de la API limpios y centrados en su rol de controlador.
const recipeInclude = {
	ingredients: {
		include: {
			product: true,
			customIngredient: true
		}
	}
};
/**
 * Función auxiliar para asegurar que todos los productos de una receta
 * están cacheados en nuestra base de datos antes de la operación principal.
 * @param ingredients - La lista de ingredientes de la receta.
 */
async function ensureProductsAreCached(ingredients: RecipeData['ingredients']) {
	const productCachePromises = ingredients
		.filter((ing) => ing.type === 'product')
		.map((ing) => productService.findByBarcode(ing.id));
	// Justificación (Promise.all): Se ejecutan todas las verificaciones de caché
	// en paralelo para mejorar el rendimiento, en lugar de una por una en secuencia.
	await Promise.all(productCachePromises);
}
export const recipeService = {
	/**
	 * Obtiene todas las recetas con sus ingredientes.
	 */
	async getAll() {
		return await prisma.recipe.findMany({
			include: recipeInclude,
			orderBy: { title: 'asc' }
		});
	},
	/**
	 * Obtiene una receta por su ID, incluyendo todos sus ingredientes.
	 * @param id - El ID de la receta.
	 */
	async getById(id: string) {
		return await prisma.recipe.findUnique({
			where: { id },
			include: recipeInclude
		});
	},
	/**
	 * Crea una nueva receta y sus ingredientes asociados en una transacción.
	 * @param data - Datos de la receta validados por Zod.
	 */
	async create(data: RecipeData) {
		const { title, description, steps, ingredients } = data;
		// Paso 1: Asegurar que todos los productos de OFF están en nuestra caché.
		await ensureProductsAreCached(ingredients);
		// Paso 2: Proceder con la creación de la receta en una transacción.
		// Justificación (transacción): Se usa $transaction para asegurar la atomicidad.
		// O se crea la receta Y todos sus ingredientes, o no se crea nada.
		// Esto previene que queden datos huérfanos si una de las operaciones falla.
		return await prisma.$transaction(async (tx) => {
			const newRecipe = await tx.recipe.create({
				data: { title, description, steps }
			});
			for (const ingredient of ingredients) {
				await tx.recipeIngredient.create({
					data: {
						recipeId: newRecipe.id,
						quantity: ingredient.quantity,
						productId: ingredient.type === 'product' ? ingredient.id : null,
						customIngredientId: ingredient.type === 'custom' ? ingredient.id : null
					}
				});
			}
			// Devolvemos la receta completa con sus ingredientes recién creados.
			return await tx.recipe.findUnique({
				where: { id: newRecipe.id },
				include: recipeInclude
			});
		});
	},
	/**
	 * Actualiza una receta existente y sus ingredientes en una transacción.
	 * @param id - El ID de la receta a actualizar.
	 * @param data - Datos de la receta validados por Zod.
	 */
	async update(id: string, data: RecipeData) {
		const { title, description, steps, ingredients } = data;
		// Paso 1: Asegurar que todos los productos de OFF están en nuestra caché.
		await ensureProductsAreCached(ingredients);
		// Paso 2: Proceder con la actualización de la receta en una transacción.
		return await prisma.$transaction(async (tx) => {
			// 1. Actualizar los datos básicos de la receta.
			await tx.recipe.update({
				where: { id },
				data: { title, description, steps }
			});
			// 2. Eliminar todos los ingredientes antiguos. Es la forma más simple y robusta
			// de manejar actualizaciones, eliminaciones y adiciones de ingredientes.
			await tx.recipeIngredient.deleteMany({
				where: { recipeId: id }
			});
			// 3. Crear los nuevos ingredientes asociados a la receta.
			for (const ingredient of ingredients) {
				await tx.recipeIngredient.create({
					data: {
						recipeId: id,
						quantity: ingredient.quantity,
						productId: ingredient.type === 'product' ? ingredient.id : null,
						customIngredientId: ingredient.type === 'custom' ? ingredient.id : null
					}
				});
			}
			// Devolvemos la receta actualizada completa.
			return await tx.recipe.findUnique({
				where: { id },
				include: recipeInclude
			});
		});
	},
	/**
	 * Elimina una receta. La cascada se encarga de los ingredientes.
	 * @param id - El ID de la receta a eliminar.
	 */
	async deleteById(id: string) {
		return await prisma.recipe.delete({
			where: { id }
		});
	}
};

// --- Ruta: src/lib/server/services/productService.ts ---
// Ruta: src/lib/server/services/productService.ts
import prisma from '$lib/server/prisma';
import type { Prisma } from '@prisma/client';
import ky from 'ky';
import { normalizeText } from '$lib/utils';
// Definición de tipos para la respuesta de la API de Open Food Facts
type OpenFoodFactsProduct = {
	code: string;
	product_name: string;
	brands?: string;
	image_url?: string;
	nutriments: {
		'energy-kcal_100g'?: number; // Variante con guion
		energy_kcal_100g?: number; // Variante con guion bajo
		fat_100g?: number;
		proteins_100g?: number;
		carbohydrates_100g?: number;
	};
};
type OpenFoodFactsResponse = {
	status: number;
	product?: OpenFoodFactsProduct;
};
// Justificación: La capa de servicio abstrae la lógica de negocio y el acceso a datos.
// Para este servicio, se coordinará la consulta a la caché local (Prisma) y
// la llamada a la API externa (Open Food Facts) si es necesario.
export const productService = {
	/**
	 * Busca un producto por su código de barras.
	 * Primero intenta encontrarlo en la caché local (tabla Product).
	 * Si no lo encuentra, lo busca en la API de Open Food Facts,
	 * lo guarda en la caché y luego lo devuelve.
	 * @param barcode - El código de barras del producto a buscar.
	 */
	async findByBarcode(barcode: string) {
		const cachedProduct = await prisma.product.findUnique({
			where: { id: barcode }
		});
		if (cachedProduct) {
			console.log(`[Cache] HIT for barcode: ${barcode}`);
			return cachedProduct;
		}
		console.log(`[Cache] MISS for barcode: ${barcode}. Fetching from OFF.`);
		const url = `https://world.openfoodfacts.org/api/v2/product/${barcode}.json`;
		try {
			const response = await ky.get(url).json<OpenFoodFactsResponse>();
			if (response.status === 0 || !response.product) {
				return null; // Producto no encontrado en OFF
			}
			const productFromApi = response.product;
			const calories =
				productFromApi.nutriments['energy-kcal_100g'] ??
				productFromApi.nutriments.energy_kcal_100g;
			// 1. Normalizar datos de la API a nuestro esquema
			const normalizedProduct = {
				id: productFromApi.code,
				name: productFromApi.product_name,
				// Justificación: Se genera el nombre normalizado para la búsqueda.
				normalizedName: normalizeText(productFromApi.product_name),
				brand: productFromApi.brands,
				imageUrl: productFromApi.image_url,
				calories: calories,
				fat: productFromApi.nutriments.fat_100g,
				protein: productFromApi.nutriments.proteins_100g,
				carbs: productFromApi.nutriments.carbohydrates_100g,
				// Justificación (Prisma.InputJsonValue): Hacemos un type casting a `InputJsonValue`
				// para asegurar a TypeScript que la estructura del objeto de la API
				// es compatible con el tipo `Json` que Prisma espera.
				fullPayload: productFromApi as Prisma.InputJsonValue
			};
			// 2. Guardar en caché para futuras peticiones
			console.log(`[Cache] WRITING product: ${normalizedProduct.name}`);
			const newCachedProduct = await prisma.product.create({
				data: normalizedProduct
			});
			// 3. Devolver el producto recién cacheado
			return newCachedProduct;
		} catch (error) {
			console.error(`[OFF] Error fetching product ${barcode}:`, error);
			return null;
		}
	},
	/**
	 * Elimina un producto de la caché por su ID (código de barras).
	 * @param barcode - El ID del producto a eliminar.
	 */
	async deleteById(barcode: string) {
		return await prisma.product.delete({
			where: { id: barcode }
		});
	}
};

// --- Ruta: src/lib/server/services/productService.spec.ts ---
// Ruta: src/lib/server/services/productService.spec.ts
import { describe, it, expect, vi, beforeEach, type Mock } from 'vitest';
import prisma from '$lib/server/prisma';
import ky from 'ky';
import { productService } from './productService';
import type { Prisma, Product } from '@prisma/client';
import { normalizeText } from '$lib/utils';
// Justificación: Mockeamos los módulos externos para aislar nuestro servicio.
vi.mock('$lib/server/prisma', () => ({
	default: {
		product: {
			findUnique: vi.fn(),
			create: vi.fn()
		}
	}
}));
vi.mock('ky', () => ({
	default: {
		get: vi.fn()
	}
}));
vi.mock('$lib/utils', () => ({
	normalizeText: vi.fn((text) => text.toLowerCase())
}));
const mockedPrisma = prisma;
const mockedKy = ky;
const mockedNormalizeText = normalizeText as Mock;
// Definimos los tipos aquí para que el test sea autocontenido.
type OpenFoodFactsProduct = {
	code: string;
	product_name: string;
	brands?: string;
	image_url?: string;
	nutriments: {
		energy_kcal_100g?: number;
		fat_100g?: number;
		proteins_100g?: number;
		carbohydrates_100g?: number;
	};
};
type OpenFoodFactsResponse = {
	status: number;
	product?: OpenFoodFactsProduct;
};
describe('productService', () => {
	beforeEach(() => {
		vi.resetAllMocks();
	});
	const barcode = '123456789';
	const cachedProduct: Product = {
		id: barcode,
		name: 'Producto en Caché',
		normalizedName: 'producto en caché',
		brand: 'Marca Caché',
		imageUrl: 'http://cache.com/img.png',
		calories: 100,
		fat: 10,
		protein: 5,
		carbs: 20,
		fullPayload: {} as Prisma.JsonValue,
		createdAt: new Date(),
		updatedAt: new Date()
	};
	const productFromApi: OpenFoodFactsProduct = {
		code: barcode,
		product_name: 'Producto de API',
		brands: 'Marca API',
		image_url: 'http://api.com/img.png',
		nutriments: {
			energy_kcal_100g: 200,
			fat_100g: 20,
			proteins_100g: 10,
			carbohydrates_100g: 40
		}
	};
	const apiProductResponse: OpenFoodFactsResponse = {
		status: 1,
		product: productFromApi
	};
	it('debería devolver un producto de la caché si existe (Cache Hit)', async () => {
		// Arrange
		(mockedPrisma.product.findUnique as Mock).mockResolvedValue(cachedProduct);
		// Act
		const result = await productService.findByBarcode(barcode);
		// Assert
		expect(result).toEqual(cachedProduct);
		expect(mockedPrisma.product.findUnique).toHaveBeenCalledTimes(1);
		expect(mockedKy.get).not.toHaveBeenCalled();
	});
	it('debería obtener el producto de la API y guardarlo en caché si no existe (Cache Miss)', async () => {
		// Arrange
		(mockedPrisma.product.findUnique as Mock).mockResolvedValue(null);
		(mockedKy.get as Mock).mockReturnValue({
			json: vi.fn().mockResolvedValue(apiProductResponse)
		});
		const expectedDataToCreate = {
			id: productFromApi.code,
			name: productFromApi.product_name,
			normalizedName: 'producto de api',
			brand: productFromApi.brands,
			imageUrl: productFromApi.image_url,
			calories: productFromApi.nutriments.energy_kcal_100g,
			fat: productFromApi.nutriments.fat_100g,
			protein: productFromApi.nutriments.proteins_100g,
			carbs: productFromApi.nutriments.carbohydrates_100g,
			fullPayload: productFromApi as unknown as Prisma.JsonValue
		};
		(mockedPrisma.product.create as Mock).mockResolvedValue({
			...expectedDataToCreate,
			createdAt: new Date(),
			updatedAt: new Date()
		});
		mockedNormalizeText.mockReturnValue('producto de api');
		// Act
		await productService.findByBarcode(barcode);
		// Assert
		expect(mockedPrisma.product.findUnique).toHaveBeenCalledTimes(1);
		expect(mockedKy.get).toHaveBeenCalledTimes(1);
		expect(mockedPrisma.product.create).toHaveBeenCalledTimes(1);
		expect(mockedPrisma.product.create).toHaveBeenCalledWith({
			data: expectedDataToCreate
		});
	});
	it('debería devolver null si el producto no se encuentra ni en caché ni en la API', async () => {
		// Arrange
		(mockedPrisma.product.findUnique as Mock).mockResolvedValue(null);
		(mockedKy.get as Mock).mockReturnValue({
			json: vi.fn().mockResolvedValue({ status: 0 }) // Simula producto no encontrado en OFF
		});
		// Act
		const result = await productService.findByBarcode(barcode);
		// Assert
		expect(result).toBeNull();
		expect(mockedPrisma.product.create).not.toHaveBeenCalled();
	});
});

// --- Ruta: src/lib/server/services/ingredientService.ts ---
// Ruta: src/lib/server/services/ingredientService.ts
import type { CustomIngredient, Product } from '@prisma/client';
import prisma from '$lib/server/prisma';
// Justificación: Importamos el 'const' IngredientSchema para la validación en tiempo de ejecución
// y el 'type' Ingredient para las anotaciones de tipo estáticas, cumpliendo con verbatimModuleSyntax.
import { type Ingredient } from '$lib/schemas/ingredientSchema';
import { normalizeText } from '$lib/utils';
// Justificación: La capa de servicio abstrae la lógica de negocio y el acceso a datos.
// Esto mantiene los endpoints de la API (controladores) limpios y centrados en manejar
// la petición y la respuesta, mientras que la lógica real reside aquí.
export const ingredientService = {
	/**
	 * Busca ingredientes por nombre en la base de datos local (custom y cacheados).
	 * @param query - El término de búsqueda.
	 */
	async searchByName(query: string): Promise<{ customIngredients: CustomIngredient[], cachedProducts: Product[] }> {
		const normalizedQuery = normalizeText(query);
		const customIngredients = await prisma.customIngredient.findMany({
			where: {
				normalizedName: {
					contains: normalizedQuery
				}
			}
		});
		const cachedProducts = await prisma.product.findMany({
			where: {
				normalizedName: {
					contains: normalizedQuery
				}
			}
		});
		return {
			customIngredients,
			cachedProducts
		};
	},
	/**
	 * Obtiene todos los ingredientes personalizados.
	 */
	async getAll() {
		return await prisma.customIngredient.findMany({
			orderBy: { name: 'asc' }
		});
	},
	/**
	 * Obtiene todos los ingredientes (personalizados y cacheados) en una lista unificada.
	 */
	async getAllUnified() {
		const customIngredients = await prisma.customIngredient.findMany({
			orderBy: { name: 'asc' }
		});
		const cachedProducts = await prisma.product.findMany({
			orderBy: { name: 'asc' }
		});
		const unifiedList = [
			...customIngredients.map((i) => ({ ...i, source: 'custom' as const })),
			...cachedProducts.map((p) => ({ ...p, source: 'product' as const }))
		];
		return unifiedList.sort((a, b) => a.name.localeCompare(b.name));
	},
	/**
	 * Crea un nuevo ingrediente personalizado.
	 * @param data - Datos validados por Zod.
	 */
	async create(data: Ingredient) {
		// Justificación: Se genera el nombre normalizado antes de la inserción
		// para asegurar que la búsqueda insensible a acentos funcione correctamente.
		const normalizedName = normalizeText(data.name);
		return await prisma.customIngredient.create({
			data: {
				...data,
				normalizedName
			}
		});
	},
	/**
	 * Actualiza un ingrediente personalizado existente.
	 * @param id - El ID del ingrediente a actualizar.
	 * @param data - Datos validados por Zod.
	 */
	async update(id: string, data: Ingredient) {
		// Justificación: Se actualiza el nombre normalizado junto con el nombre
		// para mantener la consistencia de los datos para la búsqueda.
		const normalizedName = normalizeText(data.name);
		return await prisma.customIngredient.update({
			where: { id },
			data: {
				...data,
				normalizedName
			}
		});
	},
	/**
	 * Elimina un ingrediente personalizado.
	 * @param id - El ID del ingrediente a eliminar.
	 */
	async deleteById(id: string) {
		return await prisma.customIngredient.delete({
			where: { id }
		});
	},
	/**
	 * Sincroniza los ingredientes de la base de datos local que provienen de Open Food Facts (OFF).
	 * Compara los datos locales con los de la API de OFF y actualiza si hay diferencias.
	 * Incluye un retardo para no sobrecargar la API y maneja errores por ingrediente.
	 */
	async syncWithOpenFoodFacts(): Promise<{
		updatedIngredients: string[];
		failedIngredients: { id: string; name: string; reason: string }[];
	}> {
		const updatedIngredients: string[] = [];
		const failedIngredients: { id: string; name: string; reason: string }[] = [];
		const API_DELAY_MS = 300; // Justificación: Retardo para ser respetuosos con la API de OFF.
		// Justificación: Obtenemos solo los productos cacheados, que son los que provienen de OFF.
		const productsToSync = await prisma.product.findMany();
		for (const product of productsToSync) {
			try {
				const response = await fetch(`https://world.openfoodfacts.org/api/v2/product/${product.id}.json`);
				// Justificación: Pausa para evitar rate-limiting.
				await new Promise((resolve) => setTimeout(resolve, API_DELAY_MS));
				if (!response.ok) {
					failedIngredients.push({
						id: product.id,
						name: product.name,
						reason: `Error ${response.status}: ${response.statusText}`
					});
					continue; // Salta al siguiente ingrediente
				}
				const offData = await response.json();
				if (offData.status !== 1 || !offData.product) {
					failedIngredients.push({
						id: product.id,
						name: product.name,
						reason: 'Producto no encontrado en Open Food Facts'
					});
					continue;
				}
				const offProduct = offData.product;
				// Justificación: Mapeamos los datos de OFF a nuestra estructura de Product.
				// Usamos el operador de encadenamiento opcional y el de anulación (??)
				// para manejar de forma segura la posible ausencia de datos en la respuesta de la API.
				const newProductData = {
					name: offProduct.product_name || product.name,
					normalizedName: normalizeText(offProduct.product_name || product.name),
					brand: offProduct.brands || product.brand,
					imageUrl: offProduct.image_url || product.imageUrl,
					calories: offProduct.nutriments?.['energy-kcal_100g'] ?? product.calories,
					fat: offProduct.nutriments?.fat_100g ?? product.fat,
					protein: offProduct.nutriments?.proteins_100g ?? product.protein,
					carbs: offProduct.nutriments?.carbohydrates_100g ?? product.carbs,
					fullPayload: offProduct
				};
				// Justificación: Comparamos los campos relevantes para ver si es necesaria una actualización.
				// Se comparan los valores primitivos y el payload JSON completo para detectar cualquier cambio.
				const isDifferent =
					newProductData.name !== product.name ||
					newProductData.brand !== product.brand ||
					newProductData.imageUrl !== product.imageUrl ||
					newProductData.calories !== product.calories ||
					newProductData.fat !== product.fat ||
					newProductData.protein !== product.protein ||
					newProductData.carbs !== product.carbs;
				if (isDifferent) {
					await prisma.product.update({
						where: { id: product.id },
						data: newProductData
					});
					updatedIngredients.push(product.name);
				}
			} catch (error) {
				failedIngredients.push({
					id: product.id,
					name: product.name,
					reason: error instanceof Error ? error.message : 'Error desconocido'
				});
			}
		}
		return { updatedIngredients, failedIngredients };
	}
};

// --- Ruta: src/lib/server/services/ingredientService.spec.ts ---
// Ruta: src/lib/server/services/ingredientService.spec.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import prisma from '$lib/server/prisma';
import { ingredientService } from './ingredientService';
import type { Ingredient } from '$lib/schemas/ingredientSchema';
import { normalizeText } from '$lib/utils';
// Justificación: Mockeamos el módulo de Prisma para aislar el servicio de la base de datos.
// `vi.mock` reemplaza las exportaciones del módulo con mocks, permitiéndonos controlar
// el comportamiento de `prisma.customIngredient.create` y otras funciones de Prisma durante el test.
vi.mock('$lib/server/prisma', () => {
	return {
		default: {
			customIngredient: {
				findMany: vi.fn(),
				create: vi.fn(),
				update: vi.fn(),
				delete: vi.fn()
			},
			product: {
				findMany: vi.fn(),
				update: vi.fn()
			}
		}
	};
});
// Mockeamos fetch globalmente para interceptar las llamadas a la API de OFF
global.fetch = vi.fn();
describe('ingredientService', () => {
	// Limpiamos los mocks antes de cada test para asegurar que no haya interferencias entre pruebas.
	beforeEach(() => {
		vi.clearAllMocks();
	});
	afterEach(() => {
		vi.useRealTimers(); // Restauramos los temporizadores reales después de cada test
	});
	it('debería llamar a prisma.customIngredient.create con los datos correctos', async () => {
		// 1. Arrange (Preparación)
		const newIngredientData: Ingredient = {
			name: 'Harina de Almendras',
			calories: 579,
			protein: 21.1,
			fat: 49.9,
			carbs: 21.6
		};
		const expectedResult = {
			id: 'clxmjm8om0000v9a1b2c3d4e5',
			...newIngredientData
		};
		// Configuramos el mock para que devuelva un valor específico cuando se llame.
		vi.mocked(prisma.customIngredient.create).mockResolvedValue(expectedResult);
		// 2. Act (Actuación)
		const result = await ingredientService.create(newIngredientData);
		// 3. Assert (Verificación)
		// Verificamos que la función 'create' de prisma fue llamada exactamente una vez.
		expect(prisma.customIngredient.create).toHaveBeenCalledTimes(1);
		// Verificamos que la función 'create' de prisma fue llamada con el objeto de datos correcto.
		expect(prisma.customIngredient.create).toHaveBeenCalledWith({
			data: {
				...newIngredientData,
				normalizedName: 'harina de almendras' // Justificación: Añadimos el campo esperado.
			}
		});
		// Verificamos que el resultado de nuestro servicio es el que esperábamos.
		expect(result).toEqual(expectedResult);
	});
	describe('syncWithOpenFoodFacts', () => {
		beforeEach(() => {
			vi.useFakeTimers();
		});
		afterEach(() => {
			vi.useRealTimers();
		});
		it('debería actualizar un producto cuando los datos de OFF son diferentes', async () => {
			// Arrange
			const mockProduct = {
				id: '12345',
				name: 'Old Name',
				brand: 'Old Brand',
				calories: 100,
				fat: 10,
				protein: 10,
				carbs: 10,
				imageUrl: 'old_url',
				normalizedName: 'old name',
				fullPayload: {}
			};
			vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct]);
			const offApiResponse = {
				status: 1,
				product: {
					product_name: 'New Name',
					brands: 'New Brand',
					nutriments: {
						'energy-kcal_100g': 200,
						fat_100g: 20,
						proteins_100g: 20,
						carbohydrates_100g: 20
					},
					image_url: 'new_url'
				}
			};
			vi.mocked(fetch).mockResolvedValue({
				ok: true,
				json: async () => offApiResponse
			} as Response);
			// Act
			const promise = ingredientService.syncWithOpenFoodFacts();
			await vi.runAllTimersAsync();
			const result = await promise;
			// Assert
			expect(prisma.product.update).toHaveBeenCalledTimes(1);
			expect(prisma.product.update).toHaveBeenCalledWith({
				where: { id: '12345' },
				data: {
					name: 'New Name',
					normalizedName: 'new name',
					brand: 'New Brand',
					imageUrl: 'new_url',
					calories: 200,
					fat: 20,
					protein: 20,
					carbs: 20,
					fullPayload: offApiResponse.product
				}
			});
			expect(result.updatedIngredients).toEqual(['Old Name']);
			expect(result.failedIngredients).toEqual([]);
		});
		it('NO debería actualizar un producto si los datos son idénticos', async () => {
			// Arrange
			const mockProduct = {
				id: '12345',
				name: 'Same Name',
				brand: 'Same Brand',
				calories: 100,
				fat: 10,
				protein: 10,
				carbs: 10,
				imageUrl: 'same_url',
				normalizedName: 'same name',
				fullPayload: {}
			};
			vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct]);
			const offApiResponse = {
				status: 1,
				product: {
					product_name: 'Same Name',
					brands: 'Same Brand',
					nutriments: {
						'energy-kcal_100g': 100,
						fat_100g: 10,
						proteins_100g: 10,
						carbohydrates_100g: 10
					},
					image_url: 'same_url'
				}
			};
			vi.mocked(fetch).mockResolvedValue({
				ok: true,
				json: async () => offApiResponse
			} as Response);
			// Act
			const promise = ingredientService.syncWithOpenFoodFacts();
			await vi.runAllTimersAsync();
			const result = await promise;
			// Assert
			expect(prisma.product.update).not.toHaveBeenCalled();
			expect(result.updatedIngredients).toEqual([]);
			expect(result.failedIngredients).toEqual([]);
		});
		it('debería registrar un fallo si la API de OFF devuelve un error', async () => {
			// Arrange
			const mockProduct = { id: '12345', name: 'Failing Product' };
			vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct as any]);
			vi.mocked(fetch).mockResolvedValue({
				ok: false,
				status: 500,
				statusText: 'Internal Server Error'
			} as Response);
			// Act
			const promise = ingredientService.syncWithOpenFoodFacts();
			await vi.runAllTimersAsync();
			const result = await promise;
			// Assert
			expect(prisma.product.update).not.toHaveBeenCalled();
			expect(result.updatedIngredients).toEqual([]);
			expect(result.failedIngredients).toEqual([
				{ id: '12345', name: 'Failing Product', reason: 'Error 500: Internal Server Error' }
			]);
		});
		it('debería registrar un fallo si el producto no se encuentra en OFF', async () => {
			// Arrange
			const mockProduct = { id: '12345', name: 'Not Found Product' };
			vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct as any]);
			vi.mocked(fetch).mockResolvedValue({
				ok: true,
				json: async () => ({ status: 0 }) // status: 0 indica no encontrado
			} as Response);
			// Act
			const promise = ingredientService.syncWithOpenFoodFacts();
			await vi.runAllTimersAsync();
			const result = await promise;
			// Assert
			expect(result.failedIngredients).toEqual([
				{
					id: '12345',
					name: 'Not Found Product',
					reason: 'Producto no encontrado en Open Food Facts'
				}
			]);
		});
	});
});

// --- Ruta: src/lib/components/admin/SyncDialog.svelte ---
<!-- Ruta: src/lib/components/admin/SyncDialog.svelte -->
<script lang="ts">
	import { Button, buttonVariants } from '$lib/components/ui/button';
	import * as Dialog from '$lib/components/ui/dialog';
	import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table';
	import { CircleDashed } from 'lucide-svelte';
	// Justificación: Este componente ahora solo se encarga de mostrar el *contenido* del diálogo.
	// El control de apertura/cierre y el disparador se gestionan en la página padre,
	// siguiendo las convenciones del proyecto y de Svelte 5.
	type $Props = {
		state: 'idle' | 'loading' | 'success' | 'error';
		result: {
			updatedIngredients: string[];
			failedIngredients: { id: string; name: string; reason: string }[];
		} | null;
	};
	let { state, result }: $Props = $props();
</script>
<Dialog.Content class="sm:max-w-[625px]">
	{#if state === 'loading'}
		<div class="flex flex-col items-center justify-center p-8">
			<CircleDashed class="h-12 w-12 animate-spin text-primary" />
			<p class="mt-4 text-lg text-muted-foreground">Sincronizando ingredientes...</p>
			<p class="text-sm text-muted-foreground">
				Este proceso puede tardar varios minutos. Por favor, no cierres esta ventana.
			</p>
		</div>
	{:else if state === 'success' && result}
		<Dialog.Header>
			<Dialog.Title>Sincronización Completada</Dialog.Title>
			<Dialog.Description>
				Se actualizaron <strong>{result.updatedIngredients.length}</strong> ingredientes.
				{#if result.failedIngredients.length > 0}
					Hubo <strong>{result.failedIngredients.length}</strong> errores.
				{/if}
			</Dialog.Description>
		</Dialog.Header>
		<div class="max-h-[400px] overflow-y-auto">
			{#if result.updatedIngredients.length > 0}
				<h3 class="mb-2 font-semibold">Ingredientes Actualizados</h3>
				<Table>
					<TableHeader>
						<TableRow>
							<TableHead>Nombre</TableHead>
						</TableRow>
					</TableHeader>
					<TableBody>
						{#each result.updatedIngredients as name}
							<TableRow>
								<TableCell>{name}</TableCell>
							</TableRow>
						{/each}
					</TableBody>
				</Table>
			{/if}
			{#if result.failedIngredients.length > 0}
				<h3 class="mb-2 mt-4 font-semibold">Ingredientes con Errores</h3>
				<Table>
					<TableHeader>
						<TableRow>
							<TableHead>Nombre</TableHead>
							<TableHead>Motivo del Error</TableHead>
						</TableRow>
					</TableHeader>
					<TableBody>
						{#each result.failedIngredients as failure}
							<TableRow>
								<TableCell>{failure.name} ({failure.id})</TableCell>
								<TableCell>{failure.reason}</TableCell>
							</TableRow>
						{/each}
					</TableBody>
				</Table>
			{/if}
		</div>
		<Dialog.Footer>
			<!-- Justificación: Se usa Dialog.Close directamente estilizado como un botón,
			     evitando la complejidad y errores de 'asChild'. -->
			<Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cerrar</Dialog.Close>
		</Dialog.Footer>
	{:else if state === 'error'}
		<Dialog.Header>
			<Dialog.Title>Error en la Sincronización</Dialog.Title>
			<Dialog.Description>
				Ocurrió un error inesperado al intentar sincronizar los ingredientes. Por favor, inténtalo
				de nuevo más tarde.
			</Dialog.Description>
		</Dialog.Header>
		<Dialog.Footer>
			<Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cerrar</Dialog.Close>
		</Dialog.Footer>
	{/if}
</Dialog.Content>

// --- Ruta: src/routes/api/recipes/[id]/+server.ts ---
// Ruta: src/routes/api/recipes/[id]/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { recipeService } from '$lib/server/services/recipeService';
import { RecipeSchema } from '$lib/schemas/recipeSchema';
import { ZodError } from 'zod';
import { formatZodError } from '$lib/server/zodErrors';
/**
 * Maneja las peticiones GET para obtener una receta por su ID.
 */
export const GET: RequestHandler = async ({ params }) => {
	try {
		const recipe = await recipeService.getById(params.id);
		if (!recipe) {
			return json({ message: 'Receta no encontrada' }, { status: 404 });
		}
		return json(recipe);
	} catch (error) {
		console.error(`Error fetching recipe ${params.id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};
/**
 * Maneja las peticiones PUT para actualizar una receta.
 */
export const PUT: RequestHandler = async ({ request, params }) => {
	try {
		const body = await request.json();
		const validatedData = RecipeSchema.parse(body);
		const updatedRecipe = await recipeService.update(params.id, validatedData);
		if (!updatedRecipe) {
			return json({ message: 'Receta no encontrada para actualizar' }, { status: 404 });
		}
		return json(updatedRecipe);
	} catch (error) {
		if (error instanceof ZodError) {
			return json(formatZodError(error), { status: 400 });
		}
		console.error(`Error updating recipe ${params.id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};
/**
 * Maneja las peticiones DELETE para eliminar una receta.
 */
export const DELETE: RequestHandler = async ({ params }) => {
	try {
		await recipeService.deleteById(params.id);
		return new Response(null, { status: 204 }); // 204 No Content
	} catch (error) {
		// Podríamos verificar si el error es porque el registro no existe (P2025 en Prisma)
		console.error(`Error deleting recipe ${params.id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/recetas/[id]/editar/+page.svelte ---
<!-- Ruta: src/routes/recetas/[id]/editar/+page.svelte -->
<script lang="ts">
	import { goto } from '$app/navigation';
	import { Button } from '$lib/components/ui/button';
	import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card';
	import { Input } from '$lib/components/ui/input';
	import { Label } from '$lib/components/ui/label';
	import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table';
	import { Textarea } from '$lib/components/ui/textarea';
	import { calculateNutritionalInfo, type CalculableIngredient } from '$lib/recipeCalculator';
	import type { RecipeIngredient } from '$lib/schemas/recipeSchema';
	import * as Popover from '$lib/components/ui/popover';
	import * as Command from '$lib/components/ui/command';
	import { ChevronsUpDown } from 'lucide-svelte';
	import type { PageData } from './$types';
	const { data }: { data: PageData } = $props();
	type IngredientWithDetails = RecipeIngredient & CalculableIngredient & { name: string };
	type SearchResult = {
		id: string;
		name: string;
		source: 'local' | 'off';
		type: 'custom' | 'product';
		imageUrl: string | null;
	};
	// Inicializar estado con los datos de la receta
	let title = $state(data.recipe.title);
	let description = $state(data.recipe.description ?? '');
	let steps = $state(data.recipe.steps);
	const initialIngredients = data.recipe.ingredients
	.map((ing): IngredientWithDetails | null => {
		const quantity = ing.quantity;
		if (ing.customIngredient) {
			return {
				id: ing.customIngredient.id,
				type: 'custom',
				quantity,
				name: ing.customIngredient.name,
				calories: ing.customIngredient.calories ?? 0,
				protein: ing.customIngredient.protein ?? 0,
				fat: ing.customIngredient.fat ?? 0,
				carbs: ing.customIngredient.carbs ?? 0
			};
		}
		if (ing.product) {
			return {
				id: ing.product.id,
				type: 'product',
				quantity,
				name: ing.product.name,
				calories: ing.product.calories ?? 0,
				protein: ing.product.protein ?? 0,
				fat: ing.product.fat ?? 0,
				carbs: ing.product.carbs ?? 0
			};
		}
		return null;
	})
	.filter((ing): ing is IngredientWithDetails => ing !== null);
	let ingredients = $state<IngredientWithDetails[]>(initialIngredients);
	let searchResults = $state<SearchResult[]>([]);
	let isSearching = $state(false);
	let open = $state(false);
	let inputValue = $state('');
	let searchTerm = $state('');
	$effect(() => {
		let eventSource: EventSource | null = null;
		if (searchTerm.length < 3) {
			searchResults = [];
			isSearching = false;
		} else {
			isSearching = true;
			searchResults = [];
			eventSource = new EventSource(`/api/ingredients/search?q=${encodeURIComponent(searchTerm)}`);
			eventSource.addEventListener('message', (e) => {
				const newResults = JSON.parse(e.data);
				searchResults = [...searchResults, ...newResults];
			});
			eventSource.addEventListener('stream_error', (e) => {
				const errorData = JSON.parse((e as MessageEvent).data);
				console.error('Error de stream recibido:', errorData);
			});
			eventSource.onerror = (err) => {
				console.error('Error en la conexión de EventSource:', err);
				isSearching = false;
				eventSource?.close();
			};
			eventSource.addEventListener('close', () => {
				isSearching = false;
				eventSource?.close();
			});
		}
		// Función de limpieza de $effect
		return () => {
			eventSource?.close();
		};
	});
	async function addIngredient(result: SearchResult) {
		if (ingredients.some((ing) => ing.id === result.id && ing.type === result.type)) return;
		try {
			const response = await fetch(`/api/ingredients/details/${result.id}?type=${result.type}`);
			if (!response.ok) throw new Error('Failed to fetch ingredient details');
			const details: CalculableIngredient = await response.json();
			ingredients.push({
				...result,
				quantity: 100,
				calories: details.calories,
				protein: details.protein,
				fat: details.fat,
				carbs: details.carbs
			});
		} catch (error) {
			console.error('Error adding ingredient:', error);
		} finally {
			open = false;
			searchResults = [];
			searchTerm = '';
			inputValue = '';
		}
	}
	function removeIngredient(index: number) {
		ingredients.splice(index, 1);
	}
	let nutritionalInfo = $derived(calculateNutritionalInfo(ingredients));
	let isSubmitting = $state(false);
	let errors = $state<Record<string, any>>({});
	async function handleSubmit(event: SubmitEvent) {
		event.preventDefault();
		isSubmitting = true;
		errors = {};
		const payload = {
			title,
			description,
			steps,
			ingredients: ingredients.map(({ id, quantity, type }) => ({ id, quantity, type }))
		};
		try {
			const response = await fetch(`/api/recipes/${data.recipe.id}`, {
				method: 'PUT',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload)
			});
			if (response.ok) {
				const updatedRecipe = await response.json();
				await goto(`/recetas/${updatedRecipe.id}`);
			} else {
				const errorData = await response.json();
				if (response.status === 400) {
					errors = errorData.errors;
				} else {
					errors.general = errorData.message || 'Ocurrió un error en el servidor.';
				}
			}
		} catch (err) {
			errors.general = 'No se pudo conectar con el servidor.';
		} finally {
			isSubmitting = false;
		}
	}
</script>
<Card class="max-w-4xl mx-auto my-8">
	<CardHeader>
		<CardTitle>Editar Receta</CardTitle>
	</CardHeader>
	<CardContent>
		<form onsubmit={handleSubmit} class="space-y-6">
			<div class="space-y-2">
				<Label for="title">Título</Label>
				<Input id="title" bind:value={title} required />
				{#if errors.title}
				<p class="text-sm text-red-500">{errors.title._errors[0]}</p>
				{/if}
			</div>
			<div class="space-y-2">
				<Label for="description">Descripción (Opcional)</Label>
				<Textarea id="description" bind:value={description} />
			</div>
			<div class="space-y-2">
				<Label for="steps">Pasos</Label>
				<Textarea id="steps" bind:value={steps} rows={8} required />
				{#if errors.steps}
				<p class="text-sm text-red-500">{errors.steps._errors[0]}</p>
				{/if}
			</div>
			<div class="space-y-2">
				<Label>Añadir Ingrediente</Label>
				<Popover.Root bind:open>
					<Popover.Trigger
						class="inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border w-full justify-between h-9 px-4 py-2"
						role="combobox"
						aria-expanded={open}
					>
						<div class="flex items-center justify-between w-full">
							{inputValue || 'Seleccionar ingrediente...'}
							<ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" />
						</div>
					</Popover.Trigger>
					<Popover.Content class="w-[--trigger-width] p-0">
						<Command.Root filter={() => 1}>
							<Command.Input bind:value={searchTerm} placeholder="Buscar ingrediente..." />
							<Command.List>
								{#if searchResults.length > 0}
								{#each searchResults as result (result.id + result.type)}
								<Command.Item
								value={result.name}
								onSelect={() => {
									inputValue = result.name;
									addIngredient(result);
								}}
								class={`flex items-center gap-2 ${result.source === 'local' ? 'ring-1 ring-green-500 rounded-sm' : ''}`}
								>
								<img
								src={result.imageUrl || 'https://placehold.co/40x40?text=N/A'}
								alt={result.name}
								class="h-8 w-8 rounded-sm object-cover"
								/>
								<span>{result.name}</span>
							</Command.Item>
							{/each}
							{:else}
							<div class="p-4 text-sm text-center text-gray-500">
								{#if isSearching}
								Buscando...
								{:else if searchTerm.length < 3}
								Escribe al menos 3 caracteres para buscar...
								{:else}
								No se encontraron resultados.
								{/if}
							</div>
							{/if}
						</Command.List>
					</Command.Root>
				</Popover.Content>
			</Popover.Root>
		</div>
		<div class="space-y-2">
			<h3 class="text-lg font-medium">Ingredientes de la Receta</h3>
			<Table>
				<TableHeader>
					<TableRow>
						<TableHead>Nombre</TableHead>
						<TableHead class="w-[150px]">Cantidad (g)</TableHead>
						<TableHead class="w-[100px] text-right">Acciones</TableHead>
					</TableRow>
				</TableHeader>
				<TableBody>
					{#each ingredients as ingredient, i}
					<TableRow>
						<TableCell>{ingredient.name}</TableCell>
						<TableCell>
							<Input type="number" bind:value={ingredient.quantity} min="1" class="w-full" />
						</TableCell>
						<TableCell class="text-right">
							<Button
							type="button"
							variant="destructive"
							size="sm"
							onclick={() => removeIngredient(i)}
							>
							Quitar
						</Button>
					</TableCell>
				</TableRow>
				{/each}
				{#if ingredients.length === 0}
				<TableRow>
					<TableCell colspan={3} class="text-center text-gray-500">
						Añade ingredientes usando el buscador.
					</TableCell>
				</TableRow>
				{/if}
			</TableBody>
		</Table>
	</div>
	<div class="space-y-2 p-4 border rounded-lg bg-gray-50">
		<h3 class="text-lg font-medium">Información Nutricional (Total)</h3>
		<div class="grid grid-cols-2 md:grid-cols-4 gap-4">
			<div>
				<p class="font-bold text-xl">{nutritionalInfo.totalCalories.toFixed(2)}</p>
				<p class="text-sm text-gray-600">Calorías (kcal)</p>
			</div>
			<div>
				<p class="font-bold text-xl">{nutritionalInfo.totalProtein.toFixed(2)} g</p>
				<p class="text-sm text-gray-600">Proteínas</p>
			</div>
			<div>
				<p class="font-bold text-xl">{nutritionalInfo.totalFat.toFixed(2)} g</p>
				<p class="text-sm text-gray-600">Grasas</p>
			</div>
			<div>
				<p class="font-bold text-xl">{nutritionalInfo.totalCarbs.toFixed(2)} g</p>
				<p class="text-sm text-gray-600">Carbohidratos</p>
			</div>
		</div>
	</div>
	<div class="flex justify-end">
		<Button type="submit" disabled={isSubmitting}>
			{isSubmitting ? 'Guardando...' : 'Guardar Cambios'}
		</Button>
	</div>
	{#if errors.general}
	<p class="text-sm text-red-500 text-right">{errors.general}</p>
	{/if}
</form>
</CardContent>
</Card>

// --- Ruta: src/routes/recetas/[id]/editar/+page.server.ts ---
// Ruta: src/routes/recetas/[id]/editar/+page.server.ts
import { error } from '@sveltejs/kit';
import { recipeService } from '$lib/server/services/recipeService';
import type { PageServerLoad } from './$types';
// Justificación: La función `load` se ejecuta en el servidor antes de renderizar la página.
// Es el lugar idóneo para cargar los datos necesarios para la edición de una receta.
// Si la receta no se encuentra, lanzamos un error 404 para que SvelteKit muestre la página de error.
export const load: PageServerLoad = async ({ params }) => {
	const recipe = await recipeService.getById(params.id);
	if (!recipe) {
		throw error(404, 'Receta no encontrada');
	}
	// Justificación: Devolvemos un objeto `recipe` que contiene todos los datos necesarios.
	// SvelteKit se encarga de serializarlo y pasarlo como prop `data` a la página Svelte.
	// Esto asegura que el frontend tenga toda la información para pre-rellenar el formulario.
	return {
		recipe
	};
};

// --- Ruta: src/routes/api/ingredients/search/api.spec.ts ---
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { GET } from './+server';
import { ingredientService } from '$lib/server/services/ingredientService';
import { json } from '@sveltejs/kit';
// Mockear los módulos externos
vi.mock('$lib/server/services/ingredientService', () => ({
	ingredientService: {
		searchByName: vi.fn()
	}
}));
vi.mock('@sveltejs/kit', async () => {
	const actual = await vi.importActual('@sveltejs/kit');
	return {
		...actual,
		json: vi.fn((data, init) => new Response(JSON.stringify(data), init))
	};
});
// Helper para consumir el stream y obtener los resultados como un array
async function consumeStream(stream: ReadableStream | null) {
	if (!stream) return [];
	const reader = stream.getReader();
	const results = [];
	// Mockear TextDecoder para el entorno de prueba de Node.js
	global.TextDecoder = class TextDecoder {
		decode(chunk: any) {
			return chunk.toString();
		}
	} as any;
	while (true) {
		const { done, value } = await reader.read();
		if (done) break;
		// En el entorno de prueba, los chunks pueden no ser Uint8Array.
		// Los tratamos como texto y procesamos el formato SSE.
		const chunk = value.toString();
		const lines = chunk.split('\n\n').filter(Boolean);
		for (const line of lines) {
			if (line.startsWith('event: message')) {
				const data = JSON.parse(line.split('data: ')[1]);
				results.push(...data);
			}
		}
	}
	return results;
}
describe('API Endpoint: /api/ingredients/search', () => {
	const mockSearchByName = vi.mocked(ingredientService.searchByName);
	const mockJsonResponse = vi.mocked(json);
	beforeEach(() => {
		vi.resetAllMocks();
	});
	it('debe devolver resultados locales del ingredientService', async () => {
		// Arrange
		const mockLocalResults = {
			customIngredients: [{ id: 'custom1', name: 'Tomate de la huerta' }],
			cachedProducts: [{ id: 'prod1', name: 'Tomate Frito (Mercadona)', imageUrl: 'url_image' }]
		};
		mockSearchByName.mockResolvedValue(mockLocalResults);
		const mockFetch = vi.fn().mockResolvedValue({
			ok: true,
			json: () => Promise.resolve({ products: [] })
		});
		const request = { url: new URL('http://localhost/api/ingredients/search?q=tomate') };
		// Act
		const response = await GET({ url: request.url, fetch: mockFetch } as any);
		const result = await consumeStream(response.body as ReadableStream);
		// Assert
		expect(mockSearchByName).toHaveBeenCalledWith('tomate');
		expect(result).toContainEqual({
			id: 'custom1',
			name: 'Tomate de la huerta',
			source: 'local',
			type: 'custom',
			imageUrl: null
		});
		expect(result).toContainEqual({
			id: 'prod1',
			name: 'Tomate Frito (Mercadona)',
			source: 'local',
			type: 'product',
			imageUrl: 'url_image'
		});
	});
	it('debe llamar a la API de Open Food Facts con "Hacendado" y "Mercadona" añadido a la query', async () => {
		// Arrange
		mockSearchByName.mockResolvedValue({ customIngredients: [], cachedProducts: [] });
		const mockFetch = vi.fn().mockResolvedValue({
			ok: true,
			json: () => Promise.resolve({ products: [] })
		});
		const request = { url: new URL('http://localhost/api/ingredients/search?q=queso') };
		// Act
		const response = await GET({ url: request.url, fetch: mockFetch } as any);
		await consumeStream(response.body as ReadableStream); // Consumir para que se ejecute
		// Assert
		expect(mockFetch).toHaveBeenCalledTimes(2);
		const fetchUrl1 = mockFetch.mock.calls[0][0] as string;
		const fetchUrl2 = mockFetch.mock.calls[1][0] as string;
		expect(fetchUrl1).toContain('search_terms=queso%20Hacendado');
		expect(fetchUrl2).toContain('search_terms=queso%20Mercadona');
	});
	it('debe unificar resultados y eliminar duplicados dando prioridad a los locales', async () => {
		// Arrange
		const mockLocalResults = {
			customIngredients: [],
			cachedProducts: [{ id: '12345', name: 'Producto Local Repetido', imageUrl: null }]
		};
		mockSearchByName.mockResolvedValue(mockLocalResults);
		const mockOffResponse = {
			products: [
				{ code: '12345', product_name: 'Producto OFF Repetido', image_front_small_url: 'url1' },
				{ code: '67890', product_name: 'Producto OFF Único', image_front_small_url: 'url2' }
			]
		};
		const mockFetch = vi.fn().mockResolvedValue({
			ok: true,
			json: () => Promise.resolve(mockOffResponse)
		});
		const request = { url: new URL('http://localhost/api/ingredients/search?q=producto') };
		// Act
		const response = await GET({ url: request.url, fetch: mockFetch } as any);
		const result = await consumeStream(response.body as ReadableStream);
		// Assert
		expect(result).toHaveLength(2);
		expect(result).toContainEqual({
			id: '12345',
			name: 'Producto Local Repetido',
			source: 'local',
			type: 'product',
			imageUrl: null
		});
		expect(result).toContainEqual({
			id: '67890',
			name: 'Producto OFF Único',
			source: 'off',
			type: 'product',
			imageUrl: 'url2'
		});
		expect(result.find((r) => r.id === '12345' && r.source === 'off')).toBeUndefined();
	});
	it('debe devolver un error 400 si no se proporciona el parámetro "q"', async () => {
		// Arrange
		const request = { url: new URL('http://localhost/api/ingredients/search') };
		const mockFetch = vi.fn();
		// Act
		const response = await GET({ url: request.url, fetch: mockFetch } as any);
		// Assert
		expect(response.status).toBe(400);
		const body = await response.json();
		expect(body.error).toBe('Query parameter "q" is required');
	});
});

// --- Ruta: src/routes/api/ingredients/search/+server.ts ---
import { ingredientService } from '$lib/server/services/ingredientService';
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
// Definimos un tipo para la respuesta de OFF para mejorar la legibilidad
type OffProduct = {
	code: string;
	product_name: string;
	image_front_small_url?: string;
};
export const GET: RequestHandler = ({ url, fetch }) => {
	const query = url.searchParams.get('q');
	if (!query) {
		return json({ error: 'Query parameter "q" is required' }, { status: 400 });
	}
	const stream = new ReadableStream({
		async start(controller) {
			const localIds = new Set<string>();
			type SearchResult = {
				id: string;
				name: string;
				source: 'local' | 'off';
				type: 'custom' | 'product';
				imageUrl: string | null;
			};
			// Función para enviar eventos con nombre al stream
			const sendEvent = (event: string, data: object) => {
				controller.enqueue(`event: ${event}\ndata: ${JSON.stringify(data)}\n\n`);
			};
			try {
				// 1. Búsqueda local (rápida)
				const { customIngredients, cachedProducts } = await ingredientService.searchByName(query);
				const localResults: SearchResult[] = [
					...customIngredients.map(
						(i) =>
							({
								id: i.id,
								name: i.name,
								source: 'local',
								type: 'custom',
								imageUrl: null
							}) as const
					),
					...cachedProducts.map(
						(p) =>
							({
								id: p.id,
								name: p.name,
								source: 'local',
								type: 'product',
								imageUrl: p.imageUrl
							}) as const
					)
				];
				if (localResults.length > 0) {
					localResults.forEach((r) => localIds.add(r.id));
					sendEvent('message', localResults);
				}
				// 2. Búsquedas externas (lentas)
				const brands = ['Hacendado', 'Mercadona'];
				const offSearchPromises = brands.map((brand) => {
					const offQuery = `${query} ${brand}`;
					const offUrl = `https://world.openfoodfacts.org/cgi/search.pl?search_terms=${encodeURIComponent(
						offQuery
					)}&search_simple=1&action=process&json=1&page_size=10`;
					return fetch(offUrl)
						.then(async (res) => {
							if (!res.ok) throw new Error(`API returned status ${res.status}`);
							return res.json() as Promise<{ products: OffProduct[] }>;
						})
						.then((response) => {
							const offProducts = response.products || [];
							const uniqueOffProducts: SearchResult[] = offProducts
								.filter((p) => p.code && !localIds.has(p.code))
								.map((p) => {
									localIds.add(p.code);
									return {
										id: p.code,
										name: p.product_name,
										source: 'off' as const,
										type: 'product' as const,
										imageUrl: p.image_front_small_url || null
									};
								});
							if (uniqueOffProducts.length > 0) {
								sendEvent('message', uniqueOffProducts);
							}
						})
						.catch((err) => {
							// Lanzar el error para que Promise.allSettled lo capture
							throw new Error(`Failed to fetch from ${brand}: ${err.message}`);
						});
				});
				const results = await Promise.allSettled(offSearchPromises);
				results.forEach((result) => {
					if (result.status === 'rejected') {
						console.error('A fetch promise was rejected:', result.reason);
						sendEvent('stream_error', { source: 'off-api', message: result.reason.message });
					}
				});
			} catch (error) {
				console.error('[Search Stream Error]', error);
				const errorMessage = error instanceof Error ? error.message : 'Unknown stream error';
				sendEvent('stream_error', { source: 'server', message: errorMessage });
			} finally {
				// Notificar al cliente que el stream ha finalizado
				sendEvent('close', { message: 'Stream closed' });
				controller.close();
			}
		}
	});
	return new Response(stream, {
		headers: {
			'Content-Type': 'text/event-stream',
			'Cache-Control': 'no-cache',
			'Connection': 'keep-alive'
		}
	});
};

// --- Ruta: src/routes/api/products/[id]/+server.ts ---
// Ruta: src/routes/api/products/[id]/+server.ts
import { json, type RequestHandler } from '@sveltejs/kit';
import { productService } from '$lib/server/services/productService';
export const DELETE: RequestHandler = async ({ params }) => {
	const { id } = params;
	if (!id) {
		return json({ message: 'El ID del producto es requerido.' }, { status: 400 });
	}
	try {
		await productService.deleteById(id);
		return new Response(null, { status: 204 }); // No Content
	} catch (error) {
		console.error(`Error deleting product ${id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/api/ingredients/[id]/+server.ts ---
// Ruta: src/routes/api/ingredients/[id]/+server.ts
import { json, type RequestHandler } from '@sveltejs/kit';
import { ingredientService } from '$lib/server/services/ingredientService';
import { IngredientSchema } from '$lib/schemas/ingredientSchema';
import { ZodError } from 'zod';
import { formatZodError } from '$lib/server/zodErrors';
// Justificación (PUT): Endpoint para la actualización de un recurso específico.
// Valida tanto el ID de la ruta como los datos del cuerpo antes de actuar.
export const PUT: RequestHandler = async ({ request, params }) => {
	const { id } = params;
	if (!id) {
		return json({ message: 'ID de ingrediente es requerido' }, { status: 400 });
	}
	try {
		const body = await request.json();
		const validatedData = IngredientSchema.parse(body);
		const updatedIngredient = await ingredientService.update(id, validatedData);
		return json(updatedIngredient);
	} catch (error) {
		if (error instanceof ZodError) {
			return json(formatZodError(error), { status: 400 });
		}
		console.error(`Error updating ingredient with id ${params.id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};
// Justificación (DELETE): Endpoint para la eliminación de un recurso específico.
// Solo requiere el ID del recurso, haciendo la operación simple y clara.
export const DELETE: RequestHandler = async ({ params }) => {
	const { id } = params;
	if (!id) {
		return json({ message: 'ID de ingrediente es requerido' }, { status: 400 });
	}
	try {
		await ingredientService.deleteById(id);
		return new Response(null, { status: 204 }); // 204 No Content
	} catch (error) {
		// Aquí también se podrían manejar errores de 'RecordNotFound'.
		console.error(`Error deleting ingredient ${id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/admin/ingredientes/off/+page.svelte ---
<script lang="ts">
	import { Button, buttonVariants } from '$lib/components/ui/button';
	import { Input } from '$lib/components/ui/input';
	import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '$lib/components/ui/card';
	type SearchResult = {
		id: string;
		name: string;
		source: 'local' | 'off';
		imageUrl: string | null;
	};
	let searchTerm = '';
	let results: SearchResult[] = [];
	let isLoading = false;
	let searchAttempted = false; // Para mostrar el mensaje de "no resultados"
	let eventSource: EventSource | null = null;
	function handleSearch() {
		if (searchTerm.length < 3) {
			results = [];
			searchAttempted = false;
			return;
		}
		results = [];
		isLoading = true;
		searchAttempted = true;
		if (eventSource) {
			eventSource.close();
		}
		eventSource = new EventSource(`/api/ingredients/search?q=${encodeURIComponent(searchTerm)}`);
		eventSource.addEventListener('message', (event) => {
			const newResults = JSON.parse(event.data);
			results = [...results, ...newResults];
		});
		// Escucha los errores de aplicación enviados explícitamente por el servidor
		eventSource.addEventListener('stream_error', (event) => {
			// Este es un MessageEvent, por lo que podemos castearlo y leer `data`
			const errorData = JSON.parse((event as MessageEvent).data);
			console.error('Error de stream recibido:', errorData);
		});
		// Escucha los errores de conexión genéricos
		eventSource.onerror = (err) => {
			// Este es un Event genérico, no tiene `data`. Solo indica fallo en la conexión.
			console.error('Error en la conexión de EventSource. La conexión se ha cerrado.', err);
			isLoading = false;
			eventSource?.close();
		};
		eventSource.addEventListener('close', () => {
			isLoading = false;
			eventSource?.close();
		});
	}
</script>
<div class="space-y-8 p-4 md:p-8">
	<div class="flex justify-between items-center">
		<h1 class="text-2xl font-bold">Añadir Ingredientes desde Open Food Facts</h1>
		<a href="/admin/ingredientes" class={buttonVariants({ variant: 'outline' })}>
			Volver al listado
		</a>
	</div>
	<form on:submit|preventDefault={handleSearch} class="flex items-center gap-2">
		<Input
		bind:value={searchTerm}
		placeholder="Buscar por nombre (ej. tomate frito)..."
		class="flex-grow"
		/>
		<Button type="submit" disabled={isLoading}>
			{#if isLoading}Buscando...{:else}Buscar{/if}
		</Button>
	</form>
	{#if results.length > 0}
	<div class="grid grid-cols-2 gap-4 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6">
		{#each results as result (result.id)}
		<Card class={result.source === 'local' ? 'ring-2 ring-green-500' : ''}>
			<CardHeader>
				<img
				src={result.imageUrl || 'https://placehold.co/400x400?text=Sin+Imagen'}
				alt={result.name}
				class="aspect-square w-full rounded-md object-cover"
				/>
			</CardHeader>
			<CardContent class="flex flex-col justify-between space-y-4">
				<CardTitle class="text-sm">{result.name}</CardTitle>
				{#if result.source === 'off'}
				<form method="POST" action="?/add">
					<input type="hidden" name="productId" value={result.id} />
					<Button type="submit" class="w-full">Añadir a la Base de Datos</Button>
				</form>
				{:else}
				<Button class="w-full" disabled>Ya está en la Base de Datos</Button>
				{/if}
			</CardContent>
		</Card>
		{/each}
	</div>
	{:else if !isLoading && searchAttempted}
	<div class="text-center text-gray-500 py-8">
		<p>No se encontraron resultados para tu búsqueda.</p>
	</div>
	{/if}
</div>

// --- Ruta: src/routes/admin/ingredientes/off/+page.server.ts ---
import { productService } from '$lib/server/services/productService';
import { fail } from '@sveltejs/kit';
import type { Actions } from './$types';
export const actions: Actions = {
	// Acción para añadir un producto de OFF a nuestra base de datos
	add: async ({ request }) => {
		const data = await request.formData();
		const productId = data.get('productId') as string;
		if (!productId) {
			return fail(400, { success: false, error: 'Product ID no proporcionado' });
		}
		try {
			const product = await productService.findByBarcode(productId);
			if (!product) {
				return fail(404, {
					success: false,
					error: `Producto con ID ${productId} no encontrado en Open Food Facts.`
				});
			}
			return { success: true, product };
		} catch (error) {
			console.error(error);
			return fail(500, {
				success: false,
				error: 'Error interno del servidor al intentar cachear el producto.'
			});
		}
	}
};

// --- Ruta: src/lib/components/ui/textarea/textarea.svelte ---
<script lang="ts">
	import { cn, type WithElementRef, type WithoutChildren } from "$lib/utils.js";
	import type { HTMLTextareaAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		value = $bindable(),
		class: className,
		...restProps
	}: WithoutChildren<WithElementRef<HTMLTextareaAttributes>> = $props();
</script>
<textarea
	bind:this={ref}
	data-slot="textarea"
	class={cn(
		"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 field-sizing-content shadow-xs flex min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base outline-none transition-[color,box-shadow] focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
		className
	)}
	bind:value
	{...restProps}
></textarea>

// --- Ruta: src/lib/components/ui/textarea/index.ts ---
import Root from "./textarea.svelte";
export {
	Root,
	//
	Root as Textarea,
};

// --- Ruta: src/lib/components/ui/table/table.svelte ---
<script lang="ts">
	import type { HTMLTableAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLTableAttributes> = $props();
</script>
<div data-slot="table-container" class="relative w-full overflow-x-auto">
	<table
		bind:this={ref}
		data-slot="table"
		class={cn("w-full caption-bottom text-sm", className)}
		{...restProps}
	>
		{@render children?.()}
	</table>
</div>

// --- Ruta: src/lib/components/ui/table/table-row.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLTableRowElement>> = $props();
</script>
<tr
	bind:this={ref}
	data-slot="table-row"
	class={cn(
		"hover:[&,&>svelte-css-wrapper]:[&>th,td]:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</tr>

// --- Ruta: src/lib/components/ui/table/table-header.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props();
</script>
<thead
	bind:this={ref}
	data-slot="table-header"
	class={cn("[&_tr]:border-b", className)}
	{...restProps}
>
	{@render children?.()}
</thead>

// --- Ruta: src/lib/components/ui/table/table-head.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLThAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLThAttributes> = $props();
</script>
<th
	bind:this={ref}
	data-slot="table-head"
	class={cn(
		"text-foreground h-10 whitespace-nowrap bg-clip-padding px-2 text-left align-middle font-medium [&:has([role=checkbox])]:pr-0",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</th>

// --- Ruta: src/lib/components/ui/table/table-footer.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props();
</script>
<tfoot
	bind:this={ref}
	data-slot="table-footer"
	class={cn("bg-muted/50 border-t font-medium [&>tr]:last:border-b-0", className)}
	{...restProps}
>
	{@render children?.()}
</tfoot>

// --- Ruta: src/lib/components/ui/table/table-cell.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLTdAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLTdAttributes> = $props();
</script>
<td
	bind:this={ref}
	data-slot="table-cell"
	class={cn(
		"whitespace-nowrap bg-clip-padding p-2 align-middle [&:has([role=checkbox])]:pr-0",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</td>

// --- Ruta: src/lib/components/ui/table/table-caption.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLElement>> = $props();
</script>
<caption
	bind:this={ref}
	data-slot="table-caption"
	class={cn("text-muted-foreground mt-4 text-sm", className)}
	{...restProps}
>
	{@render children?.()}
</caption>

// --- Ruta: src/lib/components/ui/table/table-body.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props();
</script>
<tbody
	bind:this={ref}
	data-slot="table-body"
	class={cn("[&_tr:last-child]:border-0", className)}
	{...restProps}
>
	{@render children?.()}
</tbody>

// --- Ruta: src/lib/components/ui/table/index.ts ---
import Root from "./table.svelte";
import Body from "./table-body.svelte";
import Caption from "./table-caption.svelte";
import Cell from "./table-cell.svelte";
import Footer from "./table-footer.svelte";
import Head from "./table-head.svelte";
import Header from "./table-header.svelte";
import Row from "./table-row.svelte";
export {
	Root,
	Body,
	Caption,
	Cell,
	Footer,
	Head,
	Header,
	Row,
	//
	Root as Table,
	Body as TableBody,
	Caption as TableCaption,
	Cell as TableCell,
	Footer as TableFooter,
	Head as TableHead,
	Header as TableHeader,
	Row as TableRow,
};

// --- Ruta: src/lib/components/ui/popover/popover-trigger.svelte ---
<script lang="ts">
	import { cn } from "$lib/utils.js";
	import { Popover as PopoverPrimitive } from "bits-ui";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: PopoverPrimitive.TriggerProps = $props();
</script>
<PopoverPrimitive.Trigger
	bind:ref
	data-slot="popover-trigger"
	class={cn("", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/popover/popover-content.svelte ---
<script lang="ts">
	import { cn } from "$lib/utils.js";
	import { Popover as PopoverPrimitive } from "bits-ui";
	let {
		ref = $bindable(null),
		class: className,
		sideOffset = 4,
		align = "center",
		portalProps,
		...restProps
	}: PopoverPrimitive.ContentProps & {
		portalProps?: PopoverPrimitive.PortalProps;
	} = $props();
</script>
<PopoverPrimitive.Portal {...portalProps}>
	<PopoverPrimitive.Content
		bind:ref
		data-slot="popover-content"
		{sideOffset}
		{align}
		class={cn(
			"bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-popover-content-transform-origin) outline-hidden z-50 w-72 rounded-md border p-4 shadow-md",
			className
		)}
		{...restProps}
	/>
</PopoverPrimitive.Portal>

// --- Ruta: src/lib/components/ui/popover/index.ts ---
import { Popover as PopoverPrimitive } from "bits-ui";
import Content from "./popover-content.svelte";
import Trigger from "./popover-trigger.svelte";
const Root = PopoverPrimitive.Root;
const Close = PopoverPrimitive.Close;
export {
	Root,
	Content,
	Trigger,
	Close,
	//
	Root as Popover,
	Content as PopoverContent,
	Trigger as PopoverTrigger,
	Close as PopoverClose,
};

// --- Ruta: src/lib/components/ui/label/label.svelte ---
<script lang="ts">
	import { Label as LabelPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: LabelPrimitive.RootProps = $props();
</script>
<LabelPrimitive.Root
	bind:ref
	data-slot="label"
	class={cn(
		"flex select-none items-center gap-2 text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-50 group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/label/index.ts ---
import Root from "./label.svelte";
export {
	Root,
	//
	Root as Label,
};

// --- Ruta: src/lib/components/ui/input/input.svelte ---
<script lang="ts">
	import type { HTMLInputAttributes, HTMLInputTypeAttribute } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	type InputType = Exclude<HTMLInputTypeAttribute, "file">;
	type Props = WithElementRef<
		Omit<HTMLInputAttributes, "type"> &
			({ type: "file"; files?: FileList } | { type?: InputType; files?: undefined })
	>;
	let {
		ref = $bindable(null),
		value = $bindable(),
		type,
		files = $bindable(),
		class: className,
		...restProps
	}: Props = $props();
</script>
{#if type === "file"}
	<input
		bind:this={ref}
		data-slot="input"
		class={cn(
			"selection:bg-primary dark:bg-input/30 selection:text-primary-foreground border-input ring-offset-background placeholder:text-muted-foreground shadow-xs flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 pt-1.5 text-sm font-medium outline-none transition-[color,box-shadow] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
			"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
			"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
			className
		)}
		type="file"
		bind:files
		bind:value
		{...restProps}
	/>
{:else}
	<input
		bind:this={ref}
		data-slot="input"
		class={cn(
			"border-input bg-background selection:bg-primary dark:bg-input/30 selection:text-primary-foreground ring-offset-background placeholder:text-muted-foreground shadow-xs flex h-9 w-full min-w-0 rounded-md border px-3 py-1 text-base outline-none transition-[color,box-shadow] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
			"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
			"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
			className
		)}
		{type}
		bind:value
		{...restProps}
	/>
{/if}

// --- Ruta: src/lib/components/ui/input/index.ts ---
import Root from "./input.svelte";
export {
	Root,
	//
	Root as Input,
};

// --- Ruta: src/lib/components/ui/dialog/index.ts ---
import { Dialog as DialogPrimitive } from "bits-ui";
import Title from "./dialog-title.svelte";
import Footer from "./dialog-footer.svelte";
import Header from "./dialog-header.svelte";
import Overlay from "./dialog-overlay.svelte";
import Content from "./dialog-content.svelte";
import Description from "./dialog-description.svelte";
import Trigger from "./dialog-trigger.svelte";
import Close from "./dialog-close.svelte";
const Root = DialogPrimitive.Root;
const Portal = DialogPrimitive.Portal;
export {
	Root,
	Title,
	Portal,
	Footer,
	Header,
	Trigger,
	Overlay,
	Content,
	Description,
	Close,
	//
	Root as Dialog,
	Title as DialogTitle,
	Portal as DialogPortal,
	Footer as DialogFooter,
	Header as DialogHeader,
	Trigger as DialogTrigger,
	Overlay as DialogOverlay,
	Content as DialogContent,
	Description as DialogDescription,
	Close as DialogClose,
};

// --- Ruta: src/lib/components/ui/dialog/dialog-trigger.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	let { ref = $bindable(null), ...restProps }: DialogPrimitive.TriggerProps = $props();
</script>
<DialogPrimitive.Trigger bind:ref data-slot="dialog-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-title.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: DialogPrimitive.TitleProps = $props();
</script>
<DialogPrimitive.Title
	bind:ref
	data-slot="dialog-title"
	class={cn("text-lg font-semibold leading-none", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dialog/dialog-overlay.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: DialogPrimitive.OverlayProps = $props();
</script>
<DialogPrimitive.Overlay
	bind:ref
	data-slot="dialog-overlay"
	class={cn(
		"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dialog/dialog-header.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="dialog-header"
	class={cn("flex flex-col gap-2 text-center sm:text-left", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/dialog/dialog-footer.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="dialog-footer"
	class={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/dialog/dialog-description.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: DialogPrimitive.DescriptionProps = $props();
</script>
<DialogPrimitive.Description
	bind:ref
	data-slot="dialog-description"
	class={cn("text-muted-foreground text-sm", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/dialog/dialog-content.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import XIcon from "@lucide/svelte/icons/x";
	import type { Snippet } from "svelte";
	import * as Dialog from "./index.js";
	import { cn, type WithoutChildrenOrChild } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		portalProps,
		children,
		showCloseButton = true,
		...restProps
	}: WithoutChildrenOrChild<DialogPrimitive.ContentProps> & {
		portalProps?: DialogPrimitive.PortalProps;
		children: Snippet;
		showCloseButton?: boolean;
	} = $props();
</script>
<Dialog.Portal {...portalProps}>
	<Dialog.Overlay />
	<DialogPrimitive.Content
		bind:ref
		data-slot="dialog-content"
		class={cn(
			"bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
			className
		)}
		{...restProps}
	>
		{@render children?.()}
		{#if showCloseButton}
			<DialogPrimitive.Close
				class="ring-offset-background focus:ring-ring rounded-xs focus:outline-hidden absolute right-4 top-4 opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 disabled:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0"
			>
				<XIcon />
				<span class="sr-only">Close</span>
			</DialogPrimitive.Close>
		{/if}
	</DialogPrimitive.Content>
</Dialog.Portal>

// --- Ruta: src/lib/components/ui/dialog/dialog-close.svelte ---
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	let { ref = $bindable(null), ...restProps }: DialogPrimitive.CloseProps = $props();
</script>
<DialogPrimitive.Close bind:ref data-slot="dialog-close" {...restProps} />

// --- Ruta: src/lib/components/ui/command/index.ts ---
import { Command as CommandPrimitive } from "bits-ui";
import Root from "./command.svelte";
import Dialog from "./command-dialog.svelte";
import Empty from "./command-empty.svelte";
import Group from "./command-group.svelte";
import Item from "./command-item.svelte";
import Input from "./command-input.svelte";
import List from "./command-list.svelte";
import Separator from "./command-separator.svelte";
import Shortcut from "./command-shortcut.svelte";
import LinkItem from "./command-link-item.svelte";
const Loading = CommandPrimitive.Loading;
export {
	Root,
	Dialog,
	Empty,
	Group,
	Item,
	LinkItem,
	Input,
	List,
	Separator,
	Shortcut,
	Loading,
	//
	Root as Command,
	Dialog as CommandDialog,
	Empty as CommandEmpty,
	Group as CommandGroup,
	Item as CommandItem,
	LinkItem as CommandLinkItem,
	Input as CommandInput,
	List as CommandList,
	Separator as CommandSeparator,
	Shortcut as CommandShortcut,
	Loading as CommandLoading,
};

// --- Ruta: src/lib/components/ui/command/command.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		value = $bindable(""),
		class: className,
		...restProps
	}: CommandPrimitive.RootProps = $props();
</script>
<CommandPrimitive.Root
	bind:value
	bind:ref
	data-slot="command"
	class={cn(
		"bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-shortcut.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLSpanElement>> = $props();
</script>
<span
	bind:this={ref}
	data-slot="command-shortcut"
	class={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)}
	{...restProps}
>
	{@render children?.()}
</span>

// --- Ruta: src/lib/components/ui/command/command-separator.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.SeparatorProps = $props();
</script>
<CommandPrimitive.Separator
	bind:ref
	data-slot="command-separator"
	class={cn("bg-border -mx-1 h-px", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-list.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.ListProps = $props();
</script>
<CommandPrimitive.List
	bind:ref
	data-slot="command-list"
	class={cn("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-link-item.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.LinkItemProps = $props();
</script>
<CommandPrimitive.LinkItem
	bind:ref
	data-slot="command-item"
	class={cn(
		"aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-item.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.ItemProps = $props();
</script>
<CommandPrimitive.Item
	bind:ref
	data-slot="command-item"
	class={cn(
		"aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		className
	)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-input.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import SearchIcon from "@lucide/svelte/icons/search";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		value = $bindable(""),
		...restProps
	}: CommandPrimitive.InputProps = $props();
</script>
<div class="flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper">
	<SearchIcon class="size-4 shrink-0 opacity-50" />
	<CommandPrimitive.Input
		data-slot="command-input"
		class={cn(
			"placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50",
			className
		)}
		bind:ref
		{...restProps}
		bind:value
	/>
</div>

// --- Ruta: src/lib/components/ui/command/command-group.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive, useId } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		heading,
		value,
		...restProps
	}: CommandPrimitive.GroupProps & {
		heading?: string;
	} = $props();
</script>
<CommandPrimitive.Group
	bind:ref
	data-slot="command-group"
	class={cn("text-foreground overflow-hidden p-1", className)}
	value={value ?? heading ?? `----${useId()}`}
	{...restProps}
>
	{#if heading}
		<CommandPrimitive.GroupHeading
			class="text-muted-foreground px-2 py-1.5 text-xs font-medium"
		>
			{heading}
		</CommandPrimitive.GroupHeading>
	{/if}
	<CommandPrimitive.GroupItems {children} />
</CommandPrimitive.Group>

// --- Ruta: src/lib/components/ui/command/command-empty.svelte ---
<script lang="ts">
	import { Command as CommandPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		...restProps
	}: CommandPrimitive.EmptyProps = $props();
</script>
<CommandPrimitive.Empty
	bind:ref
	data-slot="command-empty"
	class={cn("py-6 text-center text-sm", className)}
	{...restProps}
/>

// --- Ruta: src/lib/components/ui/command/command-dialog.svelte ---
<script lang="ts">
	import type { Command as CommandPrimitive, Dialog as DialogPrimitive } from "bits-ui";
	import type { Snippet } from "svelte";
	import Command from "./command.svelte";
	import * as Dialog from "$lib/components/ui/dialog/index.js";
	import type { WithoutChildrenOrChild } from "$lib/utils.js";
	let {
		open = $bindable(false),
		ref = $bindable(null),
		value = $bindable(""),
		title = "Command Palette",
		description = "Search for a command to run",
		portalProps,
		children,
		...restProps
	}: WithoutChildrenOrChild<DialogPrimitive.RootProps> &
		WithoutChildrenOrChild<CommandPrimitive.RootProps> & {
			portalProps?: DialogPrimitive.PortalProps;
			children: Snippet;
			title?: string;
			description?: string;
		} = $props();
</script>
<Dialog.Root bind:open {...restProps}>
	<Dialog.Header class="sr-only">
		<Dialog.Title>{title}</Dialog.Title>
		<Dialog.Description>{description}</Dialog.Description>
	</Dialog.Header>
	<Dialog.Content class="overflow-hidden p-0" {portalProps}>
		<Command
			class="**:data-[slot=command-input-wrapper]:h-12 [&_[data-command-group]:not([hidden])_~[data-command-group]]:pt-0 [&_[data-command-group]]:px-2 [&_[data-command-input-wrapper]_svg]:h-5 [&_[data-command-input-wrapper]_svg]:w-5 [&_[data-command-input]]:h-12 [&_[data-command-item]]:px-2 [&_[data-command-item]]:py-3 [&_[data-command-item]_svg]:h-5 [&_[data-command-item]_svg]:w-5"
			{...restProps}
			bind:value
			bind:ref
			{children}
		/>
	</Dialog.Content>
</Dialog.Root>

// --- Ruta: src/lib/components/ui/card/index.ts ---
import Root from "./card.svelte";
import Content from "./card-content.svelte";
import Description from "./card-description.svelte";
import Footer from "./card-footer.svelte";
import Header from "./card-header.svelte";
import Title from "./card-title.svelte";
import Action from "./card-action.svelte";
export {
	Root,
	Content,
	Description,
	Footer,
	Header,
	Title,
	Action,
	//
	Root as Card,
	Content as CardContent,
	Description as CardDescription,
	Footer as CardFooter,
	Header as CardHeader,
	Title as CardTitle,
	Action as CardAction,
};

// --- Ruta: src/lib/components/ui/card/card.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card"
	class={cn(
		"bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-title.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card-title"
	class={cn("font-semibold leading-none", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-header.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card-header"
	class={cn(
		"@container/card-header has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6 grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6",
		className
	)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-footer.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card-footer"
	class={cn("[.border-t]:pt-6 flex items-center px-6", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-description.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLParagraphElement>> = $props();
</script>
<p
	bind:this={ref}
	data-slot="card-description"
	class={cn("text-muted-foreground text-sm", className)}
	{...restProps}
>
	{@render children?.()}
</p>

// --- Ruta: src/lib/components/ui/card/card-content.svelte ---
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn, type WithElementRef } from "$lib/utils.js";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div bind:this={ref} data-slot="card-content" class={cn("px-6", className)} {...restProps}>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/card/card-action.svelte ---
<script lang="ts">
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAttributes } from "svelte/elements";
	let {
		ref = $bindable(null),
		class: className,
		children,
		...restProps
	}: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props();
</script>
<div
	bind:this={ref}
	data-slot="card-action"
	class={cn("col-start-2 row-span-2 row-start-1 self-start justify-self-end", className)}
	{...restProps}
>
	{@render children?.()}
</div>

// --- Ruta: src/lib/components/ui/button/index.ts ---
import Root, {
	type ButtonProps,
	type ButtonSize,
	type ButtonVariant,
	buttonVariants,
} from "./button.svelte";
export {
	Root,
	type ButtonProps as Props,
	//
	Root as Button,
	buttonVariants,
	type ButtonProps,
	type ButtonSize,
	type ButtonVariant,
};

// --- Ruta: src/lib/components/ui/button/button.svelte ---
<script lang="ts" module>
	import { cn, type WithElementRef } from "$lib/utils.js";
	import type { HTMLAnchorAttributes, HTMLButtonAttributes } from "svelte/elements";
	import { type VariantProps, tv } from "tailwind-variants";
	export const buttonVariants = tv({
		base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
				destructive:
					"bg-destructive shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white",
				outline:
					"bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border",
				secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-9 px-4 py-2 has-[>svg]:px-3",
				sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5",
				lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
				icon: "size-9",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	});
	export type ButtonVariant = VariantProps<typeof buttonVariants>["variant"];
	export type ButtonSize = VariantProps<typeof buttonVariants>["size"];
	export type ButtonProps = WithElementRef<HTMLButtonAttributes> &
		WithElementRef<HTMLAnchorAttributes> & {
			variant?: ButtonVariant;
			size?: ButtonSize;
		};
</script>
<script lang="ts">
	let {
		class: className,
		variant = "default",
		size = "default",
		ref = $bindable(null),
		href = undefined,
		type = "button",
		disabled,
		children,
		...restProps
	}: ButtonProps = $props();
</script>
{#if href}
	<a
		bind:this={ref}
		data-slot="button"
		class={cn(buttonVariants({ variant, size }), className)}
		href={disabled ? undefined : href}
		aria-disabled={disabled}
		role={disabled ? "link" : undefined}
		tabindex={disabled ? -1 : undefined}
		{...restProps}
	>
		{@render children?.()}
	</a>
{:else}
	<button
		bind:this={ref}
		data-slot="button"
		class={cn(buttonVariants({ variant, size }), className)}
		{type}
		{disabled}
		{...restProps}
	>
		{@render children?.()}
	</button>
{/if}

// --- Ruta: src/routes/api/ingredients/sync/+server.ts ---
// Ruta: src/routes/api/ingredients/sync/+server.ts
import { json, type RequestHandler } from '@sveltejs/kit';
import { ingredientService } from '$lib/server/services/ingredientService';
import { verifySessionToken } from '$lib/server/auth';
/**
 * @description Endpoint para sincronizar los ingredientes con Open Food Facts
 * @returns {Response}
 */
export const POST: RequestHandler = async ({ cookies }) => {
	// Justificación: Se protege el endpoint verificando el token de autenticación
	// del usuario. Esto asegura que solo usuarios logueados puedan iniciar un proceso
	// que consume recursos como es la sincronización.
	const token = cookies.get('session'); // CORREGIDO: El nombre de la cookie es 'session'
	if (!token || !(await verifySessionToken(token))) {
		return json({ message: 'No autorizado' }, { status: 401 });
	}
	try {
		// Justificación: Se invoca la lógica de negocio desde el servicio correspondiente.
		// El controlador (este archivo) se mantiene simple, delegando la complejidad
		// al `ingredientService`, lo que facilita el mantenimiento y las pruebas.
		const result = await ingredientService.syncWithOpenFoodFacts();
		return json(result, { status: 200 });
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : 'Error desconocido en el servidor';
		return json({ message: errorMessage }, { status: 500 });
	}
};

// --- Ruta: src/routes/api/products/search/[barcode]/+server.ts ---
// Ruta: src/routes/api/products/search/[barcode]/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { productService } from '$lib/server/services/productService';
// Justificación: Expone el `productService` a través de una API RESTful.
// El endpoint recibe el código de barras como un parámetro de la ruta (`params.barcode`),
// lo que es una práctica estándar para identificar un recurso específico.
// Se importa `RequestHandler` desde `./$types` para obtener el tipado correcto de `params`.
export const GET: RequestHandler = async ({ params }) => {
	const { barcode } = params;
	if (!barcode) {
		return json({ message: 'El código de barras es requerido' }, { status: 400 });
	}
	try {
		const product = await productService.findByBarcode(barcode);
		if (!product) {
			// Si el producto no se encuentra ni en la caché ni en la API de OFF,
			// devolvemos un 404 Not Found, que es el código de estado HTTP correcto.
			return json({ message: 'Producto no encontrado' }, { status: 404 });
		}
		// Devolvemos el producto encontrado (ya sea de la caché o de la API).
		return json(product);
	} catch (error) {
		console.error(`Error searching for barcode ${barcode}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

// --- Ruta: src/routes/api/ingredients/details/[id]/+server.ts ---
// Ruta: src/routes/api/ingredients/details/[id]/+server.ts
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import prisma from '$lib/server/prisma';
import { productService } from '$lib/server/services/productService';
// Justificación: Este endpoint centraliza la obtención de datos nutricionales
// para cualquier tipo de ingrediente. El frontend lo necesita para poder
// calcular la información nutricional en tiempo real al crear/editar una receta.
export const GET: RequestHandler = async ({ params, url }) => {
	const { id } = params;
	const type = url.searchParams.get('type');
	if (!type || (type !== 'custom' && type !== 'product')) {
		return json({ message: "El parámetro 'type' es requerido ('custom' o 'product')." }, { status: 400 });
	}
	try {
		let ingredientData = null;
		if (type === 'custom') {
			ingredientData = await prisma.customIngredient.findUnique({
				where: { id }
			});
		} else {
			// Para productos, el 'id' es el código de barras.
			// Usamos el productService que ya tiene la lógica de caché y fallback a OFF.
			ingredientData = await productService.findByBarcode(id);
		}
		if (!ingredientData) {
			return json({ message: 'Ingrediente no encontrado.' }, { status: 404 });
		}
		// Justificación: Devolvemos un objeto con una estructura consistente,
		// independientemente de la tabla de origen, para que el frontend
		// pueda procesarlo de forma sencilla.
		const response = {
			calories: ingredientData.calories,
			protein: ingredientData.protein,
			fat: ingredientData.fat,
			carbs: ingredientData.carbs
		};
		return json(response);
	} catch (error) {
		console.error(`Error fetching ingredient details for id ${id}:`, error);
		return json({ message: 'Error interno del servidor' }, { status: 500 });
	}
};

