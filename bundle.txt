/* --- Bundle de Código Generado ---
 * Modo: no-comments
 * Ficheros Incluidos: 184
 * Fecha: 2025-08-05T15:53:11.884Z
 */

// --- Ruta: vitest.config.ts ---
export default defineConfig({ plugins: [svelte()], resolve: { alias: { $lib: path.resolve(__dirname, './src/lib') }, conditions: ['browser'] }, test: { environment: 'jsdom', include: ['src*.{test,spec}.{js,ts}'], exclude: ['e2e/**'] } });

// --- Ruta: vite.config.ts ---
export default defineConfig({ plugins: [tailwindcss(), sveltekit()], ssr: { noExternal: ['bits-ui', 'svelte-sonner'] }, server: { allowedHosts: [ 'dev.dev' ] } });

// --- Ruta: tsconfig.json ---
{ "extends": "./.svelte-kit/tsconfig.json", "compilerOptions": { "allowJs": true, "checkJs": true, "esModuleInterop": true, "forceConsistentCasingInFileNames": true, "resolveJsonModule": true, "skipLibCheck": true, "sourceMap": true, "strict": true, "moduleResolution": "bundler" } }

// --- Ruta: tailwind.config.ts ---
export default { darkMode: 'class', content: ['./src*.{html,js,svelte,ts}'], theme: { extend: { fontFamily: { sans: ['var(--font-sans)', ...defaultTheme.fontFamily.sans], heading: ['var(--font-heading)', ...defaultTheme.fontFamily.sans] } } }, plugins: [] } satisfies Config;

// --- Ruta: svelte.config.js ---
const config = { preprocess: vitePreprocess(), kit: { adapter: adapter() } }; export default config;

// --- Ruta: package.json ---
{ "name": "recetario", "private": true, "version": "0.0.1", "type": "module", "scripts": { "dev": "vite dev", "build": "vite build", "preview": "vite preview", "prepare": "svelte-kit sync || echo ''", "check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json", "check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch", "format": "prettier --write .", "lint": "prettier --check . && eslint .", "test:unit": "vitest", "test": "vitest run", "seed": "node scripts/seed.js" }, "prisma": { "seed": "node scripts/seed.js" }, "devDependencies": { "@eslint/compat": "^1.2.5", "@eslint/js": "^9.18.0", "@faker-js/faker": "^9.9.0", "@internationalized/date": "^3.8.2", "@lucide/svelte": "^0.515.0", "@sveltejs/adapter-auto": "^6.0.0", "@sveltejs/adapter-cloudflare": "^4.4.0", "@sveltejs/kit": "^2.22.0", "@sveltejs/vite-plugin-svelte": "^6.0.0", "@tailwindcss/vite": "^4.1.11", "@testing-library/svelte": "^5.2.8", "@types/bcryptjs": "^2.4.6", "@types/cheerio": "^0.22.35", "@types/dompurify": "^3.0.5", "@types/jsdom": "^21.1.7", "@types/marked": "^5.0.2", "@types/node": "^24.1.0", "autoprefixer": "^10.4.21", "bits-ui": "^2.8.13", "clsx": "^2.1.1", "eslint": "^9.18.0", "eslint-config-prettier": "^10.0.1", "eslint-plugin-svelte": "^3.0.0", "glob": "^11.0.3", "globals": "^16.0.0", "ignore": "^7.0.5", "jsdom": "^26.1.0", "postcss": "^8.5.6", "prettier": "^3.4.2", "prettier-plugin-svelte": "^3.3.3", "prettier-plugin-tailwindcss": "^0.6.5", "prisma": "^6.13.0", "shadcn-svelte": "^1.0.6", "svelte": "^5.0.0", "svelte-check": "^4.0.0", "tailwind-merge": "^3.3.1", "tailwind-variants": "^1.0.0", "tailwindcss": "^4.1.11", "tailwindcss-animate": "^1.0.7", "tw-animate-css": "^1.3.6", "typescript": "^5.0.0", "typescript-eslint": "^8.20.0", "vite": "^7.0.4", "vitest": "^3.2.3" }, "optionalDependencies": { "@cloudflare/workerd-darwin-64": "^1.20250726.0", "@cloudflare/workerd-linux-64": "^1.20250726.0", "@cloudflare/workerd-win32-64": "^1.20250726.0" }, "overrides": { "esbuild": "^0.20.2" }, "dependencies": { "@prisma/adapter-d1": "^6.13.0", "@prisma/client": "^6.13.0", "@thisux/sveltednd": "^0.0.20", "bcryptjs": "^3.0.2", "cheerio": "^1.1.2", "dompurify": "^3.2.6", "jose": "^6.0.12", "ky": "^1.8.2", "lucide-svelte": "^0.535.0", "marked": "^16.1.1", "mode-watcher": "^1.1.0", "sharp": "^0.34.3", "slugify": "^1.6.6", "svelte-sonner": "^1.0.5", "zod": "^4.0.14" } }

// --- Ruta: migration.sql ---
-- CreateTable CREATE TABLE "Product" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL, "brand" TEXT, "imageUrl" TEXT, "calories" REAL, "fat" REAL, "protein" REAL, "carbs" REAL, "fullPayload" JSONB, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL ); -- CreateTable CREATE TABLE "CustomIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL, "calories" REAL NOT NULL, "fat" REAL NOT NULL, "protein" REAL NOT NULL, "carbs" REAL NOT NULL ); -- CreateTable CREATE TABLE "Recipe" ( "id" TEXT NOT NULL PRIMARY KEY, "title" TEXT NOT NULL, "normalizedTitle" TEXT NOT NULL, "steps" JSONB NOT NULL, "imageUrl" TEXT ); -- CreateTable CREATE TABLE "RecipeUrl" ( "id" TEXT NOT NULL PRIMARY KEY, "url" TEXT NOT NULL, "recipeId" TEXT NOT NULL, CONSTRAINT "RecipeUrl_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "RecipeIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "recipeId" TEXT NOT NULL, "productId" TEXT, "customIngredientId" TEXT, "quantity" REAL NOT NULL, CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "RecipeIngredient_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product" ("id") ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT "RecipeIngredient_customIngredientId_fkey" FOREIGN KEY ("customIngredientId") REFERENCES "CustomIngredient" ("id") ON DELETE SET NULL ON UPDATE CASCADE ); -- CreateIndex CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name"); -- CreateIndex CREATE UNIQUE INDEX "RecipeUrl_recipeId_url_key" ON "RecipeUrl"("recipeId", "url");

// --- Ruta: eslint.config.js ---
const gitignorePath = fileURLToPath(new URL('./.gitignore', import.meta.url)); export default ts.config( includeIgnoreFile(gitignorePath), js.configs.recommended, ...ts.configs.recommended, ...svelte.configs.recommended, prettier, ...svelte.configs.prettier, { languageOptions: { globals: { ...globals.browser, ...globals.node } }, rules: { 'no-undef': 'off' } }, { files: ['***.svelte.ts', '**/*.svelte.js'], languageOptions: { parserOptions: { projectService: true, extraFileExtensions: ['.svelte'], parser: ts.parser, svelteConfig } } } );

// --- Ruta: components.json ---
{ "$schema": "https: "tailwind": { "css": "src/app.css", "baseColor": "slate" }, "aliases": { "components": "$lib/components", "utils": "$lib/utils", "ui": "$lib/components/ui", "hooks": "$lib/hooks", "lib": "$lib" }, "typescript": true, "registry": "https: }

// --- Ruta: .prettierrc ---
{ "useTabs": true, "singleQuote": true, "trailingComma": "none", "printWidth": 100, "plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"], "overrides": [ { "files": "*.svelte", "options": { "parser": "svelte" } } ], "tailwindStylesheet": "./src/app.css" }

// --- Ruta: .prettierignore ---
# Package Managers package-lock.json pnpm-lock.yaml yarn.lock bun.lock bun.lockb # Miscellaneous /static/

// --- Ruta: .npmrc ---
engine-strict=true

// --- Ruta: .env.test ---
# Fichero: .env.test # Justificación: Este fichero de entorno es cargado automáticamente por Vitest. # Define la URL de la base de datos para que apunte a un fichero separado, # aislando completamente los tests de la base de datos de desarrollo. DATABASE_URL="file:./test.db"

// --- Ruta: src/hooks.server.ts ---
export const handle: Handle = async ({ event, resolve }) => { const token = event.cookies.get('session'); event.locals.user = token ? await verifyToken(token) : null; const { pathname } = event.url; if (event.locals.user?.isAdmin) { return resolve(event); } const isPublicRoute = pathname === '/' || pathname === '/login' || (pathname.startsWith('/recetas') && !pathname.endsWith('/editar') && pathname !== '/recetas/nueva') || (pathname.startsWith('/api/recipes') && event.request.method === 'GET'); if (!isPublicRoute) { throw redirect(303, `/login?redirectTo=${pathname}`); } return resolve(event); };

// --- Ruta: src/demo.spec.ts ---
describe('sum test', () => { it('adds 1 + 2 to equal 3', () => { expect(1 + 2).toBe(3); }); });

// --- Ruta: src/app.html ---
<!doctype html> <html lang="en"> <head> <meta charset="utf-8" /> <link rel="icon" href="%sveltekit.assets%/favicon.svg" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <script> (() => { const theme = localStorage.getItem('theme') ?? 'system'; if (theme === 'system') { const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; document.documentElement.classList.toggle('dark', systemTheme === 'dark'); return; } document.documentElement.classList.toggle('dark', theme === 'dark'); })(); </script> <!-- Google Fonts --> <link rel="preconnect" href="https: <link rel="preconnect" href="https: <link href="https: rel="stylesheet" /> %sveltekit.head% </head> <body data-sveltekit-preload-data="hover"> <div style="display: contents">%sveltekit.body%</div> </body> </html>

// --- Ruta: src/app.d.ts ---
declare global { namespace App { interface Locals { user: { sub: string; isAdmin: boolean; } | null; } } } export {};

// --- Ruta: scripts/seed.js ---
const prisma = new PrismaClient(); const SEARCH_TERMS_FOR_SEEDING = [ 'Atún claro Hacendado', 'Tortiglioni Hacendado', 'Yogur Griego Hacendado', 'Aceite de Oliva Virgen Extra Hacendado', 'Leche Entera Hacendado', 'Galletas María Hacendado', 'Huevos L Hacendado', 'Arroz Redondo Hacendado', 'Pechuga de Pollo Hacendado', 'Mantequilla sin Sal Hacendado', 'Pavo en Lonchas Hacendado', 'Queso Curado Hacendado', 'Tomate Frito Hacendado', 'Mayonesa Hacendado', 'Mostaza Dijon Hacendado', 'Jamón Serrano Hacendado', 'Lenteja Pardina Hacendado', 'Garbanzo Pedrosillano Hacendado', 'Zumo de Naranja Hacendado', 'Pan de Molde Hacendado', 'Cereales de Avena Hacendado', 'Chocolate Negro 85% Hacendado', 'Café Molido Hacendado', 'Guisantes Finos Hacendado', 'Salmón Ahumado Hacendado' ]; async function fetchAndCreateProduct(searchTerm) { console.log(`[OFF] Buscando producto para el término: "${searchTerm}"...`); const searchUrl = `https: searchTerm )} &search_simple=1&action=process&json=1&page_size=5`; try { const response = await fetch(searchUrl); if (!response.ok) { throw new Error(`La API de OFF devolvió el estado ${response.status}`); } const data = await response.json(); const productData = data.products.find((p) => { const nutriments = p.nutriments; return ( p.code && p.product_name && p.image_url && nutriments && nutriments['energy-kcal_100g'] && nutriments.proteins_100g && nutriments.fat_100g && nutriments.carbohydrates_100g ); }); if (!productData) { console.warn(`-> [ADVERTENCIA] No se encontró un producto válido para "${searchTerm}".`); return null; } const barcode = productData.code; console.log(`-> [INFO] Producto encontrado: "${productData.product_name}" (${barcode})`); const existingProduct = await prisma.product.findUnique({ where: { id: barcode } }); if (existingProduct) { console.log(`-> [CACHE] El producto "${existingProduct.name}" ya existe. Omitiendo.`); return existingProduct; } const newProduct = { id: barcode, name: productData.product_name, normalizedName: productData.product_name.toLowerCase(), isNameManuallySet: false, brand: productData.brands || 'Marca no especificada', imageUrl: productData.image_url, calories: productData.nutriments['energy-kcal_100g'] || 0, protein: productData.nutriments.proteins_100g || 0, fat: productData.nutriments.fat_100g || 0, carbs: productData.nutriments.carbohydrates_100g || 0, fullPayload: productData }; const createdProduct = await prisma.product.create({ data: newProduct }); console.log(`-> [ÉXITO] Producto "${createdProduct.name}" guardado en la base de datos.`); return createdProduct; } catch (error) { console.error(`-> [ERROR] Fallo al procesar "${searchTerm}":`, error.message); return null; } } const BASE_INGREDIENTS = [ 'Pollo', 'Ternera', 'Salmón', 'Lentejas', 'Garbanzos', 'Arroz', 'Quinoa', 'Patata', 'Brócoli', 'Espinacas', 'Tomate', 'Cebolla', 'Ajo', 'Pimiento', 'Zanahoria', 'Calabacín', 'Champiñón', 'Huevo', 'Harina de Trigo', 'Azúcar', 'Sal', 'Pimienta Negra', 'Pimentón Dulce', 'Orégano', 'Perejil Fresco' ]; function createMarkdownSteps() { const numSteps = faker.number.int({ min: 3, max: 6 }); const steps = []; for (let i = 0; i < numSteps; i++) { let stepText = faker.lorem.sentence(); if (Math.random() > 0.5) { const wordToEmphasize = faker.helpers.arrayElement(stepText.split(' ')); const markdownType = Math.random() > 0.5 ? '**' : '*'; stepText = stepText.replace(wordToEmphasize, `${markdownType}${wordToEmphasize}${markdownType}`); } steps.push(stepText); } return steps; } const delay = (ms) => new Promise((res) => setTimeout(res, ms)); async function main() { console.log('--- Limpiando la base de datos... ---'); await prisma.recipeIngredient.deleteMany(); await prisma.recipeUrl.deleteMany(); await prisma.recipe.deleteMany(); await prisma.customIngredient.deleteMany(); await prisma.product.deleteMany(); console.log('✅ Base de datos limpia.'); console.log('\n--- Fase 1: Poblando productos desde OpenFoodFacts... ---'); const productPromises = SEARCH_TERMS_FOR_SEEDING.map(fetchAndCreateProduct); const seededProducts = (await Promise.all(productPromises)).filter(p => p !== null); console.log(`✅ Fase 1 completada. ${seededProducts.length} productos de OFF procesados.`); console.log('\n--- Fase 2: Creando ingredientes personalizados... ---'); const customIngredients = []; for (const name of BASE_INGREDIENTS) { const ingredient = await prisma.customIngredient.create({ data: { name: name, normalizedName: name.toLowerCase(), calories: parseFloat(faker.number.float({ min: 50, max: 500, precision: 0.1 }).toFixed(1)), protein: parseFloat(faker.number.float({ min: 0, max: 30, precision: 0.1 }).toFixed(1)), fat: parseFloat(faker.number.float({ min: 0, max: 50, precision: 0.1 }).toFixed(1)), carbs: parseFloat(faker.number.float({ min: 0, max: 100, precision: 0.1 }).toFixed(1)) } }); customIngredients.push(ingredient); } console.log(`✅ Fase 2 completada. ${customIngredients.length} ingredientes personalizados creados.`); console.log('\n--- Fase 3: Creando recetas de prueba... ---'); const allAvailableIngredients = [ ...seededProducts.map((p) => ({ id: p.id, type: 'product', name: p.name })), ...customIngredients.map((c) => ({ id: c.id, type: 'custom', name: c.name })) ]; const usedSlugs = new Set(); for (let i = 0; i < 200; i++) { const mainIngredient = faker.helpers.arrayElement(allAvailableIngredients); const recipeTitle = `${mainIngredient.name} ${faker.food.adjective()}`; const baseSlug = slugify(recipeTitle, { lower: true, strict: true }); let finalSlug = baseSlug; let counter = 2; while (usedSlugs.has(finalSlug)) { finalSlug = `${baseSlug}-${counter}`; counter++; } usedSlugs.add(finalSlug); const otherIngredients = allAvailableIngredients.filter((ing) => ing.id !== mainIngredient.id); const secondaryIngredients = faker.helpers.arrayElements( otherIngredients, faker.number.int({ min: 2, max: 5 }) ); const recipeIngredients = [mainIngredient, ...secondaryIngredients]; const imageUrl = `https: console.log(`[RECETA ${i + 1}/200] Creando: "${recipeTitle}" (slug: ${finalSlug})...`); await prisma.recipe.create({ data: { title: recipeTitle, slug: finalSlug, normalizedTitle: recipeTitle.toLowerCase(), steps: createMarkdownSteps(), imageUrl: imageUrl, urls: { create: [{ url: faker.internet.url() }] }, ingredients: { create: recipeIngredients.map((ing) => ({ productId: ing.type === 'product' ? ing.id : undefined, customIngredientId: ing.type === 'custom' ? ing.id : undefined, quantity: parseFloat(faker.number.float({ min: 50, max: 500, precision: 1 }).toFixed(1)) })) } } }); await delay(200); } console.log('✅ Fase 3 completada. 200 recetas creadas.'); } main() .catch((e) => { console.error(e); process.exit(1); }) .finally(async () => { await prisma.$disconnect(); console.log('\n🎉 ¡Seeding completado con éxito! La base de datos está lista para usar.'); });

// --- Ruta: scripts/hash-password.js ---
const password = process.argv[2]; if (!password) { console.error('Por favor, proporciona una contraseña como argumento.'); process.exit(1); } const SALT_ROUNDS = 10; hash(password, SALT_ROUNDS).then((hash) => { console.log('Contraseña:', password); console.log('Hash:', hash); console.log('\nCopia este hash en tu fichero .env como ADMIN_PASSWORD_HASH'); });

// --- Ruta: prisma/schema.prisma ---
generator client { provider = "prisma-client-js" } datasource db { provider = "sqlite" url = env("DATABASE_URL") } model Product { id String @id name String normalizedName String isNameManuallySet Boolean @default(false) brand String? imageUrl String? calories Float? fat Float? protein Float? carbs Float? fullPayload Json? createdAt DateTime @default(now()) updatedAt DateTime @updatedAt recipeIngredients RecipeIngredient[] } model CustomIngredient { id String @id @default(cuid()) name String @unique normalizedName String calories Float fat Float protein Float carbs Float recipeIngredients RecipeIngredient[] } model Recipe { id String @id @default(cuid()) title String slug String @unique normalizedTitle String steps Json imageUrl String? ingredients RecipeIngredient[] urls RecipeUrl[] } model RecipeUrl { id String @id @default(cuid()) url String recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade) recipeId String @@unique([recipeId, url]) } model RecipeIngredient { id String @id @default(cuid()) recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade) recipeId String product Product? @relation(fields: [productId], references: [id]) productId String? customIngredient CustomIngredient? @relation(fields: [customIngredientId], references: [id]) customIngredientId String? quantity Float }

// --- Ruta: src/routes/page.server.spec.ts ---
vi.mock('$lib/server/services/recipeService'); type PageServerLoadEvent = Parameters<typeof load>[0]; type ActionEvent = Parameters<typeof actions.delete>[0]; type Recipes = Awaited<ReturnType<typeof recipeService.findPaginated>>; interface LoadResult { recipes: Recipes; hasMore: boolean; } describe('+page.server', () => { beforeEach(() => { vi.resetAllMocks(); }); describe('load', () => { it('should call findPaginated and return recipes with hasMore: true', async () => { const mockRecipes = Array(51).fill({ id: '1', title: 'Receta' }); vi.mocked(recipeService.findPaginated).mockResolvedValue(mockRecipes as Recipes); const result = (await load({} as unknown as PageServerLoadEvent)) as LoadResult; expect(recipeService.findPaginated).toHaveBeenCalledWith(null, 51, 0); expect(result.recipes).toHaveLength(50); expect(result.hasMore).toBe(true); }); it('should call findPaginated and return recipes with hasMore: false', async () => { const mockRecipes = Array(30).fill({ id: '1', title: 'Receta' }); vi.mocked(recipeService.findPaginated).mockResolvedValue(mockRecipes as Recipes); const result = (await load({} as unknown as PageServerLoadEvent)) as LoadResult; expect(recipeService.findPaginated).toHaveBeenCalledWith(null, 51, 0); expect(result.recipes).toHaveLength(30); expect(result.hasMore).toBe(false); }); }); describe('actions.delete', () => { beforeEach(() => { vi.spyOn(console, 'error').mockImplementation(() => {}); }); afterEach(() => { vi.mocked(console.error).mockRestore(); }); it('should call recipeService.deleteById with the correct id on success', async () => { const formData = new FormData(); formData.append('id', 'recipe-to-delete'); const mockRequest = { formData: async () => formData }; await actions.delete({ request: mockRequest } as unknown as ActionEvent); expect(recipeService.deleteById).toHaveBeenCalledWith('recipe-to-delete'); }); it('should return a 400 fail if the id is missing', async () => { const formData = new FormData(); const mockRequest = { formData: async () => formData }; const result = await actions.delete({ request: mockRequest } as unknown as ActionEvent); expect(recipeService.deleteById).not.toHaveBeenCalled(); expect(result).toEqual(fail(400, { message: 'ID de receta no válido' })); }); it('should return a 500 fail if recipeService.deleteById throws an error', async () => { const formData = new FormData(); formData.append('id', 'recipe-that-fails'); const mockRequest = { formData: async () => formData }; const testError = new Error('Database connection failed'); vi.mocked(recipeService.deleteById).mockRejectedValue(testError); const result = await actions.delete({ request: mockRequest } as unknown as ActionEvent); expect(recipeService.deleteById).toHaveBeenCalledWith('recipe-that-fails'); expect(result).toEqual( fail(500, { message: 'No se pudo eliminar la receta. Por favor, inténtelo de nuevo.' }) ); }); }); });

// --- Ruta: src/routes/+page.svelte ---
<!-- --> <script lang="ts"> import RecipeCard from '$lib/components/recipes/RecipeCard.svelte'; import EditQuantitiesDialog from '$lib/components/recipes/EditQuantitiesDialog.svelte'; import DeleteRecipeDialog from '$lib/components/recipes/DeleteRecipeDialog.svelte'; import { Button } from '$lib/components/ui/button/index.js'; import { Input } from '$lib/components/ui/input/index.js'; import Plus from 'lucide-svelte/icons/plus'; import SlidersHorizontal from 'lucide-svelte/icons/sliders-horizontal'; import { fade } from 'svelte/transition'; import { flip } from 'svelte/animate'; const RECIPES_PER_PAGE = 50; let { data } = $props(); type Recipe = (typeof data.recipes)[number]; let recipes = $state(data.recipes); let searchQuery = $state(''); let isLoading = $state(false); let hasMore = $state(data.hasMore); let sentinel: HTMLDivElement | undefined = $state(); let controller: AbortController; let selectedRecipe = $state<Recipe | null>(null); let isEditDialogOpen = $state(false); let isDeleteDialogOpen = $state(false); const isAdmin = $derived(!!data.user?.isAdmin); async function fetchRecipes(isNewSearch = false) { if (isLoading && !isNewSearch) return; isLoading = true; const offset = isNewSearch ? 0 : recipes.length; if (isNewSearch) { controller?.abort(); controller = new AbortController(); } const signal = controller?.signal; const url = `/api/recipes?q=${encodeURIComponent(searchQuery)}&limit=${RECIPES_PER_PAGE}&offset=${offset}`; try { const response = await fetch(url, { signal }); const result = await response.json(); if (signal?.aborted) return; if (isNewSearch) { recipes = result.recipes; } else { recipes.push(...result.recipes); } hasMore = result.hasMore; } catch (error) { if (error instanceof DOMException && error.name === 'AbortError') { return; } console.error('Error al cargar recetas:', error); } finally { if (!signal?.aborted) { isLoading = false; } } } $effect(() => { searchQuery; const handler = setTimeout(() => { fetchRecipes(true); }, 300); return () => clearTimeout(handler); }); $effect(() => { if (!sentinel) return; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting && hasMore && !isLoading) { fetchRecipes(); } }); observer.observe(sentinel); return () => observer.disconnect(); }); function handleOpenEditDialog(recipe: Recipe) { selectedRecipe = recipe; isEditDialogOpen = true; } function handleOpenDeleteDialog(recipe: Recipe) { selectedRecipe = recipe; isDeleteDialogOpen = true; } </script> <div class="container mx-auto p-4 md:p-8"> <header class="flex items-center justify-between gap-2 mb-8"> <div class="relative flex-grow"> <Input bind:value={searchQuery} placeholder="Buscar por receta o ingrediente..." /> </div> <Button href="/recetas/busqueda-avanzada" variant="ghost" size="icon" aria-label="Búsqueda avanzada"> <SlidersHorizontal class="h-4 w-4" /> </Button> <Button href="/recetas/nueva"> <Plus class="mr-2 h-4 w-4" /> Añadir Receta </Button> </header> <main class="columns-1 md:columns-2 lg:columns-3 xl:columns-4 gap-4"> {#each recipes as recipe, i (recipe.id)} <div class="mb-4 break-inside-avoid"> <RecipeCard {recipe} {isAdmin} onEditQuantities={() => handleOpenEditDialog(recipe)} onDelete={() => handleOpenDeleteDialog(recipe)} /> </div> {/each} </main> {#if hasMore} <div bind:this={sentinel} class="h-10 flex justify-center items-center text-muted-foreground"> {#if isLoading} <span>Cargando...</span> {/if} </div> {/if} {#if recipes.length === 0 && !isLoading} <div class="col-span-full text-center py-16 text-muted-foreground"> <p class="text-lg font-medium">No se encontraron recetas.</p> <p>Prueba con otro término de búsqueda o añade una nueva receta.</p> </div> {/if} </div> <EditQuantitiesDialog recipe={selectedRecipe} bind:open={isEditDialogOpen} onOpenChange={(isOpen: boolean) => (isEditDialogOpen = isOpen)} /> <DeleteRecipeDialog recipe={selectedRecipe} bind:open={isDeleteDialogOpen} onOpenChange={(isOpen: boolean) => (isDeleteDialogOpen = isOpen)} />

// --- Ruta: src/routes/+page.server.ts ---
const RECIPES_PER_PAGE = 50; export const load: PageServerLoad = async () => { const recipesPlusOne = await recipeService.findPaginated(null, RECIPES_PER_PAGE + 1, 0); const hasMore = recipesPlusOne.length > RECIPES_PER_PAGE; const recipes = recipesPlusOne.slice(0, RECIPES_PER_PAGE); return { recipes, hasMore }; }; export const actions: Actions = { logout: async ({ cookies }) => { cookies.delete('session', { path: '/' }); throw redirect(303, '/'); }, delete: async ({ request }) => { const data = await request.formData(); const id = data.get('id'); if (typeof id !== 'string' || !id) { return fail(400, { message: 'ID de receta no válido' }); } try { await recipeService.deleteById(id); return { status: 200, message: 'Receta eliminada correctamente' }; } catch (error) { console.error('Error al eliminar la receta:', error); return fail(500, { message: 'No se pudo eliminar la receta. Por favor, inténtelo de nuevo.' }); } } };

// --- Ruta: src/routes/+layout.svelte ---
<script lang="ts"> import { browser } from '$app/environment'; import { themeStore } from '$lib/stores/theme.svelte'; import '../app.css'; import ThemeToggle from '$lib/components/ThemeToggle.svelte'; import type { Snippet } from 'svelte'; import { Wrench, LogOut, LogIn } from 'lucide-svelte'; import * as Tooltip from '$lib/components/ui/tooltip'; import { buttonVariants } from '$lib/components/ui/button'; import { cn } from '$lib/utils'; import { Toaster, toast } from 'svelte-sonner'; import { enhance } from '$app/forms'; import { page } from '$app/stores'; import { fade } from 'svelte/transition'; let { children, data }: { children: Snippet; data: any } = $props(); $effect(() => { if (!browser) return; const currentTheme = themeStore.value; localStorage.setItem('theme', currentTheme); const applyTheme = () => { const themeToApply = currentTheme === 'system' ? window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light' : currentTheme; document.documentElement.classList.toggle('dark', themeToApply === 'dark'); }; applyTheme(); const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)'); const systemThemeListener = () => { if (currentTheme === 'system') { applyTheme(); } }; mediaQuery.addEventListener('change', systemThemeListener); return () => { mediaQuery.removeEventListener('change', systemThemeListener); }; }); $effect(() => { if (data.flash) { toast.success(data.flash); } }); </script> <Tooltip.Provider> <div class="min-h-screen bg-background font-sans text-foreground antialiased"> <div class="fixed bottom-4 right-4 z-50 flex flex-col items-center gap-4"> {#if data.user} {#if data.user.isAdmin} <form action="/?/logout" method="POST" use:enhance={() => { const toastId = toast.loading('Cerrando sesión...'); return async ({ update }) => { await update(); toast.success('Sesión cerrada correctamente.', { id: toastId }); }; }} > <Tooltip.Root> <Tooltip.Trigger type="submit" class={cn(buttonVariants({ variant: 'outline', size: 'icon' }))} aria-label="Cerrar sesión" > <LogOut class="h-[1.2rem] w-[1.2rem]" /> </Tooltip.Trigger> <Tooltip.Content> <p>Cerrar sesión</p> </Tooltip.Content> </Tooltip.Root> </form> <Tooltip.Root> <Tooltip.Trigger> {#snippet child({ props })} <a href="/admin/ingredientes" class={cn(buttonVariants({ variant: 'outline', size: 'icon' }))} aria-label="Administrar ingredientes" {...props} > <Wrench class="h-[1.2rem] w-[1.2rem]" /> </a> {/snippet} </Tooltip.Trigger> <Tooltip.Content> <p>Administrar ingredientes</p> </Tooltip.Content> </Tooltip.Root> {/if} {:else} <Tooltip.Root> <Tooltip.Trigger> {#snippet child({ props })} <a href="/login" class={cn(buttonVariants({ variant: 'outline', size: 'icon' }))} aria-label="Iniciar sesión" {...props} > <LogIn class="h-[1.2rem] w-[1.2rem]" /> </a> {/snippet} </Tooltip.Trigger> <Tooltip.Content> <p>Iniciar sesión</p> </Tooltip.Content> </Tooltip.Root> {/if} <ThemeToggle /> </div> {#key $page.url.pathname} <div transition:fade={{ duration: 200 }}> {@render children()} </div> {/key} <Toaster richColors closeButton /> </div> </Tooltip.Provider>

// --- Ruta: src/routes/+layout.server.ts ---
export const load: LayoutServerLoad = async ({ locals, cookies }) => { const flash = cookies.get('flash_message'); if (flash) { cookies.delete('flash_message', { path: '/' }); } return { user: locals.user, theme: cookies.get('theme'), flash }; };

// --- Ruta: src/lib/utils.ts ---
export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)); } export function normalizeText(text: string): string { return text .toLowerCase() .normalize('NFD') .replace(/[\u0300-\u036f]/g, ''); } export type WithoutChild<T> = T extends { child?: any } ? Omit<T, 'child'> : T; export type WithoutChildren<T> = T extends { children?: any } ? Omit<T, 'children'> : T; export type WithoutChildrenOrChild<T> = WithoutChildren<WithoutChild<T>>; export type WithElementRef<T, U extends HTMLElement = HTMLElement> = T & { ref?: U | null };

// --- Ruta: src/lib/recipeCalculator.ts ---
export type CalculableIngredient = { quantity: number; calories?: number | null; protein?: number | null; fat?: number | null; carbs?: number | null; }; export type NutritionalInfo = { totalCalories: number; totalProtein: number; totalFat: number; totalCarbs: number; }; export function calculateNutritionalInfo(ingredients: CalculableIngredient[]): NutritionalInfo { const totals: NutritionalInfo = { totalCalories: 0, totalProtein: 0, totalFat: 0, totalCarbs: 0 }; for (const ingredient of ingredients) { const factor = ingredient.quantity / 100; totals.totalCalories += (ingredient.calories || 0) * factor; totals.totalProtein += (ingredient.protein || 0) * factor; totals.totalFat += (ingredient.fat || 0) * factor; totals.totalCarbs += (ingredient.carbs || 0) * factor; } return { totalCalories: Math.round(totals.totalCalories * 100) / 100, totalProtein: Math.round(totals.totalProtein * 100) / 100, totalFat: Math.round(totals.totalFat * 100) / 100, totalCarbs: Math.round(totals.totalCarbs * 100) / 100 }; }

// --- Ruta: src/lib/recipeCalculator.spec.ts ---
describe('calculateNutritionalInfo', () => { it('should calculate totals correctly for a list of standard ingredients', () => { const ingredients: CalculableIngredient[] = [ { quantity: 150, calories: 100, protein: 10, fat: 5, carbs: 20 }, { quantity: 50, calories: 200, protein: 2, fat: 1, carbs: 40 } ]; const result = calculateNutritionalInfo(ingredients); expect(result.totalCalories).toBe(150 + 100); expect(result.totalProtein).toBe(15 + 1); expect(result.totalFat).toBe(7.5 + 0.5); expect(result.totalCarbs).toBe(30 + 20); }); it('should return all zeros when the ingredient list is empty', () => { const ingredients: CalculableIngredient[] = []; const result = calculateNutritionalInfo(ingredients); expect(result.totalCalories).toBe(0); expect(result.totalProtein).toBe(0); expect(result.totalFat).toBe(0); expect(result.totalCarbs).toBe(0); }); it('should treat null or undefined nutritional values as zero', () => { const ingredients: CalculableIngredient[] = [ { quantity: 100, calories: 100, protein: 10, fat: null, carbs: 20 }, { quantity: 100, calories: 50, protein: 5, fat: 5, carbs: undefined } ]; const result = calculateNutritionalInfo(ingredients); expect(result.totalCalories).toBe(150); expect(result.totalProtein).toBe(15); expect(result.totalFat).toBe(5); expect(result.totalCarbs).toBe(20); }); it('should contribute nothing to the totals if an ingredient has zero quantity', () => { const ingredients: CalculableIngredient[] = [ { quantity: 100, calories: 100, protein: 10, fat: 10, carbs: 10 }, { quantity: 0, calories: 1000, protein: 100, fat: 100, carbs: 100 } ]; const result = calculateNutritionalInfo(ingredients); expect(result.totalCalories).toBe(100); expect(result.totalProtein).toBe(10); expect(result.totalFat).toBe(10); expect(result.totalCarbs).toBe(10); }); it('should handle floating point numbers correctly and round to 2 decimal places', () => { const ingredients: CalculableIngredient[] = [ { quantity: 125.5, calories: 88.5, protein: 5.25, fat: 2.75, carbs: 10.5 } ]; const result = calculateNutritionalInfo(ingredients); expect(result.totalCalories).toBe(111.07); expect(result.totalProtein).toBe(6.59); expect(result.totalFat).toBe(3.45); expect(result.totalCarbs).toBe(13.18); }); });

// --- Ruta: prisma/migrations/migration_lock.toml ---
# Please do not edit this file manually # It should be added in your version-control system (e.g., Git) provider = "sqlite"

// --- Ruta: src/routes/login/+page.svelte ---
<!-- Ruta: src/routes/login/+page.svelte --> <script lang="ts"> import { enhance } from '$app/forms'; import type { ActionData } from './$types'; import * as Card from '$lib/components/ui/card'; import { Button } from '$lib/components/ui/button'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; export let form: ActionData; let loading = false; </script> <div class="flex min-h-screen items-center justify-center bg-muted/40"> <Card.Root class="w-full max-w-sm"> <Card.Header class="space-y-1 text-center"> <Card.Title class="text-2xl font-bold">Admin Login</Card.Title> <Card.Description>Introduce tus credenciales para acceder al panel</Card.Description> </Card.Header> <Card.Content> <!-- Justificación (form action y enhance): Se usa un <form> estándar con un `action` que apunta a la acción por defecto de esta misma página (`?/default`). `use:enhance` intercepta el envío, lo hace vía fetch, y maneja el resultado (actualizar `form`, redirigir, etc.) de forma automática y robusta. --> <form method="POST" action="?/login" use:enhance={() => { loading = true; return async ({ update }) => { await update(); loading = false; }; }} class="space-y-4" > <div class="space-y-2"> <Label for="user">Usuario</Label> <Input id="user" name="user" type="text" required /> </div> <div class="space-y-2"> <Label for="password">Contraseña</Label> <Input id="password" name="password" type="password" required /> </div> {#if form?.message} <p class="text-sm font-medium text-destructive">{form.message}</p> {/if} <Button type="submit" class="w-full" disabled={loading}> {loading ? 'Entrando...' : 'Entrar'} </Button> </form> </Card.Content> </Card.Root> </div>

// --- Ruta: src/routes/login/+page.server.ts ---
export const actions: Actions = { login: async ({ request, cookies }) => { const data = await request.formData(); const user = data.get('user'); const password = data.get('password'); if (!user || !password || typeof user !== 'string' || typeof password !== 'string') { return fail(400, { message: 'Usuario y contraseña son requeridos' }); } if (!env.ADMIN_PASSWORD_HASH) { console.error('La variable de entorno ADMIN_PASSWORD_HASH no está configurada.'); return fail(500, { message: 'Error de configuración en el servidor' }); } const isAdminUser = user === 'juanjocerero'; const isPasswordValid = await comparePasswords(password, env.ADMIN_PASSWORD_HASH); if (!isAdminUser || !isPasswordValid) { return fail(401, { message: 'Credenciales inválidas' }); } const token = await createSessionToken({ sub: 'admin' }); cookies.set('session', token, { path: '/', httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'strict', maxAge: 60 * 60 * 24 }); cookies.set('flash_message', '¡Bienvenido de nuevo!', { path: '/' }); throw redirect(303, '/'); } };

// --- Ruta: src/lib/stores/theme.svelte.ts ---
type Theme = 'light' | 'dark' | 'system'; const initialTheme: Theme = browser ? (localStorage.getItem('theme') as Theme) ?? 'system' : 'system'; let theme = $state<Theme>(initialTheme); export const themeStore = { get value() { return theme; }, set(newTheme: Theme) { theme = newTheme; } };

// --- Ruta: src/lib/server/zodErrors.ts ---
export function createFailResponse(message: string, error?: ZodError) { const response: { message: string; errors: Record<string, string | undefined> } = { message, errors: {} }; if (error) { for (const issue of error.issues) { if (issue.path.length > 0) { const field = issue.path.join('.'); if (!response.errors[field]) { response.errors[field] = issue.message; } } } } return response; }

// --- Ruta: src/lib/server/slug.ts ---
export async function generateUniqueSlug(title: string): Promise<string> { const baseSlug = slugify(title, { lower: true, strict: true }); let uniqueSlug = baseSlug; let counter = 2; while (await prisma.recipe.findUnique({ where: { slug: uniqueSlug } })) { uniqueSlug = `${baseSlug}-${counter}`; counter++; } return uniqueSlug; }

// --- Ruta: src/lib/server/prisma.ts ---
const prisma = new PrismaClient(); export default prisma;

// --- Ruta: src/lib/server/auth.ts ---
const SALT_ROUNDS = 10; export async function hashPassword(password: string) { return await hash(password, SALT_ROUNDS); } export async function comparePasswords(password: string, hash: string) { return await compare(password, hash); } if (!env.SESSION_SECRET) { throw new Error( 'La variable de entorno SESSION_SECRET no está configurada. La aplicación no puede iniciarse de forma segura.' ); } const secret = new TextEncoder().encode(env.SESSION_SECRET); const algorithm = 'HS256'; export async function createSessionToken(payload: { sub: string; [key: string]: unknown }) { return await new SignJWT(payload) .setProtectedHeader({ alg: algorithm }) .setExpirationTime('24h') .setIssuedAt() .setSubject(payload.sub) .sign(secret); } export async function verifyToken(token: string) { try { const { payload } = await jwtVerify(token, secret, { algorithms: [algorithm] }); if (!payload.sub) { return null; } const user = { sub: payload.sub, isAdmin: payload.sub === 'admin' }; return user; } catch { return null; } }

// --- Ruta: src/lib/schemas/searchSchema.ts ---
const RangeFilterSchema = z.object({ min: z.coerce.number().optional(), max: z.coerce.number().optional() }); const GramsFilterSchema = z.object({ calories: RangeFilterSchema.optional(), protein: RangeFilterSchema.optional(), carbs: RangeFilterSchema.optional(), fat: RangeFilterSchema.optional() }); const PercentFilterSchema = z.object({ protein: RangeFilterSchema.optional(), carbs: RangeFilterSchema.optional(), fat: RangeFilterSchema.optional() }); export const SearchFiltersSchema = z.object({ ingredients: z.array(z.string()).optional(), grams: GramsFilterSchema.optional(), percent: PercentFilterSchema.optional(), sortBy: z.string().optional(), limit: z.coerce.number().default(50), offset: z.coerce.number().default(0) }); export type SearchFilters = z.infer<typeof SearchFiltersSchema>;

// --- Ruta: src/lib/schemas/recipeSchema.ts ---
const RecipeIngredientSchema = z.object({ id: z.string(), type: z.enum(['product', 'custom']), quantity: z.coerce.number().positive({ message: 'La cantidad debe ser mayor que cero.' }) }); export const RecipeSchema = z.object({ title: z.string().min(1, { message: 'El título no puede estar vacío.' }), steps: z .array(z.string().min(1, { message: 'El paso no puede estar vacío.' })) .min(1, { message: 'Debe haber al menos un paso.' }), ingredients: z .array(RecipeIngredientSchema) .min(1, { message: 'La receta debe tener al menos un ingrediente.' }), imageUrl: z.string().optional(), urls: z.array(z.string().url({ message: 'La URL no es válida.' })).optional() }); export type RecipeIngredient = z.infer<typeof RecipeIngredientSchema>; export type RecipeData = z.infer<typeof RecipeSchema>;

// --- Ruta: src/lib/schemas/ingredientSchema.ts ---
export const IngredientSchema = z.object({ name: z.string().min(1, { message: 'El nombre no puede estar vacío.' }), calories: z.coerce.number().min(0, { message: 'Las calorías no pueden ser negativas.' }), fat: z.coerce.number().min(0, { message: 'La grasa no puede ser negativa.' }), protein: z.coerce.number().min(0, { message: 'La proteína no puede ser negativa.' }), carbs: z.coerce.number().min(0, { message: 'Los carbohidratos no pueden ser negativos.' }) }); export type Ingredient = z.infer<typeof IngredientSchema>;

// --- Ruta: src/lib/runes/useDebounce.svelte.ts ---
export function useDebounce<T>(value: () => T, delay: number): () => T { let debouncedValue = $state(value()); let timeoutId: ReturnType<typeof setTimeout> | null = null; $effect(() => { const currentValue = value(); if (timeoutId) { clearTimeout(timeoutId); } timeoutId = setTimeout(() => { debouncedValue = currentValue; }, delay); return () => { if (timeoutId) { clearTimeout(timeoutId); } }; }); return () => debouncedValue; }

// --- Ruta: src/lib/runes/useAutosave.ts ---
export function hasData(key: string): boolean { if (!browser) return false; return localStorage.getItem(key) !== null; } export function load<T>(key: string): T | null { if (!browser) return null; const savedData = localStorage.getItem(key); if (!savedData) return null; try { return JSON.parse(savedData) as T; } catch (e) { console.error('Failed to parse autosaved data from localStorage', e); return null; } } export function save(key: string, data: unknown): void { if (!browser) return; try { const serializedData = JSON.stringify(data); localStorage.setItem(key, serializedData); } catch (e) { console.error('Failed to save data to localStorage', e); } } export function clear(key: string): void { if (!browser) return; localStorage.removeItem(key); } export function createAutosave( key: string, data: () => unknown, options: { enabled: () => boolean; isDirty: () => boolean; } ) { let isFirstSave = true; $effect(() => { if (!options.enabled()) { return; } save(key, data()); const handler = setTimeout(() => { if (isFirstSave || !options.isDirty()) { isFirstSave = false; return; } toast.info('Progreso guardado automáticamente.', { duration: 2000 }); }, 1500); return () => clearTimeout(handler); }); }

// --- Ruta: src/lib/components/ThemeToggle.svelte ---
<!-- --> <script lang="ts"> import { Sun, Moon } from 'lucide-svelte'; import * as DropdownMenu from '$lib/components/ui/dropdown-menu'; import { themeStore } from '$lib/stores/theme.svelte'; const triggerClasses = "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border size-9"; </script> <DropdownMenu.Root> <DropdownMenu.Trigger class={triggerClasses} aria-label="Toggle theme"> <Sun class="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" /> <Moon class="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" /> <span class="sr-only">Toggle theme</span> </DropdownMenu.Trigger> <DropdownMenu.Content align="end"> <DropdownMenu.Item onclick={() => themeStore.set('light')}>Light</DropdownMenu.Item> <DropdownMenu.Item onclick={() => themeStore.set('dark')}>Dark</DropdownMenu.Item> <DropdownMenu.Item onclick={() => themeStore.set('system')}>System</DropdownMenu.Item> </DropdownMenu.Content> </DropdownMenu.Root>

// --- Ruta: prisma/migrations/20250803231715_add_isnamemanuallyset_to_product/migration.sql ---
-- RedefineTables PRAGMA defer_foreign_keys=ON; PRAGMA foreign_keys=OFF; CREATE TABLE "new_Product" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL, "isNameManuallySet" BOOLEAN NOT NULL DEFAULT false, "brand" TEXT, "imageUrl" TEXT, "calories" REAL, "fat" REAL, "protein" REAL, "carbs" REAL, "fullPayload" JSONB, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL ); INSERT INTO "new_Product" ("brand", "calories", "carbs", "createdAt", "fat", "fullPayload", "id", "imageUrl", "name", "normalizedName", "protein", "updatedAt") SELECT "brand", "calories", "carbs", "createdAt", "fat", "fullPayload", "id", "imageUrl", "name", "normalizedName", "protein", "updatedAt" FROM "Product"; DROP TABLE "Product"; ALTER TABLE "new_Product" RENAME TO "Product"; PRAGMA foreign_keys=ON; PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250803163534_add_recipe_slug/migration.sql ---
-- RedefineTables PRAGMA defer_foreign_keys=ON; PRAGMA foreign_keys=OFF; CREATE TABLE "new_Recipe" ( "id" TEXT NOT NULL PRIMARY KEY, "title" TEXT NOT NULL, "slug" TEXT NOT NULL, "normalizedTitle" TEXT NOT NULL, "steps" JSONB NOT NULL, "imageUrl" TEXT ); INSERT INTO "new_Recipe" ("id", "imageUrl", "normalizedTitle", "steps", "title") SELECT "id", "imageUrl", "normalizedTitle", "steps", "title" FROM "Recipe"; DROP TABLE "Recipe"; ALTER TABLE "new_Recipe" RENAME TO "Recipe"; CREATE UNIQUE INDEX "Recipe_slug_key" ON "Recipe"("slug"); PRAGMA foreign_keys=ON; PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250803153006_remove_description_and_json_steps/migration.sql ---
-- RedefineTables PRAGMA defer_foreign_keys=ON; PRAGMA foreign_keys=OFF; CREATE TABLE "new_Recipe" ( "id" TEXT NOT NULL PRIMARY KEY, "title" TEXT NOT NULL, "normalizedTitle" TEXT NOT NULL, "steps" JSONB NOT NULL, "imageUrl" TEXT ); INSERT INTO "new_Recipe" ("id", "imageUrl", "normalizedTitle", "steps", "title") SELECT "id", "imageUrl", "normalizedTitle", "steps", "title" FROM "Recipe"; DROP TABLE "Recipe"; ALTER TABLE "new_Recipe" RENAME TO "Recipe"; PRAGMA foreign_keys=ON; PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250802143934_add_normalized_title_to_recipe/migration.sql ---
-- RedefineTables PRAGMA defer_foreign_keys=ON; PRAGMA foreign_keys=OFF; CREATE TABLE "new_Recipe" ( "id" TEXT NOT NULL PRIMARY KEY, "title" TEXT NOT NULL, "normalizedTitle" TEXT NOT NULL, "description" TEXT, "steps" TEXT NOT NULL, "imageUrl" TEXT ); INSERT INTO "new_Recipe" ("description", "id", "imageUrl", "steps", "title") SELECT "description", "id", "imageUrl", "steps", "title" FROM "Recipe"; DROP TABLE "Recipe"; ALTER TABLE "new_Recipe" RENAME TO "Recipe"; PRAGMA foreign_keys=ON; PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250801182228_add_recipe_images_and_urls/migration.sql ---
-- AlterTable ALTER TABLE "Recipe" ADD COLUMN "imageUrl" TEXT; -- CreateTable CREATE TABLE "RecipeUrl" ( "id" TEXT NOT NULL PRIMARY KEY, "url" TEXT NOT NULL, "recipeId" TEXT NOT NULL, CONSTRAINT "RecipeUrl_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateIndex CREATE UNIQUE INDEX "RecipeUrl_recipeId_url_key" ON "RecipeUrl"("recipeId", "url");

// --- Ruta: prisma/migrations/20250801180502_init/migration.sql ---
-- DropTable PRAGMA foreign_keys=off; DROP TABLE "ProductCache"; PRAGMA foreign_keys=on; -- CreateTable CREATE TABLE "Product" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL, "brand" TEXT, "imageUrl" TEXT, "calories" REAL, "fat" REAL, "protein" REAL, "carbs" REAL, "fullPayload" JSONB, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL ); -- RedefineTables PRAGMA defer_foreign_keys=ON; PRAGMA foreign_keys=OFF; CREATE TABLE "new_CustomIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL, "calories" REAL NOT NULL, "fat" REAL NOT NULL, "protein" REAL NOT NULL, "carbs" REAL NOT NULL ); INSERT INTO "new_CustomIngredient" ("calories", "carbs", "fat", "id", "name", "normalizedName", "protein") SELECT "calories", "carbs", "fat", "id", "name", "normalizedName", "protein" FROM "CustomIngredient"; DROP TABLE "CustomIngredient"; ALTER TABLE "new_CustomIngredient" RENAME TO "CustomIngredient"; CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name"); CREATE TABLE "new_RecipeIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "recipeId" TEXT NOT NULL, "productId" TEXT, "customIngredientId" TEXT, "quantity" REAL NOT NULL, CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "RecipeIngredient_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product" ("id") ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT "RecipeIngredient_customIngredientId_fkey" FOREIGN KEY ("customIngredientId") REFERENCES "CustomIngredient" ("id") ON DELETE SET NULL ON UPDATE CASCADE ); INSERT INTO "new_RecipeIngredient" ("customIngredientId", "id", "quantity", "recipeId") SELECT "customIngredientId", "id", "quantity", "recipeId" FROM "RecipeIngredient"; DROP TABLE "RecipeIngredient"; ALTER TABLE "new_RecipeIngredient" RENAME TO "RecipeIngredient"; PRAGMA foreign_keys=ON; PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250731184218_add_normalized_names/migration.sql ---
-- RedefineTables PRAGMA defer_foreign_keys=ON; PRAGMA foreign_keys=OFF; CREATE TABLE "new_CustomIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL DEFAULT '', "calories" REAL NOT NULL, "fat" REAL NOT NULL, "protein" REAL NOT NULL, "carbs" REAL NOT NULL ); INSERT INTO "new_CustomIngredient" ("calories", "carbs", "fat", "id", "name", "protein") SELECT "calories", "carbs", "fat", "id", "name", "protein" FROM "CustomIngredient"; DROP TABLE "CustomIngredient"; ALTER TABLE "new_CustomIngredient" RENAME TO "CustomIngredient"; CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name"); CREATE TABLE "new_ProductCache" ( "id" TEXT NOT NULL PRIMARY KEY, "productName" TEXT NOT NULL, "normalizedProductName" TEXT NOT NULL DEFAULT '', "brand" TEXT, "imageUrl" TEXT, "calories" REAL, "fat" REAL, "protein" REAL, "carbs" REAL, "fullPayload" JSONB, "updatedAt" DATETIME NOT NULL ); INSERT INTO "new_ProductCache" ("brand", "calories", "carbs", "fat", "fullPayload", "id", "imageUrl", "productName", "protein", "updatedAt") SELECT "brand", "calories", "carbs", "fat", "fullPayload", "id", "imageUrl", "productName", "protein", "updatedAt" FROM "ProductCache"; DROP TABLE "ProductCache"; ALTER TABLE "new_ProductCache" RENAME TO "ProductCache"; PRAGMA foreign_keys=ON; PRAGMA defer_foreign_keys=OFF;

// --- Ruta: prisma/migrations/20250730185406_init/migration.sql ---
-- CreateTable CREATE TABLE "ProductCache" ( "id" TEXT NOT NULL PRIMARY KEY, "productName" TEXT NOT NULL, "brand" TEXT, "imageUrl" TEXT, "calories" REAL, "fat" REAL, "protein" REAL, "carbs" REAL, "fullPayload" JSONB, "updatedAt" DATETIME NOT NULL ); -- CreateTable CREATE TABLE "CustomIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "calories" REAL NOT NULL, "fat" REAL NOT NULL, "protein" REAL NOT NULL, "carbs" REAL NOT NULL ); -- CreateTable CREATE TABLE "Recipe" ( "id" TEXT NOT NULL PRIMARY KEY, "title" TEXT NOT NULL, "description" TEXT, "steps" TEXT NOT NULL ); -- CreateTable CREATE TABLE "RecipeIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "recipeId" TEXT NOT NULL, "productCacheId" TEXT, "customIngredientId" TEXT, "quantity" REAL NOT NULL, CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "RecipeIngredient_productCacheId_fkey" FOREIGN KEY ("productCacheId") REFERENCES "ProductCache" ("id") ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT "RecipeIngredient_customIngredientId_fkey" FOREIGN KEY ("customIngredientId") REFERENCES "CustomIngredient" ("id") ON DELETE SET NULL ON UPDATE CASCADE ); -- CreateIndex CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name");

// --- Ruta: src/routes/recetas/nueva/+page.svelte ---
<!-- Ruta: src/routes/recetas/nueva/+page.svelte --> <script lang="ts"> import RecipeForm from '$lib/components/recipes/RecipeForm.svelte'; import type { ActionData } from './$types'; let { form }: { form: ActionData } = $props(); </script> <RecipeForm {form} />

// --- Ruta: src/routes/recetas/nueva/+page.server.ts ---
export const actions: Actions = { default: async ({ request }) => { const formData = await request.formData(); const data = Object.fromEntries(formData.entries()); const dataToValidate = { ...data, ingredients: JSON.parse(data.ingredients as string), urls: JSON.parse(data.urls as string), steps: JSON.parse(data.steps as string) }; const validation = RecipeSchema.safeParse(dataToValidate); if (!validation.success) { const response = createFailResponse( 'La validación falló. Revisa los campos.', validation.error ); return fail(400, response); } try { const newRecipe = await recipeService.create(validation.data); if (newRecipe) { throw redirect(303, `/recetas/${newRecipe.slug}`); } return fail(500, createFailResponse('La receta no se pudo crear.')); } catch (err) { if ((err as { status?: number })?.status === 303) { throw err; } console.error(err); const response = createFailResponse('No se pudo crear la receta en el servidor.'); return fail(500, response); } } };

// --- Ruta: src/routes/recetas/busqueda-avanzada/+page.svelte ---
<script lang="ts"> import { browser } from '$app/environment'; import IngredientCombobox from '$lib/components/recipes/IngredientCombobox.svelte'; import MacroFilters from '$lib/components/recipes/MacroFilters.svelte'; import type { GramFilters, PercentFilters } from '$lib/components/recipes/MacroFilters.svelte'; import RecipeCard from '$lib/components/recipes/RecipeCard.svelte'; import { Badge } from '$lib/components/ui/badge/index.js'; import X from 'lucide-svelte/icons/x'; import { fade } from 'svelte/transition'; import { flip } from 'svelte/animate'; type Ingredient = { id: string; name: string; type: 'product' | 'custom'; source: 'local' | 'off'; imageUrl: string | null; }; type Recipe = any; type SearchPayload = { ingredients: string[]; grams: GramFilters; percent: PercentFilters; sortBy: string; }; let filters = $state({ selectedIngredients: [] as Ingredient[], gramFilters: { calories: {}, protein: {}, carbs: {}, fat: {} } as GramFilters, percentFilters: { protein: {}, carbs: {}, fat: {} } as PercentFilters, sortBy: 'title_asc' }); let recipes = $state<Recipe[]>([]); let isLoading = $state(false); let hasMore = $state(false); let sentinel: HTMLDivElement | undefined = $state(); let controller: AbortController | undefined; export const snapshot = { capture: () => { return { filters: JSON.parse(JSON.stringify(filters)), recipes: JSON.parse(JSON.stringify(recipes)) }; }, restore: (data: any) => { if (data && data.filters && data.recipes) { filters = data.filters; recipes = data.recipes; } } }; function areFiltersActive() { const hasMacroGrams = Object.values(filters.gramFilters).some( (range) => range && (range.min != null || range.max != null) ); const hasMacroPercent = Object.values(filters.percentFilters).some( (range) => range && (range.min != null || range.max != null) ); return filters.selectedIngredients.length > 0 || hasMacroGrams || hasMacroPercent; } async function performSearch(payload: SearchPayload) { if (!areFiltersActive()) { recipes = []; hasMore = false; return; } isLoading = true; const signal = controller?.signal; try { const body = { ...payload, offset: 0 }; const response = await fetch('/api/recipes/search', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body), signal }); const result = await response.json(); if (signal?.aborted) return; recipes = result.recipes; hasMore = result.hasMore; } catch (error) { if (error instanceof DOMException && error.name === 'AbortError') return; console.error('Error en la búsqueda:', error); } finally { if (!signal?.aborted) isLoading = false; } } async function loadMore(payload: SearchPayload) { if (!areFiltersActive() || isLoading) return; isLoading = true; try { const body = { ...payload, offset: recipes.length }; const response = await fetch('/api/recipes/search', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) }); const result = await response.json(); recipes.push(...result.recipes); hasMore = result.hasMore; } catch (error) { console.error('Error al cargar más recetas:', error); } finally { isLoading = false; } } $effect(() => { if (!browser) return; if (!areFiltersActive()) { recipes = []; hasMore = false; return; } controller?.abort(); controller = new AbortController(); const payload: SearchPayload = { ingredients: filters.selectedIngredients.map((i) => i.id), grams: filters.gramFilters, percent: filters.percentFilters, sortBy: filters.sortBy }; const timerId = setTimeout(() => { performSearch(payload); }, 350); return () => clearTimeout(timerId); }); $effect(() => { if (!sentinel) return; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting && hasMore && !isLoading && areFiltersActive()) { const payload: SearchPayload = { ingredients: filters.selectedIngredients.map((i) => i.id), grams: filters.gramFilters, percent: filters.percentFilters, sortBy: filters.sortBy }; loadMore(payload); } }); observer.observe(sentinel); return () => observer.disconnect(); }); function handleAddIngredient(ingredient: Ingredient) { if (!filters.selectedIngredients.some((i) => i.id === ingredient.id)) { filters.selectedIngredients = [...filters.selectedIngredients, ingredient]; } } function handleRemoveIngredient(ingredientId: string) { filters.selectedIngredients = filters.selectedIngredients.filter((i) => i.id !== ingredientId); } function clearIngredients() { filters.selectedIngredients = []; } function handleGramsChange(macro: keyof GramFilters, key: 'min' | 'max', value: number | undefined) { filters.gramFilters = { ...filters.gramFilters, [macro]: { ...filters.gramFilters[macro], [key]: value } }; } function handlePercentChange( macro: keyof PercentFilters, key: 'min' | 'max', value: number | undefined ) { filters.percentFilters = { ...filters.percentFilters, [macro]: { ...filters.percentFilters[macro], [key]: value } }; } function handleClearMacros() { filters.gramFilters = { calories: {}, protein: {}, carbs: {}, fat: {} }; filters.percentFilters = { protein: {}, carbs: {}, fat: {} }; } </script> <div class="container mx-auto p-4 md:p-8"> <header class="mb-8 flex items-center justify-between"> <div> <h1 class="text-3xl font-bold tracking-tight">Búsqueda Avanzada</h1> <p class="text-muted-foreground"> Filtra por ingredientes, macronutrientes y más. </p> </div> </header> <div class="grid grid-cols-1 gap-8 lg:grid-cols-3"> <aside class="lg:col-span-1"> <div class="space-y-6 rounded-lg border p-4 sticky top-4"> <div class="space-y-2"> <h3 class="text-lg font-semibold">Ingredientes</h3> <IngredientCombobox onSelect={handleAddIngredient} selectedIds={filters.selectedIngredients.map((i) => i.id)} onClear={clearIngredients} /> <div class="flex flex-wrap gap-2 pt-2 min-h-[24px]"> {#each filters.selectedIngredients as ingredient (ingredient.id)} <Badge variant="secondary" class="flex items-center gap-2"> {ingredient.name} <button onclick={() => handleRemoveIngredient(ingredient.id)} class="focus:ring-ring rounded-sm focus:outline-none focus:ring-2 focus:ring-offset-2" > <X class="h-3 w-3" /> </button> </Badge> {/each} </div> </div> <hr /> <MacroFilters gramFilters={filters.gramFilters} percentFilters={filters.percentFilters} onGramsChange={handleGramsChange} onPercentChange={handlePercentChange} onClear={handleClearMacros} /> </div> </aside> <main class="lg:col-span-2"> <div class="space-y-4"> {#if recipes.length > 0} <div class="columns-1 md:columns-2 gap-4"> {#each recipes as recipe, i (recipe.id)} <div class="mb-4 break-inside-avoid"> <RecipeCard {recipe} isAdmin={false} onEditQuantities={() => {}} onDelete={() => {}} /> </div> {/each} </div> {:else if !isLoading} <div class="rounded-lg border p-8 text-center"> <p class="text-muted-foreground"> {#if areFiltersActive()} No se encontraron recetas con estos criterios. {:else} Selecciona uno o más filtros para empezar a buscar. {/if} </p> </div> {/if} {#if hasMore} <div bind:this={sentinel} class="h-10 flex justify-center items-center text-muted-foreground"> {#if isLoading} <span>Cargando...</span> {/if} </div> {/if} </div> </main> </div> </div>

// --- Ruta: src/routes/recetas/[slug]/+page.svelte ---
<!-- --> <script lang="ts"> import { Button } from '$lib/components/ui/button/index.js'; import * as Card from '$lib/components/ui/card/index.js'; import { Separator } from '$lib/components/ui/separator/index.js'; import { calculateNutritionalInfo, type CalculableIngredient } from '$lib/recipeCalculator'; import { ArrowLeft } from 'lucide-svelte'; import type { PageData } from './$types'; import { fly } from 'svelte/transition'; let { data }: { data: PageData } = $props(); const { recipe } = data; const calculableIngredients = $derived( recipe.ingredients.map((ing) => { const source = ing.product || ing.customIngredient; return { quantity: ing.quantity, calories: source?.calories, protein: source?.protein, fat: source?.fat, carbs: source?.carbs } as CalculableIngredient; }) ); const totals = $derived(calculateNutritionalInfo(calculableIngredients)); const totalGrams = $derived(totals.totalProtein + totals.totalCarbs + totals.totalFat); const proteinPercentage = $derived(totalGrams > 0 ? (totals.totalProtein / totalGrams) * 100 : 0); const carbsPercentage = $derived(totalGrams > 0 ? (totals.totalCarbs / totalGrams) * 100 : 0); const fatPercentage = $derived(totalGrams > 0 ? (totals.totalFat / totalGrams) * 100 : 0); const { steps } = recipe; </script> <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-8"> <h1 class="font-heading font-light text-3xl md:text-4xl mb-8">{recipe.title}</h1> <!-- Sección Superior: Nutrición e Ingredientes --> <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8"> <Card.Root> <Card.Header> <Card.Title class="font-heading mt-4">Información Nutricional</Card.Title> <Card.Description>Valores totales para la receta</Card.Description> </Card.Header> <Card.Content class="space-y-4"> <div class="text-center"> <span class="text-4xl font-bold">{totals.totalCalories.toFixed(0)}</span> <span class="text-muted-foreground">kcal</span> </div> <div> <div class="flex h-2 w-full overflow-hidden rounded-full bg-muted mb-2"> <div class="bg-blue-500" style="width: {proteinPercentage}%" title="Proteínas: {totals.totalProtein.toFixed(1)}g" ></div> <div class="bg-green-500" style="width: {carbsPercentage}%" title="Carbohidratos: {totals.totalCarbs.toFixed(1)}g" ></div> <div class="bg-red-500" style="width: {fatPercentage}%" title="Grasas: {totals.totalFat.toFixed(1)}g" ></div> </div> <div class="flex justify-between text-sm text-muted-foreground"> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-blue-500"></span> Proteínas: {totals.totalProtein.toFixed(1)}g </span> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-green-500"></span> Carbs: {totals.totalCarbs.toFixed(1)}g </span> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-red-500"></span> Grasas: {totals.totalFat.toFixed(1)}g </span> </div> </div> </Card.Content> </Card.Root> <Card.Root> <Card.Header> <Card.Title class="font-heading mt-4">Ingredientes</Card.Title> </Card.Header> <Card.Content> <ul class="space-y-2 text-muted-foreground"> {#each recipe.ingredients as ing} {@const name = ing.product?.name || ing.customIngredient?.name} <li class="flex justify-between"> <span>{name}</span> <span class="font-medium">{ing.quantity.toLocaleString('es-ES')} g</span> </li> {/each} </ul> </Card.Content> </Card.Root> </div> <!-- Sección Inferior: Preparación e Imagen --> <div class="grid grid-cols-1 lg:grid-cols-3 lg:gap-x-12 gap-y-8"> <main class="lg:col-span-2"> <Card.Root> <Card.Header> <Card.Title class="font-heading text-xl mt-4">Preparación</Card.Title> </Card.Header> <Card.Content> <div class="space-y-6"> {#each steps as step, i} <div class="flex items-start gap-4"> <span class="text-2xl md:text-3xl font-bold text-primary mt-[-2px]">{i + 1}.</span> <div class="prose prose-sm sm:prose-base max-w-none flex-1"> {@html step} </div> </div> {#if i < steps.length - 1} <Separator /> {/if} {/each} {#if steps.length === 0} <p class="text-muted-foreground">No hay pasos de preparación definidos.</p> {/if} </div> </Card.Content> </Card.Root> </main> <aside class="lg:col-start-3"> {#if recipe.imageUrl} <img src={recipe.imageUrl} alt="Imagen de {recipe.title}" class="w-full rounded-lg object-cover shadow-lg sticky top-8" /> {/if} </aside> </div> <!-- Sección de Referencias --> {#if recipe.urls.length > 0} <div class="mt-8"> <Card.Root> <Card.Header> <Card.Title class="mt-4">Referencias</Card.Title> </Card.Header> <Card.Content> <ul class="list-disc pl-5 space-y-2"> {#each recipe.urls as ref} <li> <a href={ref.url} target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline break-all" > {ref.url} </a> </li> {/each} </ul> </Card.Content> </Card.Root> </div> {/if} <!-- Botón de Volver --> <div class="mt-12"> <Button variant="outline" href="/"> <ArrowLeft class="mr-2 h-4 w-4" /> Volver a todas las recetas </Button> </div> </div>

// --- Ruta: src/routes/recetas/[slug]/+page.server.ts ---
export const load: PageServerLoad = async ({ params }) => { const recipe = await recipeService.getBySlug(params.slug); if (!recipe) { throw error(404, 'Receta no encontrada'); } const window = new JSDOM('').window; const sanitizer = createDOMPurify(window as any); const processedSteps = await Promise.all( Array.isArray(recipe.steps) ? recipe.steps.map(async (step) => { const rawHtml = await marked.parse(String(step ?? '')); return sanitizer.sanitize(rawHtml); }) : [] ); return { recipe: { ...recipe, steps: processedSteps } }; }; export const actions: Actions = { default: async ({ request, params }) => { const formData = await request.formData(); const data = Object.fromEntries(formData.entries()); const dataToValidate = { ...data, ingredients: JSON.parse(data.ingredients as string), urls: JSON.parse(data.urls as string), steps: JSON.parse(data.steps as string) }; const validation = RecipeSchema.safeParse(dataToValidate); if (!validation.success) { const response = createFailResponse('La validación falló. Revisa los campos.', validation.error); return fail(400, response); } try { const originalRecipe = await recipeService.getBySlug(params.slug); if (!originalRecipe) { throw error(404, 'Receta no encontrada para actualizar'); } const updatedRecipe = await recipeService.update(originalRecipe.id, validation.data); return { status: 200, body: { recipe: updatedRecipe } }; } catch (err) { console.error(err); const response = createFailResponse('No se pudo actualizar la receta.'); return fail(500, response); } } };

// --- Ruta: src/routes/admin/ingredientes/+page.svelte ---
<script lang="ts"> import { applyAction, enhance } from '$app/forms'; import type { ActionData, PageData } from './$types'; import { goto, invalidateAll } from '$app/navigation'; import { toast } from 'svelte-sonner'; import { page } from '$app/state'; import IngredientsDesktopView from '$lib/components/admin/IngredientsDesktopView.svelte'; import IngredientsMobileView from '$lib/components/admin/IngredientsMobileView.svelte'; let { data, form } = $props<{ data: PageData; form: ActionData }>(); let searchTerm = $state(data.search ?? ''); $effect(() => { const currentSearchTerm = searchTerm; const handler = setTimeout(() => { const url = new URL(page.url); if (currentSearchTerm) { url.searchParams.set('search', currentSearchTerm); } else { url.searchParams.delete('search'); } if (url.search !== page.url.search) { goto(url, { keepFocus: true, noScroll: true, replaceState: true }); } }, 300); return () => { clearTimeout(handler); }; }); function sort(column: string) { const url = new URL(page.url); const currentSort = url.searchParams.get('sort'); const currentOrder = url.searchParams.get('order'); const newOrder = currentSort === column && currentOrder === 'asc' ? 'desc' : 'asc'; url.searchParams.set('sort', column); url.searchParams.set('order', newOrder); goto(url, { keepFocus: true, noScroll: true, replaceState: true }); } let isProductEditDialogOpen = $state(false); let editingProductName = $state(''); let editingProductId = $state<string | null>(null); async function handleUpdateProductName() { if (!editingProductId) return; const toastId = toast.loading('Actualizando nombre del producto...'); try { const productId = editingProductId.startsWith('product-') ? editingProductId.substring(8) : editingProductId; const encodedProductId = encodeURIComponent(productId); const response = await fetch(`/api/products/${encodedProductId}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: editingProductName }) }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error?.message || 'Error al actualizar el nombre'); } toast.success('Nombre del producto actualizado con éxito.', { id: toastId }); await invalidateAll(); isProductEditDialogOpen = false; } catch (error) { console.error('Error al actualizar el nombre del producto:', error); const message = error instanceof Error ? error.message : 'Ocurrió un error desconocido.'; toast.error(message, { id: toastId }); } } </script> <div class="container mx-auto py-10"> <IngredientsDesktopView {data} {form} bind:searchTerm bind:isProductEditDialogOpen bind:editingProductName bind:editingProductId {handleUpdateProductName} /> <IngredientsMobileView {data} bind:searchTerm {sort} bind:isProductEditDialogOpen bind:editingProductName bind:editingProductId {handleUpdateProductName} /> </div>

// --- Ruta: src/routes/admin/ingredientes/+page.server.ts ---
export const load: PageServerLoad = async ({ url }) => { const search = url.searchParams.get('search') ?? ''; const sort = url.searchParams.get('sort') ?? 'name'; const order = url.searchParams.get('order') ?? 'asc'; try { const ingredients = await ingredientService.getAllUnified(search, sort, order); return { ingredients, search, sort, order }; } catch (error) { console.error('Error al cargar los ingredientes:', error); return { ingredients: [], search, sort, order, error: 'No se pudieron cargar los ingredientes' }; } }; export const actions: Actions = { addCustom: async ({ request }) => { const formData = Object.fromEntries(await request.formData()); const validation = IngredientSchema.safeParse(formData); if (!validation.success) { return fail(400, { data: formData, ...createFailResponse('La validación falló', validation.error) }); } try { await ingredientService.create(validation.data); return { success: true, message: 'Ingrediente personalizado añadido con éxito' }; } catch (error) { console.error('Error al crear el ingrediente personalizado:', error); return fail(500, { data: formData, message: 'No se pudo crear el ingrediente personalizado.' }); } }, update: async ({ request, fetch }) => { const formData = await request.formData(); const id = formData.get('id') as string; const response = await fetch(`/api/ingredients/${id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(Object.fromEntries(formData)) }); if (!response.ok) { const result = await response.json(); return fail(response.status, { data: Object.fromEntries(formData), errors: result.errors, id }); } return { success: true, message: 'Ingrediente actualizado con éxito' }; }, delete: async ({ request, fetch }) => { const formData = await request.formData(); const response = await fetch('/api/ingredients', { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(Object.fromEntries(formData)) }); if (!response.ok) { const result = await response.json(); return fail(response.status, { message: result.message || 'Error al eliminar el ingrediente.' }); } return { success: true, message: 'Ingrediente eliminado con éxito' }; } };

// --- Ruta: src/routes/api/scrape-image/api.spec.ts ---
vi.mock('$lib/server/services/imageService', () => ({ imageService: { getImageFromUrl: vi.fn() } })); vi.mock('@sveltejs/kit', async (importOriginal) => { const original = await importOriginal<typeof import('@sveltejs/kit')>(); return { ...original, error: vi.fn((status, message) => ({ status, message })) }; }); type ApiEvent = Parameters<typeof POST>[0]; describe('POST /api/scrape-image', () => { beforeEach(() => { vi.resetAllMocks(); vi.spyOn(console, 'error').mockImplementation(() => {}); }); afterEach(() => { vi.mocked(console.error).mockRestore(); }); it('should return a 200 response with the image URL on success', async () => { const mockImageUrl = 'data:image/webp;base64,mock-image-data'; vi.mocked(imageService.getImageFromUrl).mockResolvedValue(mockImageUrl); const request = new Request('http: method: 'POST', body: JSON.stringify({ url: 'https: }); const response = await POST({ request } as unknown as ApiEvent); const body = await response.json(); expect(response.status).toBe(200); expect(body).toEqual({ imageUrl: mockImageUrl }); expect(imageService.getImageFromUrl).toHaveBeenCalledWith('https: }); it('should throw a 400 error for an invalid URL', async () => { const request = new Request('http: method: 'POST', body: JSON.stringify({ url: 'invalid-url' }) }); await expect(POST({ request } as unknown as ApiEvent)).rejects.toEqual({ status: 400, message: 'URL no válida' }); }); it('should throw a 404 error if no image is found', async () => { vi.mocked(imageService.getImageFromUrl).mockResolvedValue(null); const request = new Request('http: method: 'POST', body: JSON.stringify({ url: 'https: }); await expect(POST({ request } as unknown as ApiEvent)).rejects.toEqual({ status: 404, message: 'No se pudo encontrar una imagen en la URL proporcionada' }); }); it('should throw a 500 error for internal server errors', async () => { vi.mocked(imageService.getImageFromUrl).mockRejectedValue(new Error('Internal processing error')); const request = new Request('http: method: 'POST', body: JSON.stringify({ url: 'https: }); await expect(POST({ request } as unknown as ApiEvent)).rejects.toEqual({ status: 500, message: 'Error interno al procesar la imagen' }); }); });

// --- Ruta: src/routes/api/scrape-image/+server.ts ---
export const POST: RequestHandler = async ({ request }) => { try { const { url } = await request.json(); if (!url || !url.startsWith('http')) { throw error(400, 'URL no válida'); } const imageUrl = await imageService.getImageFromUrl(url); if (!imageUrl) { throw error(404, 'No se pudo encontrar una imagen en la URL proporcionada'); } return json({ imageUrl }); } catch (e) { if (typeof e === 'object' && e !== null && 'status' in e) { throw e; } console.error('Error scraping image:', e); throw error(500, 'Error interno al procesar la imagen'); } };

// --- Ruta: src/routes/api/recipes/server.spec.ts ---
vi.mock('$lib/server/services/recipeService'); vi.mock('@sveltejs/kit', async (importOriginal) => { const original = await importOriginal<typeof import('@sveltejs/kit')>(); return { ...original, json: vi.fn() }; }); type ApiEvent = Parameters<typeof GET>[0]; type Recipes = Awaited<ReturnType<typeof recipeService.findPaginated>>; describe('GET /api/recipes', () => { beforeEach(() => { vi.resetAllMocks(); }); it('should call recipeService.findPaginated with correct default parameters', async () => { vi.mocked(recipeService.findPaginated).mockResolvedValue([]); const url = new URL('http: await GET({ url } as unknown as ApiEvent); expect(recipeService.findPaginated).toHaveBeenCalledWith(null, 51, 0); }); it('should call recipeService.findPaginated with provided query parameters', async () => { vi.mocked(recipeService.findPaginated).mockResolvedValue([]); const url = new URL('http: await GET({ url } as unknown as ApiEvent); expect(recipeService.findPaginated).toHaveBeenCalledWith('pollo', 11, 20); }); it('should return hasMore: true when the service returns more items than the limit', async () => { const url = new URL('http: const mockRecipes = Array(11).fill({ id: '1' }); vi.mocked(recipeService.findPaginated).mockResolvedValue(mockRecipes as Recipes); await GET({ url } as unknown as ApiEvent); expect(json).toHaveBeenCalledWith({ recipes: mockRecipes.slice(0, 10), hasMore: true }); }); it('should return hasMore: false when the service returns fewer items than the limit', async () => { const url = new URL('http: const mockRecipes = Array(5).fill({ id: '1' }); vi.mocked(recipeService.findPaginated).mockResolvedValue(mockRecipes as Recipes); await GET({ url } as unknown as ApiEvent); expect(json).toHaveBeenCalledWith({ recipes: mockRecipes, hasMore: false }); }); it('should return a 500 error if the service throws an exception', async () => { const url = new URL('http: vi.mocked(recipeService.findPaginated).mockRejectedValue(new Error('Database error')); vi.spyOn(console, 'error').mockImplementation(() => {}); await GET({ url } as unknown as ApiEvent); expect(json).toHaveBeenCalledWith({ message: 'Error interno del servidor' }, { status: 500 }); vi.mocked(console.error).mockRestore(); }); });

// --- Ruta: src/routes/api/recipes/+server.ts ---
const DEFAULT_LIMIT = 50; export const GET: RequestHandler = async ({ url }) => { try { const searchTerm = url.searchParams.get('q'); const limit = parseInt(url.searchParams.get('limit') ?? `${DEFAULT_LIMIT}`, 10); const offset = parseInt(url.searchParams.get('offset') ?? '0', 10); const recipesPlusOne = await recipeService.findPaginated(searchTerm, limit + 1, offset); const hasMore = recipesPlusOne.length > limit; const recipes = recipesPlusOne.slice(0, limit); return json({ recipes, hasMore }); } catch (error) { console.error('Error en el endpoint de búsqueda de recetas:', error); return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

// --- Ruta: src/routes/api/ingredients/+server.ts ---
export const GET: RequestHandler = async ({ url }) => { try { const search = url.searchParams.get('search') ?? undefined; const sort = url.searchParams.get('sort') ?? 'name'; const order = url.searchParams.get('order') ?? 'asc'; const ingredients = await ingredientService.getAllUnified(search, sort, order); return json(ingredients); } catch (error) { console.error('Error fetching ingredients:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const POST: RequestHandler = async ({ request }) => { try { const body = await request.json(); const validatedData = IngredientSchema.parse(body); const newIngredient = await ingredientService.create(validatedData); return json(newIngredient, { status: 201 }); } catch (error) { if (error instanceof ZodError) { return json(createFailResponse('La validación falló', error), { status: 400 }); } console.error('Error creating ingredient:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const DELETE: RequestHandler = async ({ request }) => { try { const { id, source } = await request.json(); if (!id || !source) { return json(createFailResponse('Faltan los campos "id" y "source"'), { status: 400 }); } if (source === 'custom') { await ingredientService.deleteById(id); } else if (source === 'product') { const productId = id.startsWith('product-') ? id.substring(8) : id; await ingredientService.deleteProductById(productId); } else { return json(createFailResponse('Tipo de ingrediente no válido.'), { status: 400 }); } return json({ success: true, message: 'Ingrediente eliminado con éxito' }, { status: 200 }); } catch (error) { console.error('Error al eliminar el ingrediente:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/lib/server/services/recipeService.ts ---
const recipeInclude = { ingredients: { include: { product: true, customIngredient: true } }, urls: true }; type FullRecipe = Prisma.RecipeGetPayload<{ include: typeof recipeInclude; }>; export type MacroFilter = { min?: number; max?: number; }; export type AdvancedSearchFilters = ZodSearchFilters; type RawRecipeQueryResult = { id: string; title: string; imageUrl: string | null; }; export const recipeService = { async getAll(): Promise<FullRecipe[]> { return await prisma.recipe.findMany({ include: recipeInclude, orderBy: { title: 'asc' } }); }, async getById(id: string): Promise<FullRecipe | null> { return await prisma.recipe.findUnique({ where: { id }, include: recipeInclude }); }, async getBySlug(slug: string): Promise<FullRecipe | null> { return await prisma.recipe.findUnique({ where: { slug }, include: recipeInclude }); }, async create(data: RecipeData): Promise<FullRecipe> { const { title, steps, ingredients, urls, imageUrl } = data; const slug = await generateUniqueSlug(title); const createdRecipe = await prisma.$transaction(async (tx) => { const newRecipe = await tx.recipe.create({ data: { title, slug, normalizedTitle: title.toLowerCase(), steps, imageUrl, urls: { create: urls?.map((url: string) => ({ url })) } } }); const ingredientsData = ingredients.map((ingredient) => ({ recipeId: newRecipe.id, quantity: ingredient.quantity, productId: ingredient.type === 'product' ? ingredient.id : null, customIngredientId: ingredient.type === 'custom' ? ingredient.id : null })); await tx.recipeIngredient.createMany({ data: ingredientsData }); return newRecipe; }); const fullNewRecipe = await prisma.recipe.findUnique({ where: { id: createdRecipe.id }, include: recipeInclude }); if (!fullNewRecipe) { throw new Error('No se pudo encontrar la receta recién creada.'); } return fullNewRecipe; }, async update(id: string, data: RecipeData) { const { title, steps, ingredients, urls, imageUrl } = data; const originalRecipe = await prisma.recipe.findUnique({ where: { id } }); let slug: string | undefined; if (originalRecipe && originalRecipe.title !== title) { slug = await generateUniqueSlug(title); } return await prisma.$transaction(async (tx) => { await tx.recipe.update({ where: { id }, data: { title, slug, normalizedTitle: title.toLowerCase(), steps, imageUrl } }); await tx.recipeIngredient.deleteMany({ where: { recipeId: id } }); for (const ingredient of ingredients) { await tx.recipeIngredient.create({ data: { recipeId: id, quantity: ingredient.quantity, productId: ingredient.type === 'product' ? ingredient.id : null, customIngredientId: ingredient.type === 'custom' ? ingredient.id : null } }); } await tx.recipeUrl.deleteMany({ where: { recipeId: id } }); if (urls && urls.length > 0) { await tx.recipeUrl.createMany({ data: urls.map((url: string) => ({ recipeId: id, url })) }); } return await tx.recipe.findUnique({ where: { id }, include: recipeInclude }); }); }, async deleteById(id: string) { return await prisma.recipe.delete({ where: { id } }); }, async findPaginated(searchTerm: string | null, limit: number, offset: number) { const normalizedSearchTerm = searchTerm?.toLowerCase(); const whereClause: Prisma.RecipeWhereInput = normalizedSearchTerm ? { OR: [ { normalizedTitle: { contains: normalizedSearchTerm } }, { ingredients: { some: { OR: [ { product: { normalizedName: { contains: normalizedSearchTerm } } }, { customIngredient: { normalizedName: { contains: normalizedSearchTerm } } } ] } } } ] } : {}; return prisma.recipe.findMany({ where: whereClause, include: recipeInclude, orderBy: { title: 'asc' }, take: limit, skip: offset }); }, async findAdvanced(filters: AdvancedSearchFilters): Promise<FullRecipe[]> { const { ingredients, grams, percent, sortBy, limit, offset } = filters; const withClause = Prisma.sql` WITH "RecipeTotals" AS ( SELECT ri."recipeId", SUM(COALESCE(p.calories, ci.calories, 0) * ri.quantity / 100.0) AS "totalCalories", SUM(COALESCE(p.protein, ci.protein, 0) * ri.quantity / 100.0) AS "totalProtein", SUM(COALESCE(p.carbs, ci.carbs, 0) * ri.quantity / 100.0) AS "totalCarbs", SUM(COALESCE(p.fat, ci.fat, 0) * ri.quantity / 100.0) AS "totalFat" FROM "RecipeIngredient" ri LEFT JOIN "Product" p ON ri."productId" = p.id LEFT JOIN "CustomIngredient" ci ON ri."customIngredientId" = ci.id GROUP BY ri."recipeId" ), "RecipePercentages" AS ( SELECT "recipeId", "totalCalories", "totalProtein", "totalCarbs", "totalFat", "totalProtein" * 4 * 100.0 / NULLIF("totalCalories", 0) AS "percentProtein", "totalCarbs" * 4 * 100.0 / NULLIF("totalCalories", 0) AS "percentCarbs", "totalFat" * 9 * 100.0 / NULLIF("totalCalories", 0) AS "percentFat" FROM "RecipeTotals" ) `; const selectClause = Prisma.sql` SELECT r.id, r.title, r.imageUrl FROM "Recipe" r JOIN "RecipePercentages" rt ON r.id = rt."recipeId" `; const whereConditions: Prisma.Sql[] = []; if (ingredients && ingredients.length > 0) { ingredients.forEach((ingredientId) => { let isProduct = false; let id = ingredientId; if (id.startsWith('product-')) { isProduct = true; id = id.replace('product-', ''); } else if (id.startsWith('custom-')) { id = id.replace('custom-', ''); } else if (!isNaN(Number(id))) { isProduct = true; } if (isProduct) { whereConditions.push(Prisma.sql` EXISTS ( SELECT 1 FROM "RecipeIngredient" ri WHERE ri."recipeId" = r.id AND ri."productId" = ${id} ) `); } else { whereConditions.push(Prisma.sql` EXISTS ( SELECT 1 FROM "RecipeIngredient" ri WHERE ri."recipeId" = r.id AND ri."customIngredientId" = ${id} ) `); } }); } if (grams?.calories?.min != null) whereConditions.push(Prisma.sql`rt."totalCalories" >= ${grams.calories.min}`); if (grams?.calories?.max != null) whereConditions.push(Prisma.sql`rt."totalCalories" <= ${grams.calories.max}`); if (grams?.protein?.min != null) whereConditions.push(Prisma.sql`rt."totalProtein" >= ${grams.protein.min}`); if (grams?.protein?.max != null) whereConditions.push(Prisma.sql`rt."totalProtein" <= ${grams.protein.max}`); if (grams?.carbs?.min != null) whereConditions.push(Prisma.sql`rt."totalCarbs" >= ${grams.carbs.min}`); if (grams?.carbs?.max != null) whereConditions.push(Prisma.sql`rt."totalCarbs" <= ${grams.carbs.max}`); if (grams?.fat?.min != null) whereConditions.push(Prisma.sql`rt."totalFat" >= ${grams.fat.min}`); if (grams?.fat?.max != null) whereConditions.push(Prisma.sql`rt."totalFat" <= ${grams.fat.max}`); if (percent?.protein?.min != null) whereConditions.push(Prisma.sql`rt."percentProtein" >= ${percent.protein.min}`); if (percent?.protein?.max != null) whereConditions.push(Prisma.sql`rt."percentProtein" <= ${percent.protein.max}`); if (percent?.carbs?.min != null) whereConditions.push(Prisma.sql`rt."percentCarbs" >= ${percent.carbs.min}`); if (percent?.carbs?.max != null) whereConditions.push(Prisma.sql`rt."percentCarbs" <= ${percent.carbs.max}`); if (percent?.fat?.min != null) whereConditions.push(Prisma.sql`rt."percentFat" >= ${percent.fat.min}`); if (percent?.fat?.max != null) whereConditions.push(Prisma.sql`rt."percentFat" <= ${percent.fat.max}`); const whereClause = whereConditions.length > 0 ? Prisma.sql`WHERE ${Prisma.join(whereConditions, ' AND ')}` : Prisma.empty; let orderByClause: Prisma.Sql; switch (sortBy) { case 'calories_asc': orderByClause = Prisma.sql`ORDER BY rt."totalCalories" ASC`; break; case 'calories_desc': orderByClause = Prisma.sql`ORDER BY rt."totalCalories" DESC`; break; case 'protein_desc': orderByClause = (percent?.protein?.min != null || percent?.protein?.max != null) ? Prisma.sql`ORDER BY rt."percentProtein" DESC` : Prisma.sql`ORDER BY rt."totalProtein" DESC`; break; default: orderByClause = Prisma.sql`ORDER BY r.title ASC`; } const paginationClause = Prisma.sql`LIMIT ${limit} OFFSET ${offset}`; const fullQuery = Prisma.sql`${withClause} ${selectClause} ${whereClause} ${orderByClause} ${paginationClause}`; const result = await prisma.$queryRaw<RawRecipeQueryResult[]>(fullQuery); const recipeIds = result.map((r) => r.id); if (recipeIds.length === 0) return []; const recipesInOrder = await prisma.recipe.findMany({ where: { id: { in: recipeIds } }, include: recipeInclude }); return recipeIds.map(id => recipesInOrder.find(r => r.id === id)).filter((r): r is FullRecipe => !!r); } };

// --- Ruta: src/lib/server/services/recipeService.spec.ts ---
vi.mock('./imageService', () => ({ imageService: { getImageFromUrl: vi.fn() } })); beforeEach(async () => { await prisma.recipeIngredient.deleteMany(); await prisma.recipeUrl.deleteMany(); await prisma.recipe.deleteMany(); await prisma.customIngredient.deleteMany(); vi.clearAllMocks(); }); const MOCK_RECIPE_DATA: RecipeData = { title: 'Test Recipe', description: 'A test description', steps: 'Step 1. Do this.', ingredients: [], urls: ['https: imageUrl: '' }; describe('recipeService with images and URLs', () => { it('should create a recipe with a user-provided image', async () => { const recipeData = { ...MOCK_RECIPE_DATA, imageUrl: 'data:image/png;base64,test' }; const result = await recipeService.create(recipeData); expect(result).toBeDefined(); expect(result.title).toBe(recipeData.title); expect(result.imageUrl).toBe(recipeData.imageUrl); expect(imageService.getImageFromUrl).not.toHaveBeenCalled(); }); it('should call imageService to get an image if no image is provided but a URL is', async () => { const recipeData = { ...MOCK_RECIPE_DATA, imageUrl: undefined }; const fetchedImageUrl = 'data:image/webp;base64,fetched-image'; (imageService.getImageFromUrl as vi.Mock).mockResolvedValue(fetchedImageUrl); const result = await recipeService.create(recipeData); expect(result).toBeDefined(); expect(imageService.getImageFromUrl).toHaveBeenCalledWith(recipeData.urls![0]); expect(result.imageUrl).toBe(fetchedImageUrl); }); it('should create a recipe with URLs', async () => { const recipeData = { ...MOCK_RECIPE_DATA }; const result = await recipeService.create(recipeData); const dbRecipe = await prisma.recipe.findUnique({ where: { id: result!.id }, include: { urls: true } }); expect(dbRecipe).toBeDefined(); expect(dbRecipe?.urls).toHaveLength(1); expect(dbRecipe?.urls[0].url).toBe(recipeData.urls![0]); }); it('should update a recipe, removing old URLs and adding new ones', async () => { const initialRecipe = await prisma.recipe.create({ data: { title: 'Initial', normalizedTitle: 'initial', steps: 'Initial', urls: { create: { url: 'https: } }); const updateData = { ...MOCK_RECIPE_DATA, title: 'Updated Recipe', urls: ['https: }; const updatedRecipe = await recipeService.update(initialRecipe.id, updateData); const dbRecipe = await prisma.recipe.findUnique({ where: { id: updatedRecipe!.id }, include: { urls: true } }); expect(dbRecipe).toBeDefined(); expect(dbRecipe?.title).toBe('Updated Recipe'); expect(dbRecipe?.urls).toHaveLength(1); expect(dbRecipe?.urls[0].url).toBe('https: }); }); describe('recipeService.findPaginated', () => { beforeEach(async () => { const pollo = await prisma.customIngredient.create({ data: { name: 'Pollo', normalizedName: 'pollo', calories: 165, protein: 31, fat: 3.6, carbs: 0 } }); const arroz = await prisma.customIngredient.create({ data: { name: 'Arroz', normalizedName: 'arroz', calories: 130, protein: 2.7, fat: 0.3, carbs: 28 } }); const lentejas = await prisma.customIngredient.create({ data: { name: 'Lentejas', normalizedName: 'lentejas', calories: 116, protein: 9, fat: 0.4, carbs: 20 } }); await prisma.recipe.create({ data: { title: 'Pollo con Arroz', normalizedTitle: 'pollo con arroz', steps: '...', ingredients: { create: [ { customIngredientId: pollo.id, quantity: 200 }, { customIngredientId: arroz.id, quantity: 150 } ] } } }); await prisma.recipe.create({ data: { title: 'Lentejas Estofadas', normalizedTitle: 'lentejas estofadas', steps: '...', ingredients: { create: [{ customIngredientId: lentejas.id, quantity: 300 }] } } }); await prisma.recipe.create({ data: { title: 'Arroz con Pollo', normalizedTitle: 'arroz con pollo', steps: '...', ingredients: { create: [ { customIngredientId: arroz.id, quantity: 200 }, { customIngredientId: pollo.id, quantity: 150 } ] } } }); }); it('should return all recipes paginated when search term is null', async () => { const recipes = await recipeService.findPaginated(null, 2, 0); expect(recipes).toHaveLength(2); expect(recipes[0].title).toBe('Arroz con Pollo'); expect(recipes[1].title).toBe('Lentejas Estofadas'); const nextPage = await recipeService.findPaginated(null, 2, 2); expect(nextPage).toHaveLength(1); expect(nextPage[0].title).toBe('Pollo con Arroz'); }); it('should filter recipes by title', async () => { const recipes = await recipeService.findPaginated('lentejas', 5, 0); expect(recipes).toHaveLength(1); expect(recipes[0].title).toBe('Lentejas Estofadas'); }); it('should filter recipes by ingredient name', async () => { const recipes = await recipeService.findPaginated('pollo', 5, 0); expect(recipes).toHaveLength(2); const titles = recipes.map((r) => r.title).sort(); expect(titles).toEqual(['Arroz con Pollo', 'Pollo con Arroz']); }); it('should return an empty array if no recipe matches the search term', async () => { const recipes = await recipeService.findPaginated('pescado', 5, 0); expect(recipes).toHaveLength(0); }); });

// --- Ruta: src/lib/server/services/productService.ts ---
type OpenFoodFactsProduct = { code: string; product_name: string; brands?: string; image_url?: string; nutriments: { 'energy-kcal_100g'?: number; energy_kcal_100g?: number; fat_100g?: number; proteins_100g?: number; carbohydrates_100g?: number; }; }; type OpenFoodFactsResponse = { status: number; product?: OpenFoodFactsProduct; }; export const productService = { async findByBarcode(barcode: string) { const cachedProduct = await prisma.product.findUnique({ where: { id: barcode } }); if (cachedProduct) { console.log(`[Cache] HIT for barcode: ${barcode}`); return cachedProduct; } console.log(`[Cache] MISS for barcode: ${barcode}. Fetching from OFF.`); const url = `https: try { const response = await ky.get(url).json<OpenFoodFactsResponse>(); if (response.status === 0 || !response.product) { return null; } const productFromApi = response.product; const parseNutriment = (value: unknown): number => { if (typeof value === 'number') return value; if (typeof value === 'string') { const parsed = parseFloat(value); return isNaN(parsed) ? 0 : parsed; } return 0; }; const calories = productFromApi.nutriments['energy-kcal_100g'] ?? productFromApi.nutriments.energy_kcal_100g; const normalizedProduct = { id: productFromApi.code, name: productFromApi.product_name, normalizedName: normalizeText(productFromApi.product_name), brand: productFromApi.brands, imageUrl: productFromApi.image_url, calories: parseNutriment(calories), fat: parseNutriment(productFromApi.nutriments.fat_100g), protein: parseNutriment(productFromApi.nutriments.proteins_100g), carbs: parseNutriment(productFromApi.nutriments.carbohydrates_100g), fullPayload: productFromApi as Prisma.InputJsonValue }; console.log(`[Cache] WRITING product: ${normalizedProduct.name}`); const newCachedProduct = await prisma.product.create({ data: normalizedProduct }); return newCachedProduct; } catch (error) { console.error(`[OFF] Error fetching product ${barcode}:`, error); return null; } }, async deleteById(barcode: string) { return await prisma.product.delete({ where: { id: barcode } }); } };

// --- Ruta: src/lib/server/services/productService.spec.ts ---
vi.mock('$lib/server/prisma', () => ({ default: { product: { findUnique: vi.fn(), create: vi.fn() } } })); vi.mock('ky', () => ({ default: { get: vi.fn() } })); vi.mock('$lib/utils', () => ({ normalizeText: vi.fn((text) => text.toLowerCase()) })); const mockedPrisma = prisma; const mockedKy = ky; const mockedNormalizeText = normalizeText as Mock; type OpenFoodFactsProduct = { code: string; product_name: string; brands?: string; image_url?: string; nutriments: { energy_kcal_100g?: number; fat_100g?: number; proteins_100g?: number; carbohydrates_100g?: number; }; }; type OpenFoodFactsResponse = { status: number; product?: OpenFoodFactsProduct; }; describe('productService', () => { beforeEach(() => { vi.resetAllMocks(); vi.spyOn(console, 'log').mockImplementation(() => {}); }); afterEach(() => { vi.mocked(console.log).mockRestore(); }); const barcode = '123456789'; const cachedProduct: Product = { id: barcode, name: 'Producto en Caché', normalizedName: 'producto en caché', brand: 'Marca Caché', imageUrl: 'http: calories: 100, fat: 10, protein: 5, carbs: 20, fullPayload: {} as Prisma.JsonValue, createdAt: new Date(), updatedAt: new Date() }; const productFromApi: OpenFoodFactsProduct = { code: barcode, product_name: 'Producto de API', brands: 'Marca API', image_url: 'http: nutriments: { energy_kcal_100g: 200, fat_100g: 20, proteins_100g: 10, carbohydrates_100g: 40 } }; const apiProductResponse: OpenFoodFactsResponse = { status: 1, product: productFromApi }; it('debería devolver un producto de la caché si existe (Cache Hit)', async () => { (mockedPrisma.product.findUnique as Mock).mockResolvedValue(cachedProduct); const result = await productService.findByBarcode(barcode); expect(result).toEqual(cachedProduct); expect(mockedPrisma.product.findUnique).toHaveBeenCalledTimes(1); expect(mockedKy.get).not.toHaveBeenCalled(); }); it('debería obtener el producto de la API y guardarlo en caché si no existe (Cache Miss)', async () => { (mockedPrisma.product.findUnique as Mock).mockResolvedValue(null); (mockedKy.get as Mock).mockReturnValue({ json: vi.fn().mockResolvedValue(apiProductResponse) }); const expectedDataToCreate = { id: productFromApi.code, name: productFromApi.product_name, normalizedName: 'producto de api', brand: productFromApi.brands, imageUrl: productFromApi.image_url, calories: productFromApi.nutriments.energy_kcal_100g, fat: productFromApi.nutriments.fat_100g, protein: productFromApi.nutriments.proteins_100g, carbs: productFromApi.nutriments.carbohydrates_100g, fullPayload: productFromApi as unknown as Prisma.JsonValue }; (mockedPrisma.product.create as Mock).mockResolvedValue({ ...expectedDataToCreate, createdAt: new Date(), updatedAt: new Date() }); mockedNormalizeText.mockReturnValue('producto de api'); await productService.findByBarcode(barcode); expect(mockedPrisma.product.findUnique).toHaveBeenCalledTimes(1); expect(mockedKy.get).toHaveBeenCalledTimes(1); expect(mockedPrisma.product.create).toHaveBeenCalledTimes(1); expect(mockedPrisma.product.create).toHaveBeenCalledWith({ data: expectedDataToCreate }); }); it('debería devolver null si el producto no se encuentra ni en caché ni en la API', async () => { (mockedPrisma.product.findUnique as Mock).mockResolvedValue(null); (mockedKy.get as Mock).mockReturnValue({ json: vi.fn().mockResolvedValue({ status: 0 }) }); const result = await productService.findByBarcode(barcode); expect(result).toBeNull(); expect(mockedPrisma.product.create).not.toHaveBeenCalled(); }); });

// --- Ruta: src/lib/server/services/ingredientService.ts ---
export const ingredientService = { async searchByName( query: string ): Promise<{ customIngredients: CustomIngredient[]; cachedProducts: Product[] }> { const normalizedQuery = normalizeText(query); const customIngredients = await prisma.customIngredient.findMany({ where: { normalizedName: { contains: normalizedQuery } } }); const cachedProducts = await prisma.product.findMany({ where: { normalizedName: { contains: normalizedQuery } } }); return { customIngredients, cachedProducts }; }, async getAll() { return await prisma.customIngredient.findMany({ orderBy: { name: 'asc' } }); }, async getAllUnified(search?: string, sort: string = 'name', order: string = 'asc') { const whereClause = search ? { normalizedName: { contains: normalizeText(search) } } : {}; const customIngredients = await prisma.customIngredient.findMany({ where: whereClause }); const cachedProducts = await prisma.product.findMany({ where: whereClause }); const unifiedList = [ ...customIngredients.map((i) => ({ ...i, source: 'custom' as const })), ...cachedProducts.map((p) => ({ ...p, source: 'product' as const })) ]; unifiedList.sort((a, b) => { const aValue = a[sort as keyof typeof a]; const bValue = b[sort as keyof typeof b]; let compare = 0; if (typeof aValue === 'string' && typeof bValue === 'string') { compare = aValue.localeCompare(bValue); } else if (typeof aValue === 'number' && typeof bValue === 'number') { compare = aValue - bValue; } else if (aValue === null || aValue === undefined) { compare = 1; } else if (bValue === null || bValue === undefined) { compare = -1; } return order === 'asc' ? compare : -compare; }); return unifiedList; }, async create(data: Ingredient) { const normalizedName = normalizeText(data.name); return await prisma.customIngredient.create({ data: { name: data.name, calories: data.calories, fat: data.fat, protein: data.protein, carbs: data.carbs, normalizedName } }); }, async update(id: string, data: Ingredient) { const normalizedName = normalizeText(data.name); return await prisma.customIngredient.update({ where: { id }, data: { ...data, normalizedName } }); }, async deleteById(id: string) { return await prisma.customIngredient.delete({ where: { id } }); }, async deleteProductById(id: string) { return await prisma.product.delete({ where: { id } }); }, async syncWithOpenFoodFacts(): Promise<{ updatedIngredients: string[]; failedIngredients: { id: string; name: string; reason: string }[]; }> { const updatedIngredients: string[] = []; const failedIngredients: { id: string; name: string; reason: string }[] = []; const API_DELAY_MS = 300; const productsToSync = await prisma.product.findMany(); for (const product of productsToSync) { try { const response = await fetch(`https: await new Promise((resolve) => setTimeout(resolve, API_DELAY_MS)); if (!response.ok) { failedIngredients.push({ id: product.id, name: product.name, reason: `Error ${response.status}: ${response.statusText}` }); continue; } const offData = await response.json(); if (offData.status !== 1 || !offData.product) { failedIngredients.push({ id: product.id, name: product.name, reason: 'Producto no encontrado en Open Food Facts' }); continue; } const offProduct = offData.product; const newProductData: Prisma.ProductUpdateInput = { brand: offProduct.brands || product.brand, imageUrl: offProduct.image_url || product.imageUrl, calories: offProduct.nutriments?.['energy-kcal_100g'] ?? product.calories, fat: offProduct.nutriments?.fat_100g ?? product.fat, protein: offProduct.nutriments?.proteins_100g ?? product.protein, carbs: offProduct.nutriments?.carbohydrates_100g ?? product.carbs, fullPayload: offProduct }; if (!product.isNameManuallySet) { const nameFromOff = offProduct.product_name || product.name; newProductData.name = nameFromOff; newProductData.normalizedName = normalizeText(nameFromOff); } const isDifferent = (newProductData.name && newProductData.name !== product.name) || newProductData.brand !== product.brand || newProductData.imageUrl !== product.imageUrl || newProductData.calories !== product.calories || newProductData.fat !== product.fat || newProductData.protein !== product.protein || newProductData.carbs !== product.carbs; if (isDifferent) { await prisma.product.update({ where: { id: product.id }, data: newProductData }); updatedIngredients.push(product.name); } } catch (error) { failedIngredients.push({ id: product.id, name: product.name, reason: error instanceof Error ? error.message : 'Error desconocido' }); } } return { updatedIngredients, failedIngredients }; }, async updateProductName(id: string, newName: string) { const normalizedName = normalizeText(newName); return await prisma.product.update({ where: { id }, data: { name: newName, normalizedName, isNameManuallySet: true } }); }, async getByIds(ids: string[]) { const productIds = ids .filter((id) => id.startsWith('product-')) .map((id) => id.replace('product-', '')); const customIngredientIds = ids .filter((id) => id.startsWith('custom-')) .map((id) => id.replace('custom-', '')); const [products, customIngredients] = await prisma.$transaction([ prisma.product.findMany({ where: { id: { in: productIds } } }), prisma.customIngredient.findMany({ where: { id: { in: customIngredientIds } } }) ]); const combined = [ ...products.map((p) => ({ ...p, id: `product-${p.id}`, type: 'product' as const, source: 'off' as const })), ...customIngredients.map((ci) => ({ ...ci, id: `custom-${ci.id}`, type: 'custom' as const, source: 'local' as const, imageUrl: null })) ]; return combined; } };

// --- Ruta: src/lib/server/services/ingredientService.spec.ts ---
vi.mock('$lib/server/prisma', () => { return { default: { customIngredient: { findMany: vi.fn(), create: vi.fn(), update: vi.fn(), delete: vi.fn() }, product: { findMany: vi.fn(), update: vi.fn() } } }; }); global.fetch = vi.fn(); describe('ingredientService', () => { beforeEach(() => { vi.clearAllMocks(); }); afterEach(() => { vi.useRealTimers(); }); it('debería llamar a prisma.customIngredient.create con los datos correctos', async () => { const newIngredientData: Ingredient = { name: 'Harina de Almendras', calories: 579, protein: 21.1, fat: 49.9, carbs: 21.6 }; const expectedResult = { id: 'clxmjm8om0000v9a1b2c3d4e5', ...newIngredientData }; vi.mocked(prisma.customIngredient.create).mockResolvedValue(expectedResult); const result = await ingredientService.create(newIngredientData); expect(prisma.customIngredient.create).toHaveBeenCalledTimes(1); expect(prisma.customIngredient.create).toHaveBeenCalledWith({ data: { ...newIngredientData, normalizedName: 'harina de almendras' } }); expect(result).toEqual(expectedResult); }); describe('syncWithOpenFoodFacts', () => { beforeEach(() => { vi.useFakeTimers(); }); afterEach(() => { vi.useRealTimers(); }); it('debería actualizar un producto cuando los datos de OFF son diferentes', async () => { const mockProduct = { id: '12345', name: 'Old Name', brand: 'Old Brand', calories: 100, fat: 10, protein: 10, carbs: 10, imageUrl: 'old_url', normalizedName: 'old name', fullPayload: {} }; vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct]); const offApiResponse = { status: 1, product: { product_name: 'New Name', brands: 'New Brand', nutriments: { 'energy-kcal_100g': 200, fat_100g: 20, proteins_100g: 20, carbohydrates_100g: 20 }, image_url: 'new_url' } }; vi.mocked(fetch).mockResolvedValue({ ok: true, json: async () => offApiResponse } as Response); const promise = ingredientService.syncWithOpenFoodFacts(); await vi.runAllTimersAsync(); const result = await promise; expect(prisma.product.update).toHaveBeenCalledTimes(1); expect(prisma.product.update).toHaveBeenCalledWith({ where: { id: '12345' }, data: { name: 'New Name', normalizedName: 'new name', brand: 'New Brand', imageUrl: 'new_url', calories: 200, fat: 20, protein: 20, carbs: 20, fullPayload: offApiResponse.product } }); expect(result.updatedIngredients).toEqual(['Old Name']); expect(result.failedIngredients).toEqual([]); }); it('NO debería actualizar un producto si los datos son idénticos', async () => { const mockProduct = { id: '12345', name: 'Same Name', brand: 'Same Brand', calories: 100, fat: 10, protein: 10, carbs: 10, imageUrl: 'same_url', normalizedName: 'same name', fullPayload: {} }; vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct]); const offApiResponse = { status: 1, product: { product_name: 'Same Name', brands: 'Same Brand', nutriments: { 'energy-kcal_100g': 100, fat_100g: 10, proteins_100g: 10, carbohydrates_100g: 10 }, image_url: 'same_url' } }; vi.mocked(fetch).mockResolvedValue({ ok: true, json: async () => offApiResponse } as Response); const promise = ingredientService.syncWithOpenFoodFacts(); await vi.runAllTimersAsync(); const result = await promise; expect(prisma.product.update).not.toHaveBeenCalled(); expect(result.updatedIngredients).toEqual([]); expect(result.failedIngredients).toEqual([]); }); it('debería registrar un fallo si la API de OFF devuelve un error', async () => { const mockProduct = { id: '12345', name: 'Failing Product' }; vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct as any]); vi.mocked(fetch).mockResolvedValue({ ok: false, status: 500, statusText: 'Internal Server Error' } as Response); const promise = ingredientService.syncWithOpenFoodFacts(); await vi.runAllTimersAsync(); const result = await promise; expect(prisma.product.update).not.toHaveBeenCalled(); expect(result.updatedIngredients).toEqual([]); expect(result.failedIngredients).toEqual([ { id: '12345', name: 'Failing Product', reason: 'Error 500: Internal Server Error' } ]); }); it('debería registrar un fallo si el producto no se encuentra en OFF', async () => { const mockProduct = { id: '12345', name: 'Not Found Product' }; vi.mocked(prisma.product.findMany).mockResolvedValue([mockProduct as any]); vi.mocked(fetch).mockResolvedValue({ ok: true, json: async () => ({ status: 0 }) } as Response); const promise = ingredientService.syncWithOpenFoodFacts(); await vi.runAllTimersAsync(); const result = await promise; expect(result.failedIngredients).toEqual([ { id: '12345', name: 'Not Found Product', reason: 'Producto no encontrado en Open Food Facts' } ]); }); }); });

// --- Ruta: src/lib/server/services/imageService.ts ---
const MAX_IMAGE_WIDTH = 768; async function getImageUrlFromPage(url: string): Promise<string | null> { try { const response = await fetch(url, { headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' } }); if (!response.ok) { console.error(`Error fetching page ${url}: ${response.statusText}`); return null; } const html = await response.text(); const $ = cheerio.load(html); const ogImage = $('meta[property="og:image"]').attr('content'); if (ogImage) return ogImage; const twitterImage = $('meta[name="twitter:image"]').attr('content'); if (twitterImage) return twitterImage; return null; } catch (error) { console.error(`Failed to fetch or parse page at ${url}`, error); return null; } } async function processImage(imageUrl: string): Promise<string | null> { try { const imageResponse = await fetch(imageUrl); if (!imageResponse.ok) { console.error(`Error fetching image ${imageUrl}: ${imageResponse.statusText}`); return null; } const imageBuffer = await imageResponse.arrayBuffer(); const optimizedImageBuffer = await sharp(Buffer.from(imageBuffer)) .resize(MAX_IMAGE_WIDTH, null, { withoutEnlargement: true }) .webp({ quality: 60 }) .toBuffer(); const base64Image = optimizedImageBuffer.toString('base64'); return `data:image/webp;base64,${base64Image}`; } catch (error) { console.error(`Failed to process image at ${imageUrl}`, error); return null; } } export const imageService = { getImageFromUrl: async (pageUrl: string): Promise<string | null> => { const imageUrl = await getImageUrlFromPage(pageUrl); if (!imageUrl) { return null; } return processImage(imageUrl); } };

// --- Ruta: src/lib/server/services/imageService.spec.ts ---
vi.mock('sharp', () => { const chainable = { resize: vi.fn().mockReturnThis(), webp: vi.fn().mockReturnThis(), toBuffer: vi.fn().mockResolvedValue(Buffer.from('optimized-image-buffer')) }; return { default: vi.fn(() => chainable) }; }); global.fetch = vi.fn(); const mockedFetch = vi.mocked(global.fetch); describe('imageService', () => { beforeEach(() => { vi.clearAllMocks(); vi.spyOn(console, 'error').mockImplementation(() => {}); }); afterEach(() => { vi.mocked(console.error).mockRestore(); }); describe('getImageFromUrl', () => { it('should return a processed image from an og:image meta tag', async () => { const mockPageUrl = 'https: const mockImageUrl = 'https: const mockHtml = `<html><head><meta property="og:image" content="${mockImageUrl}" /></head></html>`; mockedFetch.mockImplementation(async (url): Promise<Response> => { if (url === mockPageUrl) { return new Response(mockHtml); } if (url === mockImageUrl) { return new Response(Buffer.from('image-data')); } throw new Error(`Unexpected fetch call to ${url}`); }); const result = await imageService.getImageFromUrl(mockPageUrl); expect(result).toBe('data:image/webp;base64,b3B0aW1pemVkLWltYWdlLWJ1ZmZlcg=='); expect(mockedFetch).toHaveBeenCalledWith(mockPageUrl, expect.any(Object)); expect(mockedFetch).toHaveBeenCalledWith(mockImageUrl); }); it('should return a processed image from a twitter:image meta tag if og:image is not present', async () => { const mockPageUrl = 'https: const mockImageUrl = 'https: const mockHtml = `<html><head><meta name="twitter:image" content="${mockImageUrl}" /></head></html>`; mockedFetch.mockImplementation(async (url): Promise<Response> => { if (url === mockPageUrl) { return new Response(mockHtml); } if (url === mockImageUrl) { return new Response(Buffer.from('image-data')); } throw new Error(`Unexpected fetch call to ${url}`); }); const result = await imageService.getImageFromUrl(mockPageUrl); expect(result).toContain('data:image/webp;base64,'); expect(mockedFetch).toHaveBeenCalledWith(mockImageUrl); }); it('should return null if no image meta tags are found', async () => { const mockPageUrl = 'https: const mockHtml = '<html><head></head></html>'; mockedFetch.mockResolvedValue(new Response(mockHtml)); const result = await imageService.getImageFromUrl(mockPageUrl); expect(result).toBeNull(); expect(mockedFetch).toHaveBeenCalledOnce(); }); it('should return null if fetching the page fails', async () => { const mockPageUrl = 'https: mockedFetch.mockRejectedValue(new Error('Network error')); const result = await imageService.getImageFromUrl(mockPageUrl); expect(result).toBeNull(); }); it('should return null if fetching the image fails', async () => { const mockPageUrl = 'https: const mockImageUrl = 'https: const mockHtml = `<html><head><meta property="og:image" content="${mockImageUrl}" /></head></html>`; mockedFetch.mockImplementation(async (url): Promise<Response> => { if (url === mockPageUrl) { return new Response(mockHtml); } if (url === mockImageUrl) { throw new Error('Image not found'); } throw new Error(`Unexpected fetch call to ${url}`); }); const result = await imageService.getImageFromUrl(mockPageUrl); expect(result).toBeNull(); }); }); });

// --- Ruta: src/lib/components/recipes/UrlImageFetcher.svelte ---
<!-- Ruta: src/lib/components/recipes/UrlImageFetcher.svelte --> <script lang="ts"> import { Input } from '$lib/components/ui/input'; import { Button } from '$lib/components/ui/button'; import { Trash2, Loader, BadgeCheck, TriangleAlert } from 'lucide-svelte'; type $Props = { urls: string[]; imageUrl: string; }; let { urls = $bindable(), imageUrl = $bindable() }: $Props = $props(); let urlStates = $state( urls.map(() => ({ status: 'idle' as 'idle' | 'loading' | 'success' | 'error', message: '' })) ); function addUrlField() { urls.push(''); urlStates.push({ status: 'idle', message: '' }); } function removeUrlField(index: number) { urls.splice(index, 1); urlStates.splice(index, 1); } async function handleUrlBlur(index: number) { const url = urls[index]; if (!url || !url.startsWith('http')) { urlStates[index] = { status: 'idle', message: '' }; return; } if (imageUrl) return; urlStates[index] = { status: 'loading', message: '' }; try { const response = await fetch('/api/scrape-image', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url }) }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.message || 'Error desconocido'); } const data = await response.json(); imageUrl = data.imageUrl; urlStates[index] = { status: 'success', message: 'Imagen encontrada' }; } catch (error) { urlStates[index] = { status: 'error', message: error instanceof Error ? error.message : 'No se pudo obtener la imagen' }; } } </script> <div class="space-y-2"> {#each urls as _, i} <div class="flex items-center gap-2"> <div class="relative flex-grow"> <Input type="url" placeholder="https: bind:value={urls[i]} onblur={() => handleUrlBlur(i)} class="pr-10" /> <div class="absolute inset-y-0 right-0 flex items-center pr-3"> {#if urlStates[i]?.status === 'loading'} <Loader class="h-5 w-5 animate-spin text-gray-400" /> {:else if urlStates[i]?.status === 'success'} <BadgeCheck class="h-5 w-5 text-green-500" /> {:else if urlStates[i]?.status === 'error'} <TriangleAlert class="h-5 w-5 text-red-500" /> {/if} </div> </div> <Button type="button" variant="ghost" size="icon" onclick={() => removeUrlField(i)}> <Trash2 class="h-4 w-4" /> </Button> </div> {#if urlStates[i]?.status === 'error'} <p class="text-sm text-red-500 ml-1">{urlStates[i].message}</p> {/if} {/each} <Button type="button" variant="outline" size="sm" onclick={addUrlField}> Añadir URL </Button> </div>

// --- Ruta: src/lib/components/recipes/RecipeForm.svelte ---
<!-- Ruta: src/lib/components/recipes/RecipeForm.svelte --> <script lang="ts"> import { page } from '$app/state'; import { Button } from '$lib/components/ui/button'; import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import { Table, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table'; import { Textarea } from '$lib/components/ui/textarea'; import { calculateNutritionalInfo, type CalculableIngredient } from '$lib/recipeCalculator'; import type { RecipeIngredient } from '$lib/schemas/recipeSchema'; import * as Popover from '$lib/components/ui/popover'; import * as Command from '$lib/components/ui/command'; import { ChevronsUpDown, Trash2, GripVertical, Database, Save, X } from 'lucide-svelte'; import { enhance, applyAction } from '$app/forms'; import UrlImageFetcher from '$lib/components/recipes/UrlImageFetcher.svelte'; import { draggable, droppable, type DragDropState } from '@thisux/sveltednd'; import { browser } from '$app/environment'; import type { ActionData } from '../../../routes/recetas/nueva/$types'; import { cn } from '$lib/utils'; import * as autosave from '$lib/runes/useAutosave'; import * as Alert from '$lib/components/ui/alert'; import { onMount } from 'svelte'; import { toast } from 'svelte-sonner'; type IngredientWithDetails = RecipeIngredient & CalculableIngredient & { name: string; imageUrl?: string | null; originalId?: string }; type SearchResult = { id: string; name: string; source: 'local' | 'off'; type: 'custom' | 'product'; imageUrl: string | null; }; type InitialData = { title: string; steps: string[]; imageUrl: string | null; urls: { url: string }[]; ingredients: (IngredientWithDetails & { customIngredient: { id: string; name: string }; product: { id: string; name: string; imageUrl: string | null }; })[]; }; let { initialData = null, form = null, cardTitle = 'Crear Nueva Receta', submitButtonText = 'Guardar Receta', onSuccess = async () => {}, recipeId = null }: { initialData?: InitialData | null; form?: ActionData | null; cardTitle?: string; submitButtonText?: string; onSuccess?: () => Promise<void>; recipeId?: string | null; } = $props(); const getRecipeSteps = (stepsData: unknown): string[] => { if (Array.isArray(stepsData)) { return stepsData.map(String); } if (browser && typeof stepsData === 'string') { try { const parsed = JSON.parse(stepsData); return Array.isArray(parsed) ? parsed.map(String) : [String(stepsData)]; } catch (e) { return [String(stepsData)]; } } return ['']; }; const mapInitialIngredients = (ingredientsData: InitialData['ingredients'] | undefined) => { if (!ingredientsData) return []; return ingredientsData .map((ing): IngredientWithDetails | null => { const quantity = ing.quantity; if (ing.customIngredient) { return { id: ing.customIngredient.id + 'custom', type: 'custom', quantity, name: ing.customIngredient.name, calories: ing.calories ?? 0, protein: ing.protein ?? 0, fat: ing.fat ?? 0, carbs: ing.carbs ?? 0, imageUrl: null }; } if (ing.product) { return { id: ing.product.id + 'product', type: 'product', quantity, name: ing.product.name, calories: ing.calories ?? 0, protein: ing.protein ?? 0, fat: ing.fat ?? 0, carbs: ing.carbs ?? 0, imageUrl: ing.product.imageUrl }; } return null; }) .filter((ing): ing is IngredientWithDetails => ing !== null); }; let formData = $state({ title: initialData?.title ?? '', steps: getRecipeSteps(initialData?.steps), imageUrl: initialData?.imageUrl ?? '', urls: initialData?.urls.map((u) => u.url) ?? [], ingredients: mapInitialIngredients(initialData?.ingredients) }); const storageKey = recipeId ? `recipe-autosave-${recipeId}` : 'new-recipe-autosave'; type Status = 'initializing' | 'awaitingDecision' | 'editing'; let status = $state<Status>('initializing'); const isFormDirty = $derived( (initialData?.title ?? '') !== formData.title || JSON.stringify(getRecipeSteps(initialData?.steps)) !== JSON.stringify(formData.steps) || JSON.stringify(initialData?.urls.map((u) => u.url) ?? []) !== JSON.stringify(formData.urls) || JSON.stringify(mapInitialIngredients(initialData?.ingredients)) !== JSON.stringify(formData.ingredients) ); onMount(() => { if (autosave.hasData(storageKey)) { status = 'awaitingDecision'; } else { status = 'editing'; } }); autosave.createAutosave(storageKey, () => formData, { enabled: () => status === 'editing', isDirty: () => isFormDirty }); function handleRestore() { const savedData = autosave.load<typeof formData>(storageKey); if (savedData) { formData = savedData; } status = 'editing'; } function handleDiscard() { autosave.clear(storageKey); status = 'editing'; } function handleDrop(state: DragDropState<IngredientWithDetails>) { const { draggedItem, targetElement } = state; if (!draggedItem || !targetElement) return; const sourceIndex = formData.ingredients.findIndex((item) => item.id === draggedItem.id); const targetRow = (targetElement as HTMLElement).closest('tr'); if (!targetRow || !targetRow.parentElement) return; const targetIndex = Array.from(targetRow.parentElement.children).indexOf(targetRow); if (sourceIndex === -1 || targetIndex === -1) return; const reorderedIngredients = [...formData.ingredients]; const [removed] = reorderedIngredients.splice(sourceIndex, 1); reorderedIngredients.splice(targetIndex, 0, removed); formData.ingredients = reorderedIngredients; } let searchResults: SearchResult[] = $state([]); let isSearching = $state(false); let open = $state(false); let inputValue = $state(''); let searchTerm = $state(''); let triggerWrapperEl: HTMLDivElement | null = $state(null); $effect(() => { if (browser && open && triggerWrapperEl) { const contentEl = document.querySelector<HTMLDivElement>('[data-slot="popover-content"]'); if (contentEl) { const rect = triggerWrapperEl.getBoundingClientRect(); contentEl.style.width = `${rect.width}px`; } } }); $effect(() => { let eventSource: EventSource | null = null; if (searchTerm.length < 3) { searchResults = []; isSearching = false; } else { isSearching = true; searchResults = []; eventSource = new EventSource(`/api/ingredients/search?q=${encodeURIComponent(searchTerm)}`); eventSource.addEventListener('message', (e) => { const newResults = JSON.parse(e.data); searchResults = [...searchResults, ...newResults]; }); eventSource.addEventListener('stream_error', (e) => console.error('Error de stream:', e)); eventSource.onerror = (err) => { console.error('Error en EventSource:', err); isSearching = false; eventSource?.close(); }; eventSource.addEventListener('close', () => { isSearching = false; eventSource?.close(); }); } return () => eventSource?.close(); }); async function addIngredient(result: SearchResult) { const dndId = result.id + result.type; if (formData.ingredients.some((ing) => ing.id === dndId)) return; try { const response = await fetch(`/api/ingredients/details/${result.id}?type=${result.type}`); if (!response.ok) throw new Error('Failed to fetch ingredient details'); const details: CalculableIngredient = await response.json(); formData.ingredients.push({ ...result, ...details, id: dndId, quantity: 100 }); } catch (error) { console.error('Error adding ingredient:', error); } finally { open = false; searchResults = []; searchTerm = ''; inputValue = ''; } } function removeIngredient(id: string) { formData.ingredients = formData.ingredients.filter((ing) => ing.id !== id); } function handleImageUpload(event: Event) { const target = event.target as HTMLInputElement; const file = target.files?.[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => (formData.imageUrl = e.target?.result as string); reader.readAsDataURL(file); } } let nutritionalInfo = $derived(calculateNutritionalInfo(formData.ingredients)); let isSubmitting = $state(false); </script> <Card class="max-w-4xl mx-auto my-8"> <CardHeader> <CardTitle class="mt-4">{cardTitle}</CardTitle> {#if status === 'awaitingDecision'} <Alert.Root class="mt-4"> <Save class="h-4 w-4" /> <Alert.Title>¡Borrador encontrado!</Alert.Title> <Alert.Description class="flex items-center justify-between"> <p>Hemos encontrado un borrador guardado. ¿Quieres continuar donde lo dejaste?</p> <div class="flex gap-2 mt-2 md:mt-0"> <Button type="button" size="sm" onclick={handleRestore}>Restaurar</Button> <Button type="button" variant="destructive" size="sm" onclick={handleDiscard}> <X class="h-4 w-4 mr-2" /> Descartar </Button> </div> </Alert.Description> </Alert.Root> {/if} </CardHeader> <CardContent> <form method="POST" use:enhance={() => { isSubmitting = true; const toastId = toast.loading('Guardando receta...'); return async ({ result }) => { await applyAction(result); isSubmitting = false; if (result.type === 'success') { toast.success('Receta guardada con éxito.', { id: toastId }); autosave.clear(storageKey); await onSuccess(); } else if (result.type === 'failure') { const message = form?.message || 'Error al guardar la receta. Revisa los campos.'; toast.error(message, { id: toastId }); } else { toast.dismiss(toastId); } }; }} class="space-y-6" > <!-- Campos ocultos --> <input type="hidden" name="ingredients" value={JSON.stringify( formData.ingredients.map(({ id, quantity, type }) => ({ id: id.replace(type, ''), quantity, type })) )} /> <input type="hidden" name="urls" value={JSON.stringify(formData.urls.filter((u) => u.trim() !== ''))} /> <input type="hidden" name="steps" value={JSON.stringify(formData.steps.filter((s) => s.trim() !== ''))} /> <input type="hidden" name="imageUrl" value={formData.imageUrl} /> <!-- Campos del formulario --> <div class="space-y-2"> <Label for="title">Título</Label> <Input id="title" name="title" bind:value={formData.title} required /> {#if form?.errors?.title} <p class="text-sm text-red-500">{form.errors.title}</p> {/if} </div> <div class="space-y-2"> <Label for="image">Imagen de la Receta</Label> <div class="flex items-center gap-4"> {#if formData.imageUrl} <img src={formData.imageUrl} alt="Previsualización de la receta" class="h-24 w-24 rounded-md object-cover" /> {/if} <Input id="image" type="file" onchange={handleImageUpload} accept="image/*" /> </div> <p class="text-sm text-gray-500"> Sube una imagen o deja el campo vacío para intentar usar la de la primera URL de referencia. </p> </div> <div class="space-y-2"> <Label>URLs de Referencia</Label> <UrlImageFetcher bind:urls={formData.urls} bind:imageUrl={formData.imageUrl} /> {#if form?.errors?.urls} <p class="text-sm text-red-500">{form.errors.urls}</p> {/if} </div> <div class="space-y-4"> <Label class="text-lg font-medium">Pasos de la Receta</Label> {#each formData.steps as step, i} <div class="flex items-start gap-2"> <div class="flex-1 space-y-1"> <Label for={`step-${i}`} class="text-sm font-normal text-gray-600" >Paso {i + 1}</Label > <Textarea id={`step-${i}`} name={`step-${i}`} bind:value={formData.steps[i]} rows={3} placeholder="Describe este paso... (soporta Markdown)" /> </div> <Button type="button" variant="ghost" size="icon" onclick={() => formData.steps.splice(i, 1)} class="mt-6" aria-label="Eliminar paso" > <Trash2 class="h-4 w-4" /> </Button> </div> {/each} <Button type="button" variant="outline" onclick={() => formData.steps.push('')}> Añadir Paso </Button> {#if form?.errors?.steps} <p class="text-sm text-red-500">{form.errors.steps}</p> {/if} </div> <!-- Buscador y tabla de ingredientes --> <div class="space-y-2"> <Label>Añadir Ingrediente</Label> <div bind:this={triggerWrapperEl}> <Popover.Root bind:open> <Popover.Trigger class="inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border w-full justify-between h-9 px-4 py-2" role="combobox" aria-expanded={open} > <div class="flex items-center justify-between w-full"> {inputValue || 'Seleccionar ingrediente...'} <ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" /> </div> </Popover.Trigger> <Popover.Content class="p-0"> <Command.Root filter={() => 1}> <Command.Input bind:value={searchTerm} placeholder="Buscar ingrediente..." /> <Command.List> {#if searchResults.length > 0} {#each searchResults as result (result.id + result.type)} <Command.Item value={result.name} onSelect={() => { inputValue = result.name; addIngredient(result); }} class={cn( 'flex items-center justify-between w-full', result.source === 'local' ? 'bg-muted/50' : '' )} > <div class="flex items-center gap-2"> <img src={result.imageUrl || 'https: alt={result.name} class="h-8 w-8 rounded-sm object-cover" /> <span>{result.name}</span> </div> {#if result.source === 'local'} <Database class="h-4 w-4 text-muted-foreground" /> {/if} </Command.Item> {/each} {:else} <div class="p-4 text-sm text-center text-gray-500"> {#if isSearching} Buscando... {:else if searchTerm.length < 3} Escribe al menos 3 caracteres para buscar... {:else} No se encontraron resultados. {/if} </div> {/if} </Command.List> </Command.Root> </Popover.Content> </Popover.Root> </div> </div> <div class="space-y-2"> <h3 class="text-lg font-medium">Ingredientes de la Receta</h3> <Table> <TableHeader> <TableRow> <TableHead class="w-[50px]"></TableHead> <TableHead>Nombre</TableHead> <TableHead class="w-[150px]">Cantidad (g)</TableHead> <TableHead class="w-[100px] text-right">Acciones</TableHead> </TableRow> </TableHeader> <tbody use:droppable={{ container: 'ingredients', callbacks: { onDrop: handleDrop } }} > {#each formData.ingredients as ingredient, i (ingredient.id)} <tr use:draggable={{ container: 'ingredients', dragData: ingredient, interactive: ['[data-quitar-btn]'] }} class="hover:[&,&>svelte-css-wrapper]:[&>th,td]:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors" > <TableCell class="cursor-grab"> <div class="flex items-center gap-2 text-muted-foreground"> <GripVertical class="h-5 w-5" /> <span class="text-sm font-medium">{i + 1}</span> </div> </TableCell> <TableCell>{ingredient.name}</TableCell> <TableCell> <Input type="number" value={ingredient.quantity} oninput={(e) => (ingredient.quantity = e.currentTarget.valueAsNumber)} min="1" class="w-full hide-arrows" /> </TableCell> <TableCell class="text-right"> <Button type="button" variant="destructive" size="sm" data-quitar-btn onclick={() => removeIngredient(ingredient.id)} > Quitar </Button> </TableCell> </tr> {/each} {#if formData.ingredients.length === 0} <tr class="hover:[&,&>svelte-css-wrapper]:[&>th,td]:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors" > <TableCell colspan={4} class="text-center text-gray-500"> Añade ingredientes usando el buscador. </TableCell> </tr> {/if} </tbody> </Table> {#if form?.errors?.ingredients} <p class="text-sm text-red-500">{form.errors.ingredients}</p> {/if} </div> <!-- Información nutricional --> <div class="space-y-2 p-4 border rounded-lg bg-muted/20"> <h3 class="text-lg font-medium">Información Nutricional</h3> <div class="grid grid-cols-2 md:grid-cols-4 gap-4"> <div> <p class="font-bold text-xl">{nutritionalInfo.totalCalories.toFixed(1)}</p> <p class="text-sm text-muted-foreground">Calorías (kcal)</p> </div> <div> <p class="font-bold text-xl">{nutritionalInfo.totalProtein.toFixed(1)} g</p> <p class="text-sm text-muted-foreground">Proteínas</p> </div> <div> <p class="font-bold text-xl">{nutritionalInfo.totalFat.toFixed(1)} g</p> <p class="text-sm text-muted-foreground">Grasas</p> </div> <div> <p class="font-bold text-xl">{nutritionalInfo.totalCarbs.toFixed(1)} g</p> <p class="text-sm text-muted-foreground">Carbohidratos</p> </div> </div> </div> <div class="flex justify-end"> <Button type="submit" disabled={isSubmitting}> {submitButtonText} </Button> </div> {#if form?.message} <p class="text-sm text-red-500 text-right">{form.message}</p> {/if} </form> </CardContent> </Card> <style> :global(.hide-arrows::-webkit-inner-spin-button), :global(.hide-arrows::-webkit-outer-spin-button) { -webkit-appearance: none; margin: 0; } :global(.hide-arrows) { -moz-appearance: textfield; appearance: textfield; } </style>

// --- Ruta: src/lib/components/recipes/RecipeCard.svelte ---
<!-- --> <script lang="ts"> import { calculateNutritionalInfo } from '$lib/recipeCalculator'; import type { CalculableIngredient } from '$lib/recipeCalculator'; import * as Card from '$lib/components/ui/card/index.js'; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator, DropdownMenuTrigger } from '$lib/components/ui/dropdown-menu'; import { Button } from '$lib/components/ui/button/index.js'; import MoreVertical from 'lucide-svelte/icons/more-vertical'; type Recipe = { id: string; slug: string; title: string; imageUrl: string | null; ingredients: { quantity: number; product: { calories: number | null; protein: number | null; fat: number | null; carbs: number | null; } | null; customIngredient: { calories: number | null; protein: number | null; fat: number | null; carbs: number | null; } | null; }[]; }; let { recipe, isAdmin, onEditQuantities, onDelete }: { recipe: Recipe; isAdmin: boolean; onEditQuantities: (recipe: Recipe) => void; onDelete: (recipe: Recipe) => void; } = $props(); const calculableIngredients = $derived( recipe.ingredients.map((ing) => { const source = ing.product || ing.customIngredient; return { quantity: ing.quantity, calories: source?.calories, protein: source?.protein, fat: source?.fat, carbs: source?.carbs } as CalculableIngredient; }) ); const totals = $derived(calculateNutritionalInfo(calculableIngredients)); const totalGrams = $derived(totals.totalProtein + totals.totalCarbs + totals.totalFat); const proteinPercentage = $derived(totalGrams > 0 ? (totals.totalProtein / totalGrams) * 100 : 0); const carbsPercentage = $derived(totalGrams > 0 ? (totals.totalCarbs / totalGrams) * 100 : 0); const fatPercentage = $derived(totalGrams > 0 ? (totals.totalFat / totalGrams) * 100 : 0); function handleEditQuantities(event: MouseEvent) { event.preventDefault(); onEditQuantities(recipe); } function handleDelete(event: MouseEvent) { event.preventDefault(); onDelete(recipe); } </script> <Card.Root class="flex flex-col break-inside-avoid"> <a href="/recetas/{recipe.slug}" class="flex flex-col h-full" aria-label="Ver receta: {recipe.title}"> <div class="relative"> {#if recipe.imageUrl} <img src={recipe.imageUrl} alt="Imagen de {recipe.title}" class="aspect-video w-full rounded-t-lg object-cover" /> {/if} {#if isAdmin} <div class="absolute top-2 right-2"> <DropdownMenu> <DropdownMenuTrigger class="bg-background/60 hover:bg-background/80 backdrop-blur-sm rounded-full h-8 w-8 inline-flex items-center justify-center" onclick={(e: MouseEvent) => { e.stopPropagation(); e.preventDefault(); }} aria-label="Abrir menú de acciones para {recipe.title}" > <MoreVertical class="h-4 w-4" /> </DropdownMenuTrigger> <DropdownMenuContent class="w-48" align="end" onclick={(e: MouseEvent) => e.stopPropagation()} > <DropdownMenuItem onclick={handleEditQuantities}> Editar cantidades </DropdownMenuItem> <DropdownMenuItem> <a href="/recetas/{recipe.slug}/editar" class="w-full">Editar receta</a> </DropdownMenuItem> <DropdownMenuSeparator /> <DropdownMenuItem onclick={handleDelete} class="text-destructive focus:text-destructive"> Eliminar </DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> </div> {/if} </div> <Card.Header> <Card.Title class="font-heading text-lg text-light pt-2">{recipe.title}</Card.Title> <Card.Description class="py-2">{totals.totalCalories.toFixed(0)} kcal</Card.Description> </Card.Header> <Card.Content class="flex-grow"> <div class="flex h-2 w-full overflow-hidden rounded-full bg-muted"> <div class="bg-blue-500" style="width: {proteinPercentage}%" title="Proteínas: {totals.totalProtein.toFixed(1)}g" ></div> <div class="bg-green-500" style="width: {carbsPercentage}%" title="Carbohidratos: {totals.totalCarbs.toFixed(1)}g" ></div> <div class="bg-red-500" style="width: {fatPercentage}%" title="Grasas: {totals.totalFat.toFixed(1)}g" ></div> </div> <div class="mt-2 flex justify-between text-xs text-muted-foreground"> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-blue-500"></span> P ({totals.totalProtein.toFixed(1)}) </span> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-green-500"></span> C ({totals.totalCarbs.toFixed(1)}) </span> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-red-500"></span> G ({totals.totalFat.toFixed(1)}) </span> </div> </Card.Content> </a> </Card.Root>

// --- Ruta: src/lib/components/recipes/MacroFilters.svelte ---
<script lang="ts"> import { Input } from '$lib/components/ui/input/index.js'; import { Label } from '$lib/components/ui/label/index.js'; import { Button } from '$lib/components/ui/button/index.js'; import Trash2 from 'lucide-svelte/icons/trash-2'; type RangeFilter = { min?: number; max?: number }; export type GramFilters = { calories: RangeFilter; protein: RangeFilter; carbs: RangeFilter; fat: RangeFilter; }; export type PercentFilters = { protein: RangeFilter; carbs: RangeFilter; fat: RangeFilter; }; let { gramFilters, percentFilters, onGramsChange, onPercentChange, onClear }: { gramFilters: GramFilters; percentFilters: PercentFilters; onGramsChange: (macro: keyof GramFilters, key: 'min' | 'max', value: number | undefined) => void; onPercentChange: (macro: keyof PercentFilters, key: 'min' | 'max', value: number | undefined) => void; onClear: () => void; } = $props(); function handleGramsInput(macro: keyof GramFilters, key: 'min' | 'max', e: Event) { const target = e.currentTarget as HTMLInputElement; const value = target.valueAsNumber; onGramsChange(macro, key, isNaN(value) ? undefined : value); } function handlePercentInput(macro: keyof PercentFilters, key: 'min' | 'max', e: Event) { const target = e.currentTarget as HTMLInputElement; const value = target.valueAsNumber; onPercentChange(macro, key, isNaN(value) ? undefined : value); } </script> <div class="space-y-4"> <div class="flex items-center justify-between"> <h3 class="text-lg font-semibold">Macronutrientes</h3> <Button onclick={onClear} variant="ghost" size="icon" aria-label="Limpiar filtros de macros"> <Trash2 class="h-4 w-4" /> </Button> </div> <!-- Filtros de Gramos y Calorías --> <div class="space-y-4"> <div class="space-y-2"> <Label for="calories-min">Calorías (kcal)</Label> <div class="flex gap-2"> <Input id="calories-min" type="number" placeholder="Min" class="hide-arrows" value={gramFilters.calories.min ?? ''} oninput={(e) => handleGramsInput('calories', 'min', e)} /> <Input id="calories-max" type="number" placeholder="Max" class="hide-arrows" value={gramFilters.calories.max ?? ''} oninput={(e) => handleGramsInput('calories', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="protein-grams-min">Proteínas (g)</Label> <div class="flex gap-2"> <Input id="protein-grams-min" type="number" placeholder="Min" class="hide-arrows" value={gramFilters.protein.min ?? ''} oninput={(e) => handleGramsInput('protein', 'min', e)} /> <Input id="protein-grams-max" type="number" placeholder="Max" class="hide-arrows" value={gramFilters.protein.max ?? ''} oninput={(e) => handleGramsInput('protein', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="carbs-grams-min">Carbohidratos (g)</Label> <div class="flex gap-2"> <Input id="carbs-grams-min" type="number" placeholder="Min" class="hide-arrows" value={gramFilters.carbs.min ?? ''} oninput={(e) => handleGramsInput('carbs', 'min', e)} /> <Input id="carbs-grams-max" type="number" placeholder="Max" class="hide-arrows" value={gramFilters.carbs.max ?? ''} oninput={(e) => handleGramsInput('carbs', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="fat-grams-min">Grasas (g)</Label> <div class="flex gap-2"> <Input id="fat-grams-min" type="number" placeholder="Min" class="hide-arrows" value={gramFilters.fat.min ?? ''} oninput={(e) => handleGramsInput('fat', 'min', e)} /> <Input id="fat-grams-max" type="number" placeholder="Max" class="hide-arrows" value={gramFilters.fat.max ?? ''} oninput={(e) => handleGramsInput('fat', 'max', e)} /> </div> </div> </div> <hr/> <!-- Filtros de Porcentaje --> <div class="space-y-4"> <div class="space-y-2"> <Label for="protein-percent-min">Proteínas (%)</Label> <div class="flex gap-2"> <Input id="protein-percent-min" type="number" placeholder="Min" class="hide-arrows" value={percentFilters.protein.min ?? ''} oninput={(e) => handlePercentInput('protein', 'min', e)} /> <Input id="protein-percent-max" type="number" placeholder="Max" class="hide-arrows" value={percentFilters.protein.max ?? ''} oninput={(e) => handlePercentInput('protein', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="carbs-percent-min">Carbohidratos (%)</Label> <div class="flex gap-2"> <Input id="carbs-percent-min" type="number" placeholder="Min" class="hide-arrows" value={percentFilters.carbs.min ?? ''} oninput={(e) => handlePercentInput('carbs', 'min', e)} /> <Input id="carbs-percent-max" type="number" placeholder="Max" class="hide-arrows" value={percentFilters.carbs.max ?? ''} oninput={(e) => handlePercentInput('carbs', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="fat-percent-min">Grasas (%)</Label> <div class="flex gap-2"> <Input id="fat-percent-min" type="number" placeholder="Min" class="hide-arrows" value={percentFilters.fat.min ?? ''} oninput={(e) => handlePercentInput('fat', 'min', e)} /> <Input id="fat-percent-max" type="number" placeholder="Max" class="hide-arrows" value={percentFilters.fat.max ?? ''} oninput={(e) => handlePercentInput('fat', 'max', e)} /> </div> </div> </div> </div> <style> :global(.hide-arrows::-webkit-inner-spin-button), :global(.hide-arrows::-webkit-outer-spin-button) { -webkit-appearance: none; margin: 0; } :global(.hide-arrows) { -moz-appearance: textfield; appearance: textfield; } </style>

// --- Ruta: src/lib/components/recipes/IngredientCombobox.svelte ---
<script lang="ts"> import { Button } from '$lib/components/ui/button/index.js'; import * as Popover from '$lib/components/ui/popover/index.js'; import * as Command from '$lib/components/ui/command/index.js'; import ChevronsUpDown from 'lucide-svelte/icons/chevrons-up-down'; import Trash2 from 'lucide-svelte/icons/trash-2'; import { browser } from '$app/environment'; type Ingredient = { id: string; name: string; type: 'product' | 'custom'; source: 'local' | 'off'; imageUrl: string | null; }; let { onSelect, selectedIds = [], onClear }: { onSelect: (ingredient: Ingredient) => void; selectedIds: string[]; onClear: () => void; } = $props(); let open = $state(false); let searchValue = $state(''); let searchResults = $state<Ingredient[]>([]); let isLoading = $state(false); let controller: AbortController; let triggerWrapperEl: HTMLDivElement | null = $state(null); $effect(() => { if (browser && open && triggerWrapperEl) { const contentEl = document.querySelector<HTMLDivElement>('[data-slot="popover-content"]'); if (contentEl) { const rect = triggerWrapperEl.getBoundingClientRect(); contentEl.style.width = `${rect.width}px`; } } }); $effect(() => { controller?.abort(); const query = searchValue; if (query.length < 2 || !open) { searchResults = []; isLoading = false; return; } controller = new AbortController(); async function search() { isLoading = true; try { const response = await fetch(`/api/ingredients/autocomplete?q=${encodeURIComponent(query)}`, { signal: controller.signal }); const allResults: Ingredient[] = await response.json(); searchResults.length = 0; searchResults.push(...allResults.filter((r) => !selectedIds.includes(r.id))); } catch (e) { if (e instanceof DOMException && e.name === 'AbortError') { return; } console.error('Failed to search ingredients', e); searchResults = []; } finally { isLoading = false; } } search(); }); function handleSelect(ingredient: Ingredient) { onSelect(ingredient); searchValue = ''; open = false; } </script> <div class="flex items-center gap-2"> <div class="flex-grow" bind:this={triggerWrapperEl}> <Popover.Root bind:open> <Popover.Trigger role="combobox" class="flex h-10 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 hover:bg-accent hover:text-accent-foreground" > Seleccionar ingrediente... <ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" /> </Popover.Trigger> <Popover.Content data-slot="popover-content" class="p-0"> {#key searchValue} <Command.Root> <Command.Input bind:value={searchValue} placeholder="Buscar ingrediente..." /> <Command.Empty> {#if isLoading} Buscando... {:else if searchValue.length < 2} Escribe al menos 2 letras. {:else} No se encontraron ingredientes. {/if} </Command.Empty> <Command.Group> {#each searchResults as ingredient (ingredient.id)} <Command.Item onSelect={() => handleSelect(ingredient)}> {ingredient.name} </Command.Item> {/each} </Command.Group> </Command.Root> {/key} </Popover.Content> </Popover.Root> </div> {#if selectedIds.length > 0} <Button onclick={onClear} variant="ghost" size="icon" aria-label="Limpiar ingredientes seleccionados"> <Trash2 class="h-4 w-4" /> </Button> {/if} </div>

// --- Ruta: src/lib/components/recipes/EditQuantitiesDialog.svelte ---
<!-- --> <script lang="ts"> import { calculateNutritionalInfo, type CalculableIngredient } from '$lib/recipeCalculator'; import * as Dialog from '$lib/components/ui/dialog/index.js'; import { Input } from '$lib/components/ui/input/index.js'; import { Label } from '$lib/components/ui/label/index.js'; import { Button } from '$lib/components/ui/button/index.js'; type Recipe = { id: string; title: string; ingredients: { quantity: number; product: { id: string; name: string; calories: number | null; protein: number | null; fat: number | null; carbs: number | null; } | null; customIngredient: { id: string; name: string; calories: number | null; protein: number | null; fat: number | null; carbs: number | null; } | null; }[]; }; let { recipe, open = $bindable(), onOpenChange }: { recipe: Recipe | null; open?: boolean; onOpenChange: (isOpen: boolean) => void; } = $props(); let editableIngredients = $state< { id: string; name: string; quantity: number; baseValues: Omit<CalculableIngredient, 'quantity'>; }[] >([]); $effect(() => { if (open && recipe) { editableIngredients = recipe.ingredients.map((ing) => { const source = ing.product || ing.customIngredient; const id = ing.product?.id || ing.customIngredient?.id || ''; const name = ing.product?.name || ing.customIngredient?.name || 'Ingrediente desconocido'; return { id, name, quantity: ing.quantity, baseValues: { calories: source?.calories, protein: source?.protein, fat: source?.fat, carbs: source?.carbs } }; }); } else { editableIngredients = []; } }); const originalTotals = $derived( recipe ? calculateNutritionalInfo(recipe.ingredients.map(ing => { const source = ing.product || ing.customIngredient; return { quantity: ing.quantity, calories: source?.calories, protein: source?.protein, fat: source?.fat, carbs: source?.carbs } })) : null ); const newTotals = $derived( calculateNutritionalInfo( editableIngredients.map((ing) => ({ ...ing.baseValues, quantity: Number(ing.quantity) || 0 })) ) ); </script> <Dialog.Root bind:open onOpenChange={onOpenChange}> <Dialog.Content class="sm:max-w-[600px]"> <Dialog.Header> <Dialog.Title>Editar Cantidades: {recipe?.title}</Dialog.Title> <Dialog.Description> Ajusta las cantidades en gramos para esta preparación específica. Los cambios no afectarán a la receta original. </Dialog.Description> </Dialog.Header> <div class="grid gap-4 py-4"> {#each editableIngredients as ingredient (ingredient.id)} <div class="grid grid-cols-4 items-center gap-4"> <Label for={ingredient.id} class="text-right col-span-2">{ingredient.name}</Label> <Input id={ingredient.id} type="number" bind:value={ingredient.quantity} class="col-span-2" /> </div> {/each} </div> <hr /> <!-- Justificación: Se añade un data-testid al contenedor para poder seleccionarlo de forma inequívoca en los tests. --> <div data-testid="comparison-section" class="grid grid-cols-2 gap-x-8 gap-y-2 mt-4 text-sm"> <h3 class="font-semibold col-span-2">Comparativa Nutricional</h3> <div class="font-medium text-muted-foreground">Original</div> <div class="font-medium text-muted-foreground">Recalculado</div> <div>Calorías: {originalTotals?.totalCalories.toFixed(0) ?? 0} kcal</div> <div class="font-semibold">Calorías: {newTotals.totalCalories.toFixed(0)} kcal</div> <div>Proteínas: {originalTotals?.totalProtein.toFixed(1) ?? 0} g</div> <div class="font-semibold">Proteínas: {newTotals.totalProtein.toFixed(1)} g</div> <div>Grasas: {originalTotals?.totalFat.toFixed(1) ?? 0} g</div> <div class="font-semibold">Grasas: {newTotals.totalFat.toFixed(1)} g</div> <div>Carbohidratos: {originalTotals?.totalCarbs.toFixed(1) ?? 0} g</div> <div class="font-semibold">Carbohidratos: {newTotals.totalCarbs.toFixed(1)} g</div> </div> <Dialog.Footer> <!-- Justificación: Se añade un data-testid al botón para seleccionarlo sin ambigüedad. --> <Button data-testid="dialog-close-button" onclick={() => onOpenChange(false)}>Cerrar</Button> </Dialog.Footer> </Dialog.Content> </Dialog.Root>

// --- Ruta: src/lib/components/recipes/EditQuantitiesDialog.spec.ts ---
const mockRecipe = { id: 'recipe-1', title: 'Pollo con Arroz', ingredients: [ { quantity: 200, product: { id: 'product-1', name: 'Pechuga de Pollo', calories: 165, protein: 31, fat: 3.6, carbs: 0 }, customIngredient: null }, { quantity: 150, product: null, customIngredient: { id: 'custom-1', name: 'Arroz Blanco', calories: 130, protein: 2.7, fat: 0.3, carbs: 28 } } ] }; describe('EditQuantitiesDialog.svelte', () => { afterEach(() => cleanup()); it('should render initial data and original totals correctly', async () => { render(EditQuantitiesDialog, { props: { recipe: mockRecipe, open: true, onOpenChange: () => {} } }); expect(screen.getByText('Editar Cantidades: Pollo con Arroz')).toBeTruthy(); const comparisonSection = screen.getByTestId('comparison-section'); const initialCalories = within(comparisonSection).getAllByText(/Calorías: 525 kcal/i); expect(initialCalories).toHaveLength(2); }); it('should recalculate totals in real-time when an ingredient quantity changes', async () => { render(EditQuantitiesDialog, { props: { recipe: mockRecipe, open: true, onOpenChange: () => {} } }); const polloInput = screen.getByLabelText('Pechuga de Pollo'); await fireEvent.input(polloInput, { target: { value: '100' } }); const comparisonSection = screen.getByTestId('comparison-section'); const originalCalories = within(comparisonSection).getByText(/Calorías: 525 kcal/i); const recalculatedCalories = within(comparisonSection).getByText(/Calorías: 360 kcal/i); expect(originalCalories).toBeTruthy(); expect(recalculatedCalories).toBeTruthy(); }); it('should call onOpenChange with false when the close button is clicked', async () => { const onOpenChangeMock = vi.fn(); render(EditQuantitiesDialog, { props: { recipe: mockRecipe, open: true, onOpenChange: onOpenChangeMock } }); const closeButton = screen.getByTestId('dialog-close-button'); await fireEvent.click(closeButton); expect(onOpenChangeMock).toHaveBeenCalledWith(false); expect(onOpenChangeMock).toHaveBeenCalledOnce(); }); });

// --- Ruta: src/lib/components/recipes/DeleteRecipeDialog.svelte ---
<!-- --> <script lang="ts"> import { enhance, applyAction } from '$app/forms'; import * as AlertDialog from '$lib/components/ui/alert-dialog/index.js'; import { Button } from '$lib/components/ui/button/index.js'; import { toast } from 'svelte-sonner'; type Recipe = { id: string; title: string; }; let { recipe, open = $bindable(), onOpenChange }: { recipe: Recipe | null; open?: boolean; onOpenChange: (isOpen: boolean) => void; } = $props(); let formElement: HTMLFormElement; function handleConfirmClick() { if (formElement) { formElement.requestSubmit(); } } </script> <AlertDialog.Root bind:open onOpenChange={onOpenChange}> <AlertDialog.Content> <AlertDialog.Header> <AlertDialog.Title>¿Estás absolutely seguro?</AlertDialog.Title> <AlertDialog.Description> Esta acción no se puede deshacer. Esto eliminará permanentemente la receta de <strong>{@html recipe?.title ?? 'seleccionada'}</strong>. </AlertDialog.Description> </AlertDialog.Header> <form method="POST" action="?/delete" bind:this={formElement} use:enhance={() => { onOpenChange(false); const toastId = toast.loading('Eliminando receta...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Receta eliminada correctamente.', { id: toastId }); } else if (result.type === 'failure') { toast.error('No se pudo eliminar la receta.', { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <input type="hidden" name="id" value={recipe?.id} /> </form> <AlertDialog.Footer> <AlertDialog.Cancel>Cancelar</AlertDialog.Cancel> <AlertDialog.Action onclick={handleConfirmClick}> <Button variant="destructive">Eliminar</Button> </AlertDialog.Action> </AlertDialog.Footer> </AlertDialog.Content> </AlertDialog.Root>

// --- Ruta: src/lib/components/admin/SyncDialog.svelte ---
<!-- Ruta: src/lib/components/admin/SyncDialog.svelte --> <script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import * as Dialog from '$lib/components/ui/dialog'; import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table'; import { CircleDashed } from 'lucide-svelte'; type $Props = { state: 'idle' | 'loading' | 'success' | 'error'; result: { updatedIngredients: string[]; failedIngredients: { id: string; name: string; reason: string }[]; } | null; }; let { state, result }: $Props = $props(); </script> <Dialog.Content class="sm:max-w-[625px]"> {#if state === 'loading'} <div class="flex flex-col items-center justify-center p-8"> <CircleDashed class="h-12 w-12 animate-spin text-primary" /> <p class="mt-4 text-lg text-muted-foreground">Sincronizando ingredientes...</p> <p class="text-sm text-muted-foreground"> Este proceso puede tardar varios minutos. Por favor, no cierres esta ventana. </p> </div> {:else if state === 'success' && result} <Dialog.Header> <Dialog.Title>Sincronización Completada</Dialog.Title> <Dialog.Description> Se actualizaron <strong>{result.updatedIngredients.length}</strong> ingredientes. {#if result.failedIngredients.length > 0} Hubo <strong>{result.failedIngredients.length}</strong> errores. {/if} </Dialog.Description> </Dialog.Header> <div class="max-h-[400px] overflow-y-auto"> {#if result.updatedIngredients.length > 0} <h3 class="mb-2 font-semibold">Ingredientes Actualizados</h3> <Table> <TableHeader> <TableRow> <TableHead>Nombre</TableHead> </TableRow> </TableHeader> <TableBody> {#each result.updatedIngredients as name} <TableRow> <TableCell>{name}</TableCell> </TableRow> {/each} </TableBody> </Table> {/if} {#if result.failedIngredients.length > 0} <h3 class="mb-2 mt-4 font-semibold">Ingredientes con Errores</h3> <Table> <TableHeader> <TableRow> <TableHead>Nombre</TableHead> <TableHead>Motivo del Error</TableHead> </TableRow> </TableHeader> <TableBody> {#each result.failedIngredients as failure} <TableRow> <TableCell>{failure.name} ({failure.id})</TableCell> <TableCell>{failure.reason}</TableCell> </TableRow> {/each} </TableBody> </Table> {/if} </div> <Dialog.Footer> <!-- Justificación: Se usa Dialog.Close directamente estilizado como un botón, evitando la complejidad y errores de 'asChild'. --> <Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cerrar</Dialog.Close> </Dialog.Footer> {:else if state === 'error'} <Dialog.Header> <Dialog.Title>Error en la Sincronización</Dialog.Title> <Dialog.Description> Ocurrió un error inesperado al intentar sincronizar los ingredientes. Por favor, inténtalo de nuevo más tarde. </Dialog.Description> </Dialog.Header> <Dialog.Footer> <Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cerrar</Dialog.Close> </Dialog.Footer> {/if} </Dialog.Content>

// --- Ruta: src/lib/components/admin/SortableHeader.svelte ---
<script lang="ts"> import { ArrowDown, ArrowUp } from 'lucide-svelte'; import * as Table from '$lib/components/ui/table'; import { cn } from '$lib/utils'; import { page } from '$app/state'; let { class: className = '', column, label } = $props<{ class?: string; column: string; label: string }>(); const currentSort = $derived(page.url.searchParams.get('sort')); const currentOrder = $derived(page.url.searchParams.get('order')); const currentSearch = $derived(page.url.searchParams.get('search')); const isActive = $derived(currentSort === column); const nextOrder = $derived(isActive && currentOrder === 'asc' ? 'desc' : 'asc'); let href = $state(''); $effect(() => { const params = new URLSearchParams(); if (currentSearch) { params.set('search', currentSearch); } params.set('sort', column); params.set('order', nextOrder); href = `?${params.toString()}`; }); </script> <Table.Head class={cn('p-0', className)}> <a {href} class="flex w-full items-center gap-2 p-4 no-underline hover:bg-muted/50"> <span>{label}</span> {#if isActive} {#if currentOrder === 'asc'} <ArrowUp class="h-4 w-4" /> {:else} <ArrowDown class="h-4 w-4" /> {/if} {/if} </a> </Table.Head>

// --- Ruta: src/lib/components/admin/IngredientsMobileView.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import * as Dialog from '$lib/components/ui/dialog'; import { Input } from '$lib/components/ui/input'; import type { PageData } from '../../../routes/admin/ingredientes/$types'; import { Search, ChevronDown, X } from 'lucide-svelte'; import * as DropdownMenu from '$lib/components/ui/dropdown-menu'; import IngredientActions from '$lib/components/admin/IngredientActions.svelte'; let { data, searchTerm = $bindable(), sort, isProductEditDialogOpen = $bindable(), editingProductName = $bindable(), editingProductId = $bindable(), handleUpdateProductName } = $props<{ data: PageData; searchTerm: string; sort: (column: string) => void; isProductEditDialogOpen: boolean; editingProductName: string; editingProductId: string | null; handleUpdateProductName: () => Promise<void>; }>(); let expandedRows = $state<{ [key: string]: boolean }>({}); function toggleRow(id: string) { expandedRows[id] = !expandedRows[id]; } </script> <div class="block md:hidden"> <div class="mb-4 flex items-center justify-between gap-2"> <div class="relative flex-grow"> <Search class="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" /> <Input class="pl-8 pr-8" placeholder="Buscar..." bind:value={searchTerm} /> {#if searchTerm} <button onclick={() => (searchTerm = '')} class="absolute right-2.5 top-2.5 rounded-full p-0.5 text-muted-foreground transition-colors hover:bg-muted" aria-label="Limpiar búsqueda" > <X class="h-4 w-4" /> </button> {/if} </div> <DropdownMenu.Root> <DropdownMenu.Trigger class={buttonVariants({ variant: 'outline' })} >Ordenar <ChevronDown class="ml-2 h-4 w-4" /> </DropdownMenu.Trigger> <DropdownMenu.Content> <DropdownMenu.Label>Ordenar por</DropdownMenu.Label> <DropdownMenu.Separator /> <DropdownMenu.Item onclick={() => sort('name')}>Nombre</DropdownMenu.Item> <DropdownMenu.Item onclick={() => sort('source')}>Origen</DropdownMenu.Item> <DropdownMenu.Item onclick={() => sort('calories')}>Calorías</DropdownMenu.Item> <DropdownMenu.Item onclick={() => sort('protein')}>Proteínas</DropdownMenu.Item> <DropdownMenu.Item onclick={() => sort('fat')}>Grasas</DropdownMenu.Item> <DropdownMenu.Item onclick={() => sort('carbs')}>Carbs</DropdownMenu.Item> </DropdownMenu.Content> </DropdownMenu.Root> </div> <div class="space-y-4"> {#each data.ingredients as ingredient (ingredient.id)} <div class="rounded-lg border"> <div class="flex w-full items-center p-4"> <button type="button" class="flex flex-grow items-center text-left" onclick={() => toggleRow(ingredient.id)} aria-expanded={expandedRows[ingredient.id] ?? false} aria-controls="details-{ingredient.id}" > <span class="font-medium">{ingredient.name}</span> <ChevronDown class="ml-2 h-4 w-4 shrink-0 transition-transform duration-200 {expandedRows[ ingredient.id ] ? 'rotate-180' : ''}" /> </button> <IngredientActions bind:isProductEditDialogOpen bind:editingProductName bind:editingProductId {ingredient} {handleUpdateProductName} /> </div> {#if expandedRows[ingredient.id]} <div class="p-4 pt-0" id="details-{ingredient.id}"> <div class="border-t pt-4"> <div class="flex justify-between text-sm"> <span class="text-muted-foreground">Origen:</span> <span>{ingredient.source === 'custom' ? 'Personalizado' : 'Caché de OFF'}</span> </div> <div class="flex justify-between text-sm"> <span class="text-muted-foreground">Calorías:</span> <span>{ingredient.calories?.toFixed(1) ?? 'N/A'}</span> </div> <div class="flex justify-between text-sm"> <span class="text-muted-foreground">Proteínas:</span> <span>{ingredient.protein?.toFixed(1) ?? 'N/A'}</span> </div> <div class="flex justify-between text-sm"> <span class="text-muted-foreground">Grasas:</span> <span>{ingredient.fat?.toFixed(1) ?? 'N/A'}</span> </div> <div class="flex justify-between text-sm"> <span class="text-muted-foreground">Carbs:</span> <span>{ingredient.carbs?.toFixed(1) ?? 'N/A'}</span> </div> </div> </div> {/if} </div> {:else} <p class="text-center text-muted-foreground">No hay ingredientes.</p> {/each} </div> </div>

// --- Ruta: src/lib/components/admin/IngredientsDesktopView.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import * as Dialog from '$lib/components/ui/dialog'; import { Input } from '$lib/components/ui/input'; import * as Separator from '$lib/components/ui/separator'; import * as Table from '$lib/components/ui/table'; import type { PageData } from '../../../routes/admin/ingredientes/$types'; import { invalidateAll } from '$app/navigation'; import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card'; import * as Tooltip from '$lib/components/ui/tooltip'; import { RefreshCw, Download, Plus, LayoutDashboard, Search, X } from 'lucide-svelte'; import SortableHeader from '$lib/components/admin/SortableHeader.svelte'; import IngredientActions from '$lib/components/admin/IngredientActions.svelte'; import { Label } from '$lib/components/ui/label'; import { enhance, applyAction } from '$app/forms'; import { toast } from 'svelte-sonner'; let { data, form, searchTerm = $bindable(), isProductEditDialogOpen = $bindable(), editingProductName = $bindable(), editingProductId = $bindable(), handleUpdateProductName } = $props<{ data: PageData; form: any; searchTerm: string; isProductEditDialogOpen: boolean; editingProductName: string; editingProductId: string | null; handleUpdateProductName: () => Promise<void>; }>(); async function handleSync() { const toastId = toast.loading('Iniciando sincronización con Open Food Facts... Esto puede tardar.'); try { const response = await fetch('/api/ingredients/sync', { method: 'POST', credentials: 'include' }); if (!response.ok) throw new Error('Falló la petición de sincronización'); toast.success('Sincronización completada con éxito.', { id: toastId }); await invalidateAll(); } catch (error) { console.error('Error durante la sincronización:', error); toast.error('La sincronización falló. Inténtalo de nuevo más tarde.', { id: toastId }); } } let isAddCustomDialogOpen = $state(false); let name = $state(form?.data?.name ?? ''); let calories = $state(form?.data?.calories ?? ''); let protein = $state(form?.data?.protein ?? ''); let fat = $state(form?.data?.fat ?? ''); let carbs = $state(form?.data?.carbs ?? ''); $effect(() => { name = form?.data?.name ?? ''; calories = form?.data?.calories ?? ''; protein = form?.data?.protein ?? ''; fat = form?.data?.fat ?? ''; carbs = form?.data?.carbs ?? ''; }); </script> <div class="hidden md:block"> <Card> <CardHeader> <div class="flex flex-row items-center justify-between gap-4 pt-4"> <CardTitle>Gestión de Ingredientes</CardTitle> <div class="flex flex-1 justify-end gap-2"> <div class="relative w-full max-w-sm"> <Search class="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" /> <Input class="pl-8 pr-8" placeholder="Buscar por nombre..." bind:value={searchTerm} /> {#if searchTerm} <button onclick={() => (searchTerm = '')} class="absolute right-2.5 top-2.5 rounded-full p-0.5 text-muted-foreground transition-colors hover:bg-muted" aria-label="Limpiar búsqueda" > <X class="h-4 w-4" /> </button> {/if} </div> <Tooltip.Root> <Tooltip.Trigger> <Button href="/" variant="outline" size="icon" class="h-9 w-9" aria-label="Inicio"> <LayoutDashboard class="h-4 w-4" /> </Button> </Tooltip.Trigger> <Tooltip.Content><p>Inicio</p></Tooltip.Content> </Tooltip.Root> <Tooltip.Root> <Tooltip.Trigger class={buttonVariants({ variant: 'outline', size: 'icon' })} onclick={() => invalidateAll()} > <RefreshCw class="h-4 w-4" /> </Tooltip.Trigger> <Tooltip.Content><p>Refrescar datos</p></Tooltip.Content> </Tooltip.Root> <Tooltip.Root> <Tooltip.Trigger class={buttonVariants({ variant: 'outline', size: 'icon' })} onclick={handleSync} > <Download class="h-4 w-4" /> </Tooltip.Trigger> <Tooltip.Content><p>Sincronizar con OFF</p></Tooltip.Content> </Tooltip.Root> <Dialog.Root bind:open={isAddCustomDialogOpen}> <Tooltip.Root> <Tooltip.Trigger class={buttonVariants({ size: 'icon' })} onclick={() => (isAddCustomDialogOpen = true)} > <Plus class="h-4 w-4" /> </Tooltip.Trigger> <Tooltip.Content><p>Añadir Personalizado</p></Tooltip.Content> </Tooltip.Root> <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Añadir Ingrediente Personalizado</Dialog.Title> <Dialog.Description> Añade un nuevo ingrediente con sus macros. </Dialog.Description> </Dialog.Header> <form method="POST" action="?/addCustom" use:enhance={() => { const toastId = toast.loading('Añadiendo ingrediente...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Ingrediente añadido con éxito.', { id: toastId }); isAddCustomDialogOpen = false; await invalidateAll(); } else if (result.type === 'failure') { toast.error('Error al añadir el ingrediente.', { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <div class="grid gap-4 py-4"> <div class="grid grid-cols-4 items-center gap-4"> <Label for="name" class="text-right">Nombre</Label> <Input id="name" name="name" class="col-span-3" required bind:value={name} /> </div> {#if form?.errors?.name} <p class="col-span-3 col-start-2 text-sm text-red-500"> {form.errors.name[0]} </p> {/if} <div class="grid grid-cols-4 items-center gap-4"> <Label for="calories" class="text-right">Calorías</Label> <Input id="calories" name="calories" type="number" step="0.1" class="col-span-3" required bind:value={calories} /> </div> {#if form?.errors?.calories} <p class="col-span-3 col-start-2 text-sm text-red-500"> {form.errors.calories[0]} </p> {/if} <div class="grid grid-cols-4 items-center gap-4"> <Label for="protein" class="text-right">Proteínas</Label> <Input id="protein" name="protein" type="number" step="0.1" class="col-span-3" required bind:value={protein} /> </div> {#if form?.errors?.protein} <p class="col-span-3 col-start-2 text-sm text-red-500"> {form.errors.protein[0]} </p> {/if} <div class="grid grid-cols-4 items-center gap-4"> <Label for="fat" class="text-right">Grasas</Label> <Input id="fat" name="fat" type="number" step="0.1" class="col-span-3" required bind:value={fat} /> </div> {#if form?.errors?.fat} <p class="col-span-3 col-start-2 text-sm text-red-500"> {form.errors.fat[0]} </p> {/if} <div class="grid grid-cols-4 items-center gap-4"> <Label for="carbs" class="text-right">Carbohidratos</Label> <Input id="carbs" name="carbs" type="number" step="0.1" class="col-span-3" required bind:value={carbs} /> </div> {#if form?.errors?.carbs} <p class="col-span-3 col-start-2 text-sm text-red-500"> {form.errors.carbs[0]} </p> {/if} </div> <Dialog.Footer> <Dialog.Close class={buttonVariants({ variant: 'outline' })} onclick={() => (isAddCustomDialogOpen = false)}>Cancelar</Dialog.Close > <Button type="submit">Guardar</Button> </Dialog.Footer> </form> </Dialog.Content> </Dialog.Root> </div> </div> </CardHeader> <CardContent> <div class="overflow-x-auto"> <Table.Root> <Table.Header> <Table.Row> <SortableHeader column="name" label="Nombre" /> <SortableHeader column="source" label="Origen" /> <SortableHeader column="calories" label="Calorías" class="justify-end" /> <SortableHeader column="protein" label="Proteínas" class="justify-end" /> <SortableHeader column="fat" label="Grasas" class="justify-end" /> <SortableHeader column="carbs" label="Carbs" class="justify-end" /> <Table.Head class="text-right">Acciones</Table.Head> </Table.Row> </Table.Header> <Table.Body> {#each data.ingredients as ingredient, i (ingredient.id)} <Table.Row> <Table.Cell class="font-medium">{ingredient.name}</Table.Cell> <Table.Cell> {#if ingredient.source === 'custom'} <span class="me-2 rounded bg-blue-100 px-2.5 py-0.5 text-xs font-medium text-blue-800 dark:bg-blue-900 dark:text-blue-300" >Personalizado</span > {:else} <span class="me-2 rounded bg-green-100 px-2.5 py-0.5 text-xs font-medium text-green-800 dark:bg-green-900 dark:text-green-300" >Caché de OFF</span > {/if} </Table.Cell> <Table.Cell class="text-right">{ingredient.calories?.toFixed(1) ?? 'N/A'}</Table.Cell> <Table.Cell class="text-right">{ingredient.protein?.toFixed(1) ?? 'N/A'}</Table.Cell> <Table.Cell class="text-right">{ingredient.fat?.toFixed(1) ?? 'N/A'}</Table.Cell> <Table.Cell class="text-right">{ingredient.carbs?.toFixed(1) ?? 'N/A'}</Table.Cell> <Table.Cell class="text-right"> <IngredientActions bind:isProductEditDialogOpen bind:editingProductName bind:editingProductId {ingredient} {handleUpdateProductName} /> </Table.Cell> </Table.Row> {#if i < data.ingredients.length - 1} <tr class="border-none !bg-transparent hover:!bg-transparent" ><td class="p-0" colspan="7"><Separator.Root /></td></tr > {/if} {:else} <Table.Row> <Table.Cell colspan={7} class="text-center">No hay ingredientes.</Table.Cell> </Table.Row> {/each} </Table.Body> </Table.Root> </div> </CardContent> </Card> </div>

// --- Ruta: src/lib/components/admin/IngredientActions.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import * as Dialog from '$lib/components/ui/dialog'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import { enhance, applyAction } from '$app/forms'; import type { Product } from '@prisma/client'; import { toast } from 'svelte-sonner'; import { invalidateAll } from '$app/navigation'; let { ingredient, isProductEditDialogOpen = $bindable(), editingProductName = $bindable(), editingProductId = $bindable(), handleUpdateProductName } = $props<{ ingredient: Product; isProductEditDialogOpen: boolean; editingProductName: string; editingProductId: string | null; handleUpdateProductName: () => Promise<void>; }>(); function openEditDialog() { isProductEditDialogOpen = true; editingProductName = ingredient.name; editingProductId = ingredient.id; } let isEditDialogOpen = $state(false); let isDeleteDialogOpen = $state(false); </script> <div class="flex justify-end gap-2"> {#if ingredient.source === 'custom'} <Dialog.Root bind:open={isEditDialogOpen}> <Dialog.Trigger class={buttonVariants({ variant: 'outline', size: 'sm' })} >Editar</Dialog.Trigger > <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Editar Ingrediente</Dialog.Title> </Dialog.Header> <form method="POST" action="?/update" use:enhance={() => { const toastId = toast.loading('Actualizando ingrediente...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Ingrediente actualizado.', { id: toastId }); isEditDialogOpen = false; await invalidateAll(); } else if (result.type === 'failure') { toast.error('Error al actualizar.', { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <input type="hidden" name="id" value={ingredient.id} /> <div class="grid gap-4 py-4"> <!-- Input fields --> <div class="grid grid-cols-4 items-center gap-4"> <Label for="name-edit-{ingredient.id}" class="text-right">Nombre</Label> <Input id="name-edit-{ingredient.id}" name="name" value={ingredient.name} class="col-span-3" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="calories-edit-{ingredient.id}" class="text-right">Calorías</Label> <Input id="calories-edit-{ingredient.id}" name="calories" type="number" step="0.1" value={ingredient.calories} class="col-span-3" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="protein-edit-{ingredient.id}" class="text-right">Proteínas</Label> <Input id="protein-edit-{ingredient.id}" name="protein" type="number" step="0.1" value={ingredient.protein} class="col-span-3" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="fat-edit-{ingredient.id}" class="text-right">Grasas</Label> <Input id="fat-edit-{ingredient.id}" name="fat" type="number" step="0.1" value={ingredient.fat} class="col-span-3" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="carbs-edit-{ingredient.id}" class="text-right">Carbohidratos</Label> <Input id="carbs-edit-{ingredient.id}" name="carbs" type="number" step="0.1" value={ingredient.carbs} class="col-span-3" /> </div> </div> <Dialog.Footer> <Button type="submit">Guardar Cambios</Button> </Dialog.Footer> </form> </Dialog.Content> </Dialog.Root> {:else} <Dialog.Root bind:open={isProductEditDialogOpen}> <Dialog.Trigger class={buttonVariants({ variant: 'outline', size: 'sm' })} onclick={openEditDialog} >Editar</Dialog.Trigger > <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Editar Nombre del Producto</Dialog.Title> </Dialog.Header> <div class="grid gap-4 py-4"> <div class="grid grid-cols-4 items-center gap-4"> <Label for="name-edit-off-{ingredient.id}" class="text-right">Nombre</Label> <Input id="name-edit-off-{ingredient.id}" bind:value={editingProductName} class="col-span-3" /> </div> </div> <Dialog.Footer> <Button onclick={handleUpdateProductName}>Guardar Cambios</Button> </Dialog.Footer> </Dialog.Content> </Dialog.Root> {/if} <Dialog.Root bind:open={isDeleteDialogOpen}> <Dialog.Trigger class={buttonVariants({ variant: 'destructive', size: 'sm' })} >Eliminar</Dialog.Trigger > <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Confirmar Eliminación</Dialog.Title> <Dialog.Description> ¿Estás seguro de que quieres eliminar el ingrediente "{ingredient.name}"? Esta acción no se puede deshacer. </Dialog.Description> </Dialog.Header> <form method="POST" action="?/delete" use:enhance={() => { const toastId = toast.loading('Eliminando ingrediente...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Ingrediente eliminado.', { id: toastId }); isDeleteDialogOpen = false; await invalidateAll(); } else if (result.type === 'failure') { toast.error('Error al eliminar.', { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <input type="hidden" name="id" value={ingredient.id} /> <input type="hidden" name="source" value={ingredient.source} /> <Dialog.Footer> <Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cancelar</Dialog.Close> <Button variant="destructive" type="submit">Eliminar</Button> </Dialog.Footer> </form> </Dialog.Content> </Dialog.Root> </div>

// --- Ruta: src/routes/recetas/[slug]/editar/+page.svelte ---
<!-- Ruta: src/routes/recetas/[slug]/editar/+page.svelte --> <script lang="ts"> import RecipeForm from '$lib/components/recipes/RecipeForm.svelte'; import type { PageData, ActionData } from './$types'; import { goto } from '$app/navigation'; let { data, form }: { data: PageData; form: ActionData } = $props(); async function handleSuccess() { await goto(`/recetas/${data.recipe.slug}`); } </script> <RecipeForm initialData={data.recipe} recipeId={data.recipe.id} {form} cardTitle="Editar Receta" submitButtonText="Guardar Cambios" onSuccess={handleSuccess} />

// --- Ruta: src/routes/recetas/[slug]/editar/+page.server.ts ---
export const load: PageServerLoad = async ({ params }) => { const recipe = await recipeService.getBySlug(params.slug); if (!recipe) { throw error(404, 'Receta no encontrada'); } return { recipe }; }; export const actions: Actions = { default: async ({ request, params }) => { const formData = await request.formData(); const data = Object.fromEntries(formData.entries()); const dataToValidate = { ...data, ingredients: JSON.parse(data.ingredients as string), urls: JSON.parse(data.urls as string), steps: JSON.parse(data.steps as string) }; const validation = RecipeSchema.safeParse(dataToValidate); if (!validation.success) { const response = createFailResponse('La validación falló. Revisa los campos.', validation.error); return fail(400, response); } try { const originalRecipe = await recipeService.getBySlug(params.slug); if (!originalRecipe) { throw error(404, 'Receta no encontrada para actualizar'); } const updatedRecipe = await recipeService.update(originalRecipe.id, validation.data); return { status: 200, body: { recipe: updatedRecipe } }; } catch (err) { console.error(err); const response = createFailResponse('No se pudo actualizar la receta en el servidor.'); return fail(500, response); } } };

// --- Ruta: src/routes/admin/ingredientes/off/+page.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import { Input } from '$lib/components/ui/input'; import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card'; import { fade } from 'svelte/transition'; import { flip } from 'svelte/animate'; type SearchResult = { id: string; name: string; source: 'local' | 'off'; imageUrl: string | null; }; let searchTerm = $state(''); let results = $state<SearchResult[]>([]); let isLoading = $state(false); let searchAttempted = $state(false); $effect(() => { let eventSource: EventSource | null = null; if (searchTerm.length < 3) { results = []; searchAttempted = false; isLoading = false; } else { results = []; isLoading = true; searchAttempted = true; eventSource = new EventSource(`/api/ingredients/search?q=${encodeURIComponent(searchTerm)}`); eventSource.addEventListener('message', (event) => { const newResults = JSON.parse(event.data); results = [...results, ...newResults]; }); eventSource.addEventListener('stream_error', (event) => { const errorData = JSON.parse((event as MessageEvent).data); console.error('Error de stream recibido:', errorData); }); eventSource.onerror = (err) => { console.error('Error en la conexión de EventSource:', err); isLoading = false; eventSource?.close(); }; eventSource.addEventListener('close', () => { isLoading = false; eventSource?.close(); }); } return () => { eventSource?.close(); }; }); </script> <div class="space-y-8 p-4 md:p-8"> <div class="flex justify-between items-center"> <h1 class="text-2xl font-bold">Añadir Ingredientes desde Open Food Facts</h1> <a href="/admin/ingredientes" class={buttonVariants({ variant: 'outline' })}> Volver al listado </a> </div> <div class="flex items-center gap-2"> <Input bind:value={searchTerm} placeholder="Buscar por nombre (ej. tomate frito)..." class="flex-grow" /> {#if isLoading} <p class="text-sm text-gray-500">Buscando...</p> {/if} </div> {#if results.length > 0} <div class="grid grid-cols-2 gap-4 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6"> {#each results as result, i (result.id)} <div animate:flip={{ duration: 300 }} in:fade={{ duration: 250, delay: i * 20 }}> <Card class={result.source === 'local' ? 'ring-2 ring-green-500' : ''}> <CardHeader> <img src={result.imageUrl || 'https: alt={result.name} class="aspect-square w-full rounded-md object-cover" /> </CardHeader> <CardContent class="flex flex-col justify-between space-y-4"> <CardTitle class="text-sm">{result.name}</CardTitle> {#if result.source === 'off'} <form method="POST" action="?/add"> <input type="hidden" name="productId" value={result.id} /> <Button type="submit" class="w-full">Añadir</Button> </form> {:else} <Button class="w-full" disabled>Añadido</Button> {/if} </CardContent> </Card> </div> {/each} </div> {:else if !isLoading && searchAttempted} <div class="text-center text-gray-500 py-8"> <p>No se encontraron resultados para tu búsqueda.</p> </div> {/if} </div>

// --- Ruta: src/routes/admin/ingredientes/off/+page.server.ts ---
export const actions: Actions = { add: async ({ request }) => { const data = await request.formData(); const productId = data.get('productId') as string; if (!productId) { return fail(400, { success: false, error: 'Product ID no proporcionado' }); } try { const product = await productService.findByBarcode(productId); if (!product) { return fail(404, { success: false, error: `Producto con ID ${productId} no encontrado en Open Food Facts.` }); } return { success: true, product }; } catch (error) { console.error(error); return fail(500, { success: false, error: 'Error interno del servidor al intentar cachear el producto.' }); } } };

// --- Ruta: src/routes/api/recipes/search/+server.ts ---
const RECIPES_PER_PAGE = 50; export const POST: RequestHandler = async ({ request }) => { const requestId = `req_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`; console.log(`\n--- [${requestId}] INICIO: Petición de búsqueda recibida ---`); try { const body = await request.json(); console.log(`[${requestId}] BODY RECIBIDO:`, JSON.stringify(body, null, 2)); const filters = SearchFiltersSchema.parse(body); console.log(`[${requestId}] FILTROS VALIDADOS:`, JSON.stringify(filters, null, 2)); const queryOptions = { ...filters, limit: RECIPES_PER_PAGE + 1 }; console.log(`[${requestId}] QUERY OPTIONS (para recipeService):`, JSON.stringify(queryOptions, null, 2)); const recipesPlusOne = await recipeService.findAdvanced(queryOptions); const hasMore = recipesPlusOne.length > RECIPES_PER_PAGE; const recipes = recipesPlusOne.slice(0, RECIPES_PER_PAGE); console.log(`[${requestId}] RESULTADO: ${recipes.length} recetas encontradas. ¿Hay más?: ${hasMore}`); console.log(`--- [${requestId}] FIN: Petición completada exitosamente ---`); return json({ recipes, hasMore }); } catch (error) { console.error(`--- [${requestId}] ERROR: Ha ocurrido un error en el endpoint ---`, error); if (error instanceof ZodError) { return json({ message: 'Datos de búsqueda inválidos', errors: error.flatten() }, { status: 400 }); } return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

// --- Ruta: src/routes/api/recipes/[id]/+server.ts ---
export const GET: RequestHandler = async ({ params }) => { try { const recipe = await recipeService.getById(params.id); if (!recipe) { return json(createFailResponse('Receta no encontrada'), { status: 404 }); } return json(recipe); } catch (error) { console.error(`Error fetching recipe ${params.id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const PUT: RequestHandler = async ({ request, params }) => { try { const body = await request.json(); const validatedData = RecipeSchema.parse(body); const updatedRecipe = await recipeService.update(params.id, validatedData); if (!updatedRecipe) { return json(createFailResponse('Receta no encontrada para actualizar'), { status: 404 }); } return json(updatedRecipe); } catch (error) { if (error instanceof ZodError) { return json(createFailResponse('La validación falló', error), { status: 400 }); } console.error(`Error updating recipe ${params.id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const DELETE: RequestHandler = async ({ params }) => { try { await recipeService.deleteById(params.id); return new Response(null, { status: 204 }); } catch (error) { console.error(`Error deleting recipe ${params.id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/routes/api/products/[id]/+server.ts ---
const updateNameSchema = z.object({ name: z.string().min(2, 'El nombre debe tener al menos 2 caracteres.') }); export async function PATCH({ params, request }) { const { id } = params; if (!id) { return json({ error: 'ID de producto no proporcionado.' }, { status: 400 }); } try { const body = await request.json(); const validation = updateNameSchema.safeParse(body); if (!validation.success) { return json({ error: validation.error.flatten() }, { status: 400 }); } const { name } = validation.data; const updatedProduct = await ingredientService.updateProductName(id, name); return json(updatedProduct); } catch (error) { console.error(`[API] Error al actualizar el nombre del producto ${id}:`, error); if (typeof error === 'object' && error !== null && 'code' in error && error.code === 'P2025') { return json({ error: 'Producto no encontrado.' }, { status: 404 }); } return json({ error: 'Error interno del servidor.' }, { status: 500 }); } }

// --- Ruta: src/routes/api/ingredients/sync/+server.ts ---
export const POST: RequestHandler = async ({ cookies }) => { const token = cookies.get('session'); if (!token || !(await verifySessionToken(token))) { return json({ message: 'No autorizado' }, { status: 401 }); } try { const result = await ingredientService.syncWithOpenFoodFacts(); return json(result, { status: 200 }); } catch (error) { const errorMessage = error instanceof Error ? error.message : 'Error desconocido en el servidor'; return json({ message: errorMessage }, { status: 500 }); } };

// --- Ruta: src/routes/api/ingredients/search/api.spec.ts ---
vi.mock('$lib/server/services/ingredientService', () => ({ ingredientService: { searchByName: vi.fn() } })); vi.mock('@sveltejs/kit', async (importOriginal) => { const original = await importOriginal<typeof import('@sveltejs/kit')>(); return { ...original, json: vi.fn((data, init) => new Response(JSON.stringify(data), init)) }; }); type ApiEvent = Parameters<typeof GET>[0]; async function consumeStream(stream: ReadableStream | null) { if (!stream) return []; const reader = stream.getReader(); const results = []; while (true) { const { done, value } = await reader.read(); if (done) break; const chunk = value.toString(); const lines = chunk.split('\n\n').filter(Boolean); for (const line of lines) { if (line.startsWith('event: message')) { const data = JSON.parse(line.split('data: ')[1]); results.push(...data); } } } return results; } describe('API Endpoint: /api/ingredients/search', () => { const mockSearchByName = vi.mocked(ingredientService.searchByName); beforeEach(() => { vi.resetAllMocks(); }); it('debe devolver resultados locales del ingredientService', async () => { const mockLocalResults = { customIngredients: [ { id: 'custom1', name: 'Tomate de la huerta', normalizedName: 'tomate de la huerta', calories: 22, fat: 0.2, protein: 0.9, carbs: 3.9 } ], cachedProducts: [ { id: 'prod1', name: 'Tomate Frito (Mercadona)', normalizedName: 'tomate frito (mercadona)', brand: 'Hacendado', imageUrl: 'url_image', calories: 77, fat: 3.5, protein: 1.5, carbs: 8.5, fullPayload: {}, createdAt: new Date(), updatedAt: new Date() } ] }; mockSearchByName.mockResolvedValue(mockLocalResults); const mockFetch = vi.fn().mockResolvedValue({ ok: true, json: () => Promise.resolve({ products: [] }) }); const url = new URL('http: const response = await GET({ url, fetch: mockFetch } as unknown as ApiEvent); const result = await consumeStream(response.body as ReadableStream); expect(mockSearchByName).toHaveBeenCalledWith('tomate'); expect(result).toContainEqual({ id: 'custom1', name: 'Tomate de la huerta', source: 'local', type: 'custom', imageUrl: null }); expect(result).toContainEqual({ id: 'prod1', name: 'Tomate Frito (Mercadona)', source: 'local', type: 'product', imageUrl: 'url_image' }); }); it('debe llamar a la API de Open Food Facts con "Hacendado" y "Mercadona" añadido a la query', async () => { mockSearchByName.mockResolvedValue({ customIngredients: [], cachedProducts: [] }); const mockFetch = vi.fn().mockResolvedValue({ ok: true, json: () => Promise.resolve({ products: [] }) }); const url = new URL('http: const response = await GET({ url, fetch: mockFetch } as unknown as ApiEvent); await consumeStream(response.body as ReadableStream); expect(mockFetch).toHaveBeenCalledTimes(2); const fetchUrl1 = mockFetch.mock.calls[0][0] as string; const fetchUrl2 = mockFetch.mock.calls[1][0] as string; expect(fetchUrl1).toContain('search_terms=queso%20Hacendado'); expect(fetchUrl2).toContain('search_terms=queso%20Mercadona'); }); it('debe unificar resultados y eliminar duplicados dando prioridad a los locales', async () => { const mockLocalResults = { customIngredients: [], cachedProducts: [ { id: '12345', name: 'Producto Local Repetido', normalizedName: 'producto local repetido', brand: 'Local', imageUrl: null, calories: 1, fat: 1, protein: 1, carbs: 1, fullPayload: {}, createdAt: new Date(), updatedAt: new Date() } ] }; mockSearchByName.mockResolvedValue(mockLocalResults); const mockOffResponse = { products: [ { code: '12345', product_name: 'Producto OFF Repetido', image_front_small_url: 'url1' }, { code: '67890', product_name: 'Producto OFF Único', image_front_small_url: 'url2' } ] }; const mockFetch = vi.fn().mockResolvedValue({ ok: true, json: () => Promise.resolve(mockOffResponse) }); const url = new URL('http: const response = await GET({ url, fetch: mockFetch } as unknown as ApiEvent); const result = await consumeStream(response.body as ReadableStream); expect(result).toHaveLength(2); expect(result).toContainEqual({ id: '12345', name: 'Producto Local Repetido', source: 'local', type: 'product', imageUrl: null }); expect(result).toContainEqual({ id: '67890', name: 'Producto OFF Único', source: 'off', type: 'product', imageUrl: 'url2' }); }); it('debe devolver un error 400 si no se proporciona el parámetro "q"', async () => { const url = new URL('http: const mockFetch = vi.fn(); const response = await GET({ url, fetch: mockFetch } as unknown as ApiEvent); expect(response.status).toBe(400); const body = await response.json(); expect(body.error).toBe('Query parameter "q" is required'); }); });

// --- Ruta: src/routes/api/ingredients/search/+server.ts ---
type OffProduct = { code: string; product_name: string; image_front_small_url?: string; }; export const GET: RequestHandler = ({ url, fetch }) => { const query = url.searchParams.get('q'); if (!query) { return json({ error: 'Query parameter "q" is required' }, { status: 400 }); } const abortController = new AbortController(); const stream = new ReadableStream({ async start(controller) { const localIds = new Set<string>(); type SearchResult = { id: string; name: string; source: 'local' | 'off'; type: 'custom' | 'product'; imageUrl: string | null; }; const sendEvent = (event: string, data: object) => { try { controller.enqueue(`event: ${event}\ndata: ${JSON.stringify(data)}\n\n`); } catch (e) { console.warn(`Stream enqueue failed: ${(e as Error).message}`); } }; try { const { customIngredients, cachedProducts } = await ingredientService.searchByName(query); const localResults: SearchResult[] = [ ...customIngredients.map( (i) => ({ ...i, id: i.id, name: i.name, source: 'local', type: 'custom', imageUrl: null }) as const ), ...cachedProducts.map( (p) => ({ ...p, id: p.id, name: p.name, source: 'local', type: 'product', imageUrl: p.imageUrl }) as const ) ]; if (localResults.length > 0) { localResults.forEach((r) => localIds.add(r.id)); sendEvent('message', localResults); } const brands = ['Hacendado', 'Mercadona']; const offSearchPromises = brands.map((brand) => { const offQuery = `${query} ${brand}`; const offUrl = `https: offQuery )} &search_simple=1&action=process&json=1&page_size=10`; return fetch(offUrl, { signal: abortController.signal }) .then(async (res) => { if (!res.ok) throw new Error(`API returned status ${res.status}`); return res.json() as Promise<{ products: OffProduct[] }>; }) .then((response) => { const offProducts = response.products || []; const uniqueOffProducts: SearchResult[] = offProducts .filter((p) => p.code && !localIds.has(p.code)) .map((p) => { localIds.add(p.code); return { id: p.code, name: p.product_name, source: 'off' as const, type: 'product' as const, imageUrl: p.image_front_small_url || null }; }); if (uniqueOffProducts.length > 0) { sendEvent('message', uniqueOffProducts); } }) .catch((err) => { if (err.name === 'AbortError') { console.log(`Fetch aborted for ${brand}.`); return; } throw new Error(`Failed to fetch from ${brand}: ${err.message}`); }); }); const results = await Promise.allSettled(offSearchPromises); results.forEach((result) => { if (result.status === 'rejected') { if (result.reason && result.reason.name !== 'AbortError') { console.error('A fetch promise was rejected:', result.reason); sendEvent('stream_error', { source: 'off-api', message: result.reason.message }); } } }); } catch (error) { if (error instanceof Error && error.name === 'AbortError') { console.log('Stream aborted by client.'); } else { console.error('[Search Stream Error]', error); const errorMessage = error instanceof Error ? error.message : 'Unknown stream error'; sendEvent('stream_error', { source: 'server', message: errorMessage }); } } finally { sendEvent('close', { message: 'Stream closed' }); if (!abortController.signal.aborted) { controller.close(); } } }, cancel(reason) { console.log('Stream cancelled by client.', reason); abortController.abort(reason); } }); return new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' } }); };

// --- Ruta: src/routes/api/ingredients/details/+server.ts ---
export const GET: RequestHandler = async ({ url }) => { const idsParam = url.searchParams.get('ids'); if (!idsParam) { return json({ message: 'Missing "ids" query parameter' }, { status: 400 }); } const ids = idsParam.split(','); if (ids.length === 0) { return json([]); } try { const ingredients = await ingredientService.getByIds(ids); return json(ingredients); } catch (error) { console.error('Failed to fetch ingredient details:', error); return json({ message: 'An error occurred while fetching ingredient details.' }, { status: 500 }); } };

// --- Ruta: src/routes/api/ingredients/autocomplete/+server.ts ---
export const GET: RequestHandler = async ({ url }) => { const query = url.searchParams.get('q'); if (!query) { return json({ error: 'Query parameter "q" is required' }, { status: 400 }); } try { const { customIngredients, cachedProducts } = await ingredientService.searchByName(query); const results = [ ...customIngredients.map((ing) => ({ id: ing.id, name: ing.name, type: 'custom', source: 'local', imageUrl: null })), ...cachedProducts.map((prod) => ({ id: prod.id, name: prod.name, type: 'product', source: 'local', imageUrl: prod.imageUrl })) ]; return json(results); } catch (error) { console.error('Error en el endpoint de autocompletado de ingredientes:', error); return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

// --- Ruta: src/routes/api/ingredients/[id]/+server.ts ---
export const PUT: RequestHandler = async ({ request, params }) => { const { id } = params; if (!id) { return json(createFailResponse('ID de ingrediente es requerido'), { status: 400 }); } try { const body = await request.json(); const validatedData = IngredientSchema.parse(body); const updatedIngredient = await ingredientService.update(id, validatedData); return json(updatedIngredient); } catch (error) { if (error instanceof ZodError) { return json(createFailResponse('La validación falló', error), { status: 400 }); } console.error(`Error updating ingredient with id ${id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const DELETE: RequestHandler = async ({ params }) => { const { id } = params; if (!id) { return json(createFailResponse('ID de ingrediente es requerido'), { status: 400 }); } try { await ingredientService.deleteById(id); return new Response(null, { status: 204 }); } catch (error) { console.error(`Error deleting ingredient ${id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/lib/components/ui/textarea/textarea.svelte ---
<script lang="ts"> import { cn, type WithElementRef, type WithoutChildren } from "$lib/utils.js"; import type { HTMLTextareaAttributes } from "svelte/elements"; let { ref = $bindable(null), value = $bindable(), class: className, ...restProps }: WithoutChildren<WithElementRef<HTMLTextareaAttributes>> = $props(); </script> <textarea bind:this={ref} data-slot="textarea" class={cn( "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 field-sizing-content shadow-xs flex min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base outline-none transition-[color,box-shadow] focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", className )} bind:value {...restProps} ></textarea>

// --- Ruta: src/lib/components/ui/textarea/index.ts ---
export { Root, Root as Textarea, };

// --- Ruta: src/lib/components/ui/tooltip/tooltip-trigger.svelte ---
<script lang="ts"> import { Tooltip as TooltipPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: TooltipPrimitive.TriggerProps = $props(); </script> <TooltipPrimitive.Trigger bind:ref data-slot="tooltip-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/tooltip/tooltip-content.svelte ---
<script lang="ts"> import { Tooltip as TooltipPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, sideOffset = 0, side = "top", children, arrowClasses, ...restProps }: TooltipPrimitive.ContentProps & { arrowClasses?: string; } = $props(); </script> <TooltipPrimitive.Portal> <TooltipPrimitive.Content bind:ref data-slot="tooltip-content" {sideOffset} {side} class={cn( "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-tooltip-content-transform-origin) z-50 w-fit text-balance rounded-md px-3 py-1.5 text-xs", className )} {...restProps} > {@render children?.()} <TooltipPrimitive.Arrow> {#snippet child({ props })} <div class={cn( "bg-primary z-50 size-2.5 rotate-45 rounded-[2px]", "data-[side=top]:translate-x-1/2 data-[side=top]:translate-y-[calc(-50%_+_2px)]", "data-[side=bottom]:-translate-x-1/2 data-[side=bottom]:-translate-y-[calc(-50%_+_1px)]", "data-[side=right]:translate-x-[calc(50%_+_2px)] data-[side=right]:translate-y-1/2", "data-[side=left]:-translate-y-[calc(50%_-_3px)]", arrowClasses )} {...props} ></div> {/snippet} </TooltipPrimitive.Arrow> </TooltipPrimitive.Content> </TooltipPrimitive.Portal>

// --- Ruta: src/lib/components/ui/tooltip/index.ts ---
const Root = TooltipPrimitive.Root; const Provider = TooltipPrimitive.Provider; const Portal = TooltipPrimitive.Portal; export { Root, Trigger, Content, Provider, Portal, Root as Tooltip, Content as TooltipContent, Trigger as TooltipTrigger, Provider as TooltipProvider, Portal as TooltipPortal, };

// --- Ruta: src/lib/components/ui/switch/switch.svelte ---
<script lang="ts"> import { Switch as SwitchPrimitive } from "bits-ui"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, checked = $bindable(false), ...restProps }: WithoutChildrenOrChild<SwitchPrimitive.RootProps> = $props(); </script> <SwitchPrimitive.Root bind:ref bind:checked data-slot="switch" class={cn( "data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 shadow-xs peer inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent outline-none transition-all focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", className )} {...restProps} > <SwitchPrimitive.Thumb data-slot="switch-thumb" class={cn( "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0" )} /> </SwitchPrimitive.Root>

// --- Ruta: src/lib/components/ui/switch/index.ts ---
export { Root, Root as Switch, };

// --- Ruta: src/lib/components/ui/table/table.svelte ---
<script lang="ts"> import type { HTMLTableAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLTableAttributes> = $props(); </script> <div data-slot="table-container" class="relative w-full overflow-x-auto"> <table bind:this={ref} data-slot="table" class={cn("w-full caption-bottom text-sm", className)} {...restProps} > {@render children?.()} </table> </div>

// --- Ruta: src/lib/components/ui/table/table-row.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLTableRowElement>> = $props(); </script> <tr bind:this={ref} data-slot="table-row" class={cn( "hover:[&,&>svelte-css-wrapper]:[&>th,td]:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors", className )} {...restProps} > {@render children?.()} </tr>

// --- Ruta: src/lib/components/ui/table/table-header.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props(); </script> <thead bind:this={ref} data-slot="table-header" class={cn("[&_tr]:border-b", className)} {...restProps} > {@render children?.()} </thead>

// --- Ruta: src/lib/components/ui/table/table-head.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLThAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLThAttributes> = $props(); </script> <th bind:this={ref} data-slot="table-head" class={cn( "text-foreground h-10 whitespace-nowrap bg-clip-padding px-2 text-left align-middle font-medium [&:has([role=checkbox])]:pr-0", className )} {...restProps} > {@render children?.()} </th>

// --- Ruta: src/lib/components/ui/table/table-footer.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props(); </script> <tfoot bind:this={ref} data-slot="table-footer" class={cn("bg-muted/50 border-t font-medium [&>tr]:last:border-b-0", className)} {...restProps} > {@render children?.()} </tfoot>

// --- Ruta: src/lib/components/ui/table/table-cell.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLTdAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLTdAttributes> = $props(); </script> <td bind:this={ref} data-slot="table-cell" class={cn( "whitespace-nowrap bg-clip-padding p-2 align-middle [&:has([role=checkbox])]:pr-0", className )} {...restProps} > {@render children?.()} </td>

// --- Ruta: src/lib/components/ui/table/table-caption.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLElement>> = $props(); </script> <caption bind:this={ref} data-slot="table-caption" class={cn("text-muted-foreground mt-4 text-sm", className)} {...restProps} > {@render children?.()} </caption>

// --- Ruta: src/lib/components/ui/table/table-body.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props(); </script> <tbody bind:this={ref} data-slot="table-body" class={cn("[&_tr:last-child]:border-0", className)} {...restProps} > {@render children?.()} </tbody>

// --- Ruta: src/lib/components/ui/table/index.ts ---
export { Root, Body, Caption, Cell, Footer, Head, Header, Row, Root as Table, Body as TableBody, Caption as TableCaption, Cell as TableCell, Footer as TableFooter, Head as TableHead, Header as TableHeader, Row as TableRow, };

// --- Ruta: src/lib/components/ui/popover/popover-trigger.svelte ---
<script lang="ts"> import { cn } from "$lib/utils.js"; import { Popover as PopoverPrimitive } from "bits-ui"; let { ref = $bindable(null), class: className, ...restProps }: PopoverPrimitive.TriggerProps = $props(); </script> <PopoverPrimitive.Trigger bind:ref data-slot="popover-trigger" class={cn("", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/popover/popover-content.svelte ---
<script lang="ts"> import { cn } from "$lib/utils.js"; import { Popover as PopoverPrimitive } from "bits-ui"; let { ref = $bindable(null), class: className, sideOffset = 4, align = "center", portalProps, ...restProps }: PopoverPrimitive.ContentProps & { portalProps?: PopoverPrimitive.PortalProps; } = $props(); </script> <PopoverPrimitive.Portal {...portalProps}> <PopoverPrimitive.Content bind:ref data-slot="popover-content" {sideOffset} {align} class={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-popover-content-transform-origin) outline-hidden z-50 w-72 rounded-md border p-4 shadow-md", className )} {...restProps} /> </PopoverPrimitive.Portal>

// --- Ruta: src/lib/components/ui/popover/index.ts ---
const Root = PopoverPrimitive.Root; const Close = PopoverPrimitive.Close; export { Root, Content, Trigger, Close, Root as Popover, Content as PopoverContent, Trigger as PopoverTrigger, Close as PopoverClose, };

// --- Ruta: src/lib/components/ui/label/label.svelte ---
<script lang="ts"> import { Label as LabelPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: LabelPrimitive.RootProps = $props(); </script> <LabelPrimitive.Root bind:ref data-slot="label" class={cn( "flex select-none items-center gap-2 text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-50 group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/label/index.ts ---
export { Root, Root as Label, };

// --- Ruta: src/lib/components/ui/input/input.svelte ---
<script lang="ts"> import type { HTMLInputAttributes, HTMLInputTypeAttribute } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; type InputType = Exclude<HTMLInputTypeAttribute, "file">; type Props = WithElementRef< Omit<HTMLInputAttributes, "type"> & ({ type: "file"; files?: FileList } | { type?: InputType; files?: undefined }) >; let { ref = $bindable(null), value = $bindable(), type, files = $bindable(), class: className, ...restProps }: Props = $props(); </script> {#if type === "file"} <input bind:this={ref} data-slot="input" class={cn( "selection:bg-primary dark:bg-input/30 selection:text-primary-foreground border-input ring-offset-background placeholder:text-muted-foreground shadow-xs flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 pt-1.5 text-sm font-medium outline-none transition-[color,box-shadow] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", className )} type="file" bind:files bind:value {...restProps} /> {:else} <input bind:this={ref} data-slot="input" class={cn( "border-input bg-background selection:bg-primary dark:bg-input/30 selection:text-primary-foreground ring-offset-background placeholder:text-muted-foreground shadow-xs flex h-9 w-full min-w-0 rounded-md border px-3 py-1 text-base outline-none transition-[color,box-shadow] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", className )} {type} bind:value {...restProps} /> {/if}

// --- Ruta: src/lib/components/ui/input/index.ts ---
export { Root, Root as Input, };

// --- Ruta: src/lib/components/ui/separator/separator.svelte ---
<script lang="ts"> import { Separator as SeparatorPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: SeparatorPrimitive.RootProps = $props(); </script> <SeparatorPrimitive.Root bind:ref data-slot="separator" class={cn( "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=vertical]:h-full data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-px", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/separator/index.ts ---
export { Root, Root as Separator, };

// --- Ruta: src/lib/components/ui/dropdown-menu/index.ts ---
const Sub = DropdownMenuPrimitive.Sub; const Root = DropdownMenuPrimitive.Root; export { CheckboxItem, Content, Root as DropdownMenu, CheckboxItem as DropdownMenuCheckboxItem, Content as DropdownMenuContent, Group as DropdownMenuGroup, Item as DropdownMenuItem, Label as DropdownMenuLabel, RadioGroup as DropdownMenuRadioGroup, RadioItem as DropdownMenuRadioItem, Separator as DropdownMenuSeparator, Shortcut as DropdownMenuShortcut, Sub as DropdownMenuSub, SubContent as DropdownMenuSubContent, SubTrigger as DropdownMenuSubTrigger, Trigger as DropdownMenuTrigger, GroupHeading as DropdownMenuGroupHeading, Group, GroupHeading, Item, Label, RadioGroup, RadioItem, Root, Separator, Shortcut, Sub, SubContent, SubTrigger, Trigger, };

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-trigger.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: DropdownMenuPrimitive.TriggerProps = $props(); </script> <DropdownMenuPrimitive.Trigger bind:ref data-slot="dropdown-menu-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-sub-trigger.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import ChevronRightIcon from "@lucide/svelte/icons/chevron-right"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, inset, children, ...restProps }: DropdownMenuPrimitive.SubTriggerProps & { inset?: boolean; } = $props(); </script> <DropdownMenuPrimitive.SubTrigger bind:ref data-slot="dropdown-menu-sub-trigger" data-inset={inset} class={cn( "data-highlighted:bg-accent data-highlighted:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground outline-hidden [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} > {@render children?.()} <ChevronRightIcon class="ml-auto size-4" /> </DropdownMenuPrimitive.SubTrigger>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-sub-content.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DropdownMenuPrimitive.SubContentProps = $props(); </script> <DropdownMenuPrimitive.SubContent bind:ref data-slot="dropdown-menu-sub-content" class={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-dropdown-menu-content-transform-origin) z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-shortcut.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLSpanElement>> = $props(); </script> <span bind:this={ref} data-slot="dropdown-menu-shortcut" class={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)} {...restProps} > {@render children?.()} </span>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-separator.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DropdownMenuPrimitive.SeparatorProps = $props(); </script> <DropdownMenuPrimitive.Separator bind:ref data-slot="dropdown-menu-separator" class={cn("bg-border -mx-1 my-1 h-px", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-radio-item.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import CircleIcon from "@lucide/svelte/icons/circle"; import { cn, type WithoutChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children: childrenProp, ...restProps }: WithoutChild<DropdownMenuPrimitive.RadioItemProps> = $props(); </script> <DropdownMenuPrimitive.RadioItem bind:ref data-slot="dropdown-menu-radio-item" class={cn( "focus:bg-accent focus:text-accent-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-8 pr-2 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} > {#snippet children({ checked })} <span class="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center"> {#if checked} <CircleIcon class="size-2 fill-current" /> {/if} </span> {@render childrenProp?.({ checked })} {/snippet} </DropdownMenuPrimitive.RadioItem>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-radio-group.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), value = $bindable(), ...restProps }: DropdownMenuPrimitive.RadioGroupProps = $props(); </script> <DropdownMenuPrimitive.RadioGroup bind:ref bind:value data-slot="dropdown-menu-radio-group" {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-label.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, inset, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> & { inset?: boolean; } = $props(); </script> <div bind:this={ref} data-slot="dropdown-menu-label" data-inset={inset} class={cn("px-2 py-1.5 text-sm font-semibold data-[inset]:pl-8", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-item.svelte ---
<script lang="ts"> import { cn } from "$lib/utils.js"; import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), class: className, inset, variant = "default", ...restProps }: DropdownMenuPrimitive.ItemProps & { inset?: boolean; variant?: "default" | "destructive"; } = $props(); </script> <DropdownMenuPrimitive.Item bind:ref data-slot="dropdown-menu-item" data-inset={inset} data-variant={variant} class={cn( "data-highlighted:bg-accent data-highlighted:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:data-highlighted:bg-destructive/10 dark:data-[variant=destructive]:data-highlighted:bg-destructive/20 data-[variant=destructive]:data-highlighted:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-group.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: DropdownMenuPrimitive.GroupProps = $props(); </script> <DropdownMenuPrimitive.Group bind:ref data-slot="dropdown-menu-group" {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-group-heading.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; import type { ComponentProps } from "svelte"; let { ref = $bindable(null), class: className, inset, ...restProps }: ComponentProps<typeof DropdownMenuPrimitive.GroupHeading> & { inset?: boolean; } = $props(); </script> <DropdownMenuPrimitive.GroupHeading bind:ref data-slot="dropdown-menu-group-heading" data-inset={inset} class={cn("px-2 py-1.5 text-sm font-semibold data-[inset]:pl-8", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-content.svelte ---
<script lang="ts"> import { cn } from "$lib/utils.js"; import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), sideOffset = 4, portalProps, class: className, ...restProps }: DropdownMenuPrimitive.ContentProps & { portalProps?: DropdownMenuPrimitive.PortalProps; } = $props(); </script> <DropdownMenuPrimitive.Portal {...portalProps}> <DropdownMenuPrimitive.Content bind:ref data-slot="dropdown-menu-content" {sideOffset} class={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 max-h-(--bits-dropdown-menu-content-available-height) origin-(--bits-dropdown-menu-content-transform-origin) z-50 min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border p-1 shadow-md outline-none", className )} {...restProps} /> </DropdownMenuPrimitive.Portal>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-checkbox-item.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import CheckIcon from "@lucide/svelte/icons/check"; import MinusIcon from "@lucide/svelte/icons/minus"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; import type { Snippet } from "svelte"; let { ref = $bindable(null), checked = $bindable(false), indeterminate = $bindable(false), class: className, children: childrenProp, ...restProps }: WithoutChildrenOrChild<DropdownMenuPrimitive.CheckboxItemProps> & { children?: Snippet; } = $props(); </script> <DropdownMenuPrimitive.CheckboxItem bind:ref bind:checked bind:indeterminate data-slot="dropdown-menu-checkbox-item" class={cn( "focus:bg-accent focus:text-accent-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-8 pr-2 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} > {#snippet children({ checked, indeterminate })} <span class="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center"> {#if indeterminate} <MinusIcon class="size-4" /> {:else} <CheckIcon class={cn("size-4", !checked && "text-transparent")} /> {/if} </span> {@render childrenProp?.()} {/snippet} </DropdownMenuPrimitive.CheckboxItem>

// --- Ruta: src/lib/components/ui/dialog/index.ts ---
const Root = DialogPrimitive.Dialog.Root; const Portal = DialogPrimitive.Dialog.Portal; export { Root, Title, Portal, Footer, Header, Trigger, Overlay, Content, Description, Close, Root as Dialog, Title as DialogTitle, Portal as DialogPortal, Footer as DialogFooter, Header as DialogHeader, Trigger as DialogTrigger, Overlay as DialogOverlay, Content as DialogContent, Description as DialogDescription, Close as DialogClose, };

// --- Ruta: src/lib/components/ui/dialog/dialog-trigger.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: DialogPrimitive.TriggerProps = $props(); </script> <DialogPrimitive.Trigger bind:ref data-slot="dialog-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-title.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DialogPrimitive.TitleProps = $props(); </script> <DialogPrimitive.Title bind:ref data-slot="dialog-title" class={cn("text-lg font-semibold leading-none", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-overlay.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DialogPrimitive.OverlayProps = $props(); </script> <DialogPrimitive.Overlay bind:ref data-slot="dialog-overlay" class={cn( "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-header.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="dialog-header" class={cn("flex flex-col gap-2 text-center sm:text-left", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/dialog/dialog-footer.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="dialog-footer" class={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/dialog/dialog-description.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DialogPrimitive.DescriptionProps = $props(); </script> <DialogPrimitive.Description bind:ref data-slot="dialog-description" class={cn("text-muted-foreground text-sm", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-content.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; import XIcon from "@lucide/svelte/icons/x"; import type { Snippet } from "svelte"; import * as Dialog from "./index.js"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, portalProps, children, showCloseButton = true, ...restProps }: WithoutChildrenOrChild<DialogPrimitive.ContentProps> & { portalProps?: DialogPrimitive.PortalProps; children: Snippet; showCloseButton?: boolean; } = $props(); </script> <Dialog.Portal {...portalProps}> <Dialog.Overlay /> <DialogPrimitive.Content bind:ref data-slot="dialog-content" class={cn( "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", className )} {...restProps} > {@render children?.()} {#if showCloseButton} <DialogPrimitive.Close class="ring-offset-background focus:ring-ring rounded-xs focus:outline-hidden absolute right-4 top-4 opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 disabled:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0" > <XIcon /> <span class="sr-only">Close</span> </DialogPrimitive.Close> {/if} </DialogPrimitive.Content> </Dialog.Portal>

// --- Ruta: src/lib/components/ui/dialog/dialog-close.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: DialogPrimitive.CloseProps = $props(); </script> <DialogPrimitive.Close bind:ref data-slot="dialog-close" {...restProps} />

// --- Ruta: src/lib/components/ui/command/index.ts ---
const Loading = CommandPrimitive.Loading; export { Root, Dialog, Empty, Group, Item, LinkItem, Input, List, Separator, Shortcut, Loading, Root as Command, Dialog as CommandDialog, Empty as CommandEmpty, Group as CommandGroup, Item as CommandItem, LinkItem as CommandLinkItem, Input as CommandInput, List as CommandList, Separator as CommandSeparator, Shortcut as CommandShortcut, Loading as CommandLoading, };

// --- Ruta: src/lib/components/ui/command/command.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), value = $bindable(""), class: className, ...restProps }: CommandPrimitive.RootProps = $props(); </script> <CommandPrimitive.Root bind:value bind:ref data-slot="command" class={cn( "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-shortcut.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLSpanElement>> = $props(); </script> <span bind:this={ref} data-slot="command-shortcut" class={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)} {...restProps} > {@render children?.()} </span>

// --- Ruta: src/lib/components/ui/command/command-separator.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.SeparatorProps = $props(); </script> <CommandPrimitive.Separator bind:ref data-slot="command-separator" class={cn("bg-border -mx-1 h-px", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-list.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.ListProps = $props(); </script> <CommandPrimitive.List bind:ref data-slot="command-list" class={cn("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-link-item.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.LinkItemProps = $props(); </script> <CommandPrimitive.LinkItem bind:ref data-slot="command-item" class={cn( "aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-item.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.ItemProps = $props(); </script> <CommandPrimitive.Item bind:ref data-slot="command-item" class={cn( "aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-input.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import SearchIcon from "@lucide/svelte/icons/search"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, value = $bindable(""), ...restProps }: CommandPrimitive.InputProps = $props(); </script> <div class="flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"> <SearchIcon class="size-4 shrink-0 opacity-50" /> <CommandPrimitive.Input data-slot="command-input" class={cn( "placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", className )} bind:ref {...restProps} bind:value /> </div>

// --- Ruta: src/lib/components/ui/command/command-group.svelte ---
<script lang="ts"> import { Command as CommandPrimitive, useId } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, heading, value, ...restProps }: CommandPrimitive.GroupProps & { heading?: string; } = $props(); </script> <CommandPrimitive.Group bind:ref data-slot="command-group" class={cn("text-foreground overflow-hidden p-1", className)} value={value ?? heading ?? `----${useId()}`} {...restProps} > {#if heading} <CommandPrimitive.GroupHeading class="text-muted-foreground px-2 py-1.5 text-xs font-medium" > {heading} </CommandPrimitive.GroupHeading> {/if} <CommandPrimitive.GroupItems {children} /> </CommandPrimitive.Group>

// --- Ruta: src/lib/components/ui/command/command-empty.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.EmptyProps = $props(); </script> <CommandPrimitive.Empty bind:ref data-slot="command-empty" class={cn("py-6 text-center text-sm", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-dialog.svelte ---
<script lang="ts"> import type { Command as CommandPrimitive, Dialog as DialogPrimitive } from "bits-ui"; import type { Snippet } from "svelte"; import Command from "./command.svelte"; import * as Dialog from "$lib/components/ui/dialog/index.js"; import type { WithoutChildrenOrChild } from "$lib/utils.js"; let { open = $bindable(false), ref = $bindable(null), value = $bindable(""), title = "Command Palette", description = "Search for a command to run", portalProps, children, ...restProps }: WithoutChildrenOrChild<DialogPrimitive.RootProps> & WithoutChildrenOrChild<CommandPrimitive.RootProps> & { portalProps?: DialogPrimitive.PortalProps; children: Snippet; title?: string; description?: string; } = $props(); </script> <Dialog.Root bind:open {...restProps}> <Dialog.Header class="sr-only"> <Dialog.Title>{title}</Dialog.Title> <Dialog.Description>{description}</Dialog.Description> </Dialog.Header> <Dialog.Content class="overflow-hidden p-0" {portalProps}> <Command class="**:data-[slot=command-input-wrapper]:h-12 [&_[data-command-group]:not([hidden])_~[data-command-group]]:pt-0 [&_[data-command-group]]:px-2 [&_[data-command-input-wrapper]_svg]:h-5 [&_[data-command-input-wrapper]_svg]:w-5 [&_[data-command-input]]:h-12 [&_[data-command-item]]:px-2 [&_[data-command-item]]:py-3 [&_[data-command-item]_svg]:h-5 [&_[data-command-item]_svg]:w-5" {...restProps} bind:value bind:ref {children} /> </Dialog.Content> </Dialog.Root>

// --- Ruta: src/lib/components/ui/card/index.ts ---
export { Root, Content, Description, Footer, Header, Title, Action, Root as Card, Content as CardContent, Description as CardDescription, Footer as CardFooter, Header as CardHeader, Title as CardTitle, Action as CardAction, };

// --- Ruta: src/lib/components/ui/card/card.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card" class={cn( "bg-card text-card-foreground flex flex-col gap-6 pb-6 rounded-xl border shadow-sm", className )} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-title.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-title" class={cn("font-semibold leading-none", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-header.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-header" class={cn( "@container/card-header has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6 grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6", className )} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-footer.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-footer" class={cn("[.border-t]:pt-6 flex items-center px-6", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-description.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLParagraphElement>> = $props(); </script> <p bind:this={ref} data-slot="card-description" class={cn("text-muted-foreground text-sm", className)} {...restProps} > {@render children?.()} </p>

// --- Ruta: src/lib/components/ui/card/card-content.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-content" class={cn("px-6", className)} {...restProps}> {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-action.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-action" class={cn("col-start-2 row-span-2 row-start-1 self-start justify-self-end", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/button/index.ts ---
type ButtonProps, type ButtonSize, type ButtonVariant, buttonVariants, } from "./button.svelte"; export { Root, type ButtonProps as Props, Root as Button, buttonVariants, type ButtonProps, type ButtonSize, type ButtonVariant, };

// --- Ruta: src/lib/components/ui/button/button.svelte ---
<script lang="ts" module> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAnchorAttributes, HTMLButtonAttributes } from "svelte/elements"; import { type VariantProps, tv } from "tailwind-variants"; export const buttonVariants = tv({ base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", variants: { variant: { default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90", destructive: "bg-destructive shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white", outline: "bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border", secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50", link: "text-primary underline-offset-4 hover:underline", }, size: { default: "h-9 px-4 py-2 has-[>svg]:px-3", sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5", lg: "h-10 rounded-md px-6 has-[>svg]:px-4", icon: "size-9", }, }, defaultVariants: { variant: "default", size: "default", }, }); export type ButtonVariant = VariantProps<typeof buttonVariants>["variant"]; export type ButtonSize = VariantProps<typeof buttonVariants>["size"]; export type ButtonProps = WithElementRef<HTMLButtonAttributes> & WithElementRef<HTMLAnchorAttributes> & { variant?: ButtonVariant; size?: ButtonSize; }; </script> <script lang="ts"> let { class: className, variant = "default", size = "default", ref = $bindable(null), href = undefined, type = "button", disabled, children, ...restProps }: ButtonProps = $props(); </script> {#if href} <a bind:this={ref} data-slot="button" class={cn(buttonVariants({ variant, size }), className)} href={disabled ? undefined : href} aria-disabled={disabled} role={disabled ? "link" : undefined} tabindex={disabled ? -1 : undefined} {...restProps} > {@render children?.()} </a> {:else} <button bind:this={ref} data-slot="button" class={cn(buttonVariants({ variant, size }), className)} {type} {disabled} {...restProps} > {@render children?.()} </button> {/if}

// --- Ruta: src/lib/components/ui/badge/index.ts ---
export { default as Badge } from "./badge.svelte"; export { badgeVariants, type BadgeVariant } from "./badge.svelte";

// --- Ruta: src/lib/components/ui/badge/badge.svelte ---
<script lang="ts" module> import { type VariantProps, tv } from "tailwind-variants"; export const badgeVariants = tv({ base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex w-fit shrink-0 items-center justify-center gap-1 overflow-hidden whitespace-nowrap rounded-md border px-2 py-0.5 text-xs font-medium transition-[color,box-shadow] focus-visible:ring-[3px] [&>svg]:pointer-events-none [&>svg]:size-3", variants: { variant: { default: "bg-primary text-primary-foreground [a&]:hover:bg-primary/90 border-transparent", secondary: "bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90 border-transparent", destructive: "bg-destructive [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/70 border-transparent text-white", outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground", }, }, defaultVariants: { variant: "default", }, }); export type BadgeVariant = VariantProps<typeof badgeVariants>["variant"]; </script> <script lang="ts"> import type { HTMLAnchorAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), href, class: className, variant = "default", children, ...restProps }: WithElementRef<HTMLAnchorAttributes> & { variant?: BadgeVariant; } = $props(); </script> <svelte:element this={href ? "a" : "span"} bind:this={ref} data-slot="badge" {href} class={cn(badgeVariants({ variant }), className)} {...restProps} > {@render children?.()} </svelte:element>

// --- Ruta: src/lib/components/ui/alert-dialog/index.ts ---
const Root = AlertDialogPrimitive.Root; const Portal = AlertDialogPrimitive.Portal; export { Root, Title, Action, Cancel, Portal, Footer, Header, Trigger, Overlay, Content, Description, Root as AlertDialog, Title as AlertDialogTitle, Action as AlertDialogAction, Cancel as AlertDialogCancel, Portal as AlertDialogPortal, Footer as AlertDialogFooter, Header as AlertDialogHeader, Trigger as AlertDialogTrigger, Overlay as AlertDialogOverlay, Content as AlertDialogContent, Description as AlertDialogDescription, };

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-trigger.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: AlertDialogPrimitive.TriggerProps = $props(); </script> <AlertDialogPrimitive.Trigger bind:ref data-slot="alert-dialog-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-title.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.TitleProps = $props(); </script> <AlertDialogPrimitive.Title bind:ref data-slot="alert-dialog-title" class={cn("text-lg font-semibold", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-overlay.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.OverlayProps = $props(); </script> <AlertDialogPrimitive.Overlay bind:ref data-slot="alert-dialog-overlay" class={cn( "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-header.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="alert-dialog-header" class={cn("flex flex-col gap-2 text-center sm:text-left", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-footer.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="alert-dialog-footer" class={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-description.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.DescriptionProps = $props(); </script> <AlertDialogPrimitive.Description bind:ref data-slot="alert-dialog-description" class={cn("text-muted-foreground text-sm", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-content.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import AlertDialogOverlay from "./alert-dialog-overlay.svelte"; import { cn, type WithoutChild, type WithoutChildrenOrChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, portalProps, ...restProps }: WithoutChild<AlertDialogPrimitive.ContentProps> & { portalProps?: WithoutChildrenOrChild<AlertDialogPrimitive.PortalProps>; } = $props(); </script> <AlertDialogPrimitive.Portal {...portalProps}> <AlertDialogOverlay /> <AlertDialogPrimitive.Content bind:ref data-slot="alert-dialog-content" class={cn( "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", className )} {...restProps} /> </AlertDialogPrimitive.Portal>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-cancel.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { buttonVariants } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.CancelProps = $props(); </script> <AlertDialogPrimitive.Cancel bind:ref data-slot="alert-dialog-cancel" class={cn(buttonVariants({ variant: "outline" }), className)} {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-action.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { buttonVariants } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.ActionProps = $props(); </script> <AlertDialogPrimitive.Action bind:ref data-slot="alert-dialog-action" class={cn(buttonVariants(), className)} {...restProps} />

// --- Ruta: src/lib/components/ui/alert/index.ts ---
export { alertVariants, type AlertVariant } from "./alert.svelte"; export { Root, Description, Title, Root as Alert, Description as AlertDescription, Title as AlertTitle, };

// --- Ruta: src/lib/components/ui/alert/alert.svelte ---
<script lang="ts" module> import { type VariantProps, tv } from "tailwind-variants"; export const alertVariants = tv({ base: "relative grid w-full grid-cols-[0_1fr] items-start gap-y-0.5 rounded-lg border px-4 py-3 text-sm has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] has-[>svg]:gap-x-3 [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current", variants: { variant: { default: "bg-card text-card-foreground", destructive: "text-destructive bg-card *:data-[slot=alert-description]:text-destructive/90 [&>svg]:text-current", }, }, defaultVariants: { variant: "default", }, }); export type AlertVariant = VariantProps<typeof alertVariants>["variant"]; </script> <script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, variant = "default", children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> & { variant?: AlertVariant; } = $props(); </script> <div bind:this={ref} data-slot="alert" class={cn(alertVariants({ variant }), className)} {...restProps} role="alert" > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert/alert-title.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="alert-title" class={cn("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert/alert-description.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="alert-description" class={cn( "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed", className )} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/routes/api/products/search/[barcode]/+server.ts ---
export const GET: RequestHandler = async ({ params }) => { const { barcode } = params; if (!barcode) { return json({ message: 'El código de barras es requerido' }, { status: 400 }); } try { const product = await productService.findByBarcode(barcode); if (!product) { return json({ message: 'Producto no encontrado' }, { status: 404 }); } return json(product); } catch (error) { console.error(`Error searching for barcode ${barcode}:`, error); return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

// --- Ruta: src/routes/api/ingredients/details/[id]/+server.ts ---
export const GET: RequestHandler = async ({ params, url }) => { const { id } = params; const type = url.searchParams.get('type'); if (!type || (type !== 'custom' && type !== 'product')) { return json({ message: "El parámetro 'type' es requerido ('custom' o 'product')." }, { status: 400 }); } try { let ingredientData = null; if (type === 'custom') { ingredientData = await prisma.customIngredient.findUnique({ where: { id } }); } else { ingredientData = await productService.findByBarcode(id); } if (!ingredientData) { return json({ message: 'Ingrediente no encontrado.' }, { status: 404 }); } const response = { calories: ingredientData.calories, protein: ingredientData.protein, fat: ingredientData.fat, carbs: ingredientData.carbs }; return json(response); } catch (error) { console.error(`Error fetching ingredient details for id ${id}:`, error); return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

