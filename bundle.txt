/* --- Bundle de Código Generado ---
 * Modo: no-comments
 * Ficheros Incluidos: 255
 * Fecha: 2025-08-12T23:01:18.283Z
 */

// --- Ruta: webhook-server.js ---
const express = require('express'); const bodyParser = require('body-parser'); const { exec } = require('child_process'); const crypto = require('crypto'); const app = express(); const SECRET = 'tu_secreto_webhook'; app.use(bodyParser.json()); app.post('/deploy', (req, res) => { const signature = req.headers['x-hub-signature-256']; const hmac = crypto.createHmac('sha256', SECRET); const digest = 'sha256=' + hmac.update(JSON.stringify(req.body)).digest('hex'); if (signature !== digest) { return res.status(401).send('Unauthorized'); } console.log('🔄 Webhook recibido. Iniciando despliegue...'); exec('node deploy.mjs', (error, stdout, stderr) => { if (error) { console.error(`Error: ${stderr}`); return res.status(500).send('Deployment failed'); } console.log(`Output: ${stdout}`); res.send('Deployment successful'); }); }); const port = process.env.PORT || 4000; app.listen(port, () => console.log(`Webhook server running on port ${port}`));

// --- Ruta: vitest.config.ts ---
export default defineConfig({ plugins: [svelte()], resolve: { alias: { $lib: path.resolve(__dirname, './src/lib') }, conditions: ['browser'] }, test: { environment: 'jsdom', include: ['src*.{test,spec}.{js,ts}'], exclude: ['e2e/**'] } });

// --- Ruta: vite.config.ts ---
dotenv.config(); export default defineConfig({ plugins: [tailwindcss(), sveltekit()], ssr: { noExternal: ['bits-ui', 'svelte-sonner'] }, build: { rollupOptions: { } } });

// --- Ruta: tsconfig.json ---
{ "extends": "./.svelte-kit/tsconfig.json", "compilerOptions": { "allowJs": true, "checkJs": true, "esModuleInterop": true, "forceConsistentCasingInFileNames": true, "resolveJsonModule": true, "skipLibCheck": true, "sourceMap": true, "strict": true, "moduleResolution": "bundler" } }

// --- Ruta: tailwind.config.ts ---
export default { darkMode: 'class', content: ['./src*.{html,js,svelte,ts}'], theme: { extend: { fontFamily: { sans: ['var(--font-sans)', ...defaultTheme.fontFamily.sans], heading: ['var(--font-heading)', ...defaultTheme.fontFamily.sans] } } }, plugins: [] } satisfies Config;

// --- Ruta: svelte.config.js ---
const config = { preprocess: vitePreprocess(), kit: { adapter: adapter() } }; export default config;

// --- Ruta: prisma.config.ts ---
export default defineConfig({ schema: path.join('prisma', 'schema.prisma'), migrations: { path: path.join('prisma', 'migrations'), seed: 'tsx prisma/seed.ts', }, });

// --- Ruta: package.json ---
{ "name": "recetario", "private": true, "version": "0.0.1", "type": "module", "scripts": { "dev": "vite dev", "build": "vite build", "preview": "vite preview", "prepare": "svelte-kit sync || echo ''", "check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json", "check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch", "format": "prettier --write .", "lint": "prettier --check . && eslint .", "test:unit": "vitest", "test": "vitest run", "seed": "node scripts/seed.js" }, "devDependencies": { "@better-auth/cli": "^1.3.5", "@eslint/compat": "^1.2.5", "@eslint/js": "^9.18.0", "@faker-js/faker": "^9.9.0", "@internationalized/date": "^3.8.2", "@lucide/svelte": "^0.515.0", "@sveltejs/adapter-auto": "^6.0.0", "@sveltejs/adapter-cloudflare": "^4.4.0", "@sveltejs/adapter-node": "^5.2.14", "@sveltejs/kit": "^2.22.0", "@sveltejs/vite-plugin-svelte": "^6.0.0", "@tailwindcss/vite": "^4.1.11", "@testing-library/svelte": "^5.2.8", "@types/bcryptjs": "^2.4.6", "@types/cheerio": "^0.22.35", "@types/dompurify": "^3.0.5", "@types/jsdom": "^21.1.7", "@types/marked": "^5.0.2", "@types/node": "^24.1.0", "autoprefixer": "^10.4.21", "bits-ui": "^2.8.13", "clsx": "^2.1.1", "eslint": "^9.18.0", "eslint-config-prettier": "^10.0.1", "eslint-plugin-svelte": "^3.0.0", "glob": "^11.0.3", "globals": "^16.0.0", "ignore": "^7.0.5", "jsdom": "^26.1.0", "postcss": "^8.5.6", "prettier": "^3.4.2", "prettier-plugin-svelte": "^3.3.3", "prettier-plugin-tailwindcss": "^0.6.5", "prisma": "^6.14.0", "shadcn-svelte": "^1.0.6", "svelte": "^5.0.0", "svelte-check": "^4.0.0", "tailwind-merge": "^3.3.1", "tailwind-variants": "^1.0.0", "tailwindcss": "^4.1.11", "tailwindcss-animate": "^1.0.7", "ts-node": "^10.9.2", "tsx": "^4.20.3", "tw-animate-css": "^1.3.6", "typescript": "^5.0.0", "typescript-eslint": "^8.20.0", "vite": "^7.0.4", "vitest": "^3.2.3" }, "overrides": { "esbuild": "^0.20.2" }, "dependencies": { "@node-rs/argon2": "^2.0.2", "@prisma/client": "^6.14.0", "@thisux/sveltednd": "^0.0.20", "bcryptjs": "^3.0.2", "better-auth": "^1.3.5", "cheerio": "^1.1.2", "date-fns": "^4.1.0", "date-fns-tz": "^3.2.0", "dompurify": "^3.2.6", "dotenv": "^17.2.1", "jose": "^6.0.12", "ky": "^1.8.2", "lucide-svelte": "^0.535.0", "marked": "^16.1.1", "mode-watcher": "^1.1.0", "sharp": "^0.34.3", "slugify": "^1.6.6", "svelte-sonner": "^1.0.5", "zod": "^4.0.14" } }

// --- Ruta: migration.sql ---
-- CreateTable CREATE TABLE "Product" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL, "brand" TEXT, "imageUrl" TEXT, "calories" REAL, "fat" REAL, "protein" REAL, "carbs" REAL, "fullPayload" JSONB, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL ); -- CreateTable CREATE TABLE "CustomIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL, "calories" REAL NOT NULL, "fat" REAL NOT NULL, "protein" REAL NOT NULL, "carbs" REAL NOT NULL ); -- CreateTable CREATE TABLE "Recipe" ( "id" TEXT NOT NULL PRIMARY KEY, "title" TEXT NOT NULL, "normalizedTitle" TEXT NOT NULL, "steps" JSONB NOT NULL, "imageUrl" TEXT ); -- CreateTable CREATE TABLE "RecipeUrl" ( "id" TEXT NOT NULL PRIMARY KEY, "url" TEXT NOT NULL, "recipeId" TEXT NOT NULL, CONSTRAINT "RecipeUrl_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "RecipeIngredient" ( "id" TEXT NOT NULL PRIMARY KEY, "recipeId" TEXT NOT NULL, "productId" TEXT, "customIngredientId" TEXT, "quantity" REAL NOT NULL, CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "RecipeIngredient_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product" ("id") ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT "RecipeIngredient_customIngredientId_fkey" FOREIGN KEY ("customIngredientId") REFERENCES "CustomIngredient" ("id") ON DELETE SET NULL ON UPDATE CASCADE ); -- CreateIndex CREATE UNIQUE INDEX "CustomIngredient_name_key" ON "CustomIngredient"("name"); -- CreateIndex CREATE UNIQUE INDEX "RecipeUrl_recipeId_url_key" ON "RecipeUrl"("recipeId", "url");

// --- Ruta: eslint.config.js ---
const gitignorePath = fileURLToPath(new URL('./.gitignore', import.meta.url)); export default ts.config( includeIgnoreFile(gitignorePath), js.configs.recommended, ...ts.configs.recommended, ...svelte.configs.recommended, prettier, ...svelte.configs.prettier, { languageOptions: { globals: { ...globals.browser, ...globals.node } }, rules: { 'no-undef': 'off' } }, { files: ['***.svelte.ts', '**/*.svelte.js'], languageOptions: { parserOptions: { projectService: true, extraFileExtensions: ['.svelte'], parser: ts.parser, svelteConfig } } } );

// --- Ruta: deploy.mjs ---
#!/usr/bin/env node const cfg = JSON.parse(readFileSync('./deploy.config.json', 'utf8')); const { host, remotePath, localPath, buildPath, sshUser, pm2AppName, pm2Script, port, exclude } = cfg; function runCommand(command, args = []) { return new Promise((resolve, reject) => { console.log(`🔨 Ejecutando: ${command} ${args.join(' ')}`); const proc = spawn(command, args, { stdio: 'inherit' }); proc.on('close', (code) => { if (code === 0) { resolve(); } else { reject(new Error(`Comando falló con código ${code}: ${command} ${args.join(' ')}`)); } }); }); } function runRemoteCommand(command) { return new Promise((resolve, reject) => { console.log(`🖥️ Ejecutando en servidor: ${command}`); const commandWithNvm = `source ~/.nvm/nvm.sh && ${command}`; const sshArgs = [ '-o', 'UserKnownHostsFile=/dev/null', '-o', 'StrictHostKeyChecking=no', `${sshUser}@${host}`, commandWithNvm ]; const ssh = spawn('ssh', sshArgs, { stdio: 'inherit' }); ssh.on('close', (code) => { if (code === 0) { resolve(); } else { reject(new Error(`Comando remoto falló con código ${code}: ${command}`)); } }); }); } async function generateEcosystemFile() { console.log('📝 Generando fichero ecosystem.config.cjs...'); const fileContent = ` require('dotenv').config({ path: '${remotePath}/.env' }); module.exports = { apps: [{ name: '${pm2AppName}', script: '${pm2Script}', cwd: '${remotePath}', env: { NODE_ENV: 'production', PORT: ${port}, DATABASE_URL: process.env.DATABASE_URL, SESSION_SECRET: process.env.SESSION_SECRET, ADMIN_PASSWORD_HASH: process.env.ADMIN_PASSWORD_HASH, } }] }; `; await writeFile('ecosystem.config.cjs', fileContent.trim(), 'utf8'); console.log('✅ Fichero ecosystem.config.cjs generado.'); } async function deploy() { try { console.log('🚀 Iniciando proceso de despliegue...\n'); console.log('📦 Paso 1/9: Compilando aplicación localmente...'); await runCommand('npm', ['run', 'build']); console.log('✅ Compilación local completada\n'); console.log('📦 Paso 2/9: Generando fichero de configuración de PM2...'); await generateEcosystemFile(); console.log('✅ Configuración de PM2 generada\n'); console.log('📦 Paso 3/9: Subiendo repositorio al servidor...'); const excludeArgs = exclude.map(item => `--exclude=${item}`); await runCommand('rsync', [ '-avz', '--progress', '--delete', ...excludeArgs, `${localPath}/`, `${sshUser}@${host}:${remotePath}` ]); console.log('✅ Repositorio sincronizado\n'); console.log('📦 Paso 4/9: Subiendo archivos compilados...'); await runCommand('rsync', [ '-avz', '--progress', '--delete', `${buildPath}/`, `${sshUser}@${host}:${remotePath}/${buildPath}` ]); console.log('✅ Archivos compilados subidos\n'); console.log('📦 Paso 5/9: Instalando dependencias en el servidor...'); await runRemoteCommand(`cd ${remotePath} && npm ci`); console.log('✅ Dependencias instaladas\n'); console.log('🗄️ Paso 6/9: Generando cliente Prisma...'); await runRemoteCommand(`cd ${remotePath} && npx prisma generate`); console.log('✅ Cliente Prisma generado\n'); console.log('🔄 Paso 7/9: Aplicando migraciones...'); await runRemoteCommand(`cd ${remotePath} && npx prisma migrate deploy`); console.log('✅ Migraciones aplicadas\n'); console.log('👤 Paso 8/9: Creando usuario administrador...'); await runRemoteCommand( `cd ${remotePath} && export $(grep -v '^#' .env | xargs) && npx tsx scripts/create-admin.ts` ); console.log('✅ Proceso de creación de administrador finalizado\n'); console.log('🔄 Paso 9/9: Reiniciando aplicación...'); await runRemoteCommand(`cd ${remotePath} && pm2 startOrReload ecosystem.config.cjs`); console.log('✅ Aplicación reiniciada\n'); console.log('🎉 ¡Despliegue completado con éxito!'); } catch (error) { console.error('\n❌ Error durante el despliegue:', error.message); console.error('\n💡 Revisa los pasos anteriores para identificar el problema'); exit(1); } } deploy();

// --- Ruta: deploy.config.json ---
{ "host": "vps", "remotePath": "/home/juanjocerero/apps/recetario", "localPath": ".", "buildPath": "build", "sshUser": "juanjocerero", "pm2AppName": "recetario", "pm2Script": "build/index.js", "port": 3000, "exclude": [ "node_modules", ".git", ".env", "build" ] }

// --- Ruta: components.json ---
{ "$schema": "https: "tailwind": { "css": "src/app.css", "baseColor": "slate" }, "aliases": { "components": "$lib/components", "utils": "$lib/utils", "ui": "$lib/components/ui", "hooks": "$lib/hooks", "lib": "$lib" }, "typescript": true, "registry": "https: }

// --- Ruta: .prettierrc ---
{ "useTabs": true, "singleQuote": true, "trailingComma": "none", "printWidth": 100, "plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"], "overrides": [ { "files": "*.svelte", "options": { "parser": "svelte" } } ], "tailwindStylesheet": "./src/app.css" }

// --- Ruta: .prettierignore ---
# Package Managers package-lock.json pnpm-lock.yaml yarn.lock bun.lock bun.lockb # Miscellaneous /static/

// --- Ruta: .npmrc ---
engine-strict=true

// --- Ruta: .env.test ---
# Fichero: .env.test # Justificación: Este fichero de entorno es cargado automáticamente por Vitest. # Define la URL de la base de datos para que apunte a un fichero separado, # aislando completamente los tests de la base de datos de desarrollo. DATABASE_URL="file:./test.db"

// --- Ruta: src/hooks.server.ts ---
const betterAuthHandle: Handle = async ({ event, resolve }) => { return svelteKitHandler({ event, resolve, auth, building }); }; const authorizationHandle: Handle = async ({ event, resolve }) => { if (!event.url.pathname.startsWith('/api/auth')) { event.locals.session = await auth.api.getSession({ headers: event.request.headers }); const { pathname } = event.url; const publicRoutes = ['/login', '/signup', '/', '/recetas/busqueda-avanzada']; if (publicRoutes.includes(pathname)) { return resolve(event); } if ( (pathname.startsWith('/api/recipes') && event.request.method === 'GET') || (pathname === '/api/recipes/search' && event.request.method === 'POST') || (pathname === '/api/search/all' && event.request.method === 'GET') ) { return resolve(event); } if (!event.locals.session) { throw redirect(303, `/login?redirectTo=${pathname}`); } } return resolve(event); }; export const handle = sequence(betterAuthHandle, authorizationHandle);

// --- Ruta: src/app.html ---
<!doctype html> <html lang="es"> <head> <meta charset="utf-8" /> <title>Recetas de Cerero</title> <meta name="description" content="Un recetario y dietario personal" /> <meta name="author" content="Juanjo Cerero" /> <meta name="robots" content="noindex,nofollow" /> <link rel="canonical" href="https: <link rel="icon" href="%sveltekit.assets%/favicon.ico" sizes="48x48" /> <link rel="icon" href="%sveltekit.assets%/favicon-32x32.png" sizes="32x32" type="image/png" /> <link rel="icon" href="%sveltekit.assets%/favicon-16x16.png" sizes="16x16" type="image/png" /> <link rel="apple-touch-icon" href="%sveltekit.assets%/apple-touch-icon.png" /> <link rel="manifest" href="%sveltekit.assets%/site.webmanifest" /> <meta name="msapplication-TileColor" content="#0f172b" /> <meta name="theme-color" content="#0f172b" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <meta property="og:type" content="website" /> <meta property="og:url" content="https: <meta property="og:title" content="Recetas de Cerero" /> <meta property="og:description" content="Un recetario y dietario personal" /> <!-- <meta property="og:image" content="https: <!-- <meta name="twitter:card" content="summary_large_image" /> --> <meta name="twitter:site" content="@juanjocerero" /> <script> (() => { const theme = localStorage.getItem('theme') ?? 'system'; if (theme === 'system') { const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; document.documentElement.classList.toggle('dark', systemTheme === 'dark'); return; } document.documentElement.classList.toggle('dark', theme === 'dark'); })(); </script> <!-- Google Fonts --> <link rel="preconnect" href="https: <link rel="preconnect" href="https: <link href="https: rel="stylesheet" /> %sveltekit.head% </head> <body data-sveltekit-preload-data="hover"> <div style="display: contents">%sveltekit.body%</div> </body> </html>

// --- Ruta: src/app.d.ts ---
type AuthSession = { session: BetterAuthSession; user: App.User; } | null; declare global { namespace App { interface Locals { session: AuthSession; } interface PageData { session?: BetterAuthSession; user?: User; } interface User extends BetterAuthUser { role: string; } } } export {};

// --- Ruta: scripts/hash-password.js ---
const password = process.argv[2]; if (!password) { console.error('Por favor, proporciona una contraseña como argumento.'); process.exit(1); } const SALT_ROUNDS = 10; hash(password, SALT_ROUNDS).then((hash) => { console.log('Contraseña:', password); console.log('Hash:', hash); console.log('\nCopia este hash en tu fichero .env como ADMIN_PASSWORD_HASH'); });

// --- Ruta: scripts/create-admin.ts ---
const prisma = new PrismaClient(); const ADMIN_EMAIL = 'juanjocerero@gmail.com'; function isErrorWithMessage(error: unknown): error is { message: string } { return ( typeof error === 'object' && error !== null && 'message' in error && typeof (error as { message: unknown }).message === 'string' ); } async function createAdmin() { console.log(`🚀 Iniciando creación del usuario administrador: ${ADMIN_EMAIL}`); const password = process.env.ADMIN_PASSWORD; if (!password) { console.error('❌ Error: La variable de entorno ADMIN_PASSWORD no está definida.'); console.error("👉 Ejecuta el script así: ADMIN_PASSWORD='tu_super_contraseña' npx tsx scripts/create-admin.ts"); process.exit(1); } if (password.length < 8) { console.error('❌ Error: La contraseña debe tener al menos 8 caracteres.'); process.exit(1); } const existingUser = await prisma.user.findUnique({ where: { email: ADMIN_EMAIL } }); if (existingUser) { console.warn(`⚠️ Advertencia: El usuario administrador con email "${ADMIN_EMAIL}" ya existe.`); return; } console.log('⏳ Creando usuario...'); const result = await auth.api.signUpEmail({ body: { email: ADMIN_EMAIL, password: password, name: 'Administrador' } }); if ('user' in result && result.user) { console.log(`✅ Usuario creado con ID: ${result.user.id}. Asignando rol de ADMIN...`); await prisma.user.update({ where: { id: result.user.id }, data: { role: 'ADMIN' } }); console.log('🎉 ¡Usuario administrador creado con éxito!'); } else if ('error' in result) { const errorMessage = isErrorWithMessage(result.error) ? result.error.message : 'Error desconocido'; console.error('❌ Error al crear el usuario:', errorMessage); process.exit(1); } } createAdmin() .catch((e) => { console.error(e); process.exit(1); }) .finally(async () => { await prisma.$disconnect(); });

// --- Ruta: prisma/seed.ts ---
console.log('🚀 Seed iniciado...'); const prisma = new PrismaClient(); function isErrorWithMessage(error: unknown): error is { message: string } { return ( typeof error === 'object' && error !== null && 'message' in error && typeof (error as { message: unknown }).message === 'string' ); } async function createUsers() { console.log('--- Limpiando usuarios y sesiones antiguas... ---'); await prisma.user.deleteMany(); console.log('✅ Usuarios y sesiones limpiados.'); console.log('--- Creando usuarios de prueba usando la API de Better Auth... ---'); const adminResult = await auth.api.signUpEmail({ body: { email: 'juanjocerero@gmail.com', password: 'admin1234', name: 'Admin User' } }); if ('user' in adminResult && adminResult.user) { await prisma.user.update({ where: { id: adminResult.user.id }, data: { role: 'admin' } }); console.log('-> Administrador creado: juanjocerero@gmail.com (Contraseña: admin1234)'); } else if ('error' in adminResult) { const errorMessage = isErrorWithMessage(adminResult.error) ? adminResult.error.message : 'Error desconocido'; console.error('Error al crear el usuario administrador:', errorMessage); } const userResult = await auth.api.signUpEmail({ body: { email: 'ana.14mp@hotmail.com', password: 'user1234', name: 'Ana User' } }); if ('user' in userResult && userResult.user) { await prisma.user.update({ where: { id: userResult.user.id }, data: { role: 'user' } }); console.log('-> Usuario creado: ana.14mp@hotmail.com (Contraseña: user1234)'); } else if ('error' in userResult) { const errorMessage = isErrorWithMessage(userResult.error) ? userResult.error.message : 'Error desconocido'; console.error('Error al crear el usuario estándar:', errorMessage); } } interface OffNutriments { 'energy-kcal_100g'?: number; proteins_100g?: number; fat_100g?: number; carbohydrates_100g?: number; } interface OffProduct { code: string; product_name: string; nutriments: OffNutriments; image_url?: string; } interface OffSearchResponse { products: OffProduct[]; } const SEARCH_TERMS_FOR_SEEDING = [ 'Atún claro Hacendado', 'Tortiglioni Hacendado', 'Yogur Griego Hacendado', 'Aceite de Oliva Virgen Extra Hacendado', 'Leche Entera Hacendado', 'Galletas María Hacendado', 'Huevos L Hacendado', 'Arroz Redondo Hacendado', 'Pechuga de Pollo Hacendado', 'Mantequilla sin Sal Hacendado', 'Pavo en Lonchas Hacendado', 'Queso Curado Hacendado', 'Tomate Frito Hacendado', 'Mayonesa Hacendado', 'Mostaza Dijon Hacendado', 'Jamón Serrano Hacendado', 'Lenteja Pardina Hacendado', 'Garbanzo Pedrosillano Hacendado', 'Zumo de Naranja Hacendado', 'Pan de Molde Hacendado', 'Cereales de Avena Hacendado', 'Chocolate Negro 85% Hacendado', 'Café Molido Hacendado', 'Guisantes Finos Hacendado', 'Salmón Ahumado Hacendado' ]; async function fetchAndCreateProduct(searchTerm: string): Promise<Product | null> { console.log(`[OFF] Buscando producto para el término: "${searchTerm}"...`); const searchUrl = `https: searchTerm )}&search_simple=1&action=process&json=1&page_size=5`; try { const response = await fetch(searchUrl); if (!response.ok) throw new Error(`La API de OFF devolvió el estado ${response.status}`); const data: OffSearchResponse = await response.json(); const productData = data.products.find( (p) => p.code && p.product_name && p.nutriments?.['energy-kcal_100g'] && p.nutriments?.proteins_100g && p.nutriments?.fat_100g && p.nutriments?.carbohydrates_100g ); if (!productData) { console.warn(`-> [ADVERTENCIA] No se encontró un producto válido para "${searchTerm}".`); return null; } const existingProduct = await prisma.product.findUnique({ where: { barcode: productData.code } }); if (existingProduct) { console.log(`-> [CACHE] El producto "${existingProduct.name}" ya existe. Omitiendo.`); return existingProduct; } const createdProduct = await prisma.product.create({ data: { name: productData.product_name, normalizedName: normalizeText(productData.product_name), barcode: productData.code, imageUrl: productData.image_url, calories: Number(productData.nutriments['energy-kcal_100g']) || 0, protein: Number(productData.nutriments.proteins_100g) || 0, fat: Number(productData.nutriments.fat_100g) || 0, carbs: Number(productData.nutriments.carbohydrates_100g) || 0 } }); console.log(`-> [ÉXITO] Producto "${createdProduct.name}" guardado.`); return createdProduct; } catch (error) { console.error(`-> [ERROR] Fallo al procesar "${searchTerm}":`, (error as Error).message); return null; } } const BASE_PRODUCTS = [ 'Pollo', 'Ternera', 'Salmón', 'Lentejas', 'Garbanzos', 'Arroz', 'Quinoa', 'Patata', 'Brócoli', 'Espinacas', 'Tomate', 'Cebolla', 'Ajo', 'Pimiento', 'Zanahoria', 'Calabacín', 'Champiñón', 'Huevo', 'Harina de Trigo', 'Azúcar', 'Sal', 'Pimienta Negra', 'Pimentón Dulce', 'Orégano', 'Perejil Fresco' ]; function createMarkdownSteps(): string[] { const numSteps = faker.number.int({ min: 3, max: 6 }); return Array.from({ length: numSteps }, () => faker.lorem.sentence()); } const delay = (ms: number) => new Promise((res) => setTimeout(res, ms)); async function main() { await createUsers(); console.log('\n--- Limpiando datos antiguos (excepto usuarios)... ---'); await prisma.diaryEntry.deleteMany(); await prisma.recipeIngredient.deleteMany(); await prisma.recipeUrl.deleteMany(); await prisma.recipe.deleteMany(); await prisma.product.deleteMany(); console.log('✅ Datos antiguos limpiados.'); console.log('\n--- Fase 1: Poblando productos desde OpenFoodFacts... ---'); const offProducts = ( await Promise.all(SEARCH_TERMS_FOR_SEEDING.map(fetchAndCreateProduct)) ).filter((p): p is Product => p !== null); console.log(`✅ Fase 1 completada. ${offProducts.length} productos de OFF procesados.`); console.log('\n--- Fase 2: Creando productos base... ---'); const baseProducts: Product[] = []; for (const name of BASE_PRODUCTS) { const productName = name; const product = await prisma.product.create({ data: { name: productName, normalizedName: normalizeText(productName), calories: parseFloat(faker.number.float({ min: 50, max: 500, fractionDigits: 2 }).toFixed(2)), protein: parseFloat(faker.number.float({ min: 0, max: 30, fractionDigits: 2 }).toFixed(2)), fat: parseFloat(faker.number.float({ min: 0, max: 50, fractionDigits: 2 }).toFixed(2)), carbs: parseFloat(faker.number.float({ min: 0, max: 100, fractionDigits: 2 }).toFixed(2)) } }); baseProducts.push(product); } console.log(`✅ Fase 2 completada. ${baseProducts.length} productos base creados.`); console.log('\n--- Fase 3: Creando recetas de prueba... ---'); const allAvailableProducts = [...offProducts, ...baseProducts]; const usedSlugs = new Set<string>(); const adminUser = await prisma.user.findUnique({ where: { email: 'juanjocerero@gmail.com' } }); for (let i = 0; i < 50; i++) { const mainProduct = faker.helpers.arrayElement(allAvailableProducts); const recipeTitle = `${mainProduct.name} ${faker.food.adjective()}`; const baseSlug = slugify(recipeTitle, { lower: true, strict: true }); let finalSlug = baseSlug; let counter = 2; while (usedSlugs.has(finalSlug)) { finalSlug = `${baseSlug}-${counter++}`; } usedSlugs.add(finalSlug); const secondaryProducts = faker.helpers.arrayElements( allAvailableProducts.filter((p) => p.id !== mainProduct.id), faker.number.int({ min: 2, max: 5 }) ); const recipeProducts = [mainProduct, ...secondaryProducts]; console.log(`[RECETA ${i + 1}/50] Creando: "${recipeTitle}"...`); await prisma.recipe.create({ data: { title: recipeTitle, slug: finalSlug, normalizedTitle: normalizeText(recipeTitle), steps: createMarkdownSteps(), imageUrl: `https: urls: { create: [{ url: faker.internet.url() }] }, ingredients: { create: recipeProducts.map((p) => ({ productId: p.id, quantity: parseFloat(faker.number.float({ min: 50, max: 500, fractionDigits: 1 }).toFixed(1)) })) } } }); await delay(50); } console.log('✅ Fase 3 completada. 50 recetas creadas.'); console.log('\n--- Fase 4: Creando entradas de diario de prueba... ---'); if (adminUser) { const allRecipes = await prisma.recipe.findMany({ include: { ingredients: { include: { product: true } } } }); const allProducts = await prisma.product.findMany(); const diaryItems = [...allProducts.map(p => ({ ...p, type: 'PRODUCT' as const })), ...allRecipes.map(r => ({ ...r, type: 'RECIPE' as const }))]; for (let day = 3; day <= 10; day++) { const date = new Date(`2025-08-${String(day).padStart(2, '0')}`); const numEntries = faker.number.int({ min: 5, max: 10 }); const selectedItems = faker.helpers.arrayElements(diaryItems, numEntries); console.log(`[DIARIO] Creando ${numEntries} entradas para el ${date.toLocaleDateString('es-ES')}...`); for (const item of selectedItems) { const entryDate = new Date(date); entryDate.setHours(faker.number.int({ min: 8, max: 22 }), faker.number.int({ min: 0, max: 59 })); if (item.type === 'PRODUCT') { const quantity = faker.number.int({ min: 50, max: 250 }); await prisma.diaryEntry.create({ data: { userId: adminUser.id, date: entryDate, type: 'PRODUCT', name: item.name, quantity, calories: (item.calories / 100) * quantity, protein: (item.protein / 100) * quantity, fat: (item.fat / 100) * quantity, carbs: (item.carbs / 100) * quantity, baseProductId: item.id } }); } else { const recipeIngredients = item.ingredients.map(ing => ({ quantity: ing.quantity, ...ing.product })); const totals = calculateNutritionalInfo(recipeIngredients); const totalQuantity = recipeIngredients.reduce((sum, ing) => sum + ing.quantity, 0); const ingredientsJson = item.ingredients.map(ing => ({ id: ing.product.id, name: ing.product.name, quantity: ing.quantity, baseValues: { calories: ing.product.calories, protein: ing.product.protein, fat: ing.product.fat, carbs: ing.product.carbs } })); await prisma.diaryEntry.create({ data: { userId: adminUser.id, date: entryDate, type: 'RECIPE', name: item.title, quantity: totalQuantity, calories: totals.totalCalories, protein: totals.totalProtein, fat: totals.totalFat, carbs: totals.totalCarbs, ingredients: ingredientsJson, baseRecipeId: item.id } }); } } } console.log('✅ Fase 4 completada. Entradas de diario creadas.'); } } main() .catch((e) => { console.error(e); process.exit(1); }) .finally(async () => { await prisma.$disconnect(); console.log('\n🎉 ¡Seeding completado con éxito! La base de datos está lista para usar.'); });

// --- Ruta: prisma/schema.prisma ---
generator client { provider = "prisma-client-js" } datasource db { provider = "postgresql" url = env("DATABASE_URL") } model User { id String @id @default(cuid()) name String? email String? @unique image String? role String @default("user") emailVerified Boolean createdAt DateTime updatedAt DateTime sessions Session[] accounts Account[] @@map("user") } model Product { id String @id @default(cuid()) barcode String? @unique name String normalizedName String imageUrl String? calories Float fat Float protein Float carbs Float createdAt DateTime @default(now()) updatedAt DateTime @updatedAt recipeIngredients RecipeIngredient[] diaryEntries DiaryEntry[] @@index([normalizedName]) } model Recipe { id String @id @default(cuid()) title String slug String @unique normalizedTitle String steps Json imageUrl String? createdAt DateTime @default(now()) updatedAt DateTime @updatedAt ingredients RecipeIngredient[] urls RecipeUrl[] diaryEntries DiaryEntry[] @@index([normalizedTitle]) @@index([slug]) } model RecipeUrl { id String @id @default(cuid()) url String recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade) recipeId String @@unique([recipeId, url]) @@index([recipeId]) } model RecipeIngredient { id String @id @default(cuid()) recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade) recipeId String product Product @relation(fields: [productId], references: [id], onDelete: Cascade) productId String quantity Float @@index([recipeId]) @@index([productId]) } model DiaryEntry { id String @id @default(cuid()) date DateTime userId String? type String name String quantity Float calories Float protein Float fat Float carbs Float ingredients Json? baseProduct Product? @relation(fields: [baseProductId], references: [id], onDelete: SetNull) baseProductId String? baseRecipe Recipe? @relation(fields: [baseRecipeId], references: [id], onDelete: SetNull) baseRecipeId String? createdAt DateTime @default(now()) updatedAt DateTime @updatedAt @@index([userId]) @@index([date]) } model Session { id String @id @default(cuid()) expiresAt DateTime token String createdAt DateTime updatedAt DateTime ipAddress String? userAgent String? userId String user User @relation(fields: [userId], references: [id], onDelete: Cascade) @@unique([token]) @@map("session") } model Account { id String @id @default(cuid()) accountId String providerId String userId String user User @relation(fields: [userId], references: [id], onDelete: Cascade) accessToken String? refreshToken String? idToken String? accessTokenExpiresAt DateTime? refreshTokenExpiresAt DateTime? scope String? password String? createdAt DateTime updatedAt DateTime @@map("account") } model Verification { id String @id @default(cuid()) identifier String value String expiresAt DateTime createdAt DateTime? updatedAt DateTime? @@map("verification") }

// --- Ruta: diary/diary_tests.txt ---
### **Plan de Pruebas Manuales: Funcionalidad de Diario** **1. Verificación de la Vista Principal y Carga de Datos** * [X] **Acción:** Navega a la ruta `/diario`. * [X] **Resultado Esperado:** La página debe cargar sin errores. Deberías ver el título "Diario de Consumo", el selector de fecha (inicializado en la fecha actual), el panel "Añadir Elemento" y el panel de "Resumen Nutricional". La lista de entradas debe mostrar "No hay entradas para la fecha seleccionada", ya que el seed no crea entradas para el día de hoy. **2. Verificación del Selector de Fecha y Datos de Prueba** * [X] **Acción:** Haz clic en el selector de fecha y elige un rango entre el 3 y el 10 de agosto de 2025. * [X] **Resultado Esperado:** La lista de "Entradas del Periodo" debería llenarse con los datos generados por el script de seeding. El "Resumen Nutricional" debería actualizarse y mostrar los totales y promedios para el rango seleccionado. El número de días en el título del resumen debe coincidir con los días que tienen entradas. **3. Funcionalidad de Añadir un Producto** * [X] **Acción:** En el panel "Añadir Elemento", despliégalo y busca un producto existente (ej. "Atún"). * [X] **Acción:** Haz clic en el producto desde los resultados. * [X] **Resultado Esperado:** El producto debería aparecer inmediatamente en la lista de entradas del día actual (con una cantidad por defecto de 100g). El "Resumen Nutricional" debería actualizarse para reflejar los valores del nuevo producto. **4. Funcionalidad de Añadir una Receta** * [X] **Acción:** En el panel "Añadir Elemento", busca una receta (puedes usar un término genérico como "Pollo" o "Arroz"). * [X] **Acción:** Haz clic en la receta desde los resultados. * [X] **Resultado Esperado:** La receta debería aparecer en la lista de entradas del día actual. Sus valores nutricionales y cantidad total deberían haberse calculado correctamente. El "Resumen Nutricional" debe actualizarse. **5. Funcionalidad de Editar una Entrada (Producto)** * [X] **Acción:** En la entrada del producto que acabas de añadir, haz clic en el icono del lápiz (Editar). * [X] **Acción:** En el diálogo que aparece, cambia la cantidad (ej. de 100 a 150) y haz clic en "Guardar Cambios". * [X] **Resultado Esperado:** El diálogo debe cerrarse. La cantidad y los valores nutricionales de la entrada en la lista deben actualizarse para reflejar el cambio. El "Resumen Nutricional" general también debe actualizarse. **6. Funcionalidad de Editar una Entrada (Receta)** * [X] **Acción:** En la entrada de la receta que añadiste, haz clic en el icono de Editar. * [X] **Acción:** En el diálogo, cambia la cantidad de uno de sus ingredientes y haz clic en "Guardar Cambios". * [X] **Resultado Esperado:** El diálogo debe cerrarse. Los valores nutricionales de la entrada de la receta en la lista deben recalcularse y actualizarse. El "Resumen Nutricional" general también debe cambiar. **7. Funcionalidad de Eliminar una Entrada** * [X] **Acción:** En cualquier entrada, haz clic en el icono de la papelera (Eliminar). * [X] **Acción:** Confirma la eliminación en el diálogo del navegador. * [X] **Resultado Esperado:** La entrada debe desaparecer de la lista. El "Resumen Nutricional" debe actualizarse para reflejar la eliminación. **8. Verificación de la Búsqueda Avanzada (Refactorización)** * [X] **Acción:** Navega a `/recetas/busqueda-avanzada`. * [X] **Resultado Esperado:** La página debe funcionar correctamente. Los paneles de "Filtros" y "Ordenar por" deben ser desplegables y mantener su funcionalidad, confirmando que la refactorización para eliminar `CollapsiblePanel` fue exitosa.

// --- Ruta: diary/diary_plan.txt ---
# Plan de Implementación: Funcionalidad de Diario Este plan detalla los pasos para implementar la funcionalidad de seguimiento de consumo diario ("Diario") en la aplicación. ## Hito 1: Backend y Base de Datos **Objetivo:** Establecer el modelo de datos, las rutas de API y la lógica de negocio necesarios para gestionar las entradas del diario. * **Paso 1.1: Modificar el Esquema de la Base de Datos** * **Qué:** Añadir el nuevo modelo `DiaryEntry` al fichero `prisma/schema.prisma` según la propuesta de diseño. Se incluirán campos para `id`, `date`, `userId`, `type`, `name`, `quantity`, valores nutricionales (`calories`, `protein`, `fat`, `carbs`), un campo `Json` para `ingredients`, y las relaciones opcionales `baseProductId` y `baseRecipeId`. El campo userId será opcional de momento, ya que solo hay un usuario en la aplicación. La funcionalidad de gestión de usuarios se implementará más tarde. * **Por qué:** Es la base sobre la que se construirá toda la funcionalidad. El esquema propuesto garantiza la integridad de los datos históricos y permite la edición independiente de las entradas. * **Verificación:** Detenerse y revisar que el modelo se ha añadido correctamente y que se han establecido todas las claves y optimizaciones necesarias para asegurar el rendimiento de la aplicación en PostgreSQL. * **Paso 1.2: Aplicar la Migración de la Base de Datos** * **Qué:** Ejecutar `npx prisma migrate dev --name add-diary-entries` en la terminal. * **Por qué:** Este comando actualiza la base de datos PostgreSQL para que coincida con el nuevo esquema de Prisma, creando la tabla `DiaryEntry` y sus columnas. * **Verificación:** Detenerse y asegurarse de que se ha creado correctamente. * **Paso 1.3: Crear Servicios de Lógica de Negocio** * **Qué:** Crear un nuevo fichero `src/lib/server/services/diaryService.ts`. Este servicio contendrá funciones para: 1. `getDiaryEntries(userId, startDate, endDate)`: Obtener entradas para un rango de fechas. 2. `addDiaryEntry(userId, entryData)`: Añadir una nueva entrada (producto o receta). 3. `updateDiaryEntry(entryId, updates)`: Modificar una entrada existente (ej. cantidad o ingredientes JSON). 4. `deleteDiaryEntry(entryId)`: Eliminar una entrada. 5. `getAggregatedNutrients(entries)`: Calcular totales y promedios a partir de una lista de entradas. * **Por qué:** Centraliza toda la lógica de interacción con la base de datos, manteniendo los endpoints limpios y siguiendo la arquitectura existente (`recipeService.ts`, `productService.ts`). * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 1.4: Crear Endpoints de la API** * **Qué:** Crear los ficheros necesarios bajo una nueva ruta `src/routes/api/diary/`. * `[...date]/+server.ts`: Un endpoint que gestionará `GET` para obtener entradas por día o rango de fechas. * `+server.ts`: Gestionará `POST` para crear nuevas entradas. * `[id]/+server.ts`: Gestionará `PUT` para actualizar y `DELETE` para eliminar entradas. * **Por qué:** Proporciona la interfaz necesaria para que el frontend pueda interactuar con el backend de forma segura y estructurada. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 1.5: Crear Endpoint de Búsqueda Unificada** * **Qué:** Crear un nuevo endpoint en `src/routes/api/search/all/+server.ts`. Este endpoint aceptará un término de búsqueda (`q`) y devolverá una lista combinada de `Product` y `Recipe` que coincidan, añadiendo un campo `type` a cada resultado. * **Por qué:** Es un requisito clave para el buscador "Añadir elementos", que debe buscar en ambas tablas simultáneamente. * **Verificación:** Detenerse y dar al usuario instrucciones para hacer curls de prueba a este endpoint y asegurarse de que los resultados se muestran correctamente en la consola de desarrollo. Esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. ## Hito 2: Interfaz de Usuario - Vista Principal del Diario **Objetivo:** Construir la interfaz principal donde el usuario visualizará y gestionará su diario. * **Paso 2.1: Crear la Ruta y Página Principal del Diario** * **Qué:** Crear la estructura de ficheros para la nueva ruta: `src/routes/diario/+page.svelte` y `src/routes/diario/+page.server.ts`. * **Por qué:** Establece el nuevo apartado "Diario" en la aplicación. El `+page.server.ts` cargará los datos iniciales para el día actual. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 2.2: Implementar el Selector de Fecha** * **Qué:** Añadir un componente de calendario de `shadcn-svelte` en `+page.svelte`. Se configurará para permitir la selección de un rango de fechas. El estado del rango seleccionado (`startDate`, `endDate`) será reactivo. * **Por qué:** Permite al usuario navegar entre días y seleccionar rangos para la vista semanal, cumpliendo ambos requisitos con un solo componente. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 2.3: Crear el Panel de Resumen Nutricional** * **Qué:** Crear un componente `src/lib/components/diary/NutritionalSummary.svelte`. Este componente recibirá los datos nutricionales totales y medios y los mostrará, reutilizando el `MacroBar.svelte` existente. * **Por qué:** Presenta la información clave de un vistazo. Se dividirá en dos secciones: "Totales del Periodo" y "Promedio Diario" (este último solo visible si el rango es > 1 día). * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 2.4: Crear la Lista de Entradas del Diario** * **Qué:** Crear un componente `src/lib/components/diary/DiaryEntryList.svelte`. Este componente recibirá la lista de entradas del día/periodo y las renderizará. Cada fila mostrará el nombre, calorías, una `MacroBar` y botones de acción (editar, eliminar). * **Por qué:** Es el núcleo de la vista, mostrando los alimentos consumidos de forma clara y ordenada. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. ## Hito 3: Añadir y Editar Entradas **Objetivo:** Implementar la funcionalidad interactiva para que los usuarios puedan poblar y modificar su diario. * **Paso 3.1: Refactorizar el Diálogo de Edición de Cantidades** * **Qué:** Modificar `src/lib/components/recipes/EditQuantitiesDialog.svelte` para que sea más genérico. Se llamará `EditEntryDialog.svelte` y podrá manejar tanto la edición de cantidad de un producto como la edición de la lista de ingredientes de una receta (que se pasará como el objeto JSON). * **Por qué:** Reutiliza la lógica de UI existente como se solicitó, adaptándola para que funcione con el nuevo modelo de `DiaryEntry` y su campo `ingredients`. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 3.2: Crear el Componente "Añadir Elemento"** * **Qué:** Crear `src/lib/components/diary/AddItemPanel.svelte`. Este componente contendrá un `Collapsible` de `shadcn-svelte`. Dentro, habrá un campo de búsqueda que llame al endpoint de búsqueda unificada (`/api/search/all`). * **Por qué:** Proporciona la interfaz para que los usuarios busquen y añadan nuevos elementos a su diario. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 3.3: Implementar la Lógica de Adición** * **Qué:** Cuando un usuario seleccione un ítem de los resultados de búsqueda, se llamará al `diaryService` para crear la `DiaryEntry` correspondiente. Si es una receta, se copiarán sus ingredientes al campo JSON. La UI se actualizará reactivamente para mostrar la nueva entrada en la lista. * **Por qué:** Completa el flujo de añadir un nuevo alimento al diario. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 3.4: Implementar la Lógica de Eliminación y Edición** * **Qué:** Conectar los botones de la `DiaryEntryList` a las funciones correspondientes. El botón de eliminar llamará al endpoint `DELETE /api/diary/[id]`. El botón de editar abrirá el `EditEntryDialog.svelte` refactorizado. * **Por qué:** Permite al usuario gestionar las entradas de su diario, corrigiendo errores o ajustando cantidades. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. ## Hito 4: Poblar la Base de Datos con Datos de Prueba (Seeding) **Objetivo:** Generar datos de prueba realistas para verificar la funcionalidad completa. * **Paso 4.1: Modificar el Script de Seeding** * **Qué:** Añadir una nueva fase al final del fichero `prisma/seed.ts`. * **Por qué:** Asegura que los datos del diario se creen después de que ya existan los productos y recetas necesarios. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. * **Paso 4.2: Implementar la Lógica de Creación de Diarios** * **Qué:** 1. Limpiar la tabla `DiaryEntry` al inicio del script. 2. Definir un `userId` de prueba (ej. `test-user@example.com`). 3. Iterar sobre los días del 3 al 10 de agosto de 2025. 4. Para cada día, seleccionar aleatoriamente entre 5 y 10 elementos (mezcla de `Product` y `Recipe`) de los ya creados. 5. Para cada elemento, crear una `DiaryEntry`, asignando una hora aleatoria dentro de ese día. 6. Si el elemento es una receta, copiar su estructura de ingredientes y cantidades al campo `ingredients` de la `DiaryEntry`. 7. Calcular y almacenar los valores nutricionales en la propia entrada. * **Por qué:** Crea un conjunto de datos completo y realista que permite probar la vista de día, la vista de semana, los cálculos de totales y promedios, y la ordenación cronológica. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar. ## Hito 5: Diseñar un plan de pruebas manual para el usuario **Objetivo:** Aseguarse de que la implementación es completa y correcta antes de dar por finalizado el trabajo. * **Paso 5.1: Diseñar un plan de pruebas* * **Qué:** Crear un plan de pruebas manuales para asegurarse de que todas las vistas, endpoints y funcionalidades de la nueva implementación se han realizado correctamente. Comunicar el plan al usuario dividido en pasos atómicos relativos a cada funcionalidad individual. * **Por qué:** Asegura que todo el trabajo es correcto antes de darlo por finalizado. * **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores. ## Otras consideraciones importantes: Contexto y ficheros de código de la base de datos ya existentes para tener como referencia o guía de diseño: 1. El esquema de la base de datos: `@prisma/schema.prisma` 2. El diálogo de edición de cantidades de una receta: `@src/lib/components/recipes/RecipeCard.svelte` 3. La barra de distribución de macronutrientes: `@src/lib/components/shared/MacroBar.svelte` 4. Vista de ejemplo de grid de recetas para inspirarte en el diseño: `@src/routes/+page.svelte` 5. Vista de ejemplo de lista de productos para inspirarte en el diseño: `@src/lib/components/admin/ProductsDesktopView.svelte y src/lib/components/admin/ProductsMobileView.svelte` 6. Vista de creación y edición de nuevas recetas: `@src/lib/components/recipes/RecipeForm.svelte` 7. Vista de edición de productos: `@src/lib/components/admin/OFFProductDialog.svelte` 8. Vista de edición de cantidades: `@src/lib/components/recipes/EditQuantitiesDialog.svelte` Si tienes alguna duda o necesitas aclarar aspectos o tener acceso a otras partes de la base de código, dímelo antes de continuar.

// --- Ruta: diary/diary_changes.txt ---
# Resumen de Cambios: Implementación de la Funcionalidad de Diario Este documento detalla el proceso de implementación de la funcionalidad de "Diario", incluyendo las decisiones de diseño, las correcciones realizadas y una lista completa de los ficheros afectados. ## Razonamiento General El objetivo era construir una sección de diario de consumo siguiendo un plan predefinido. La implementación se dividió en hitos, comenzando por el backend (base de datos y API) y avanzando hacia la interfaz de usuario (componentes de Svelte) y la generación de datos de prueba (seeding). A lo largo del proceso, se priorizó la reutilización de componentes existentes, el seguimiento de la arquitectura del proyecto y la corrección de errores de tipado y patrones de código para asegurar una solución robusta y mantenible. --- ## Hito 1: Backend y Base de Datos ### 1.1. Modelo de Base de Datos (`prisma/schema.prisma`) * **Qué se hizo:** Se añadió el modelo `DiaryEntry` al esquema de Prisma. Este modelo incluye campos para la fecha, tipo de entrada (producto/receta), valores nutricionales y relaciones opcionales con los modelos `Product` y `Recipe`. * **Razonamiento:** Este fue el primer paso fundamental para crear la estructura de datos necesaria. El diseño del modelo permite almacenar una "instantánea" de los datos nutricionales en el momento del registro, asegurando que los informes históricos no cambien si se modifica una receta o producto base. ### 1.2. Migración y Servicios (`diaryService.ts`) * **Qué se hizo:** Se ejecutó la migración de la base de datos y se creó el fichero `src/lib/server/services/diaryService.ts`. * **Razonamiento:** Siguiendo la arquitectura existente, se centralizó toda la lógica de negocio relacionada con el diario en un único servicio. Esto mantiene los endpoints de la API limpios y la lógica de base de datos desacoplada. ### 1.3. Endpoints de la API (`src/routes/api/...`) * **Qué se hizo:** Se crearon los endpoints para `GET` (por fecha), `POST` (crear), `PUT` (actualizar) y `DELETE` (eliminar) entradas del diario. También se creó un endpoint de búsqueda unificada (`/api/search/all`) que combina resultados de productos y recetas. * **Razonamiento:** Estos endpoints proporcionan la interfaz necesaria para que el frontend interactúe con el backend. La búsqueda unificada fue un requisito clave para el panel "Añadir Elemento", simplificando la lógica en el cliente. * **Corrección:** Inicialmente, el endpoint de búsqueda no funcionaba porque estaba protegido por el hook de autenticación en `src/hooks.server.ts`. Se modificó el hook para añadir una excepción a esta ruta, permitiendo el acceso público. ### 1.4. Extracción de Tipos (`src/lib/models/recipe.ts`) * **Qué se hizo:** Se creó un nuevo fichero de modelo para extraer la definición del tipo `FullRecipe`. * **Razonamiento:** Se detectó un error de arquitectura al intentar importar un tipo definido en un módulo de servidor (`recipeService.ts`) desde un componente de cliente. La solución correcta fue mover la definición del tipo a un fichero compartido en `$lib/models`, respetando la separación entre cliente y servidor de SvelteKit y creando una fuente única de verdad para el tipo. --- ## Hito 2: Interfaz de Usuario - Vista Principal ### 2.1. Página del Diario (`src/routes/diario/...`) * **Qué se hizo:** Se crearon los ficheros `+page.svelte` y `+page.server.ts` para la nueva ruta `/diario`. * **Razonamiento:** Esto estableció la nueva sección en la aplicación. El `page.server.ts` se encarga de la carga inicial de datos para el día actual. ### 2.2. Selector de Fecha y Componentes UI * **Qué se hizo:** Se implementó un selector de rango de fechas usando `Popover` y `RangeCalendar`. * **Razonamiento:** Proporciona la navegación principal de la página. * **Corrección:** Se cometieron varios errores durante este paso que fueron corregidos gracias a las indicaciones: 1. **Patrones Obsoletos:** Inicialmente se usaron patrones anticuados de `shadcn-svelte` (`asChild`, `let:builder`). Se corrigió para usar la composición directa de componentes, aplicando estilos al `Popover.Trigger`. 2. **Componente Incorrecto:** Se usó `<Calendar>` en lugar de `<RangeCalendar>`, lo que causaba un error de tipos. Se reemplazó por el componente correcto para la selección de rangos. ### 2.3. Lógica de Cálculo (`src/lib/utils.ts`) * **Qué se hizo:** Se creó el componente `NutritionalSummary.svelte` y se centralizó la lógica de cálculo de nutrientes en una nueva función `calculateAggregatedNutrients` dentro de `src/lib/utils.ts`. * **Razonamiento:** Inicialmente, la lógica de cálculo se duplicó en el servidor y el cliente. Para evitar esta redundancia y mejorar el mantenimiento, se extrajo a un fichero de utilidades compartido, accesible desde ambos entornos. Además, se refinó la lógica para que el promedio se calcule solo sobre los días que contienen entradas. ### 2.4. Lista de Entradas (`DiaryEntryList.svelte`) * **Qué se hizo:** Se creó un componente dedicado para renderizar la lista de entradas del diario, mostrando detalles y botones de acción. * **Razonamiento:** Separa la responsabilidad de la visualización de la lista de la lógica principal de la página, haciendo el código más modular. --- ## Hito 3: Añadir y Editar Entradas ### 3.1. Diálogo de Edición (`EditEntryDialog.svelte`) * **Qué se hizo:** Se creó un nuevo diálogo genérico para editar tanto productos como recetas dentro del diario. * **Razonamiento:** Aunque el plan inicial sugería refactorizar un diálogo existente, se optó por crear uno nuevo para no interferir con la funcionalidad ya existente en otras partes de la aplicación (la edición de cantidades de recetas en la página principal). Este nuevo diálogo está específicamente diseñado para trabajar con el modelo `DiaryEntry`. ### 3.2. Panel de Adición (`AddItemPanel.svelte`) * **Qué se hizo:** Se creó el panel desplegable con una barra de búsqueda que consume el endpoint `/api/search/all`. * **Razonamiento:** Proporciona la UI principal para añadir nuevos elementos al diario. * **Corrección:** Se volvió a usar un patrón obsoleto de `Collapsible`, que fue corregido para usar la composición de componentes adecuada. ### 3.3. Lógica de Adición y Eliminación * **Qué se hizo:** Se implementó la lógica en la página `/diario` para manejar la creación de nuevas entradas a través de la API. También se implementó la lógica de eliminación en el componente `DiaryEntryList`. * **Razonamiento:** Conecta la interfaz de usuario con el backend, completando el ciclo de vida de la gestión de entradas. ### 3.4. Correcciones de Tipado en el Backend * **Qué se hizo:** Se corrigieron varios errores de tipado en `diaryService.ts`. * **Razonamiento:** Los errores se debían a un manejo incorrecto de los tipos de Prisma, especialmente con valores nulos en campos JSON y la importación de `Prisma` como tipo en lugar de como valor. Se corrigió la importación a `import { Prisma, type DiaryEntry } ...` y se usó `Prisma.JsonNull` para asegurar la compatibilidad con la base de datos. --- ## Hito 4: Seeding de Datos ### 4.1. Script de Seeding (`prisma/seed.ts`) * **Qué se hizo:** Se añadió una nueva fase al script de seeding para poblar la tabla `DiaryEntry` con datos realistas para un rango de fechas. * **Razonamiento:** Es crucial para poder probar la funcionalidad de la interfaz de usuario de manera efectiva sin tener que introducir todos los datos manualmente. * **Corrección:** El script inicial tenía errores de tipado porque no distinguía correctamente entre los objetos de tipo `Product` y `Recipe`. Se solucionó usando una **unión discriminada** basada en el campo `type`, lo que permite a TypeScript inferir el tipo correcto dentro de cada bloque condicional. --- ## Lista de Ficheros Creados o Modificados ### Ficheros Creados: - `src/lib/server/services/diaryService.ts` - `src/routes/api/diary/+server.ts` - `src/routes/api/diary/[id]/+server.ts` - `src/routes/api/diary/[...date]/+server.ts` - `src/routes/api/search/all/+server.ts` - `src/routes/diario/+page.server.ts` - `src/routes/diario/+page.svelte` - `src/lib/components/diary/NutritionalSummary.svelte` - `src/lib/components/diary/DiaryEntryList.svelte` - `src/lib/components/diary/EditEntryDialog.svelte` - `src/lib/components/diary/AddItemPanel.svelte` - `src/lib/models/recipe.ts` - `src/lib/schemas/diarySchema.ts` - `diary_changes.txt` ### Ficheros Modificados: - `prisma/schema.prisma` - `src/hooks.server.ts` - `src/lib/utils.ts` - `src/lib/server/services/recipeService.ts` - `src/routes/recetas/busqueda-avanzada/+page.svelte` - `prisma/seed.ts`

// --- Ruta: betterauth/betterauth_tests.txt ---
# Plan de Pruebas Funcionales: Implementación de Better Auth Este documento detalla los casos de prueba para validar la correcta implementación del sistema de autenticación con Better Auth. --- ### Test Suite 1: Acceso Público y Protección de Rutas **Objetivo:** Verificar que las rutas públicas son accesibles y las protegidas redirigen correctamente. * **Test Case 1.1: Acceso a rutas públicas sin autenticación.** * **Precondiciones:** No hay ninguna sesión de usuario activa (navegador en modo incógnito o después de cerrar sesión). * **Pasos:** 1. Navegar a la página de inicio (`/`). 2. Navegar a la página de búsqueda avanzada (`/recetas/busqueda-avanzada`). 3. Navegar a la página de login (`/login`). 4. Navegar a la página de registro (`/signup`). * **Resultado Esperado:** Todas las páginas se cargan correctamente sin redirecciones. * **Test Case 1.2: Intento de acceso a ruta protegida sin autenticación.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Intentar navegar directamente a la ruta del diario (`/diario`). * **Resultado Esperado:** 1. El sistema redirige automáticamente al usuario a la página de login (`/login`). 2. La URL final es `/login?redirectTo=/diario`. * **Test Case 1.3: Intento de acceso a ruta de administrador sin autenticación.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Intentar navegar directamente a la ruta de administración de productos (`/admin/products`). * **Resultado Esperado:** 1. El sistema redirige al usuario a `/login`. 2. La URL final es `/login?redirectTo=/admin/products`. --- ### Test Suite 2: Registro de Usuario (Sign Up) **Objetivo:** Validar el flujo de creación de nuevas cuentas. * **Test Case 2.1: Registro exitoso con datos válidos.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Navegar a la página de registro (`/signup`). 2. Rellenar el formulario con un nombre, un email **nuevo** (ej. `testuser@example.com`) y una contraseña válida (mínimo 8 caracteres). 3. Enviar el formulario. * **Resultado Esperado:** 1. Se muestra una notificación de éxito. 2. El usuario es redirigido a la página de inicio (`/`). 3. El menú de navegación ahora muestra las opciones para un usuario autenticado (Diario, Cerrar Sesión). * **Test Case 2.2: Intento de registro con un email ya existente.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Navegar a `/signup`. 2. Rellenar el formulario usando el email de un usuario ya existente (ej. `ana.14mp@hotmail.com`). 3. Enviar el formulario. * **Resultado Esperado:** 1. El formulario muestra un mensaje de error específico indicando que el email ya está en uso. 2. El usuario no es redirigido y permanece en la página de registro. * **Test Case 2.3: Intento de registro con contraseña inválida.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Navegar a `/signup`. 2. Rellenar el formulario con datos válidos pero una contraseña corta (ej. `123`). 3. Enviar el formulario. * **Resultado Esperado:** 1. El formulario muestra un mensaje de error indicando que la contraseña no cumple los requisitos de longitud. 2. El usuario no es redirigido. --- ### Test Suite 3: Inicio de Sesión (Login) **Objetivo:** Validar el flujo de autenticación de usuarios existentes. * **Test Case 3.1: Login fallido con credenciales incorrectas.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Navegar a `/login`. 2. Introducir un email válido (`ana.14mp@hotmail.com`) y una contraseña **incorrecta**. 3. Enviar el formulario. * **Resultado Esperado:** 1. Se muestra un mensaje de error de "Credenciales inválidas". 2. El usuario permanece en la página de login. * **Test Case 3.2: Login exitoso de usuario estándar.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Navegar a `/login`. 2. Introducir las credenciales del usuario estándar: * Email: `ana.14mp@hotmail.com` * Contraseña: `user1234` 3. Enviar el formulario. * **Resultado Esperado:** 1. Se muestra una notificación de bienvenida. 2. El usuario es redirigido a la página de inicio (`/`). 3. El menú de navegación **no** muestra el botón de "Administrar productos". * **Test Case 3.3: Login exitoso de usuario administrador.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Navegar a `/login`. 2. Introducir las credenciales del administrador: * Email: `juanjocerero@gmail.com` * Contraseña: `admin1234` 3. Enviar el formulario. * **Resultado Esperado:** 1. Se muestra una notificación de bienvenida. 2. El usuario es redirigido a la página de inicio (`/`). 3. El menú de navegación **sí** muestra el botón de "Administrar productos". * **Test Case 3.4: Login exitoso con redirección a ruta previa.** * **Precondiciones:** No hay ninguna sesión de usuario activa. * **Pasos:** 1. Navegar directamente a `/diario`. El sistema redirige a `/login?redirectTo=/diario`. 2. Iniciar sesión con cualquier usuario válido. * **Resultado Esperado:** 1. Tras el login exitoso, el usuario es redirigido a `/diario`, no a la página de inicio. --- ### Test Suite 4: Cierre de Sesión (Logout) **Objetivo:** Validar que la sesión del usuario se termina correctamente. * **Test Case 4.1: Cierre de sesión exitoso.** * **Precondiciones:** Un usuario está autenticado. * **Pasos:** 1. Abrir el menú de navegación. 2. Hacer clic en el botón "Cerrar Sesión". * **Resultado Esperado:** 1. Se muestra una notificación de "Sesión cerrada". 2. El menú de navegación se actualiza para mostrar el botón de "Iniciar Sesión". 3. Si se intenta acceder a una ruta protegida (ej. `/diario`), se redirige al login.

// --- Ruta: betterauth/betterauth_plan.txt ---
# Plan de Implementación: Migración a Better Auth Este plan detalla el proceso paso a paso para migrar el sistema de autenticación de la aplicación a Better Auth, reemplazando la implementación existente. El plan está optimizado para ser ejecutado por un agente de IA, con hitos claros y pasos atómicos. --- ### Hito 1: Preparación del Entorno y Dependencias **Objetivo:** Configurar el espacio de trabajo y añadir las nuevas librerías necesarias. * **Paso 1.1: Crear una nueva rama de Git.** * **Acción:** Ejecutar el comando `git checkout -b feat/better-auth-migration`. * **Justificación:** Se aísla el desarrollo de la migración en una rama dedicada para no afectar la rama principal (`main`) hasta que la implementación sea estable y verificada. * **Verificación:** Detenerse y confirmar que la rama activa es `feat/better-auth-migration` usando `git branch`. * **Paso 1.2: Instalar dependencias.** * **Acción:** Ejecutar `npm install better-auth` y `npm install -D @better-auth/cli`. * **Justificación:** Se añade la librería principal de Better Auth al proyecto y su herramienta de línea de comandos (CLI) como una dependencia de desarrollo. El CLI es necesario para generar el esquema de la base de datos. * **Verificación:** Detenerse y revisar que `package.json` contiene las nuevas dependencias en las secciones `dependencies` y `devDependencies`. --- ### Hito 2: Configuración del Esquema de Base de Datos **Objetivo:** Adaptar el esquema de la base de datos a los requerimientos de Better Auth y añadir el sistema de roles. * **Paso 2.1: Modificar el esquema de Prisma.** * **Acción:** Editar el fichero `prisma/schema.prisma`. 1. Añadir un `enum Role` para definir los roles de usuario. 2. Eliminar los modelos `Key` y `Session` existentes (probablemente de Lucia). 3. Modificar el modelo `User` para que se ajuste a Better Auth, eliminando campos y añadiendo el campo `role`. 4. Añadir los nuevos modelos `Session` y `VerificationToken` que requiere Better Auth. * **Justificación:** Se actualiza la estructura de la base de datos para que sea compatible con Better Auth. El `enum Role` formaliza el sistema de permisos requerido. * **Verificación:** Detenerse y revisar el fichero `prisma/schema.prisma` para asegurar que los cambios son sintácticamente correctos y reflejan los modelos de Better Auth. * **Paso 2.2: Generar y aplicar la migración de la base de datos.** * **Acción:** Ejecutar `npx prisma migrate dev --name better-auth-migration`. * **Justificación:** Este comando genera un nuevo fichero de migración SQL basado en los cambios del `schema.prisma` y lo aplica a la base de datos de desarrollo, actualizando su estructura. * **Verificación:** Detenerse y confirmar que el comando se ha ejecutado sin errores y que se ha creado una nueva carpeta de migración en `prisma/migrations`. --- ### Hito 3: Actualización del Script de Seeding **Objetivo:** Poblar la base de datos con usuarios de prueba, incluyendo el administrador y un usuario estándar. * **Paso 3.1: Modificar el script de seeding.** * **Acción:** Editar el fichero `prisma/seed.ts`. 1. Al principio del script, añadir la limpieza de las tablas de usuarios y sesiones: `await prisma.user.deleteMany(); await prisma.session.deleteMany();`. 2. Importar `hashPassword` de `better-auth/password`. 3. Añadir la lógica para crear dos usuarios: * Un usuario `ADMIN` con email `juanjocerero@gmail.com`. * Un usuario `USER` con email `ana.14mp@hotmail.com`. 4. Asignar contraseñas seguras pero conocidas para el entorno de desarrollo y hashearlas con `hashPassword` antes de guardarlas. * **Justificación:** Se asegura que la base de datos de desarrollo siempre tenga los usuarios necesarios para las pruebas funcionales y de permisos, con contraseñas seguras. * **Verificación:** Detenerse y ejecutar `npx prisma db seed`. Confirmar que el script se ejecuta sin errores y que los nuevos usuarios se han creado en la base de datos. Informa al usuario de cuáles son las contraseñas creadas para cada uno de los usuarios. --- ### Hito 4: Implementación del Backend de Autenticación **Objetivo:** Configurar y poner en marcha la lógica de servidor de Better Auth. * **Paso 4.1: Configurar variables de entorno.** * **Acción:** Editar el fichero `.env.example` y añadir las siguientes variables: `BETTER_AUTH_SECRET=""` y `BETTER_AUTH_URL="http: * **Justificación:** Better Auth requiere un secreto para firmar tokens y una URL base para construir las URLs de callback. * **Verificación:** Detenerse y asegurarse de que las variables están presentes en `.env.example` y configuradas en el fichero `.env` local. * **Paso 4.2: Crear el fichero de configuración de Better Auth.** * **Acción:** Crear un nuevo fichero en `src/lib/server/auth.ts` o modificar el ya existente. En este fichero, se configurará la instancia de Better Auth usando el adaptador de Prisma (`prismaAdapter`) y se habilitará el proveedor de `emailAndPassword`. * **Justificación:** Centraliza toda la configuración de autenticación del lado del servidor en un único módulo, siguiendo las mejores prácticas. * **Verificación:** Detenerse y revisar que el fichero `src/lib/server/auth.ts` se ha creado y exporta correctamente la instancia `auth`. * **Paso 4.3: Actualizar los hooks del servidor de SvelteKit.** * **Acción:** Editar el fichero `src/hooks.server.ts`. Reemplazar el manejador de autenticación existente por el `svelteKitHandler` de Better Auth. * **Justificación:** Este es el punto de entrada principal para que Better Auth intercepte, gestione y procese todas las peticiones relacionadas con la autenticación (`/api/auth/*`). * **Verificación:** Detenerse y revisar que el `handle` en `src/hooks.server.ts` utiliza `svelteKitHandler` y que la aplicación sigue compilando y ejecutándose. * **Paso 4.4: Crear el cliente de autenticación.** * **Acción:** Crear un nuevo fichero en `src/lib/auth-client.ts`. En él, se importará `createAuthClient` desde `better-auth/svelte` y se exportará una instancia del cliente. * **Justificación:** Proporciona un cliente de autenticación tipado y fácil de usar en el frontend para realizar acciones como `signIn`, `signUp` y `signOut`. * **Verificación:** Detenerse y comprobar que el fichero `src/lib/auth-client.ts` existe y exporta la instancia del cliente. --- ### Hito 5: Implementación y Refactorización del Frontend **Objetivo:** Adaptar las páginas de login, registro y el layout principal para que usen Better Auth. * **Paso 5.1: Refactorizar la página de login.** * **Acción:** Editar el fichero `src/routes/login/+page.svelte`. Modificar el formulario para que, en lugar de enviar a una `form action`, llame al método `authClient.signIn.email(...)` importado desde `src/lib/auth-client.ts`. Eliminar el `+page.server.ts` si ya no es necesario. * **Justificación:** Se desacopla la lógica de la UI de las `form actions` del servidor y se utiliza el flujo de cliente que proporciona Better Auth, que se comunica con los endpoints `/api/auth/*`. * **Verificación:** Detenerse, iniciar la aplicación y probar a iniciar sesión con el usuario de prueba. Comprobar las peticiones de red en el navegador para ver la llamada a `/api/auth/email/signin`. * **Paso 5.2: Crear la página de registro.** * **Acción:** Crear los ficheros `src/routes/signup/+page.svelte` y, si es necesario, `+page.server.ts`. El Svelte component contendrá un formulario similar al de login, pero llamará a `authClient.signUp.email(...)`. Pedir al usuario un ejemplo de código de una página o componente similar para usar el diseño como guía de implementación. Por defecto, simular la vista de login. * **Justificación:** Se proporciona a los nuevos usuarios una forma de registrarse en la aplicación. * **Verificación:** Detenerse y probar el flujo de registro creando un nuevo usuario. * **Paso 5.3: Actualizar el layout principal.** * **Acción:** 1. Editar `src/routes/+layout.server.ts` para que cargue la sesión del usuario usando `await auth.api.getSession(...)` en lugar del método anterior. 2. Editar `src/routes/+layout.svelte` para que consuma los nuevos datos de la sesión y para que el botón de "Cerrar Sesión" llame a `authClient.signOut()`. * **Justificación:** Se asegura que el estado de autenticación del usuario se refleje correctamente en toda la aplicación y que la funcionalidad de cerrar sesión funcione como se espera. * **Verificación:** Detenerse y navegar por la aplicación como un usuario autenticado y como un invitado. Confirmar que la UI se actualiza correctamente y que el botón de logout funciona. --- ### Hito 6: Limpieza y Verificación Final **Objetivo:** Eliminar el código obsoleto y realizar una comprobación final completa. * **Paso 6.1: Eliminar código de autenticación antiguo.** * **Acción:** Buscar y eliminar cualquier fichero o fragmento de código relacionado con la implementación anterior que ya no se utilice. Esto incluye ficheros de configuración, adaptadores o utilidades. * **Justificación:** Mantiene la base de código limpia, legible y libre de código muerto. * **Verificación:** Detenerse y realizar una búsqueda global de elementos relacionados para asegurar que todo ha sido eliminado. * **Paso 6.2: Realizar pruebas funcionales completas.** * **Acción: Pedir al usuario:** 1. Iniciar la aplicación desde cero. 2. Registrar un nuevo usuario. 3. Cerrar sesión. 4. Iniciar sesión con el usuario `ana.14mp@hotmail.com`. 5. Iniciar sesión con el usuario administrador `juanjocerero@gmail.com`. 6. Verificar que los roles se asignan y se pueden leer correctamente. 7. Intentar acceder a rutas protegidas sin estar autenticado. * **Justificación:** Se valida de forma exhaustiva que todos los flujos de autenticación y los casos de uso principales funcionan como se espera. * **Verificación:** El plan se considerará completado con éxito cuando todas estas pruebas pasen sin errores. * **Paso 6.3: Unir la rama al main principal de GitHub.** **Acción:** 1. Unir la rama 'feat/better-auth-migration' y convertirla en la principal (main) tras asegurarse de que todo funciona correctamente y sin errores.

// --- Ruta: betterauth/betterauth_llm.txt ---
# basic-usage: Basic Usage URL: /docs/basic-usage Source: https: Getting started with Better Auth *** title: Basic Usage description: Getting started with Better Auth --------------------------------------------- Better Auth provides built-in authentication support for: * **Email and password** * **Social provider (Google, GitHub, Apple, and more)** But also can easily be extended using plugins, such as: [username](/docs/plugins/username), [magic link](/docs/plugins/magic-link), [passkey](/docs/plugins/passkey), [email-otp](/docs/plugins/email-otp), and more. ## Email & Password To enable email and password authentication: ```ts title="auth.ts" export const auth = betterAuth({ emailAndPassword: { enabled: true } }) ``` ### Sign Up To sign up a user you need to call the client method `signUp.email` with the user's information. ```ts title="sign-up.ts" const { data, error } = await authClient.signUp.email({ email, password, name, image, callbackURL: "/dashboard" }, { onRequest: (ctx) => { }, onSuccess: (ctx) => { }, onError: (ctx) => { alert(ctx.error.message); }, }); ``` By default, the users are automatically signed in after they successfully sign up. To disable this behavior you can set `autoSignIn` to `false`. ```ts title="auth.ts" export const auth = betterAuth({ emailAndPassword: { enabled: true, autoSignIn: false }, }) ``` ### Sign In To sign a user in, you can use the `signIn.email` function provided by the client. ```ts title="sign-in" const { data, error } = await authClient.signIn.email({ email, password, callbackURL: "/dashboard", rememberMe: false }, { }) ``` <Callout type="warn"> Always invoke client methods from the client side. Don't call them from the server. </Callout> ### Server-Side Authentication To authenticate a user on the server, you can use the `auth.api` methods. ```ts title="server.ts" const response = await auth.api.signInEmail({ body: { email, password }, asResponse: true }); ``` <Callout> If the server cannot return a response object, you'll need to manually parse and set cookies. But for frameworks like Next.js we provide [a plugin](/docs/integrations/next#server-action-cookies) to handle this automatically </Callout> ## Social Sign-On Better Auth supports multiple social providers, including Google, GitHub, Apple, Discord, and more. To use a social provider, you need to configure the ones you need in the `socialProviders` option on your `auth` object. ```ts title="auth.ts" export const auth = betterAuth({ socialProviders: { github: { clientId: process.env.GITHUB_CLIENT_ID!, clientSecret: process.env.GITHUB_CLIENT_SECRET!, } }, }) ``` ### Sign in with social providers To sign in using a social provider you need to call `signIn.social`. It takes an object with the following properties: ```ts title="sign-in.ts" await authClient.signIn.social({ provider: "github", callbackURL: "/dashboard", errorCallbackURL: "/error", newUserCallbackURL: "/welcome", disableRedirect: true, }); ``` You can also authenticate using `idToken` or `accessToken` from the social provider instead of redirecting the user to the provider's site. See social providers documentation for more details. ## Signout To signout a user, you can use the `signOut` function provided by the client. ```ts title="user-card.tsx" await authClient.signOut(); ``` you can pass `fetchOptions` to redirect onSuccess ```ts title="user-card.tsx" await authClient.signOut({ fetchOptions: { onSuccess: () => { router.push("/login"); }, }, }); ``` ## Session Once a user is signed in, you'll want to access the user session. Better Auth allows you easily to access the session data from the server and client side. ### Client Side #### Use Session Better Auth provides a `useSession` hook to easily access session data on the client side. This hook is implemented using nanostore and has support for each supported framework and vanilla client, ensuring that any changes to the session (such as signing out) are immediately reflected in your UI. <Tabs items={["React", "Vue","Svelte", "Solid", "Vanilla"]} defaultValue="React"> <Tab value="React"> ```tsx title="user.tsx" import { authClient } from "@/lib/auth-client" export function User(){ const { data: session, isPending, error, refetch } = authClient.useSession() return ( ) } ``` </Tab> <Tab value="Vue"> ```vue title="index.vue" <script setup lang="ts"> import { authClient } from "~/lib/auth-client" const session = authClient.useSession() </script> <template> <div> <div> <pre>{{ session.data }}</pre> <button v-if="session.data" @click="authClient.signOut()"> Sign out </button> </div> </div> </template> ``` </Tab> <Tab value="Svelte"> ```svelte title="user.svelte" <script lang="ts"> import { authClient } from "$lib/auth-client"; const session = authClient.useSession(); </script> <p> {$session.data?.user.email} </p> ``` </Tab> <Tab value="Vanilla"> ```ts title="user.svelte" import { authClient } from "~/lib/auth-client"; authClient.useSession.subscribe((value)=>{ }) ``` </Tab> <Tab value="Solid"> ```tsx title="user.tsx" import { authClient } from "~/lib/auth-client"; export default function Home() { const session = authClient.useSession() return ( <pre>{JSON.stringify(session(), null, 2)}</pre> ); } ``` </Tab> </Tabs> #### Get Session If you prefer not to use the hook, you can use the `getSession` method provided by the client. ```ts title="user.tsx" const { data: session, error } = await authClient.getSession() ``` You can also use it with client-side data-fetching libraries like [TanStack Query](https: ### Server Side The server provides a `session` object that you can use to access the session data. It requires request headers object to be passed to the `getSession` method. **Example: Using some popular frameworks** <Tabs items={["Next.js", "Nuxt", "Svelte", "Astro", "Hono", "TanStack"]}> <Tab value="Next.js"> ```ts title="server.ts" import { auth } from "./auth"; import { headers } from "next/headers"; const session = await auth.api.getSession({ headers: await headers() }) ``` </Tab> <Tab value="Remix"> ```ts title="route.ts" import { auth } from "lib/auth"; export async function loader({ request }: LoaderFunctionArgs) { const session = await auth.api.getSession({ headers: request.headers }) return json({ session }) } ``` </Tab> <Tab value="Astro"> ```astro title="index.astro" --- import { auth } from "./auth"; const session = await auth.api.getSession({ headers: Astro.request.headers, }); --- <!-- Your Astro Template --> ``` </Tab> <Tab value="Svelte"> ```ts title="+page.ts" import { auth } from "./auth"; export async function load({ request }) { const session = await auth.api.getSession({ headers: request.headers }) return { props: { session } } } ``` </Tab> <Tab value="Hono"> ```ts title="index.ts" import { auth } from "./auth"; const app = new Hono(); app.get("/path", async (c) => { const session = await auth.api.getSession({ headers: c.req.raw.headers }) }); ``` </Tab> <Tab value="Nuxt"> ```ts title="server/session.ts" import { auth } from "~/utils/auth"; export default defineEventHandler((event) => { const session = await auth.api.getSession({ headers: event.headers, }) }); ``` </Tab> <Tab value="TanStack"> ```ts title="app/routes/api/index.ts" import { auth } from "./auth"; import { createAPIFileRoute } from "@tanstack/start/api"; export const APIRoute = createAPIFileRoute("/api/$")({ GET: async ({ request }) => { const session = await auth.api.getSession({ headers: request.headers }) }, }); ``` </Tab> </Tabs> <Callout> For more details check [session-management](/docs/concepts/session-management) documentation. </Callout> ## Using Plugins One of the unique features of Better Auth is a plugins ecosystem. It allows you to add complex auth related functionality with small lines of code. Below is an example of how to add two factor authentication using two factor plugin. <Steps> <Step> ### Server Configuration To add a plugin, you need to import the plugin and pass it to the `plugins` option of the auth instance. For example, to add two factor authentication, you can use the following code: ```ts title="auth.ts" import { betterAuth } from "better-auth" import { twoFactor } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ twoFactor() ] }) ``` now two factor related routes and method will be available on the server. </Step> <Step> ### Migrate Database After adding the plugin, you'll need to add the required tables to your database. You can do this by running the `migrate` command, or by using the `generate` command to create the schema and handle the migration manually. generating the schema: ```bash title="terminal" npx @better-auth/cli generate ``` using the `migrate` command: ```bash title="terminal" npx @better-auth/cli migrate ``` <Callout> If you prefer adding the schema manually, you can check the schema required on the [two factor plugin](/docs/plugins/2fa#schema) documentation. </Callout> </Step> <Step> ### Client Configuration Once we're done with the server, we need to add the plugin to the client. To do this, you need to import the plugin and pass it to the `plugins` option of the auth client. For example, to add two factor authentication, you can use the following code: ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client"; import { twoFactorClient } from "better-auth/client/plugins"; const authClient = createAuthClient({ plugins: [ twoFactorClient({ twoFactorPage: "/two-factor" }) ] }) ``` now two factor related methods will be available on the client. ```ts title="profile.ts" import { authClient } from "./auth-client" const enableTwoFactor = async() => { const data = await authClient.twoFactor.enable({ password }) } const disableTwoFactor = async() => { const data = await authClient.twoFactor.disable({ password }) } const signInWith2Factor = async() => { const data = await authClient.signIn.email({ }) } const verifyTOTP = async() => { const data = await authClient.twoFactor.verifyTOTP({ code: "123456", trustDevice: true }) } ``` </Step> <Step> Next step: See the <Link href="/docs/plugins/2fa">two factor plugin documentation</Link>. </Step> </Steps> # comparison: Comparison URL: /docs/comparison Source: https: Comparison of Better Auth versus over other auth libraries and services. *** title: Comparison description: Comparison of Better Auth versus over other auth libraries and services. ------------------------------------------------------------------------------------- > <p className="text-orange-200">Comparison is the thief of joy.</p> Here are non detailed reasons why you may want to use Better Auth over other auth libraries and services. ### vs Other Auth Libraries * **Framework agnostic** - Works with any framework, not just specific ones * **Advanced features built-in** - 2FA, multi-tenancy, multi-session, rate limiting, and many more * **Plugin system** - Extend functionality without forking or complex workarounds * **Full control** - Customize auth flows exactly how you want ### vs Self-Hosted Auth Servers * **No separate infrastructure** - Runs in your app, users stay in your database * **Zero server maintenance** - No auth servers to deploy, monitor, or update * **Complete feature set** - Everything you need without the operational overhead ### vs Managed Auth Services * **Keep your data** - Users stay in your database, not a third-party service * **No per-user costs** - Scale without worrying about auth billing * **Single source of truth** - All user data in one place ### vs Rolling Your Own * **Security handled** - Battle-tested auth flows and security practices * **Focus on your product** - Spend time on features that matter to your business * **Plugin extensibility** - Add custom features without starting from scratch # installation: Installation URL: /docs/installation Source: https: Learn how to configure Better Auth in your project. *** title: Installation description: Learn how to configure Better Auth in your project. ---------------------------------------------------------------- <Steps> <Step> ### Install the Package Let's start by adding Better Auth to your project: <Tabs items={}> <Tab value="npm"> ```bash npm install better-auth ``` </Tab> <Tab value="pnpm"> ```bash pnpm add better-auth ``` </Tab> <Tab value="yarn"> ```bash yarn add better-auth ``` </Tab> <Tab value="bun"> ```bash bun add better-auth ``` </Tab> </Tabs> <Callout type="info"> If you're using a separate client and server setup, make sure to install Better Auth in both parts of your project. </Callout> </Step> <Step> ### Set Environment Variables Create a `.env` file in the root of your project and add the following environment variables: 1. **Secret Key** Random value used by the library for encryption and generating hashes. **You can generate one using the button below** or you can use something like openssl. ```txt title=".env" BETTER_AUTH_SECRET= ``` <GenerateSecret /> 2. **Set Base URL** ```txt title=".env" BETTER_AUTH_URL=http: ``` </Step> <Step> ### Create A Better Auth Instance Create a file named `auth.ts` in one of these locations: * Project root * `lib/` folder * `utils/` folder You can also nest any of these folders under `src/`, `app/` or `server/` folder. (e.g. `src/lib/auth.ts`, `app/lib/auth.ts`). And in this file, import Better Auth and create your auth instance. Make sure to export the auth instance with the variable name `auth` or as a `default` export. ```ts title="auth.ts" import { betterAuth } from "better-auth"; export const auth = betterAuth({ }); ``` </Step> <Step> ### Configure Database Better Auth requires a database to store user data. You can easily configure Better Auth to use SQLite, PostgreSQL, or MySQL, and more! <Tabs items={["sqlite", "postgres", "mysql"]}> <Tab value="sqlite"> ```ts title="auth.ts" import { betterAuth } from "better-auth"; import Database from "better-sqlite3"; export const auth = betterAuth({ database: new Database("./sqlite.db"), }) ``` </Tab> <Tab value="postgres"> ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { Pool } from "pg"; export const auth = betterAuth({ database: new Pool({ }), }) ``` </Tab> <Tab value="mysql"> ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { createPool } from "mysql2/promise"; export const auth = betterAuth({ database: createPool({ }), }) ``` </Tab> </Tabs> Alternatively, if you prefer to use an ORM, you can use one of the built-in adapters. <Tabs items={["drizzle", "prisma", "mongodb"]}> <Tab value="drizzle"> ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { drizzleAdapter } from "better-auth/adapters/drizzle"; import { db } from "@/db"; export const auth = betterAuth({ database: drizzleAdapter(db, { provider: "pg", }), }); ``` </Tab> <Tab value="prisma"> ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { prismaAdapter } from "better-auth/adapters/prisma"; import { PrismaClient } from "@/generated/prisma"; const prisma = new PrismaClient(); export const auth = betterAuth({ database: prismaAdapter(prisma, { provider: "sqlite", }), }); ``` </Tab> <Tab value="mongodb"> ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { mongodbAdapter } from "better-auth/adapters/mongodb"; import { client } from "@/db"; export const auth = betterAuth({ database: mongodbAdapter(client), }); ``` </Tab> </Tabs> <Callout> If your database is not listed above, check out our other supported [databases](/docs/adapters/other-relational-databases) for more information, or use one of the supported ORMs. </Callout> </Step> <Step> ### Create Database Tables Better Auth includes a CLI tool to help manage the schema required by the library. * **Generate**: This command generates an ORM schema or SQL migration file. <Callout> If you're using Kysely, you can apply the migration directly with `migrate` command below. Use `generate` only if you plan to apply the migration manually. </Callout> ```bash title="Terminal" npx @better-auth/cli generate ``` * **Migrate**: This command creates the required tables directly in the database. (Available only for the built-in Kysely adapter) ```bash title="Terminal" npx @better-auth/cli migrate ``` see the [CLI documentation](/docs/concepts/cli) for more information. <Callout> If you instead want to create the schema manually, you can find the core schema required in the [database section](/docs/concepts/database#core-schema). </Callout> </Step> <Step> ### Authentication Methods Configure the authentication methods you want to use. Better Auth comes with built-in support for email/password, and social sign-on providers. ```ts title="auth.ts" import { betterAuth } from "better-auth"; export const auth = betterAuth({ emailAndPassword: { enabled: true, }, socialProviders: { github: { clientId: process.env.GITHUB_CLIENT_ID as string, clientSecret: process.env.GITHUB_CLIENT_SECRET as string, }, }, }); ``` <Callout type="info"> You can use even more authentication methods like [passkey](/docs/plugins/passkey), [username](/docs/plugins/username), [magic link](/docs/plugins/magic-link) and more through plugins. </Callout> </Step> <Step> ### Mount Handler To handle API requests, you need to set up a route handler on your server. Create a new file or route in your framework's designated catch-all route handler. This route should handle requests for the path `/api/auth baseURL: "http: }) ``` </Tab> <Tab value="react" title="lib/auth-client.ts"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/react" export const authClient = createAuthClient({ baseURL: "http: }) ``` </Tab> <Tab value="vue" title="lib/auth-client.ts"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/vue" export const authClient = createAuthClient({ baseURL: "http: }) ``` </Tab> <Tab value="svelte" title="lib/auth-client.ts"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/svelte" export const authClient = createAuthClient({ baseURL: "http: }) ``` </Tab> <Tab value="solid" title="lib/auth-client.ts"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/solid" export const authClient = createAuthClient({ baseURL: "http: }) ``` </Tab> </Tabs> <Callout type="info"> Tip: You can also export specific methods if you prefer: </Callout> ```ts export const { signIn, signUp, useSession } = createAuthClient() ``` </Step> <Step> ### 🎉 That's it! That's it! You're now ready to use better-auth in your application. Continue to [basic usage](/docs/basic-usage) to learn how to use the auth instance to sign in users. </Step> </Steps> # introduction: Introduction URL: /docs/introduction Source: https: Introduction to Better Auth. *** title: Introduction description: Introduction to Better Auth. ----------------------------------------- Better Auth is a framework-agnostic authentication and authorization framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities. Whether you need 2FA, multi-tenancy, multi-session support, or even enterprise features like SSO, it lets you focus on building your application instead of reinventing the wheel. ## Why Better Auth? *Authentication in the TypeScript ecosystem has long been a half-solved problem. Other open-source libraries often require a lot of additional code for anything beyond basic authentication features. Rather than just pushing third-party services as the solution, I believe we can do better as a community—hence, Better Auth.* ## Features Better Auth aims to be the most comprehensive auth library. It provides a wide range of features out of the box and allows you to extend it with plugins. Here are some of the features: <Features /> ...and much more! ## LLMs.txt Better Auth provides an LLMs.txt file that helps AI models understand how to interact with your authentication system. You can find it at [https: # adapters: Community Adapters URL: /docs/adapters/community-adapters Source: https: Integrate Better Auth with community made database adapters. *** title: Community Adapters description: Integrate Better Auth with community made database adapters. ------------------------------------------------------------------------- This page showcases a list of recommended community made database adapters. We encourage you to create any missing database adapters and maybe get added to the list! | Adapter | Database Dialect | Author | | ------------------------------------------------------------------------------------------------------- | ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | | [convex-better-auth](https: | [surrealdb-better-auth](https: | [better-auth-surrealdb](https: | [payload-better-auth](https: | [@ronin/better-auth](https: | [better-auth-instantdb](https: | [@nerdfolio/remult-better-auth](https: # adapters: Drizzle ORM Adapter URL: /docs/adapters/drizzle Source: https: Integrate Better Auth with Drizzle ORM. *** title: Drizzle ORM Adapter description: Integrate Better Auth with Drizzle ORM. ---------------------------------------------------- Drizzle ORM is a powerful and flexible ORM for Node.js and TypeScript. It provides a simple and intuitive API for working with databases, and supports a wide range of databases including MySQL, PostgreSQL, SQLite, and more. Read more here: [Drizzle ORM](https: ## Example Usage Make sure you have Drizzle installed and configured. Then, you can use the Drizzle adapter to connect to your database. ```ts title="auth.ts" export const auth = betterAuth({ database: drizzleAdapter(db, { provider: "sqlite", }), }); ``` ## Schema generation & migration The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate your database schema based on your Better Auth configuration and plugins. To generate the schema required by Better Auth, run the following command: ```bash title="Schema Generation" npx @better-auth/cli@latest generate ``` To generate and apply the migration, run the following commands: ```bash title="Schema Migration" npx drizzle-kit generate # generate the migration file npx drizzle-kit migrate # apply the migration ``` ## Additional Information The Drizzle adapter expects the schema you define to match the table names. For example, if your Drizzle schema maps the `user` table to `users`, you need to manually pass the schema and map it to the user table. ```ts export const auth = betterAuth({ database: drizzleAdapter(db, { provider: "sqlite", schema: { ...schema, user: schema.users, }, }), }); ``` If all your tables are using plural form, you can just pass the `usePlural` option: ```ts export const auth = betterAuth({ database: drizzleAdapter(db, { ... usePlural: true, }), }); ``` If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>. # adapters: MongoDB Adapter URL: /docs/adapters/mongo Source: https: Integrate Better Auth with MongoDB. *** title: MongoDB Adapter description: Integrate Better Auth with MongoDB. ------------------------------------------------ MongoDB is a popular NoSQL database that is widely used for building scalable and flexible applications. It provides a flexible schema that allows for easy data modeling and querying. Read more here: [MongoDB](https: ## Example Usage Make sure you have MongoDB installed and configured. Then, you can use the mongodb adapter. ```ts title="auth.ts" const client = new MongoClient("mongodb: const db = client.db(); export const auth = betterAuth({ database: mongodbAdapter(db), }); ``` ## Schema generation & migration For MongoDB, we don't need to generate or migrate the schema. # adapters: MS SQL URL: /docs/adapters/mssql Source: https: Integrate Better Auth with MS SQL. *** title: MS SQL description: Integrate Better Auth with MS SQL. ----------------------------------------------- Microsoft SQL Server is a relational database management system developed by Microsoft, designed for enterprise-level data storage, management, and analytics with robust security and scalability features. Read more [here](https: ## Example Usage Make sure you have MS SQL installed and configured. Then, you can connect it straight into Better Auth. ```ts title="auth.ts" const dialect = new MssqlDialect({ tarn: { ...Tarn, options: { min: 0, max: 10, }, }, tedious: { ...Tedious, connectionFactory: () => new Tedious.Connection({ authentication: { options: { password: 'password', userName: 'username', }, type: 'default', }, options: { database: 'some_db', port: 1433, trustServerCertificate: true, }, server: 'localhost', }), }, }) export const auth = betterAuth({ database: { dialect, type: "mssql" } }); ``` <Callout> For more information, read Kysely's documentation to the [MssqlDialect](https: </Callout> ## Schema generation & migration The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate your database schema based on your Better Auth configuration and plugins. <table> <tr className="border-b"> <th> <p className="font-bold text-[16px] mb-1">MS SQL Schema Generation</p> </th> <th> <p className="font-bold text-[16px] mb-1">MS SQL Schema Migration</p> </th> </tr> <tr className="h-10"> <td>✅ Supported</td> <td>✅ Supported</td> </tr> </table> ```bash title="Schema Generation" npx @better-auth/cli@latest generate ``` ```bash title="Schema Migration" npx @better-auth/cli@latest migrate ``` ## Additional Information MS SQL is supported under the hood via the [Kysely](https: If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>. # adapters: MySQL URL: /docs/adapters/mysql Source: https: Integrate Better Auth with MySQL. *** title: MySQL description: Integrate Better Auth with MySQL. ---------------------------------------------- MySQL is a popular open-source relational database management system (RDBMS) that is widely used for building web applications and other types of software. It provides a flexible and scalable database solution that allows for efficient storage and retrieval of data. Read more here: [MySQL](https: ## Example Usage Make sure you have MySQL installed and configured. Then, you can connect it straight into Better Auth. ```ts title="auth.ts" export const auth = betterAuth({ database: createPool({ host: "localhost", user: "root", password: "password", database: "database", }), }); ``` <Callout> For more information, read Kysely's documentation to the [MySQLDialect](https: </Callout> ## Schema generation & migration The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate your database schema based on your Better Auth configuration and plugins. <table> <tr className="border-b"> <th> <p className="font-bold text-[16px] mb-1">MySQL Schema Generation</p> </th> <th> <p className="font-bold text-[16px] mb-1">MySQL Schema Migration</p> </th> </tr> <tr className="h-10"> <td>✅ Supported</td> <td>✅ Supported</td> </tr> </table> ```bash title="Schema Generation" npx @better-auth/cli@latest generate ``` ```bash title="Schema Migration" npx @better-auth/cli@latest migrate ``` ## Additional Information MySQL is supported under the hood via the [Kysely](https: If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>. # adapters: Other Relational Databases URL: /docs/adapters/other-relational-databases Source: https: Integrate Better Auth with other relational databases. *** title: Other Relational Databases description: Integrate Better Auth with other relational databases. ------------------------------------------------------------------- Better Auth supports a wide range of database dialects out of the box thanks to <Link href="https: Any dialect supported by Kysely can be utilized with Better Auth, including capabilities for generating and migrating database schemas through the <Link href="/docs/concepts/cli">CLI</Link>. ## Core Dialects * [MySQL](/docs/adapters/mysql) * [SQLite](/docs/adapters/sqlite) * [PostgreSQL](/docs/adapters/postgresql) * [MS SQL](/docs/adapters/mssql) ## Kysely Organization Dialects * [Postgres.js](https: * [SingleStore Data API](https: ## Kysely Community dialects * [PlanetScale Serverless Driver](https: * [Cloudflare D1](https: * [AWS RDS Data API](https: * [SurrealDB](https: * [Neon](https: * [Xata](https: * [AWS S3 Select](https: * [libSQL/sqld](https: * [Fetch driver](https: * [SQLite WASM](https: * [Deno SQLite](https: * [TiDB Cloud Serverless Driver](https: * [Capacitor SQLite Kysely](https: * [BigQuery](https: * [Clickhouse](https: * [PGLite](https: <Callout> You can see the full list of supported Kysely dialects{" "} <Link href="https: </Callout> # adapters: PostgreSQL URL: /docs/adapters/postgresql Source: https: Integrate Better Auth with PostgreSQL. *** title: PostgreSQL description: Integrate Better Auth with PostgreSQL. --------------------------------------------------- PostgreSQL is a powerful, open-source relational database management system known for its advanced features, extensibility, and support for complex queries and large datasets. Read more [here](https: ## Example Usage Make sure you have PostgreSQL installed and configured. Then, you can connect it straight into Better Auth. ```ts title="auth.ts" export const auth = betterAuth({ database: new Pool({ connectionString: "postgres: }), }); ``` <Callout> For more information, read Kysely's documentation to the [PostgresDialect](https: </Callout> ## Schema generation & migration The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate your database schema based on your Better Auth configuration and plugins. <table> <tr className="border-b"> <th> <p className="font-bold text-[16px] mb-1">PostgreSQL Schema Generation</p> </th> <th> <p className="font-bold text-[16px] mb-1">PostgreSQL Schema Migration</p> </th> </tr> <tr className="h-10"> <td>✅ Supported</td> <td>✅ Supported</td> </tr> </table> ```bash title="Schema Generation" npx @better-auth/cli@latest generate ``` ```bash title="Schema Migration" npx @better-auth/cli@latest migrate ``` ## Additional Information PostgreSQL is supported under the hood via the [Kysely](https: If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>. # adapters: Prisma URL: /docs/adapters/prisma Source: https: Integrate Better Auth with Prisma. *** title: Prisma description: Integrate Better Auth with Prisma. ----------------------------------------------- Prisma ORM is an open-source database toolkit that simplifies database access and management in applications by providing a type-safe query builder and an intuitive data modeling interface. Read more [here](https: ## Example Usage Make sure you have Prisma installed and configured. Then, you can use the Prisma adapter to connect to your database. ```ts title="auth.ts" const prisma = new PrismaClient(); export const auth = betterAuth({ database: prismaAdapter(prisma, { provider: "sqlite", }), }); ``` <Callout type="warning"> If you have configured a custom output directory in your `schema.prisma` file (e.g., `output = "../src/generated/prisma"`), make sure to import the Prisma client from that location instead of `@prisma/client`. Learn more about custom output directories in the [Prisma documentation](https: </Callout> ## Schema generation & migration The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate your database schema based on your Better Auth configuration and plugins. <table> <tr className="border-b"> <th> <p className="font-bold text-[16px] mb-1">Prisma Schema Generation</p> </th> <th> <p className="font-bold text-[16px] mb-1">Prisma Schema Migration</p> </th> </tr> <tr className="h-10"> <td>✅ Supported</td> <td>❌ Not Supported</td> </tr> </table> ```bash title="Schema Generation" npx @better-auth/cli@latest generate ``` ## Additional Information If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>. # adapters: SQLite URL: /docs/adapters/sqlite Source: https: Integrate Better Auth with SQLite. *** title: SQLite description: Integrate Better Auth with SQLite. ----------------------------------------------- SQLite is a lightweight, serverless, self-contained SQL database engine that is widely used for local data storage in applications. Read more [here.](https: ## Example Usage Make sure you have SQLite installed and configured. Then, you can connect it straight into Better Auth. ```ts title="auth.ts" export const auth = betterAuth({ database: new Database("database.sqlite"), }); ``` <Callout> For more information, read Kysely's documentation to the [SqliteDialect](https: </Callout> ## Schema generation & migration The [Better Auth CLI](/docs/concepts/cli) allows you to generate or migrate your database schema based on your Better Auth configuration and plugins. <table> <tr className="border-b"> <th> <p className="font-bold text-[16px] mb-1">SQLite Schema Generation</p> </th> <th> <p className="font-bold text-[16px] mb-1">SQLite Schema Migration</p> </th> </tr> <tr className="h-10"> <td>✅ Supported</td> <td>✅ Supported</td> </tr> </table> ```bash title="Schema Generation" npx @better-auth/cli@latest generate ``` ```bash title="Schema Migration" npx @better-auth/cli@latest migrate ``` ## Additional Information SQLite is supported under the hood via the [Kysely](https: If you're looking for performance improvements or tips, take a look at our guide to <Link href="/docs/guides/optimizing-for-performance">performance optimizations</Link>. # authentication: Apple URL: /docs/authentication/apple Source: https: Apple provider setup and usage. *** title: Apple description: Apple provider setup and usage. -------------------------------------------- <Steps> <Step> ### Get your OAuth credentials To use Apple sign in, you need a client ID and client secret. You can get them from the [Apple Developer Portal](https: You will need an active **Apple Developer account** to access the developer portal and generate these credentials. Follow these steps to set up your App ID, Service ID, and generate the key needed for your client secret: 1. **Navigate to Certificates, Identifiers & Profiles:** In the Apple Developer Portal, go to the "Certificates, Identifiers & Profiles" section. 2. **Create an App ID:** * Go to the `Identifiers` tab. * Click the `+` icon next to Identifiers. * Select `App IDs`, then click `Continue`. * Select `App` as the type, then click `Continue`. * **Description:** Enter a name for your app (e.g., "My Awesome App"). This name may be displayed to users when they sign in. * **Bundle ID:** Set a bundle ID. The recommended format is a reverse domain name (e.g., `com.yourcompany.yourapp`). Using a suffix like `.ai` (for app identifier) can help with organization but is not required (e.g., `com.yourcompany.yourapp.ai`). * Scroll down to **Capabilities**. Select the checkbox for `Sign In with Apple`. * Click `Continue`, then `Register`. 3. **Create a Service ID:** * Go back to the `Identifiers` tab. * Click the `+` icon. * Select `Service IDs`, then click `Continue`. * **Description:** Enter a description for this service (e.g., your app name again). * **Identifier:** Set a unique identifier for the service. Use a reverse domain format, distinct from your App ID (e.g., `com.yourcompany.yourapp.si`, where `.si` indicates service identifier - this is for your organization and not required). **This Service ID will be your `clientId`.** * Click `Continue`, then `Register`. 4. **Configure the Service ID:** * Find the Service ID you just created in the `Identifiers` list and click on it. * Check the `Sign In with Apple` capability, then click `Configure`. * Under **Primary App ID**, select the App ID you created earlier (e.g., `com.yourcompany.yourapp.ai`). * Under **Domains and Subdomains**, list all the root domains you will use for Sign In with Apple (e.g., `example.com`, `anotherdomain.com`). * Under **Return URLs**, enter the callback URL. `https: * Click `Next`, then `Done`. * Click `Continue`, then `Save`. 5. **Create a Client Secret Key:** * Go to the `Keys` tab. * Click the `+` icon to create a new key. * **Key Name:** Enter a name for the key (e.g., "Sign In with Apple Key"). * Scroll down and select the checkbox for `Sign In with Apple`. * Click the `Configure` button next to `Sign In with Apple`. * Select the **Primary App ID** you created earlier. * Click `Save`, then `Continue`, then `Register`. * **Download the Key:** Immediately download the `.p8` key file. **This file is only available for download once.** Note the Key ID (available on the Keys page after creation) and your Team ID (available in your Apple Developer Account settings). 6. **Generate the Client Secret (JWT):** Apple requires a JSON Web Token (JWT) to be generated dynamically using the downloaded `.p8` key, the Key ID, and your Team ID. This JWT serves as your `clientSecret`. You can use the guide below from [Apple's documentation](https: </Step> <Step> ### Configure the provider To configure the provider, you need to add it to the `socialProviders` option of the auth instance. You also need to add `https: ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { apple: { clientId: process.env.APPLE_CLIENT_ID as string, clientSecret: process.env.APPLE_CLIENT_SECRET as string, appBundleIdentifier: process.env.APPLE_APP_BUNDLE_IDENTIFIER as string, }, }, trustedOrigins: ["https: }) ``` On native iOS, it doesn't use the service ID but the app ID (bundle ID) as client ID, so if using the service ID as `clientId` in `signIn.social` with `idToken`, it throws an error: `JWTClaimValidationFailed: unexpected "aud" claim value`. So you need to provide the `appBundleIdentifier` when you want to sign in with Apple using the ID Token. </Step> </Steps> ## Usage ### Sign In with Apple To sign in with Apple, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `apple`. ```ts title="auth-client.ts" / const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "apple" }) } ``` ### Sign In with Apple With ID Token To sign in with Apple using the ID Token, you can use the `signIn.social` function to pass the ID Token. This is useful when you have the ID Token from Apple on the client-side and want to use it to sign in on the server. <Callout> If ID token is provided no redirection will happen, and the user will be signed in directly. </Callout> ```ts title="auth-client.ts" await authClient.signIn.social({ provider: "apple", idToken: { token: nonce: accessToken: } }) ``` ## Generate Apple Client Secret (JWT) <GenerateAppleJwt /> # authentication: Discord URL: /docs/authentication/discord Source: https: Discord provider setup and usage. *** title: Discord description: Discord provider setup and usage. ---------------------------------------------- <Steps> <Step> ### Get your Discord credentials To use Discord sign in, you need a client ID and client secret. You can get them from the [Discord Developer Portal](https: Make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { discord: { clientId: process.env.DISCORD_CLIENT_ID as string, clientSecret: process.env.DISCORD_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Discord To sign in with Discord, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `discord`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "discord" }) } ``` </Step> </Steps> # authentication: Dropbox URL: /docs/authentication/dropbox Source: https: Dropbox provider setup and usage. *** title: Dropbox description: Dropbox provider setup and usage. ---------------------------------------------- <Steps> <Step> ### Get your Dropbox credentials To use Dropbox sign in, you need a client ID and client secret. You can get them from the [Dropbox Developer Portal](https: Make sure to set the redirect URL to `http: </Step> If you need deeper dive into Dropbox Authentication, you can check out the [official documentation](https: <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { dropbox: { clientId: process.env.DROPBOX_CLIENT_ID as string, clientSecret: process.env.DROPBOX_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Dropbox To sign in with Dropbox, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `dropbox`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "dropbox" }) } ``` </Step> </Steps> # authentication: Email & Password URL: /docs/authentication/email-password Source: https: Implementing email and password authentication with Better Auth. *** title: Email & Password description: Implementing email and password authentication with Better Auth. ----------------------------------------------------------------------------- Email and password authentication is a common method used by many applications. Better Auth provides a built-in email and password authenticator that you can easily integrate into your project. <Callout type="info"> If you prefer username-based authentication, check out the{" "} <Link href="/docs/plugins/username">username plugin</Link>. It extends the email and password authenticator with username support. </Callout> ## Enable Email and Password To enable email and password authentication, you need to set the `emailAndPassword.enabled` option to `true` in the `auth` configuration. ```ts title="auth.ts" export const auth = betterAuth({ emailAndPassword: { enabled: true, }, }); ``` <Callout type="info"> If it's not enabled, it'll not allow you to sign in or sign up with email and password. </Callout> ## Usage ### Sign Up To sign a user up, you can use the `signUp.email` function provided by the client. <APIMethod path="/sign-up/email" method="POST"> ```ts type signUpEmail = { name: string = "John Doe" email: string = "john.doe@example.com" password: string = "password1234" image?: string = "https: callbackURL?: string = "https: } ``` </APIMethod> <Callout> These are the default properties for the sign up email endpoint, however it's possible that with [additional fields](/docs/concepts/typescript#additional-fields) or special plugins you can pass more properties to the endpoint. </Callout> ### Sign In To sign a user in, you can use the `signIn.email` function provided by the client. <APIMethod path="/sign-in/email" method="POST" requireSession> ```ts type signInEmail = { email: string = "john.doe@example.com" password: string = "password1234" rememberMe?: boolean = true callbackURL?: string = "https: } ``` </APIMethod> <Callout> These are the default properties for the sign in email endpoint, however it's possible that with [additional fields](/docs/concepts/typescript#additional-fields) or special plugins you can pass different properties to the endpoint. </Callout> ### Sign Out To sign a user out, you can use the `signOut` function provided by the client. <APIMethod path="/sign-out" method="POST" requireSession noResult> ```ts type signOut = { } ``` </APIMethod> you can pass `fetchOptions` to redirect onSuccess ```ts title="auth-client.ts" await authClient.signOut({ fetchOptions: { onSuccess: () => { router.push("/login"); }, }, }); ``` ### Email Verification To enable email verification, you need to pass a function that sends a verification email with a link. The `sendVerificationEmail` function takes a data object with the following properties: * `user`: The user object. * `url`: The URL to send to the user which contains the token. * `token`: A verification token used to complete the email verification. and a `request` object as the second parameter. ```ts title="auth.ts" export const auth = betterAuth({ emailVerification: { sendVerificationEmail: async ( { user, url, token }, request) => { await sendEmail({ to: user.email, subject: "Verify your email address", text: `Click the link to verify your email: ${url}`, }); }, }, }); ``` On the client side you can use `sendVerificationEmail` function to send verification link to user. This will trigger the `sendVerificationEmail` function you provided in the `auth` configuration. Once the user clicks on the link in the email, if the token is valid, the user will be redirected to the URL provided in the `callbackURL` parameter. If the token is invalid, the user will be redirected to the URL provided in the `callbackURL` parameter with an error message in the query string `?error=invalid_token`. #### Require Email Verification If you enable require email verification, users must verify their email before they can log in. And every time a user tries to sign in, sendVerificationEmail is called. <Callout> This only works if you have sendVerificationEmail implemented and if the user is trying to sign in with email and password. </Callout> ```ts title="auth.ts" export const auth = betterAuth({ emailAndPassword: { requireEmailVerification: true, }, }); ``` If a user tries to sign in without verifying their email, you can handle the error and show a message to the user. ```ts title="auth-client.ts" await authClient.signIn.email( { email: "email@example.com", password: "password", }, { onError: (ctx) => { if (ctx.error.status === 403) { alert("Please verify your email address"); } alert(ctx.error.message); }, } ); ``` #### Triggering manually Email Verification You can trigger the email verification manually by calling the `sendVerificationEmail` function. ```ts await authClient.sendVerificationEmail({ email: "user@email.com", callbackURL: "/", }); ``` ### Request Password Reset To allow users to reset a password first you need to provide `sendResetPassword` function to the email and password authenticator. The `sendResetPassword` function takes a data object with the following properties: * `user`: The user object. * `url`: The URL to send to the user which contains the token. * `token`: A verification token used to complete the password reset. and a `request` object as the second parameter. ```ts title="auth.ts" export const auth = betterAuth({ emailAndPassword: { enabled: true, sendResetPassword: async ({user, url, token}, request) => { await sendEmail({ to: user.email, subject: "Reset your password", text: `Click the link to reset your password: ${url}`, }); }, onPasswordReset: async ({ user }, request) => { console.log(`Password for user ${user.email} has been reset.`); }, }, }); ``` Additionally, you can provide an `onPasswordReset` callback to execute logic after a password has been successfully reset. Once you configured your server you can call `requestPasswordReset` function to send reset password link to user. If the user exists, it will trigger the `sendResetPassword` function you provided in the auth config. <APIMethod path="/request-password-reset" method="POST"> ```ts type requestPasswordReset = { email: string = "john.doe@example.com" redirectTo?: string = "https: } ``` </APIMethod> When a user clicks on the link in the email, they will be redirected to the reset password page. You can add the reset password page to your app. Then you can use `resetPassword` function to reset the password. It takes an object with the following properties: * `newPassword`: The new password of the user. ```ts title="auth-client.ts" const { data, error } = await authClient.resetPassword({ newPassword: "password1234", token, }); ``` <APIMethod path="/reset-password" method="POST"> ```ts const token = new URLSearchParams(window.location.search).get("token"); if (!token) { } type resetPassword = { newPassword: string = "password1234" token: string } ``` </APIMethod> ### Update password A user's password isn't stored in the user table. Instead, it's stored in the account table. To change the password of a user, you can use one of the following approaches: <APIMethod path="/change-password" method="POST" requireSession> ```ts type changePassword = { newPassword: string = "newpassword1234" currentPassword: string = "oldpassword1234" revokeOtherSessions?: boolean = true } ``` </APIMethod> ### Configuration **Password** Better Auth stores passwords inside the `account` table with `providerId` set to `credential`. **Password Hashing**: Better Auth uses `scrypt` to hash passwords. The `scrypt` algorithm is designed to be slow and memory-intensive to make it difficult for attackers to brute force passwords. OWASP recommends using `scrypt` if `argon2id` is not available. We decided to use `scrypt` because it's natively supported by Node.js. You can pass custom password hashing algorithm by setting `passwordHasher` option in the `auth` configuration. ```ts title="auth.ts" export const auth = betterAuth({ emailAndPassword: { password: { hash: verify: } } }) ``` <TypeTable type={{ enabled: { description: "Enable email and password authentication.", type: "boolean", default: "false", }, disableSignUp: { description: "Disable email and password sign up.", type: "boolean", default: "false" }, minPasswordLength: { description: "The minimum length of a password.", type: "number", default: 8, }, maxPasswordLength: { description: "The maximum length of a password.", type: "number", default: 128, }, sendResetPassword: { description: "Sends a password reset email. It takes a function that takes two parameters: token and user.", type: "function", }, onPasswordReset: { description: "A callback function that is triggered when a user's password is changed successfully.", type: "function", }, resetPasswordTokenExpiresIn: { description: "Number of seconds the reset password token is valid for.", type: "number", default: 3600 }, password: { description: "Password configuration.", type: "object", properties: { hash: { description: "custom password hashing function", type: "function", }, verify: { description: "custom password verification function", type: "function", }, }, }, }} /> # authentication: Facebook URL: /docs/authentication/facebook Source: https: Facebook provider setup and usage. *** title: Facebook description: Facebook provider setup and usage. ----------------------------------------------- <Steps> <Step> ### Get your Facebook credentials To use Facebook sign in, you need a client ID and client Secret. You can get them from the [Facebook Developer Portal](https: Select your app, navigate to **App Settings > Basic**, locate the following: * **App ID**: This is your `clientId` * **App Secret**: This is your `clientSecret`. <Callout type="warn"> Avoid exposing the `clientSecret` in client-side code (e.g., frontend apps) because it’s sensitive information. </Callout> Make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { facebook: { clientId: process.env.FACEBOOK_CLIENT_ID as string, clientSecret: process.env.FACEBOOK_CLIENT_SECRET as string, }, }, }) ``` <Callout> BetterAuth also supports Facebook Login for Business, all you need to do is provide the `configId` as listed in **Facebook Login For Business > Configurations** alongside your `clientId` and `clientSecret`. Note that the app must be a Business app and, since BetterAuth expects to have an email address and account id, the configuration must be of the "User access token" type. "System-user access token" is not supported. </Callout> </Step> <Step> ### Sign In with Facebook To sign in with Facebook, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `facebook`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/auth-client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "facebook" }) } ``` </Step> </Steps> ## Additional Configuration ### Scopes By default, Facebook provides basic user information. If you need additional permissions, you can specify scopes in your auth configuration: ```ts title="auth.ts" export const auth = betterAuth({ socialProviders: { facebook: { clientId: process.env.FACEBOOK_CLIENT_ID as string, clientSecret: process.env.FACEBOOK_CLIENT_SECRET as string, scopes: ["email", "public_profile", "user_friends"], fields: ["user_friends"], }, }, }) ``` Additional options: * `scopes`: Access basic account information (overwrites). * Default: `"email", "public_profile"` * `fields`: Extend list of fields to retrieve from the Facebook user profile (assignment). * Default: `"id", "name", "email", "picture"` ### Sign In with Facebook With ID or Access Token To sign in with Facebook using the ID Token, you can use the `signIn.social` function to pass the ID Token. This is useful when you have the ID Token from Facebook on the client-side and want to use it to sign in on the server. <Callout> If ID token is provided no redirection will happen, and the user will be signed in directly. </Callout> For limited login, you need to pass `idToken.token`, for only `accessToken` you need to pass `idToken.accessToken` and `idToken.token` together because of (#1183)\[[https: ```ts title="auth-client.ts" const data = await authClient.signIn.social({ provider: "facebook", idToken: { ...(platform === 'ios' ? { token: idToken } : { token: accessToken, accessToken: accessToken }), }, }) ``` For a complete list of available permissions, refer to the [Permissions Reference](https: # authentication: GitHub URL: /docs/authentication/github Source: https: GitHub provider setup and usage. *** title: GitHub description: GitHub provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your GitHub credentials To use GitHub sign in, you need a client ID and client secret. You can get them from the [GitHub Developer Portal](https: Make sure to set the redirect URL to `http: Important: You MUST include the user:email scope in your GitHub app. See details below. </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { github: { clientId: process.env.GITHUB_CLIENT_ID as string, clientSecret: process.env.GITHUB_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with GitHub To sign in with GitHub, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `github`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "github" }) } ``` </Step> </Steps> ## Usage ### Setting up your Github app Github has two types of apps: Github apps and OAuth apps. For OAuth apps, you don't have to do anything special (just follow the steps above). For Github apps, you DO have to add one more thing, which is enable it to read the user's email: 1. After creating your app, go to *Permissions and Events* > *Account Permissions* > *Email Addresses* and select "Read-Only" 2. Save changes. That's all! Now you can copy the Client ID and Client Secret of your app! <Callout> If you get "email\_not\_found" error, it's because you selected a Github app & did not configure this part! </Callout> ### Why don't I have a refresh token? Github doesn't issue refresh tokens for OAuth apps. For regular OAuth apps, GitHub issues access tokens that remain valid indefinitely unless the user revokes them, the app revokes them, or they go unused for a year. There's no need for a refresh token because the access token doesn't expire on a short interval like Google or Discord. # authentication: GitLab URL: /docs/authentication/gitlab Source: https: GitLab provider setup and usage. *** title: GitLab description: GitLab provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your GitLab credentials To use GitLab sign in, you need a client ID and client secret. [GitLab OAuth documentation](https: Make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { gitlab: { clientId: process.env.GITLAB_CLIENT_ID as string, clientSecret: process.env.GITLAB_CLIENT_SECRET as string, issuer: process.env.GITLAB_ISSUER as string, }, }, }) ``` </Step> <Step> ### Sign In with GitLab To sign in with GitLab, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `gitlab`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "gitlab" }) } ``` </Step> </Steps> # authentication: Google URL: /docs/authentication/google Source: https: Google provider setup and usage. *** title: Google description: Google provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your Google credentials To use Google as a social provider, you need to get your Google credentials. You can get them by creating a new project in the [Google Cloud Console](https: In the Google Cloud Console > Credentials > Authorized redirect URIs, make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to pass the `clientId` and `clientSecret` to `socialProviders.google` in your auth configuration. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { google: { clientId: process.env.GOOGLE_CLIENT_ID as string, clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, }, }, }) ``` </Step> </Steps> ## Usage ### Sign In with Google To sign in with Google, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `google`. ```ts title="auth-client.ts" / const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "google" }) } ``` ### Sign In with Google With ID Token To sign in with Google using the ID Token, you can use the `signIn.social` function to pass the ID Token. This is useful when you have the ID Token from Google on the client-side and want to use it to sign in on the server. <Callout> If ID token is provided no redirection will happen, and the user will be signed in directly. </Callout> ```ts title="auth-client.ts" const data = await authClient.signIn.social({ provider: "google", idToken: { token: accessToken: } }) ``` <Callout> If you want to use google one tap, you can use the [One Tap Plugin](/docs/plugins/one-tap) guide. </Callout> ### Always ask to select an account If you want to always ask the user to select an account, you pass the `prompt` parameter to the provider, setting it to `select_account`. ```ts socialProviders: { google: { prompt: "select_account", clientId: process.env.GOOGLE_CLIENT_ID as string, clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, }, } ``` ### Requesting Additional Google Scopes If your application needs additional Google scopes after the user has already signed up (e.g., for Google Drive, Gmail, or other Google services), you can request them using the `linkSocial` method with the same Google provider. ```ts title="auth-client.ts" const requestGoogleDriveAccess = async () => { await authClient.linkSocial({ provider: "google", scopes: ["https: }); }; return <button onClick={requestGoogleDriveAccess}>Add Google Drive Permissions</button>; ``` This will trigger a new OAuth flow that requests the additional scopes. After completion, your account will have the new scope in the database, and the access token will give you access to the requested Google APIs. <Callout> Ensure you're using Better Auth version 1.2.7 or later to avoid "Social account already linked" errors when requesting additional scopes from the same provider. </Callout> ### Always get refresh token Google only issues a refresh token the first time a user consents to your app. If the user has already authorized your app, subsequent OAuth flows will only return an access token, not a refresh token. To always get a refresh token, you can set the `accessType` to `offline`, and `prompt` to `select_account+consent` in the provider options. ```ts socialProviders: { google: { clientId: process.env.GOOGLE_CLIENT_ID as string, clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, accessType: "offline", prompt: "select_account consent", }, } ``` <Callout> **Revoking Access:** If you want to get a new refresh token for a user who has already authorized your app, you must have them revoke your app's access in their Google account settings, then re-authorize. </Callout> # authentication: Hugging Face URL: /docs/authentication/huggingface Source: https: Hugging Face provider setup and usage. *** title: Hugging Face description: Hugging Face provider setup and usage. --------------------------------------------------- <Steps> <Step> ### Get your Hugging Face credentials To use Hugging Face sign in, you need a client ID and client secret. [Hugging Face OAuth documentation](https: Make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { huggingface: { clientId: process.env.HUGGINGFACE_CLIENT_ID as string, clientSecret: process.env.HUGGINGFACE_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Hugging Face To sign in with Hugging Face, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `huggingface`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "huggingface" }) } ``` </Step> </Steps> # authentication: Kick URL: /docs/authentication/kick Source: https: Kick provider setup and usage. *** title: Kick description: Kick provider setup and usage. ------------------------------------------- <Steps> <Step> ### Get your Kick Credentials To use Kick sign in, you need a client ID and client secret. You can get them from the [Kick Developer Portal](https: Make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { kick: { clientId: process.env.KICK_CLIENT_ID as string, clientSecret: process.env.KICK_CLIENT_SECRET as string, }, } }) ``` </Step> <Step> ### Sign In with Kick To sign in with Kick, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `kick`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "kick" }) } ``` </Step> </Steps> # authentication: Linear URL: /docs/authentication/linear Source: https: Linear provider setup and usage. *** title: Linear description: Linear provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your Linear credentials To use Linear sign in, you need a client ID and client secret. You can get them from the [Linear Developer Portal](https: Make sure to set the redirect URL to `http: When creating your OAuth application in Linear, you'll need to specify the required scopes. The default scope is `read`, but you can also request additional scopes like `write` if needed. </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { linear: { clientId: process.env.LINEAR_CLIENT_ID as string, clientSecret: process.env.LINEAR_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Linear To sign in with Linear, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `linear`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "linear" }) } ``` </Step> <Step> ### Available scopes Linear OAuth supports the following scopes: * `read` (default): Read access for the user's account * `write`: Write access for the user's account * `issues:create`: Allows creating new issues and their attachments * `comments:create`: Allows creating new issue comments * `timeSchedule:write`: Allows creating and modifying time schedules * `admin`: Full access to admin level endpoints (use with caution) You can specify additional scopes when configuring the provider: ```ts title="auth.ts" export const auth = betterAuth({ socialProviders: { linear: { clientId: process.env.LINEAR_CLIENT_ID as string, clientSecret: process.env.LINEAR_CLIENT_SECRET as string, scope: ["read", "write"] }, }, }) ``` </Step> </Steps> # authentication: LinkedIn URL: /docs/authentication/linkedin Source: https: LinkedIn Provider *** title: LinkedIn description: LinkedIn Provider ------------------------------ <Steps> <Step> ### Get your LinkedIn credentials To use LinkedIn sign in, you need a client ID and client secret. You can get them from the [LinkedIn Developer Portal](https: Make sure to set the redirect URL to `http: </Step> <Callout type="info"> In the LinkedIn portal under products you need the **Sign In with LinkedIn using OpenID Connect** product. </Callout> There are some different Guides here: [Authorization Code Flow (3-legged OAuth) (Outdated)](https: [Sign In with LinkedIn using OpenID Connect](https: <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { linkedin: { clientId: process.env.LINKEDIN_CLIENT_ID as string, clientSecret: process.env.LINKEDIN_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with LinkedIn To sign in with LinkedIn, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `linkedin`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "linkedin" }) } ``` </Step> </Steps> # authentication: Microsoft URL: /docs/authentication/microsoft Source: https: Microsoft provider setup and usage. *** title: Microsoft description: Microsoft provider setup and usage. ------------------------------------------------ Enabling OAuth with Microsoft Azure Entra ID (formerly Active Directory) allows your users to sign in and sign up to your application with their Microsoft account. <Steps> <Step> ### Get your Microsoft credentials To use Microsoft as a social provider, you need to get your Microsoft credentials. Which involves generating your own Client ID and Client Secret using your Microsoft Entra ID dashboard account. Make sure to set the redirect URL to `http: see the [Microsoft Entra ID documentation](https: </Step> <Step> ### Configure the provider To configure the provider, you need to pass the `clientId` and `clientSecret` to `socialProviders.microsoft` in your auth configuration. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { microsoft: { clientId: process.env.MICROSOFT_CLIENT_ID as string, clientSecret: process.env.MICROSOFT_CLIENT_SECRET as string, tenantId: 'common', prompt: "select_account", }, }, }) ``` </Step> </Steps> ## Sign In with Microsoft To sign in with Microsoft, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `microsoft`. ```ts title="auth-client.ts" const authClient = createAuthClient(); const signIn = async () => { const data = await authClient.signIn.social({ provider: "microsoft", callbackURL: "/dashboard", }); }; ``` # authentication: Notion URL: /docs/authentication/notion Source: https: Notion provider setup and usage. *** title: Notion description: Notion provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your Notion credentials To use Notion as a social provider, you need to get your Notion OAuth credentials. You can get them by creating a new integration in the [Notion Developers Portal](https: In the Notion integration settings > OAuth Domain & URIs, make sure to set the redirect URL to `http: <Callout> Make sure your Notion integration has the appropriate capabilities enabled. For user authentication, you'll need the "Read user information including email addresses" capability. </Callout> </Step> <Step> ### Configure the provider To configure the provider, you need to pass the `clientId` and `clientSecret` to `socialProviders.notion` in your auth configuration. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { notion: { clientId: process.env.NOTION_CLIENT_ID as string, clientSecret: process.env.NOTION_CLIENT_SECRET as string, }, }, }) ``` </Step> </Steps> ## Usage ### Sign In with Notion To sign in with Notion, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `notion`. ```ts title="auth-client.ts" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "notion" }) } ``` ### Notion Integration Types Notion supports different integration types. When creating your integration, you can choose between: * **Public integrations**: Can be installed by any Notion workspace * **Internal integrations**: Limited to your own workspace For most authentication use cases, you'll want to create a public integration to allow users from different workspaces to sign in. ### Requesting Additional Notion Scopes If your application needs additional Notion capabilities after the user has already signed up, you can request them using the `linkSocial` method with the same Notion provider and additional scopes. ```ts title="auth-client.ts" const requestNotionAccess = async () => { await authClient.linkSocial({ provider: "notion", }); }; return <button onClick={requestNotionAccess}>Connect Notion Workspace</button>; ``` <Callout> After authentication, you can use the access token to interact with the Notion API to read and write pages, databases, and other content that the user has granted access to. </Callout> # authentication: Other Social Providers URL: /docs/authentication/other-social-providers Source: https: Other social providers setup and usage. *** title: Other Social Providers description: Other social providers setup and usage. ---------------------------------------------------- Better Auth providers out of the box support for the [Generic Oauth Plugin](/docs/plugins/generic-oauth) which allows you to use any social provider that implements the OAuth2 protocol or OpenID Connect (OIDC) flows. To use a provider that is not supported out of the box, you can use the [Generic Oauth Plugin](/docs/plugins/generic-oauth). ## Installation <Steps> <Step> ### Add the plugin to your auth config To use the Generic OAuth plugin, add it to your auth config. ```ts title="auth.ts" import { betterAuth } from "better-auth" import { genericOAuth } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ genericOAuth({ config: [ { providerId: "provider-id", clientId: "test-client-id", clientSecret: "test-client-secret", discoveryUrl: "https: }, ] }) ] }) ``` </Step> <Step> ### Add the client plugin Include the Generic OAuth client plugin in your authentication client instance. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { genericOAuthClient } from "better-auth/client/plugins" const authClient = createAuthClient({ plugins: [ genericOAuthClient() ] }) ``` </Step> </Steps> <Callout> Read more about installation and usage of the Generic Oauth plugin [here](/docs/plugins/generic-oauth#usage). </Callout> ## Example usage ### Instagram Example ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ genericOAuth({ config: [ { providerId: "instagram", clientId: process.env.INSTAGRAM_CLIENT_ID as string, clientSecret: process.env.INSTAGRAM_CLIENT_SECRET as string, authorizationUrl: "https: tokenUrl: "https: scopes: ["user_profile", "user_media"], }, ], }), ], }); ``` ```ts title="sign-in.ts" const response = await authClient.signIn.oauth2({ providerId: "instagram", callbackURL: "/dashboard", }); ``` ### Coinbase Example ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ genericOAuth({ config: [ { providerId: "coinbase", clientId: process.env.COINBASE_CLIENT_ID as string, clientSecret: process.env.COINBASE_CLIENT_SECRET as string, authorizationUrl: "https: tokenUrl: "https: scopes: ["wallet:user:read"], }, ], }), ], }); ``` ```ts title="sign-in.ts" const response = await authClient.signIn.oauth2({ providerId: "coinbase", callbackURL: "/dashboard", }); ``` # authentication: Reddit URL: /docs/authentication/reddit Source: https: Reddit provider setup and usage. *** title: Reddit description: Reddit provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your Reddit Credentials To use Reddit sign in, you need a client ID and client secret. You can get them from the [Reddit Developer Portal](https: 1. Click "Create App" or "Create Another App" 2. Select "web app" as the application type 3. Set the redirect URL to `http: 4. For production, set it to your application's domain (e.g. `https: 5. After creating the app, you'll get the client ID (under the app name) and client secret If you change the base path of the auth routes, make sure to update the redirect URL accordingly. </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { reddit: { clientId: process.env.REDDIT_CLIENT_ID as string, clientSecret: process.env.REDDIT_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Reddit To sign in with Reddit, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `reddit`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "reddit" }) } ``` </Step> </Steps> ## Additional Configuration ### Scopes By default, Reddit provides basic user information. If you need additional permissions, you can specify scopes in your auth configuration: ```ts title="auth.ts" export const auth = betterAuth({ socialProviders: { reddit: { clientId: process.env.REDDIT_CLIENT_ID as string, clientSecret: process.env.REDDIT_CLIENT_SECRET as string, duration: "permanent", scope: ["read", "submit"] }, }, }) ``` Common Reddit scopes include: * `identity`: Access basic account information * `read`: Access posts and comments * `submit`: Submit posts and comments * `subscribe`: Manage subreddit subscriptions * `history`: Access voting history For a complete list of available scopes, refer to the [Reddit OAuth2 documentation](https: # authentication: Roblox URL: /docs/authentication/roblox Source: https: Roblox provider setup and usage. *** title: Roblox description: Roblox provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your Roblox Credentials Get your Roblox credentials from the [Roblox Creator Hub](https: Make sure to set the redirect URL to `http: <Callout type="info"> The Roblox API does not provide email addresses. As a workaround, the user's `email` field uses the `preferred_username` value instead. </Callout> </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { roblox: { clientId: process.env.ROBLOX_CLIENT_ID as string, clientSecret: process.env.ROBLOX_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Roblox To sign in with Roblox, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `roblox`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "roblox" }) } ``` </Step> </Steps> # authentication: Slack URL: /docs/authentication/slack Source: https: Slack provider setup and usage. *** title: Slack description: Slack provider setup and usage. -------------------------------------------- <Steps> <Step> ### Get your Slack credentials To use Slack as a social provider, you need to create a Slack app and get your credentials. 1. Go to [Your Apps on Slack API](https: 2. Choose "From scratch" and give your app a name and select a development workspace 3. In your app settings, navigate to "OAuth & Permissions" 4. Under "Redirect URLs", add your redirect URL: * For local development: `http: * For production: `https: 5. Copy your Client ID and Client Secret from the "Basic Information" page <Callout> Slack requires HTTPS for redirect URLs in production. For local development, you can use tools like [ngrok](https: </Callout> </Step> <Step> ### Configure the provider To configure the provider, you need to pass the `clientId` and `clientSecret` to `socialProviders.slack` in your auth configuration. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { slack: { clientId: process.env.SLACK_CLIENT_ID as string, clientSecret: process.env.SLACK_CLIENT_SECRET as string, }, }, }) ``` </Step> </Steps> ## Usage ### Sign In with Slack To sign in with Slack, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `slack`. ```ts title="auth-client.ts" const authClient = createAuthClient(); const signIn = async () => { const data = await authClient.signIn.social({ provider: "slack" }); }; ``` ### Requesting Additional Scopes By default, Slack uses OpenID Connect scopes: `openid`, `profile`, and `email`. You can request additional Slack scopes during sign-in: ```ts title="auth-client.ts" const signInWithSlack = async () => { await authClient.signIn.social({ provider: "slack", scopes: ["channels:read", "chat:write"], }); }; ``` ### Workspace-Specific Sign In If you want to restrict sign-in to a specific Slack workspace, you can pass the `team` parameter: ```ts title="auth.ts" socialProviders: { slack: { clientId: process.env.SLACK_CLIENT_ID as string, clientSecret: process.env.SLACK_CLIENT_SECRET as string, team: "T1234567890", }, } ``` ### Using Slack API After Sign In After successful authentication, you can access the user's Slack information through the session. The access token can be used to make requests to the Slack API: ```ts const session = await authClient.getSession(); if (session?.user) { const slackUserId = session.user.id; } ``` <Callout> The Slack provider uses OpenID Connect by default, which provides basic user information. If you need to access other Slack APIs, make sure to request the appropriate scopes during sign-in. </Callout> # authentication: Spotify URL: /docs/authentication/spotify Source: https: Spotify provider setup and usage. *** title: Spotify description: Spotify provider setup and usage. ---------------------------------------------- <Steps> <Step> ### Get your Spotify Credentials To use Spotify sign in, you need a client ID and client secret. You can get them from the [Spotify Developer Portal](https: Make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { spotify: { clientId: process.env.SPOTIFY_CLIENT_ID as string, clientSecret: process.env.SPOTIFY_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Spotify To sign in with Spotify, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `spotify`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "spotify" }) } ``` </Step> </Steps> # authentication: TikTok URL: /docs/authentication/tiktok Source: https: TikTok provider setup and usage. *** title: TikTok description: TikTok provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your TikTok Credentials To integrate with TikTok, you need to obtain API credentials by creating an application in the [TikTok Developer Portal](https: Follow these steps: 1. Create an account on the TikTok Developer Portal 2. Create a new application 3. Set up a sandbox environment for testing 4. Configure your redirect URL (must be HTTPS) 5. Note your Client ID, Client Secret and Client Key <Callout type="info"> * The TikTok API does not work with localhost. You need to use a public domain for the redirect URL and HTTPS for local testing. You can use [NGROK](https: * For testing, you will need to use the [Sandbox mode](https: * The default scope is `user.info.profile`. For additional scopes, refer to the [Available Scopes](https: </Callout> Make sure to set the redirect URL to a valid HTTPS domain for local development. For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly. <Callout type="info"> * The TikTok API does not provide email addresses. As a workaround, this implementation uses the user's `username` value for the `email` field, which is why it requires the `user.info.profile` scope instead of just `user.info.basic`. * For production use, you will need to request approval from TikTok for the scopes you intend to use. </Callout> </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { tiktok: { clientId: process.env.TIKTOK_CLIENT_ID as string, clientSecret: process.env.TIKTOK_CLIENT_SECRET as string, clientKey: process.env.TIKTOK_CLIENT_KEY as string, }, }, }) ``` </Step> <Step> ### Sign In with TikTok To sign in with TikTok, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `tiktok`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "tiktok" }) } ``` </Step> </Steps> # authentication: Twitch URL: /docs/authentication/twitch Source: https: Twitch provider setup and usage. *** title: Twitch description: Twitch provider setup and usage. --------------------------------------------- <Steps> <Step> ### Get your Twitch Credentials To use Twitch sign in, you need a client ID and client secret. You can get them from the [Twitch Developer Portal](https: Make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { twitch: { clientId: process.env.TWITCH_CLIENT_ID as string, clientSecret: process.env.TWITCH_CLIENT_SECRET as string, }, } }) ``` </Step> <Step> ### Sign In with Twitch To sign in with Twitch, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `twitch`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "twitch" }) } ``` </Step> </Steps> # authentication: Twitter (X) URL: /docs/authentication/twitter Source: https: Twitter provider setup and usage. *** title: Twitter (X) description: Twitter provider setup and usage. ---------------------------------------------- <Steps> <Step> ### Get your Twitter Credentials Get your Twitter credentials from the [Twitter Developer Portal](https: Make sure to set the redirect URL to `http: <Callout type="info"> Twitter API v2 now supports email address retrieval. Make sure to request the `user.email` scope when configuring your Twitter app to enable this feature. </Callout> </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { twitter: { clientId: process.env.TWITTER_CLIENT_ID as string, clientSecret: process.env.TWITTER_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Twitter To sign in with Twitter, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `twitter`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "twitter" }) } ``` </Step> </Steps> # authentication: VK URL: /docs/authentication/vk Source: https: VK ID Provider *** title: VK description: VK ID Provider --------------------------- <Steps> <Step> ### Get your VK ID credentials To use VK ID sign in, you need a client ID and client secret. You can get them from the [VK ID Developer Portal](https: Make sure to set the redirect URL to `http: </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth"; export const auth = betterAuth({ socialProviders: { vk: { clientId: process.env.VK_CLIENT_ID as string, clientSecret: process.env.VK_CLIENT_SECRET as string, }, }, }); ``` </Step> <Step> ### Sign In with VK To sign in with VK, you can use the `signIn.social` function provided by the client. The `signIn` function takes an object with the following properties: * `provider`: The provider to use. It should be set to `vk`. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client"; const authClient = createAuthClient(); const signIn = async () => { const data = await authClient.signIn.social({ provider: "vk", }); }; ``` </Step> </Steps> # authentication: Zoom URL: /docs/authentication/zoom Source: https: Zoom provider setup and usage. *** title: Zoom description: Zoom provider setup and usage. ------------------------------------------- <Steps> <Step> ### Create a Zoom App from Marketplace 1. Visit [Zoom Marketplace](https: 2. Hover on the `Develop` button and select `Build App` 3. Select `General App` and click `Create` </Step> <Step> ### Configure your Zoom App Ensure that you are in the `Basic Information` of your app settings. 1. Under `Select how the app is managed`, choose `User-managed` 2. Under `App Credentials`, copy your `Client ID` and `Client Secret` and store them in a safe location 3. Under `OAuth Information` -> `OAuth Redirect URL`, add your Callback URL. For example, ``` http: ``` <Callout> For production, you should set it to the URL of your application. If you change the base path of the auth routes, you should update the redirect URL accordingly. </Callout> Skip to the `Scopes` section, then 1. Click the `Add Scopes` button 2. Search for `user:read:user` (View a user) and select it 3. Add any other scopes your applications needs and click `Done` </Step> <Step> ### Configure the provider To configure the provider, you need to import the provider and pass it to the `socialProviders` option of the auth instance. ```ts title="auth.ts" import { betterAuth } from "better-auth" export const auth = betterAuth({ socialProviders: { zoom: { clientId: process.env.ZOOM_CLIENT_ID as string, clientSecret: process.env.ZOOM_CLIENT_SECRET as string, }, }, }) ``` </Step> <Step> ### Sign In with Zoom To sign in with Zoom, you can use the `signIn.social` function provided by the client. You will need to specify `zoom` as the provider. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" const authClient = createAuthClient() const signIn = async () => { const data = await authClient.signIn.social({ provider: "zoom" }) } ``` </Step> </Steps> # concepts: API URL: /docs/concepts/api Source: https: Better Auth API. *** title: API description: Better Auth API. ----------------------------- When you create a new Better Auth instance, it provides you with an `api` object. This object exposes every endpoint that exist in your Better Auth instance. And you can use this to interact with Better Auth server side. Any endpoint added to Better Auth, whether from plugins or the core, will be accessible through the `api` object. ## Calling API Endpoints on the Server To call an API endpoint on the server, import your `auth` instance and call the endpoint using the `api` object. ```ts title="server.ts" export const auth = betterAuth({ }) await auth.api.getSession({ headers: await headers() }) ``` ### Body, Headers, Query Unlike the client, the server needs the values to be passed as an object with the key `body` for the body, `headers` for the headers, and `query` for query parameters. ```ts title="server.ts" await auth.api.getSession({ headers: await headers() }) await auth.api.signInEmail({ body: { email: "john@doe.com", password: "password" }, headers: await headers() }) await auth.api.verifyEmail({ query: { token: "my_token" } }) ``` <Callout> Better auth API endpoints are built on top of [better-call](https: </Callout> ### Getting `headers` and `Response` Object When you invoke an API endpoint on the server, it will return a standard JavaScript object or array directly as it's just a regular function call. But there are times where you might want to get the `headers` or the `Response` object instead. For example, if you need to get the cookies or the headers. #### Getting `headers` To get the `headers`, you can pass the `returnHeaders` option to the endpoint. ```ts const { headers, response } = await auth.api.signUpEmail({ returnHeaders: true, body: { email: "john@doe.com", password: "password", name: "John Doe", }, }); ``` The `headers` will be a `Headers` object. Which you can use to get the cookies or the headers. ```ts const cookies = headers.get("set-cookie"); const headers = headers.get("x-custom-header"); ``` #### Getting `Response` Object To get the `Response` object, you can pass the `asResponse` option to the endpoint. ```ts title="server.ts" const response = await auth.api.signInEmail({ body: { email: "", password: "" }, asResponse: true }) ``` ### Error Handling When you call an API endpoint in the server, it will throw an error if the request fails. You can catch the error and handle it as you see fit. The error instance is an instance of `APIError`. ```ts title="server.ts" try { await auth.api.signInEmail({ body: { email: "", password: "" } }) } catch (error) { if (error instanceof APIError) { console.log(error.message, error.status) } } ``` # concepts: CLI URL: /docs/concepts/cli Source: https: Built-in CLI for managing your project. *** title: CLI description: Built-in CLI for managing your project. ---------------------------------------------------- Better Auth comes with a built-in CLI to help you manage the database schemas, initialize your project, and generate a secret key for your application. ## Generate The `generate` command creates the schema required by Better Auth. If you're using a database adapter like Prisma or Drizzle, this command will generate the right schema for your ORM. If you're using the built-in Kysely adapter, it will generate an SQL file you can run directly on your database. ```bash title="Terminal" npx @better-auth/cli@latest generate ``` ### Options * `--output` - Where to save the generated schema. For Prisma, it will be saved in prisma/schema.prisma. For Drizzle, it goes to schema.ts in your project root. For Kysely, it’s an SQL file saved as schema.sql in your project root. * `--config` - The path to your Better Auth config file. By default, the CLI will search for a auth.ts file in **. newPassword: string = "newpassword1234" currentPassword: string = "oldpassword1234" revokeOtherSessions?: boolean = true } ``` </APIMethod> ### Set Password If a user was registered using OAuth or other providers, they won't have a password or a credential account. In this case, you can use the `setPassword` action to set a password for the user. For security reasons, this function can only be called from the server. We recommend having users go through a 'forgot password' flow to set a password for their account. ```ts await auth.api.setPassword({ body: { newPassword: "password" }, headers: }); ``` ## Delete User Better Auth provides a utility to hard delete a user from your database. It's disabled by default, but you can enable it easily by passing `enabled:true` ```ts export const auth = betterAuth({ user: { deleteUser: { enabled: true } } }) ``` Once enabled, you can call `authClient.deleteUser` to permanently delete user data from your database. ### Adding Verification Before Deletion For added security, you’ll likely want to confirm the user’s intent before deleting their account. A common approach is to send a verification email. Better Auth provides a `sendDeleteAccountVerification` utility for this purpose. This is especially needed if you have OAuth setup and want them to be able to delete their account without forcing them to login again for a fresh session. Here’s how you can set it up: ```ts export const auth = betterAuth({ user: { deleteUser: { enabled: true, sendDeleteAccountVerification: async ( { user, url, token }, request ) => { }, }, }, }); ``` **How callback verification works:** * **Callback URL**: The URL provided in `sendDeleteAccountVerification` is a pre-generated link that deletes the user data when accessed. ```ts title="delete-user.ts" await authClient.deleteUser({ callbackURL: "/goodbye" }); ``` * **Authentication Check**: The user must be signed in to the account they’re attempting to delete. If they aren’t signed in, the deletion process will fail. If you have sent a custom URL, you can use the `deleteUser` method with the token to delete the user. ```ts title="delete-user.ts" await authClient.deleteUser({ token }); ``` ### Authentication Requirements To delete a user, the user must meet one of the following requirements: 1. A valid password if the user has a password, they can delete their account by providing the password. ```ts title="delete-user.ts" await authClient.deleteUser({ password: "password" }); ``` 2. Fresh session The user must have a `fresh` session token, meaning the user must have signed in recently. This is checked if the password is not provided. <Callout type="warn"> By default `session.freshAge` is set to `60 * 60 * 24` (1 day). You can change this value by passing the `session` object to the `auth` configuration. If it is set to `0`, the freshness check is disabled. It is recommended not to disable this check if you are not using email verification for deleting the account. </Callout> ```ts title="delete-user.ts" await authClient.deleteUser(); ``` 3. Enabled email verification (needed for OAuth users) As OAuth users don't have a password, we need to send a verification email to confirm the user's intent to delete their account. If you have already added the `sendDeleteAccountVerification` callback, you can just call the `deleteUser` method without providing any other information. ```ts title="delete-user.ts" await authClient.deleteUser(); ``` 4. If you have a custom delete account page and sent that url via the `sendDeleteAccountVerification` callback. Then you need to call the `deleteUser` method with the token to complete the deletion. ```ts title="delete-user.ts" await authClient.deleteUser({ token }); ``` ### Callbacks **beforeDelete**: This callback is called before the user is deleted. You can use this callback to perform any cleanup or additional checks before deleting the user. ```ts title="auth.ts" export const auth = betterAuth({ user: { deleteUser: { enabled: true, beforeDelete: async (user) => { }, }, }, }); ``` you can also throw `APIError` to interrupt the deletion process. ```ts title="auth.ts" export const auth = betterAuth({ user: { deleteUser: { enabled: true, beforeDelete: async (user, request) => { if (user.email.includes("admin")) { throw new APIError("BAD_REQUEST", { message: "Admin accounts can't be deleted", }); } }, }, }, }); ``` **afterDelete**: This callback is called after the user is deleted. You can use this callback to perform any cleanup or additional actions after the user is deleted. ```ts title="auth.ts" export const auth = betterAuth({ user: { deleteUser: { enabled: true, afterDelete: async (user, request) => { }, }, }, }); ``` ## Accounts Better Auth supports multiple authentication methods. Each authentication method is called a provider. For example, email and password authentication is a provider, Google authentication is a provider, etc. When a user signs in using a provider, an account is created for the user. The account stores the authentication data returned by the provider. This data includes the access token, refresh token, and other information returned by the provider. The account table stores the authentication data of the user [Click here to view the schema](/docs/concepts/database#account) ### List User Accounts To list user accounts you can use `client.user.listAccounts` method. Which will return all accounts associated with a user. ```ts const accounts = await authClient.listAccounts(); ``` ### Token Encryption Better Auth doesn’t encrypt tokens by default and that’s intentional. We want you to have full control over how encryption and decryption are handled, rather than baking in behavior that could be confusing or limiting. If you need to store encrypted tokens (like accessToken or refreshToken), you can use databaseHooks to encrypt them before they’re saved to your database. ```ts export const auth = betterAuth({ databaseHooks: { account: { create: { before(account, context) { const withEncryptedTokens = { ...account }; if (account.accessToken) { const encryptedAccessToken = encrypt(account.accessToken) withEncryptedTokens.accessToken = encryptedAccessToken; } if (account.refreshToken) { const encryptedRefreshToken = encrypt(account.refreshToken); withEncryptedTokens.refreshToken = encryptedRefreshToken; } return { data: resultAccount } }, } } } }) ``` Then whenever you retrieve back the account make sure to decrypt the tokens before using them. ### Account Linking Account linking enables users to associate multiple authentication methods with a single account. With Better Auth, users can connect additional social sign-ons or OAuth providers to their existing accounts if the provider confirms the user's email as verified. If account linking is disabled, no accounts can be linked, regardless of the provider or email verification status. ```ts title="auth.ts" export const auth = betterAuth({ account: { accountLinking: { enabled: true, } }, }); ``` #### Forced Linking You can specify a list of "trusted providers." When a user logs in using a trusted provider, their account will be automatically linked even if the provider doesn’t confirm the email verification status. Use this with caution as it may increase the risk of account takeover. ```ts title="auth.ts" export const auth = betterAuth({ account: { accountLinking: { enabled: true, trustedProviders: ["google", "github"] } }, }); ``` #### Manually Linking Accounts Users already signed in can manually link their account to additional social providers or credential-based accounts. * **Linking Social Accounts:** Use the `linkSocial` method on the client to link a social provider to the user's account. ```ts await authClient.linkSocial({ provider: "google", callbackURL: "/callback" }); ``` You can also request specific scopes when linking a social account, which can be different from the scopes used during the initial authentication: ```ts await authClient.linkSocial({ provider: "google", callbackURL: "/callback", scopes: ["https: }); ``` You can also link accounts using ID tokens directly, without redirecting to the provider's OAuth flow: ```ts await authClient.linkSocial({ provider: "google", idToken: { token: "id_token_from_provider", nonce: "nonce_used_for_token", accessToken: "access_token", refreshToken: "refresh_token" } }); ``` This is useful when you already have valid tokens from the provider, for example: * After signing in with a native SDK * When using a mobile app that handles authentication * When implementing custom OAuth flows The ID token must be valid and the provider must support ID token verification. If you want your users to be able to link a social account with a different email address than the user, or if you want to use a provider that does not return email addresses, you will need to enable this in the account linking settings. ```ts title="auth.ts" export const auth = betterAuth({ account: { accountLinking: { allowDifferentEmails: true } }, }); ``` If you want the newly linked accounts to update the user information, you need to enable this in the account linking settings. ```ts title="auth.ts" export const auth = betterAuth({ account: { accountLinking: { updateUserInfoOnLink: true } }, }); ``` * **Linking Credential-Based Accounts:** To link a credential-based account (e.g., email and password), users can initiate a "forgot password" flow, or you can call the `setPassword` method on the server. ```ts await auth.api.setPassword({ headers: , password: }); ``` <Callout> `setPassword` can't be called from the client for security reasons. </Callout> ### Account Unlinking You can unlink a user account by providing a `providerId`. ```ts await authClient.unlinkAccount({ providerId: "google" }); await authClient.unlinkAccount({ providerId: "google", accountId: "123" }); ``` If the account doesn't exist, it will throw an error. Additionally, if the user only has one account, the unlinking process will fail to prevent account lockout unless `allowUnlinkingAll` is set to `true`. ```ts title="auth.ts" export const auth = betterAuth({ account: { accountLinking: { allowUnlinkingAll: true } }, }); ``` # examples: Astro Example URL: /docs/examples/astro Source: https: Better Auth Astro example. *** title: Astro Example description: Better Auth Astro example. --------------------------------------- This is an example of how to use Better Auth with Astro. It uses Solid for building the components. **Implements the following features:** Email & Password . Social Sign-in with Google . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management <ForkButton url="better-auth/better-auth/tree/main/examples/astro-example" /> <iframe src="https: style={{ width: "100%", height: "500px", border: 0, borderRadius: "4px", overflow: "hidden" }} title="Better Auth Astro+Solid Example" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts" /> ## How to run 1. Clone the code sandbox (or the repo) and open it in your code editor 2. Provide .env file with the following variables ```txt GOOGLE_CLIENT_ID= GOOGLE_CLIENT_SECRET= BETTER_AUTH_SECRET= ``` 3. Run the following commands ```bash pnpm install pnpm run dev ``` 4. Open the browser and navigate to `http: # examples: Next.js Example URL: /docs/examples/next-js Source: https: Better Auth Next.js example. *** title: Next.js Example description: Better Auth Next.js example. ----------------------------------------- This is an example of how to use Better Auth with Next. **Implements the following features:** Email & Password . Social Sign-in . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management . Organization, Members and Roles See [Demo](https: <ForkButton url="better-auth/better-auth/tree/main/demo/nextjs" /> <iframe src="https: style={{ width: "100%", height: "500px", border: 0, borderRadius: "4px", overflow: "hidden" }} title="Better Auth Next.js Example" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts" /> ## How to run 1. Clone the code sandbox (or the repo) and open it in your code editor 2. Move .env.example to .env and provide necessary variables 3. Run the following commands ```bash pnpm install pnpm dev ``` 4. Open the browser and navigate to `http: # examples: Nuxt Example URL: /docs/examples/nuxt Source: https: Better Auth Nuxt example. *** title: Nuxt Example description: Better Auth Nuxt example. -------------------------------------- This is an example of how to use Better Auth with Nuxt. **Implements the following features:** Email & Password . Social Sign-in with Google <ForkButton url="better-auth/better-auth/tree/main/examples/nuxt-example" /> <iframe src="https: style={{ width: "100%", height: "500px", border: 0, borderRadius: "4px", overflow: "hidden" }} title="Better Auth Nuxt Example" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts" /> ## How to run 1. Clone the code sandbox (or the repo) and open it in your code editor 2. Move .env.example to .env and provide necessary variables 3. Run the following commands ```bash pnpm install pnpm dev ``` 4. Open the browser and navigate to `http: # examples: Remix Example URL: /docs/examples/remix Source: https: Better Auth Remix example. *** title: Remix Example description: Better Auth Remix example. --------------------------------------- This is an example of how to use Better Auth with Remix. **Implements the following features:** Email & Password . Social Sign-in with Google . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management <ForkButton url="better-auth/better-auth/tree/main/examples/remix-example" /> <iframe src="https: style={{ width: "100%", height: "500px", border: 0, borderRadius: "4px", overflow: "hidden" }} title="Better Auth Remix Example" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts" /> ## How to run 1. Clone the code sandbox (or the repo) and open it in your code editor 2. Provide .env file with by copying the `.env.example` file and adding the variables 3. Run the following commands ```bash pnpm install pnpm run dev ``` 4. Open the browser and navigate to `http: # examples: SvelteKit Example URL: /docs/examples/svelte-kit Source: https: Better Auth SvelteKit example. *** title: SvelteKit Example description: Better Auth SvelteKit example. ------------------------------------------- This is an example of how to use Better Auth with SvelteKit. **Implements the following features:** Email & Password . <u>Social Sign-in with Google</u> . Passkeys . Email Verification . Password Reset . Two Factor Authentication . Profile Update . Session Management <ForkButton url="better-auth/better-auth/tree/main/examples/svelte-kit-example" /> <iframe src="https: style={{ width: "100%", height: "500px", border: 0, borderRadius: "4px", overflow: "hidden" }} title="Better Auth SvelteKit Example" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts" /> ## How to run 1. Clone the code sandbox (or the repo) and open it in your code editor 2. Move .env.example to .env and provide necessary variables 3. Run the following commands ```bash pnpm install pnpm dev ``` 4. Open the browser and navigate to `http: # guides: Browser Extension Guide URL: /docs/guides/browser-extension-guide Source: https: A step-by-step guide to creating a browser extension with Better Auth. *** title: Browser Extension Guide description: A step-by-step guide to creating a browser extension with Better Auth. ----------------------------------------------------------------------------------- In this guide, we'll walk you through the steps of creating a browser extension using <Link href="https: If you would like to view a completed example, you can check out the <Link href="https: <Callout type="warn"> The Plasmo framework does not provide a backend for the browser extension. This guide assumes you have{" "} <Link href="/docs/integrations/hono">a backend setup</Link> of Better Auth and are ready to create a browser extension to connect to it. </Callout> <Steps> <Step> ## Setup & Installations Initialize a new Plasmo project with TailwindCSS and a src directory. ```bash pnpm create plasmo --with-tailwindcss --with-src ``` Then, install the Better Auth package. ```bash pnpm add better-auth ``` To start the Plasmo development server, run the following command. ```bash pnpm dev ``` </Step> <Step> ## Configure tsconfig Configure the `tsconfig.json` file to include `strict` mode. For this demo, we have also changed the import alias from `~` to `@` and set it to the `src` directory. ```json title="tsconfig.json" { "compilerOptions": { "paths": { "@/_": [ "./src/_" ] }, "strict": true, "baseUrl": "." } } ``` </Step> <Step> ## Create the client auth instance Create a new file at `src/auth/auth-client.ts` and add the following code. <Files> <Folder name="src" defaultOpen> <Folder name="auth" defaultOpen> <File name="auth-client.ts" /> </Folder> </Folder> </Files> ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/react" export const authClient = createAuthClient({ baseURL: "http: plugins: [], }); ``` </Step> <Step> ## Configure the manifest We must ensure the extension knows the URL to the Better Auth backend. Head to your package.json file, and add the following code. ```json title="package.json" { "manifest": { "host_permissions": [ "https: ] } } ``` </Step> <Step> ## You're now ready! You have now set up Better Auth for your browser extension. Add your desired UI and create your dream extension! To learn more about the client Better Auth API, check out the <Link href="/docs/concepts/client">client documentation</Link>. Here's a quick example 😎 ```tsx title="src/popup.tsx" import { authClient } from "./auth/auth-client" function IndexPopup() { const {data, isPending, error} = authClient.useSession(); if(isPending){ return <>Loading...</> } if(error){ return <>Error: {error.message}</> } if(data){ return <>Signed in as {data.user.name}</> } } export default IndexPopup; ``` </Step> <Step> ## Bundle your extension To get a production build, run the following command. ```bash pnpm build ``` Head over to <Link href="chrome: <img src="https: Click on "Load Unpacked" and navigate to your extension's `build/chrome-mv3-dev` (or `build/chrome-mv3-prod`) directory. To see your popup, click on the puzzle piece icon on the Chrome toolbar, and click on your extension. Learn more about <Link href="https: </Step> <Step> ## Configure the server auth instance First, we will need your extension URL. An extension URL formed like this: `chrome-extension: You can find your extension ID at <Link href="chrome: <img src="/extension-id.png" width={500} /> Head to your server's auth file, and make sure that your extension's URL is added to the `trustedOrigins` list. ```ts title="server.ts" import { betterAuth } from "better-auth" import { auth } from "@/auth/auth" export const auth = betterAuth({ trustedOrigins: ["chrome-extension: }) ``` If you're developing multiple extensions or need to support different browser extensions with different IDs, you can use wildcard patterns: ```ts title="server.ts" export const auth = betterAuth({ trustedOrigins: [ "chrome-extension: "chrome-extension: ], }) ``` <Callout type="warn"> Using wildcards for extension origins (`chrome-extension: It's safer to explicitly list each extension ID you trust. Only use wildcards for development and testing. </Callout> </Step> <Step> ## That's it! Everything is set up! You can now start developing your extension. 🎉 </Step> </Steps> ## Wrapping Up Congratulations! You've successfully created a browser extension using Better Auth and Plasmo. We highly recommend you visit the <Link href="https: If you would like to view a completed example, you can check out the <Link href="https: If you have any questions, feel free to open an issue on our <Link href="https: # guides: Migrating from Clerk to Better Auth URL: /docs/guides/clerk-migration-guide Source: https: A step-by-step guide to transitioning from Clerk to Better Auth. *** title: Migrating from Clerk to Better Auth description: A step-by-step guide to transitioning from Clerk to Better Auth. ----------------------------------------------------------------------------- In this guide, we'll walk through the steps to migrate a project from Clerk to Better Auth — including email/password with proper hashing, social/external accounts, phone number, two-factor data, and more. <Callout type="warn"> This migration will invalidate all active sessions. This guide doesn't currently show you how to migrate Organization but it should be possible with additional steps and the [Organization](/docs/plugins/organization) Plugin. </Callout> ## Before You Begin Before starting the migration process, set up Better Auth in your project. Follow the [installation guide](/docs/installation) to get started. And go to <Steps> <Step> ### Connect to your database You'll need to connect to your database to migrate the users and accounts. You can use any database you want, but for this example, we'll use PostgreSQL. <Tabs items={}> <Tab value="npm"> ```bash npm install pg ``` </Tab> <Tab value="pnpm"> ```bash pnpm add pg ``` </Tab> <Tab value="yarn"> ```bash yarn add pg ``` </Tab> <Tab value="bun"> ```bash bun add pg ``` </Tab> </Tabs> And then you can use the following code to connect to your database. ```ts title="auth.ts" import { Pool } from "pg"; export const auth = betterAuth({ database: new Pool({ connectionString: process.env.DATABASE_URL }), }) ``` </Step> <Step> ### Enable Email and Password (Optional) Enable the email and password in your auth config and implement your own logic for sending verification emails, reset password emails, etc. ```ts title="auth.ts" import { betterAuth } from "better-auth"; export const auth = betterAuth({ database: new Pool({ connectionString: process.env.DATABASE_URL }), emailAndPassword: { enabled: true, }, emailVerification: { sendVerificationEmail: async({ user, url })=>{ } }, }) ``` See [Email and Password](/docs/authentication/email-password) for more configuration options. </Step> <Step> ### Setup Social Providers (Optional) Add social providers you have enabled in your Clerk project in your auth config. ```ts title="auth.ts" import { betterAuth } from "better-auth"; export const auth = betterAuth({ database: new Pool({ connectionString: process.env.DATABASE_URL }), emailAndPassword: { enabled: true, }, socialProviders: { github: { clientId: process.env.GITHUB_CLIENT_ID, clientSecret: process.env.GITHUB_CLIENT_SECRET, } } }) ``` </Step> <Step> ### Add Plugins (Optional) You can add the following plugins to your auth config based on your needs. [Admin](/docs/plugins/admin) Plugin will allow you to manage users, user impersonations and app level roles and permissions. [Two Factor](/docs/plugins/2fa) Plugin will allow you to add two-factor authentication to your application. [Phone Number](/docs/plugins/phone-number) Plugin will allow you to add phone number authentication to your application. [Username](/docs/plugins/username) Plugin will allow you to add username authentication to your application. ```ts title="auth.ts" import { Pool } from "pg"; import { betterAuth } from "better-auth"; import { admin, twoFactor, phoneNumber, username } from "better-auth/plugins"; export const auth = betterAuth({ database: new Pool({ connectionString: process.env.DATABASE_URL }), emailAndPassword: { enabled: true, }, socialProviders: { github: { clientId: process.env.GITHUB_CLIENT_ID!, clientSecret: process.env.GITHUB_CLIENT_SECRET!, } }, plugins: [admin(), twoFactor(), phoneNumber(), username()], }) ``` </Step> <Step> ### Generate Schema If you're using a custom database adapter, generate the schema: ```sh npx @better-auth/cli generate ``` or if you're using the default adapter, you can use the following command: ```sh npx @better-auth/cli migrate ``` </Step> <Step> ### Export Clerk Users Go to the Clerk dashboard and export the users. Check how to do it [here](https: </Step> <Step> ### Create the migration script Create a new file called `migrate-clerk.ts` in the `scripts` folder and add the following code: ```ts title="scripts/migrate-clerk.ts" import { generateRandomString, symmetricEncrypt } from "better-auth/crypto"; import { auth } from "@/lib/auth"; function getCSVData(csv: string) { const lines = csv.split('\n').filter(line => line.trim()); const headers = lines[0]?.split(',').map(header => header.trim()) || []; const jsonData = lines.slice(1).map(line => { const values = line.split(',').map(value => value.trim()); return headers.reduce((obj, header, index) => { obj[header] = values[index] || ''; return obj; }, {} as Record<string, string>); }); return jsonData as Array<{ id: string; first_name: string; last_name: string; username: string; primary_email_address: string; primary_phone_number: string; verified_email_addresses: string; unverified_email_addresses: string; verified_phone_numbers: string; unverified_phone_numbers: string; totp_secret: string; password_digest: string; password_hasher: string; }>; } const exportedUserCSV = await Bun.file("exported_users.csv").text(); async function getClerkUsers(totalUsers: number) { const clerkUsers: { id: string; first_name: string; last_name: string; username: string; image_url: string; password_enabled: boolean; two_factor_enabled: boolean; totp_enabled: boolean; backup_code_enabled: boolean; banned: boolean; locked: boolean; lockout_expires_in_seconds: number; created_at: number; updated_at: number; external_accounts: { id: string; provider: string; identification_id: string; provider_user_id: string; approved_scopes: string; email_address: string; first_name: string; last_name: string; image_url: string; created_at: number; updated_at: number; }[] }[] = []; for (let i = 0; i < totalUsers; i += 500) { const response = await fetch(`https: headers: { 'Authorization': `Bearer ${process.env.CLERK_SECRET_KEY}` } }); if (!response.ok) { throw new Error(`Failed to fetch users: ${response.statusText}`); } const clerkUsersData = await response.json(); clerkUsers.push(...clerkUsersData as any); } return clerkUsers; } export async function generateBackupCodes( secret: string, ) { const key = secret; const backupCodes = Array.from({ length: 10 }) .fill(null) .map(() => generateRandomString(10, "a-z", "0-9", "A-Z")) .map((code) => `${code.slice(0, 5)}-${code.slice(5)}`); const encCodes = await symmetricEncrypt({ data: JSON.stringify(backupCodes), key: key, }); return encCodes } function safeDateConversion(timestamp?: number): Date { if (!timestamp) return new Date(); const date = new Date(timestamp * 1000); if (isNaN(date.getTime())) { console.warn(`Invalid timestamp: ${timestamp}, falling back to current date`); return new Date(); } const year = date.getFullYear(); if (year < 2000 || year > 2100) { console.warn(`Suspicious date year: ${year}, falling back to current date`); return new Date(); } return date; } async function migrateFromClerk() { const jsonData = getCSVData(exportedUserCSV); const clerkUsers = await getClerkUsers(jsonData.length); const ctx = await auth.$context const isAdminEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "admin"); const isTwoFactorEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "two-factor"); const isUsernameEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "username"); const isPhoneNumberEnabled = ctx.options?.plugins?.find(plugin => plugin.id === "phone-number"); for (const user of jsonData) { const { id, first_name, last_name, username, primary_email_address, primary_phone_number, verified_email_addresses, unverified_email_addresses, verified_phone_numbers, unverified_phone_numbers, totp_secret, password_digest, password_hasher } = user; const clerkUser = clerkUsers.find(clerkUser => clerkUser?.id === id); const createdUser = await ctx.adapter.create<{ id: string; }>({ model: "user", data: { id, email: primary_email_address, emailVerified: verified_email_addresses.length > 0, name: `${first_name} ${last_name}`, image: clerkUser?.image_url, createdAt: safeDateConversion(clerkUser?.created_at), updatedAt: safeDateConversion(clerkUser?.updated_at), ...(isTwoFactorEnabled ? { twoFactorEnabled: clerkUser?.two_factor_enabled } : {}), ...(isAdminEnabled ? { banned: clerkUser?.banned, banExpiresAt: clerkUser?.lockout_expires_in_seconds, role: "user" } : {}), ...(isUsernameEnabled ? { username: username, } : {}), ...(isPhoneNumberEnabled ? { phoneNumber: primary_phone_number, phoneNumberVerified: verified_phone_numbers.length > 0, } : {}), }, forceAllowId: true }).catch(async e => { return await ctx.adapter.findOne<{ id: string; }>({ model: "user", where: [{ field: "id", value: id }] }) }) const externalAccounts = clerkUser?.external_accounts; if (externalAccounts) { for (const externalAccount of externalAccounts) { const { id, provider, identification_id, provider_user_id, approved_scopes, email_address, first_name, last_name, image_url, created_at, updated_at } = externalAccount; if (externalAccount.provider === "credential") { await ctx.adapter.create({ model: "account", data: { id, providerId: provider, accountId: externalAccount.provider_user_id, scope: approved_scopes, userId: createdUser?.id, createdAt: safeDateConversion(created_at), updatedAt: safeDateConversion(updated_at), password: password_digest, } }) } else { await ctx.adapter.create({ model: "account", data: { id, providerId: provider.replace("oauth_", ""), accountId: externalAccount.provider_user_id, scope: approved_scopes, userId: createdUser?.id, createdAt: safeDateConversion(created_at), updatedAt: safeDateConversion(updated_at), }, forceAllowId: true }) } } } if (isTwoFactorEnabled) { await ctx.adapter.create({ model: "twoFactor", data: { userId: createdUser?.id, secret: totp_secret, backupCodes: await generateBackupCodes(totp_secret) } }) } } } migrateFromClerk() .then(() => { console.log('Migration completed'); process.exit(0); }) .catch((error) => { console.error('Migration failed:', error); process.exit(1); }); ``` Make sure to replace the `process.env.CLERK_SECRET_KEY` with your own Clerk secret key. Feel free to customize the script to your needs. </Step> <Step> ### Run the migration Run the migration: ```sh bun run script/migrate-clerk.ts # you can use any thing you like to run the script ``` <Callout type="warning"> Make sure to: 1. Test the migration in a development environment first 2. Monitor the migration process for any errors 3. Verify the migrated data in Better Auth before proceeding 4. Keep Clerk installed and configured until the migration is complete </Callout> </Step> <Step> ### Verify the migration After running the migration, verify that all users have been properly migrated by checking the database. </Step> <Step> ### Update your components Now that the data is migrated, you can start updating your components to use Better Auth. Here's an example for the sign-in component: ```tsx title="components/auth/sign-in.tsx" import { authClient } from "better-auth/client"; export const SignIn = () => { const handleSignIn = async () => { const { data, error } = await authClient.signIn.email({ email: "user@example.com", password: "password", }); if (error) { console.error(error); return; } }; return ( <form onSubmit={handleSignIn}> <button type="submit">Sign in</button> </form> ); }; ``` </Step> <Step> ### Update the middleware Replace your Clerk middleware with Better Auth's middleware: ```ts title="middleware.ts" import { NextRequest, NextResponse } from "next/server"; import { getSessionCookie } from "better-auth/cookies"; export async function middleware(request: NextRequest) { const sessionCookie = getSessionCookie(request); const { pathname } = request.nextUrl; if (sessionCookie && ["/login", "/signup"].includes(pathname)) { return NextResponse.redirect(new URL("/dashboard", request.url)); } if (!sessionCookie && pathname.startsWith("/dashboard")) { return NextResponse.redirect(new URL("/login", request.url)); } return NextResponse.next(); } export const config = { matcher: ["/dashboard", "/login", "/signup"], }; ``` </Step> <Step> ### Remove Clerk Dependencies Once you've verified that everything is working correctly with Better Auth, you can remove Clerk: ```bash title="Remove Clerk" pnpm remove @clerk/nextjs @clerk/themes @clerk/types ``` </Step> </Steps> ## Additional Resources [Goodbye Clerk, Hello Better Auth – Full Migration Guide!](https: ## Wrapping Up Congratulations! You've successfully migrated from Clerk to Better Auth. Better Auth offers greater flexibility and more features—be sure to explore the [documentation](/docs) to unlock its full potential. # guides: Create a Database Adapter URL: /docs/guides/create-a-db-adapter Source: https: Learn how to create a custom database adapter for Better-Auth *** title: Create a Database Adapter description: Learn how to create a custom database adapter for Better-Auth -------------------------------------------------------------------------- Learn how to create a custom database adapter for Better-Auth using `createAdapter`. Our `createAdapter` function is designed to be very flexible, and we've done our best to make it easy to understand and use. Our hope is to allow you to focus on writing database logic, and not have to worry about how the adapter is working with Better-Auth. Anything from custom schema configurations, custom ID generation, safe JSON parsing, and more is handled by the `createAdapter` function. All you need to do is provide the database logic, and the `createAdapter` function will handle the rest. ## Quick Start <Steps> <Step> ### Get things ready 1. Import `createAdapter`. 2. Create `CustomAdapterConfig` interface that represents your adapter config options. 3. Create the adapter! ```ts import { createAdapter, type AdapterDebugLogs } from "better-auth/adapters"; interface CustomAdapterConfig { debugLogs?: AdapterDebugLogs; usePlural?: boolean; } export const myAdapter = (config: CustomAdapterConfig = {}) => createAdapter({ }); ``` </Step> <Step> ### Configure the adapter The `config` object is mostly used to provide information about the adapter to Better-Auth. We try to minimize the amount of code you need to write in your adapter functions, and these `config` options are used to help us do that. ```ts export const myAdapter = (config: CustomAdapterConfig = {}) => createAdapter({ config: { adapterId: "custom-adapter", adapterName: "Custom Adapter", usePlural: config.usePlural ?? false, debugLogs: config.debugLogs ?? false, supportsJSON: false, supportsDates: true, supportsBooleans: true, supportsNumericIds: true, }, }); ``` </Step> <Step> ### Create the adapter The `adapter` function is where you write the code that interacts with your database. ```ts export const myAdapter = (config: CustomAdapterConfig = {}) => createAdapter({ config: { }, adapter: ({}) => { return { create: async ({ data, model, select }) => { }, update: async ({ data, model, select }) => { }, updateMany: async ({ data, model, select }) => { }, delete: async ({ data, model, select }) => { }, }; }, }); ``` <Callout> Learn more about the `adapter` here [here](/docs/concepts/database#adapters). </Callout> </Step> </Steps> ## Adapter The `adapter` function is where you write the code that interacts with your database. If you haven't already, check out the `options` object in the [config section](#config), as it can be useful for your adapter. Before we get into the adapter function, let's go over the parameters that are available to you. * `options`: The Better Auth options. * `schema`: The schema from the user's Better Auth instance. * `debugLog`: The debug log function. * `getField`: The get field function. * `getDefaultModelName`: The get default model name function. * `getDefaultFieldName`: The get default field name function. * `getFieldAttributes`: The get field attributes function. ```ts title="Example" adapter: ({ options, schema, debugLog, getField, getDefaultModelName, getDefaultFieldName, }) => { return { }; }; ``` ### Adapter Methods * All `model` values are already transformed into the correct model name for the database based on the end-user's schema configuration. * This also means that if you need access to the `schema` version of a given model, you can't use this exact `model` value, you'll need to use the `getDefaultModelName` function provided in the options to convert the `model` to the `schema` version. * We will automatically fill in any missing fields you return based on the user's `schema` configuration. * Any method that includes a `select` parameter, is only for the purpose of getting data from your database more efficiently. You do not need to worry about only returning what the `select` parameter states, as we will handle that for you. ### `create` method The `create` method is used to create a new record in the database. <Callout> Note: If the user has enabled the `useNumberId` option, or if `generateId` is `false` in the user's Better Auth config, then it's expected that the `id` is provided in the `data` object. Otherwise, the `id` will be automatically generated. Additionally, it's possible to pass `forceAllowId` as a parameter to the `create` method, which allows `id` to be provided in the `data` object. We handle `forceAllowId` internally, so you don't need to worry about it. </Callout> parameters: * `model`: The model/table name that new data will be inserted into. * `data`: The data to insert into the database. * `select`: An array of fields to return from the database. <Callout> Make sure to return the data that is inserted into the database. </Callout> ```ts title="Example" create: async ({ model, data, select }) => { return await db.insert(model).values(data); }; ``` ### `update` method The `update` method is used to update a record in the database. parameters: * `model`: The model/table name that the record will be updated in. * `where`: The `where` clause to update the record by. * `update`: The data to update the record with. <Callout> Make sure to return the data in the row which is updated. This includes any fields that were not updated. </Callout> ```ts title="Example" update: async ({ model, where, update }) => { return await db.update(model).set(update).where(where); }; ``` ### `updateMany` method The `updateMany` method is used to update multiple records in the database. parameters: * `model`: The model/table name that the records will be updated in. * `where`: The `where` clause to update the records by. * `update`: The data to update the records with. <Callout>Make sure to return the number of records that were updated.</Callout> ```ts title="Example" updateMany: async ({ model, where, update }) => { return await db.update(model).set(update).where(where); }; ``` ### `delete` method The `delete` method is used to delete a record from the database. parameters: * `model`: The model/table name that the record will be deleted from. * `where`: The `where` clause to delete the record by. ```ts title="Example" delete: async ({ model, where }) => { await db.delete(model).where(where); } ``` ### `deleteMany` method The `deleteMany` method is used to delete multiple records from the database. parameters: * `model`: The model/table name that the records will be deleted from. * `where`: The `where` clause to delete the records by. <Callout>Make sure to return the number of records that were deleted.</Callout> ```ts title="Example" deleteMany: async ({ model, where }) => { return await db.delete(model).where(where); }; ``` ### `findOne` method The `findOne` method is used to find a single record in the database. parameters: * `model`: The model/table name that the record will be found in. * `where`: The `where` clause to find the record by. * `select`: The `select` clause to return. <Callout>Make sure to return the data that is found in the database.</Callout> ```ts title="Example" findOne: async ({ model, where, select }) => { return await db.select().from(model).where(where).limit(1); }; ``` ### `findMany` method The `findMany` method is used to find multiple records in the database. parameters: * `model`: The model/table name that the records will be found in. * `where`: The `where` clause to find the records by. * `limit`: The limit of records to return. * `sortBy`: The `sortBy` clause to sort the records by. * `offset`: The offset of records to return. <Callout> Make sure to return the array of data that is found in the database. </Callout> ```ts title="Example" findMany: async ({ model, where, limit, sortBy, offset }) => { return await db .select() .from(model) .where(where) .limit(limit) .offset(offset) .orderBy(sortBy); }; ``` ### `count` method The `count` method is used to count the number of records in the database. parameters: * `model`: The model/table name that the records will be counted in. * `where`: The `where` clause to count the records by. <Callout>Make sure to return the number of records that were counted.</Callout> ```ts title="Example" count: async ({ model, where }) => { return await db.select().from(model).where(where).count(); }; ``` ### `options` (optional) The `options` object is for any potential config that you got from your custom adapter options. ```ts title="Example" const myAdapter = (config: CustomAdapterConfig) => createAdapter({ config: { }, adapter: ({ options }) => { return { options: config, }; }, }); ``` ### `createSchema` (optional) The `createSchema` method allows the [Better Auth CLI](/docs/concepts/cli) to [generate](/docs/concepts/cli/#generate) a schema for the database. parameters: * `tables`: The tables from the user's Better-Auth instance schema; which is expected to be generated into the schema file. * `file`: The file the user may have passed in to the `generate` command as the expected schema file output path. ```ts title="Example" createSchema: async ({ file, tables }) => { }; ``` ## Test your adapter We've provided a test suite that you can use to test your adapter. It requires you to use `vitest`. ```ts title="my-adapter.test.ts" describe("My Adapter Tests", async () => { afterAll(async () => { }); const adapter = myAdapter({ debugLogs: { isRunningAdapterTests: true, }, }); await runAdapterTest({ getAdapter: async (betterAuthOptions = {}) => { return adapter(betterAuthOptions); }, }); }); ``` ### Numeric ID tests If your database supports numeric IDs, then you should run this test as well: ```ts title="my-adapter.number-id.test.ts" describe("My Adapter Numeric ID Tests", async () => { afterAll(async () => { }); const adapter = myAdapter({ debugLogs: { isRunningAdapterTests: true, }, }); await runNumberIdAdapterTest({ getAdapter: async (betterAuthOptions = {}) => { return adapter(betterAuthOptions); }, }); }); ``` ## Config The `config` object is used to provide information about the adapter to Better-Auth. We **highly recommend** going through and reading each provided option below, as it will help you understand how to properly configure your adapter. ### Required Config ### `adapterId` A unique identifier for the adapter. ### `adapterName` The name of the adapter. ### Optional Config ### `supportsNumericIds` Whether the database supports numeric IDs. If this is set to `false` and the user's config has enabled `useNumberId`, then we will throw an error. ### `supportsJSON` Whether the database supports JSON. If the database doesn't support JSON, we will use a `string` to save the JSON data.And when we retrieve the data, we will safely parse the `string` back into a JSON object. ### `supportsDates` Whether the database supports dates. If the database doesn't support dates, we will use a `string` to save the date. (ISO string) When we retrieve the data, we will safely parse the `string` back into a `Date` object. ### `supportsBooleans` Whether the database supports booleans. If the database doesn't support booleans, we will use a `0` or `1` to save the boolean value. When we retrieve the data, we will safely parse the `0` or `1` back into a boolean value. ### `usePlural` Whether the table names in the schema are plural. This is often defined by the user, and passed down through your custom adapter options. If you do not intend to allow the user to customize the table names, you can ignore this option, or set this to `false`. ```ts title="Example" const adapter = myAdapter({ usePlural: true, }); ``` ### `debugLogs` Used to enable debug logs for the adapter. You can pass in a boolean, or an object with the following keys: `create`, `update`, `updateMany`, `findOne`, `findMany`, `delete`, `deleteMany`, `count`. If any of the keys are `true`, the debug logs will be enabled for that method. ```ts title="Example" const adapter = myAdapter({ debugLogs: true, }); ``` ```ts title="Example" const adapter = myAdapter({ debugLogs: { create: true, update: true, }, }); ``` ### `disableIdGeneration` Whether to disable ID generation. If this is set to `true`, then the user's `generateId` option will be ignored. ### `customIdGenerator` If your database only supports a specific custom ID generation, then you can use this option to generate your own IDs. ### `mapKeysTransformInput` If your database uses a different key name for a given situation, you can use this option to map the keys. This is useful for databases that expect a different key name for a given situation. For example, MongoDB uses `_id` while in Better-Auth we use `id`. Each key in the returned object represents the old key to replace. The value represents the new key. This can be a partial object that only transforms some keys. ```ts title="Example" mapKeysTransformInput: () => { return { id: "_id", }; }, ``` ### `mapKeysTransformOutput` If your database uses a different key name for a given situation, you can use this option to map the keys. This is useful for databases that use a different key name for a given situation. For example, MongoDB uses `_id` while in Better-Auth we use `id`. Each key in the returned object represents the old key to replace. The value represents the new key. This can be a partial object that only transforms some keys. ```ts title="Example" mapKeysTransformOutput: () => { return { _id: "id", }; }, ``` ### `customTransformInput` If you need to transform the input data before it is saved to the database, you can use this option to transform the data. <Callout type="warn"> If you're using `supportsJSON`, `supportsDates`, or `supportsBooleans`, then the transformations will be applied before your `customTransformInput` function is called. </Callout> The `customTransformInput` function receives the following arguments: * `data`: The data to transform. * `field`: The field that is being transformed. * `fieldAttributes`: The field attributes of the field that is being transformed. * `select`: The `select` values which the query expects to return. * `model`: The model that is being transformed. * `schema`: The schema that is being transformed. * `options`: Better Auth options. The `customTransformInput` function runs at every key in the data object of a given action. ```ts title="Example" customTransformInput: ({ field, data }) => { if (field === "id") { return "123"; } return data; }; ``` ### `customTransformOutput` If you need to transform the output data before it is returned to the user, you can use this option to transform the data. The `customTransformOutput` function is used to transform the output data. Similar to the `customTransformInput` function, it runs at every key in the data object of a given action, but it runs after the data is retrieved from the database. ```ts title="Example" customTransformOutput: ({ field, data }) => { if (field === "name") { return "Bob"; } return data; }; ``` ```ts const some_data = await adapter.create({ model: "user", data: { name: "John", }, }); console.log(some_data.name); ``` # guides: Migrating from NextAuth.js to Better Auth URL: /docs/guides/next-auth-migration-guide Source: https: A step-by-step guide to transitioning from NextAuth.js to Better Auth. *** title: Migrating from NextAuth.js to Better Auth description: A step-by-step guide to transitioning from NextAuth.js to Better Auth. ----------------------------------------------------------------------------------- In this guide, we’ll walk through the steps to migrate a project from [NextAuth.js](https: *** ## Before You Begin Before starting the migration process, set up Better Auth in your project. Follow the [installation guide](/docs/installation) to get started. *** <Steps> <Step> ### Mapping Existing Columns Instead of altering your existing database column names, you can map them to match Better Auth's expected structure. This allows you to retain your current database schema. #### User Schema Map the following fields in the user schema: * (next-auth v4) `emailVerified`: datetime → boolean #### Session Schema Map the following fields in the session schema: * `expires` → `expiresAt` * `sessionToken` → `token` * (next-auth v4) add `createdAt` with datetime type * (next-auth v4) add `updatedAt` with datetime type ```typescript title="auth.ts" export const auth = betterAuth({ session: { fields: { expiresAt: "expires", token: "sessionToken" } }, }); ``` Make sure to have `createdAt` and `updatedAt` fields on your session schema. #### Account Schema Map these fields in the account schema: * (next-auth v4) `provider` → `providerId` * `providerAccountId` → `accountId` * `refresh_token` → `refreshToken` * `access_token` → `accessToken` * (next-auth v3) `access_token_expires` → `accessTokenExpiresAt` and int → datetime * (next-auth v4) `expires_at` → `accessTokenExpiresAt` and int → datetime * `id_token` → `idToken` * (next-auth v4) add `createdAt` with datetime type * (next-auth v4) add `updatedAt` with datetime type Remove the `session_state`, `type`, and `token_type` fields, as they are not required by Better Auth. ```typescript title="auth.ts" export const auth = betterAuth({ account: { fields: { accountId: "providerAccountId", refreshToken: "refresh_token", accessToken: "access_token", accessTokenExpiresAt: "access_token_expires", idToken: "id_token", } }, }); ``` **Note:** If you use ORM adapters, you can map these fields in your schema file. **Example with Prisma:** ```prisma title="schema.prisma" model Session { id String @id @default(cuid()) expiresAt DateTime @map("expires") token String @map("sessionToken") userId String user User @relation(fields: [userId], references: [id]) } ``` Make sure to have `createdAt` and `updatedAt` fields on your account schema. </Step> <Step> ### Update the Route Handler In the `app/api/auth` folder, rename the `[...nextauth]` file to `[...all]` to avoid confusion. Then, update the `route.ts` file as follows: ```typescript title="app/api/auth/[...all]/route.ts" import { toNextJsHandler } from "better-auth/next-js"; import { auth } from "~/server/auth"; export const { POST, GET } = toNextJsHandler(auth); ``` </Step> <Step> ### Update the Client Create a file named `auth-client.ts` in the `lib` folder. Add the following code: ```typescript title="auth-client.ts" import { createAuthClient } from "better-auth/react"; export const authClient = createAuthClient({ baseURL: process.env.BASE_URL! }); export const { signIn, signOut, useSession } = authClient; ``` #### Social Login Functions Update your social login functions to use Better Auth. For example, for Discord: ```typescript import { signIn } from "~/lib/auth-client"; export const signInDiscord = async () => { const data = await signIn.social({ provider: "discord" }); return data; }; ``` #### Update `useSession` Calls Replace `useSession` calls with Better Auth’s version. Example: ```typescript title="Profile.tsx" import { useSession } from "~/lib/auth-client"; export const Profile = () => { const { data } = useSession(); return ( <div> <pre> {JSON.stringify(data, null, 2)} </pre> </div> ); }; ``` </Step> <Step> ### Server-Side Session Handling Use the `auth` instance to get session data on the server: ```typescript title="actions.ts" "use server"; import { auth } from "~/server/auth"; import { headers } from "next/headers"; export const protectedAction = async () => { const session = await auth.api.getSession({ headers: await headers(), }); }; ``` </Step> <Step> ### Middleware To protect routes with middleware, refer to the [Next.js middleware guide](/docs/integrations/next#middleware). </Step> </Steps> ## Wrapping Up Congratulations! You’ve successfully migrated from NextAuth.js to Better Auth. For a complete implementation with multiple authentication methods, check out the [demo repository](https: Better Auth offers greater flexibility and more features—be sure to explore the [documentation](/docs) to unlock its full potential. # guides: Optimizing for Performance URL: /docs/guides/optimizing-for-performance Source: https: A guide to optimizing your Better Auth application for performance. *** title: Optimizing for Performance description: A guide to optimizing your Better Auth application for performance. -------------------------------------------------------------------------------- In this guide, we’ll go over some of the ways you can optimize your application for a more performant Better Auth app. ## Caching Caching is a powerful technique that can significantly improve the performance of your Better Auth application by reducing the number of database queries and speeding up response times. ### Cookie Cache Calling your database every time `useSession` or `getSession` invoked isn’t ideal, especially if sessions don’t change frequently. Cookie caching handles this by storing session data in a short-lived, signed cookie similar to how JWT access tokens are used with refresh tokens. To turn on cookie caching, just set `session.cookieCache` in your auth config: ```ts title="auth.ts" export const auth = betterAuth({ session: { cookieCache: { enabled: true, maxAge: 5 * 60, }, }, }); ``` Read more about [cookie caching](/docs/concepts/session-management#cookie-cache). ### Framework Caching Here are examples of how you can do caching in different frameworks and environments: <Tabs items={["Next", "Remix", "SolidStart", "React Query"]}> <Tab value="Next"> Since Next v15, we can use the `"use cache"` directive to cache the response of a server function. ```ts export async function getUsers() { 'use cache' const { users } = await auth.api.listUsers(); return users } ``` Learn more about NextJS use cache directive <Link href="https: </Tab> <Tab value="Remix"> In Remix, you can use the `cache` option in the `loader` function to cache responses on the server. Here’s an example: ```ts import { json } from '@remix-run/node'; export const loader = async () => { const { users } = await auth.api.listUsers(); return json(users, { headers: { 'Cache-Control': 'max-age=3600', }, }); }; ``` You can read a nice guide on Loader vs Route Cache Headers in Remix <Link href="https: </Tab> <Tab value="SolidStart"> In SolidStart, you can use the `query` function to cache data. Here’s an example: ```tsx const getUsers = query( async () => (await auth.api.listUsers()).users, "getUsers" ); ``` Learn more about SolidStart `query` function <Link href="https: </Tab> <Tab value="React Query"> With React Query you can use the `useQuery` hook to cache data. Here’s an example: ```ts import { useQuery } from '@tanstack/react-query'; const fetchUsers = async () => { const { users } = await auth.api.listUsers(); return users; }; export default function Users() { const { data: users, isLoading } = useQuery('users', fetchUsers, { staleTime: 1000 * 60 * 15, }); if (isLoading) return <div>Loading...</div>; return ( <ul> {users.map(user => ( <li key={user.id}>{user.name}</li> ))} </ul> ); } ``` Learn more about React Query use cache directive <Link href="https: </Tab> </Tabs> ## SSR Optimizations If you're using a framework that supports server-side rendering, it's usually best to pre-fetch the user session on the server and use it as a fallback on the client. ```ts const session = await auth.api.getSession({ headers: await headers(), }); ``` ## Database optimizations Optimizing database performance is essential to get the best out of Better Auth. #### Recommended fields to index | Table | Fields | Plugin | | ------------- | -------------------------- | ------------ | | users | `email` | | | accounts | `userId` | | | sessions | `userId`, `token` | | | verifications | `identifier` | | | invitations | `email`, `organizationId` | organization | | members | `userId`, `organizationId` | organization | | organizations | `slug` | organization | | passkey | `userId` | passkey | | twoFactor | `secret` | twoFactor | <Callout> We intend to add indexing support in our schema generation tool in the future. </Callout> # guides: Migrating from Supabase Auth to Better Auth URL: /docs/guides/supabase-migration-guide Source: https: A step-by-step guide to transitioning from Supabase Auth to Better Auth. *** title: Migrating from Supabase Auth to Better Auth description: A step-by-step guide to transitioning from Supabase Auth to Better Auth. ------------------------------------------------------------------------------------- In this guide, we'll walk through the steps to migrate a project from Supabase Auth to Better Auth. <Callout type="warn"> This migration will invalidate all active sessions. While this guide doesn't currently cover migrating two-factor (2FA) or Row Level Security (RLS) configurations, both should be possible with additional steps. </Callout> ## Before You Begin Before starting the migration process, set up Better Auth in your project. Follow the [installation guide](/docs/installation) to get started. <Steps> <Step> ### Connect to your database You'll need to connect to your database to migrate the users and accounts. Copy your `DATABASE_URL` from your Supabase project and use it to connect to your database. And for this example, we'll need to install `pg` to connect to the database. <Tabs items={}> <Tab value="npm"> ```bash npm install pg ``` </Tab> <Tab value="pnpm"> ```bash pnpm add pg ``` </Tab> <Tab value="yarn"> ```bash yarn add pg ``` </Tab> <Tab value="bun"> ```bash bun add pg ``` </Tab> </Tabs> And then you can use the following code to connect to your database. ```ts title="auth.ts" import { Pool } from "pg"; export const auth = betterAuth({ database: new Pool({ connectionString: process.env.DATABASE_URL }), }) ``` </Step> <Step> ### Enable Email and Password (Optional) Enable the email and password in your auth config. ```ts title="auth.ts" import { admin, anonymous } from "better-auth/plugins"; export const auth = betterAuth({ database: new Pool({ connectionString: process.env.DATABASE_URL }), emailVerification: { sendEmailVerification: async(user)=>{ } }, emailAndPassword: { enabled: true, } }) ``` </Step> <Step> ### Setup Social Providers (Optional) Add social providers you have enabled in your Supabase project in your auth config. ```ts title="auth.ts" import { admin, anonymous } from "better-auth/plugins"; export const auth = betterAuth({ database: new Pool({ connectionString: process.env.DATABASE_URL }), emailAndPassword: { enabled: true, }, socialProviders: { github: { clientId: process.env.GITHUB_CLIENT_ID, clientSecret: process.env.GITHUB_CLIENT_SECRET, } } }) ``` </Step> <Step> ### Add admin and anonymous plugins (Optional) Add the [admin](/docs/plugins/admin) and [anonymous](/docs/plugins/anonymous) plugins to your auth config. ```ts title="auth.ts" import { admin, anonymous } from "better-auth/plugins"; export const auth = betterAuth({ database: new Pool({ connectionString: process.env.DATABASE_URL }), emailAndPassword: { enabled: true, }, socialProviders: { github: { clientId: process.env.GITHUB_CLIENT_ID!, clientSecret: process.env.GITHUB_CLIENT_SECRET!, } }, plugins: [admin(), anonymous()], }) ``` </Step> <Step> ### Run the migration Run the migration to create the necessary tables in your database. ```bash title="Terminal" npx @better-auth/cli migrate ``` This will create the following tables in your database: * [`user`](/docs/concepts/database#user) * [`account`](/docs/concepts/database#account) * [`session`](/docs/concepts/database#session) * [`verification`](/docs/concepts/database#verification) This tables will be created on the `public` schema. </Step> <Step> ### Copy the migration script Now that we have the necessary tables in our database, we can run the migration script to migrate the users and accounts from Supabase to Better Auth. Start by creating a `.ts` file in your project. ```bash title="Terminal" touch migration.ts ``` And then copy and paste the following code into the file. ```ts title="migration.ts" import { Pool } from "pg"; import { auth } from "./auth"; import { User as SupabaseUser } from "@supabase/supabase-js"; type User = SupabaseUser & { is_super_admin: boolean; raw_user_meta_data: { avatar_url: string; }; encrypted_password: string; email_confirmed_at: string; created_at: string; updated_at: string; is_anonymous: boolean; identities: { provider: string; identity_data: { sub: string; email: string; }; created_at: string; updated_at: string; }; }; const migrateFromSupabase = async () => { const ctx = await auth.$context; const db = ctx.options.database as Pool; const users = await db .query(` SELECT u.*, COALESCE( json_agg( i.* ORDER BY i.id ) FILTER (WHERE i.id IS NOT NULL), '[]'::json ) as identities FROM auth.users u LEFT JOIN auth.identities i ON u.id = i.user_id GROUP BY u.id `) .then((res) => res.rows as User[]); for (const user of users) { if (!user.email) { continue; } await ctx.adapter .create({ model: "user", data: { id: user.id, email: user.email, name: user.email, role: user.is_super_admin ? "admin" : user.role, emailVerified: !!user.email_confirmed_at, image: user.raw_user_meta_data.avatar_url, createdAt: new Date(user.created_at), updatedAt: new Date(user.updated_at), isAnonymous: user.is_anonymous, }, }) .catch(() => {}); for (const identity of user.identities) { const existingAccounts = await ctx.internalAdapter.findAccounts(user.id); if (identity.provider === "email") { const hasCredential = existingAccounts.find( (account) => account.providerId === "credential", ); if (!hasCredential) { await ctx.adapter .create({ model: "account", data: { userId: user.id, providerId: "credential", accountId: user.id, password: user.encrypted_password, createdAt: new Date(user.created_at), updatedAt: new Date(user.updated_at), }, }) .catch(() => {}); } } const supportedProviders = Object.keys(ctx.options.socialProviders || {}) if (supportedProviders.includes(identity.provider)) { const hasAccount = existingAccounts.find( (account) => account.providerId === identity.provider, ); if (!hasAccount) { await ctx.adapter.create({ model: "account", data: { userId: user.id, providerId: identity.provider, accountId: identity.identity_data?.sub, createdAt: new Date(identity.created_at ?? user.created_at), updatedAt: new Date(identity.updated_at ?? user.updated_at), }, }); } } } } }; migrateFromSupabase(); ``` </Step> <Step> ### Customize the migration script (Optional) * `name`: the migration script will use the user's email as the name. You might want to customize it if you have the user display name in your database. * `socialProviderList`: the migration script will use the social providers you have enabled in your auth config. You might want to customize it if you have additional social providers that you haven't enabled in your auth config. * `role`: remove `role` if you're not using the `admin` plugin * `isAnonymous`: remove `isAnonymous` if you're not using the `anonymous` plugin. * update other tables that reference the `users` table to use the `id` field. </Step> <Step> ### Run the migration script Run the migration script to migrate the users and accounts from Supabase to Better Auth. ```bash title="Terminal" bun migration.ts # or use node, ts-node, etc. ``` </Step> <Step> ### Update your code Update your codebase from Supabase auth calls to Better Auth API. Here's a list of the Supabase auth API calls and their Better Auth counterparts. * `supabase.auth.signUp` -> `authClient.signUp.email` * `supabase.auth.signInWithPassword` -> `authClient.signIn.email` * `supabase.auth.signInWithOAuth` -> `authClient.signIn.social` * `supabase.auth.signInAnonymously` -> `authClient.signIn.anonymous` * `supabase.auth.signOut` -> `authClient.signOut` * `supabase.auth.getSession` -> `authClient.getSession` - you can also use `authClient.useSession` for reactive state Learn more: * [Basic Usage](/docs/basic-usage): Learn how to use the auth client to sign up, sign in, and sign out. * [Email and Password](/docs/authentication/email-and-password): Learn how to add email and password authentication to your project. * [Anonymous](/docs/plugins/anonymous): Learn how to add anonymous authentication to your project. * [Admin](/docs/plugins/admin): Learn how to add admin authentication to your project. * [Email OTP](/docs/authentication/email-otp): Learn how to add email OTP authentication to your project. * [Hooks](/docs/concepts/hooks): Learn how to use the hooks to listen for events. * [Next.js](/docs/integrations/next): Learn how to use the auth client in a Next.js project. </Step> </Steps> ### Middleware To protect routes with middleware, refer to the [Next.js middleware guide](/docs/integrations/next#middleware) or your framework's documentation. ## Wrapping Up Congratulations! You've successfully migrated from Supabase Auth to Better Auth. Better Auth offers greater flexibility and more features—be sure to explore the [documentation](/docs) to unlock its full potential. # guides: Create your first plugin URL: /docs/guides/your-first-plugin Source: https: A step-by-step guide to creating your first Better Auth plugin. *** title: Create your first plugin description: A step-by-step guide to creating your first Better Auth plugin. ---------------------------------------------------------------------------- In this guide, we’ll walk you through the steps of creating your first Better Auth plugin. <Callout type="warn"> This guide assumes you have <Link href="/docs/installation">setup the basics</Link> of Better Auth and are ready to create your first plugin. </Callout> <Steps> <Step> ## Plan your idea Before beginning, you must know what plugin you intend to create. In this guide, we’ll create a **birthday plugin** to keep track of user birth dates. </Step> <Step> ## Server plugin first Better Auth plugins operate as a pair: a <Link href="/docs/concepts/plugins#create-a-server-plugin">server plugin</Link> and a <Link href="/docs/concepts/plugins#create-a-client-plugin">client plugin</Link>. The server plugin forms the foundation of your authentication system, while the client plugin provides convenient frontend APIs to interact with your server implementation. <Callout> You can read more about server/client plugins in our <Link href="/docs/concepts/plugins#creating-a-plugin">documentation</Link>. </Callout> ### Creating the server plugin Go ahead and find a suitable location to create your birthday plugin folder, with an `index.ts` file within. <Files> <Folder name="birthday-plugin" defaultOpen> <File name="index.ts" /> </Folder> </Files> In the `index.ts` file, we’ll export a function that represents our server plugin. This will be what we will later add to our plugin list in the `auth.ts` file. ```ts title="index.ts" import { createAuthClient } from "better-auth/client"; import type { BetterAuthPlugin } from "better-auth"; export const birthdayPlugin = () => ({ id: "birthdayPlugin", } satisfies BetterAuthPlugin); ``` Although this does nothing, you have technically just made yourself your first plugin, congratulations! 🎉 </Step> <Step> ### Defining a schema In order to save each user’s birthday data, we must create a schema on top of the `user` model. By creating a schema here, this also allows <Link href="/docs/concepts/cli">Better Auth’s CLI</Link> to generate the schemas required to update your database. <Callout type="info"> You can learn more about <Link href="/docs/concepts/plugins#schema">plugin schemas here</Link>. </Callout> ```ts title="index.ts" export const birthdayPlugin = () => ({ id: "birthdayPlugin", schema: { user: { fields: { birthday: { type: "date", required: true, unique: false, references: null }, }, }, }, } satisfies BetterAuthPlugin); ``` </Step> <Step> ### Authorization logic For this example guide, we’ll set up authentication logic to check and ensure that the user who signs-up is older than 5. But the same concept could be applied for something like verifying users agreeing to the TOS or anything alike. To do this, we’ll utilize <Link href="/docs/concepts/plugins#hooks">Hooks</Link>, which allows us to run code `before` or `after` an action is performed. ```ts title="index.ts" export const birthdayPlugin = () => ({ hooks: { before: [ { matcher: (context) => , handler: createAuthMiddleware(async (ctx) => { }), }, ], }, } satisfies BetterAuthPlugin) ``` In our case we want to match any requests going to the signup path: ```ts title="Before hook" { matcher: (context) => context.path.startsWith("/sign-up/email"), } ``` And for our logic, we’ll write the following code to check the if user’s birthday makes them above 5 years old. ```ts title="Imports" import { APIError } from "better-auth/api"; import { createAuthMiddleware } from "better-auth/plugins"; ``` ```ts title="Before hook" { handler: createAuthMiddleware(async (ctx) => { const { birthday } = ctx.body; if(!(birthday instanceof Date)) { throw new APIError("BAD_REQUEST", { message: "Birthday must be of type Date." }); } const today = new Date(); const fiveYearsAgo = new Date(today.setFullYear(today.getFullYear() - 5)); if(birthday >= fiveYearsAgo) { throw new APIError("BAD_REQUEST", { message: "User must be above 5 years old." }); } return { context: ctx }; }), } ``` **Authorized!** 🔒 We’ve now successfully written code to ensure authorization for users above 5! </Step> <Step> ## Client Plugin We’re close to the finish line! 🏁 Now that we have created our server plugin, the next step is to develop our client plugin. Since there isn’t much frontend APIs going on for this plugin, there isn’t much to do! First, let’s create our `client.ts` file first: <Files> <Folder name="birthday-plugin" defaultOpen> <File name="index.ts" /> <File name="client.ts" /> </Folder> </Files> Then, add the following code: ```ts title="client.ts" import { BetterAuthClientPlugin } from "better-auth"; import type { birthdayPlugin } from "./index"; type BirthdayPlugin = typeof birthdayPlugin; export const birthdayClientPlugin = () => { return { id: "birthdayPlugin", $InferServerPlugin: {} as ReturnType<BirthdayPlugin>, } satisfies BetterAuthClientPlugin; }; ``` What we’ve done is allow the client plugin to infer the types defined by our schema from the server plugin. And that’s it! This is all it takes for the birthday client plugin. 🎂 </Step> <Step> ## Initiate your plugin! Both the `client` and `server` plugins are now ready, the last step is to import them to both your `auth-client.ts` and your `server.ts` files respectively to initiate the plugin. ### Server initiation ```ts title="server.ts" import { betterAuth } from "better-auth"; import { birthdayPlugin } from "./birthday-plugin"; export const auth = betterAuth({ plugins: [ birthdayPlugin(), ] }); ``` ### Client initiation ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client"; import { birthdayClientPlugin } from "./birthday-plugin/client"; const authClient = createAuthClient({ plugins: [ birthdayClientPlugin() ] }); ``` ### Oh yeah, the schemas! Don’t forget to add your `birthday` field to your `user` table model! Or, use the `generate` <Link href="/docs/concepts/cli#generate">CLI command</Link>: ```bash npx @better-auth/cli@latest generate ``` </Step> </Steps> ## Wrapping Up Congratulations! You’ve successfully created your first ever Better Auth plugin. We highly recommend you visit our <Link href="/docs/concepts/plugins">plugins documentation</Link> to learn more information. If you have a plugin you’d like to share with the community, feel free to let us know through our <Link href="https: or through a <Link href="https: and we may add it to the <Link href="/docs/plugins/community-plugins">community-plugins</Link> list! # integrations: Astro Integration URL: /docs/integrations/astro Source: https: Integrate Better Auth with Astro. *** title: Astro Integration description: Integrate Better Auth with Astro. ---------------------------------------------- Better Auth comes with first class support for Astro. This guide will show you how to integrate Better Auth with Astro. Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation). ### Mount the handler To enable Better Auth to handle requests, we need to mount the handler to a catch all API route. Create a file inside `/pages/api/auth` called `[...all].ts` and add the following code: ```ts title="pages/api/auth/[...all].ts" export const ALL: APIRoute = async (ctx) => { return auth.handler(ctx.request); }; ``` <Callout> You can change the path on your better-auth configuration but it's recommended to keep it as `/api/auth/[...all]` </Callout> ## Create a client Astro supports multiple frontend frameworks, so you can easily import your client based on the framework you're using. If you're not using a frontend framework, you can still import the vanilla client. <Tabs items={[ "vanilla", "react", "vue", "svelte", "solid", ]} defaultValue="react" > <Tab value="vanilla"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/client" export const authClient = createAuthClient() ``` </Tab> <Tab value="react" title="lib/auth-client.ts"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/react" export const authClient = createAuthClient() ``` </Tab> <Tab value="vue" title="lib/auth-client.ts"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/vue" export const authClient = createAuthClient() ``` </Tab> <Tab value="svelte" title="lib/auth-client.ts"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/svelte" export const authClient = createAuthClient() ``` </Tab> <Tab value="solid" title="lib/auth-client.ts"> ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/solid" export const authClient = createAuthClient() ``` </Tab> </Tabs> ## Auth Middleware ### Astro Locals types To have types for your Astro locals, you need to set it inside the `env.d.ts` file. ```ts title="env.d.ts" declare namespace App { interface Locals { user: import("better-auth").User | null; session: import("better-auth").Session | null; } } ``` ### Middleware To protect your routes, you can check if the user is authenticated using the `getSession` method in middleware and set the user and session data using the Astro locals with the types we set before. Start by creating a `middleware.ts` file in the root of your project and follow the example below: ```ts title="middleware.ts" export const onRequest = defineMiddleware(async (context, next) => { const isAuthed = await auth.api .getSession({ headers: context.request.headers, }) if (isAuthed) { context.locals.user = isAuthed.user; context.locals.session = isAuthed.session; } else { context.locals.user = null; context.locals.session = null; } return next(); }); ``` ### Getting session on the server inside `.astro` file You can use `Astro.locals` to check if the user has session and get the user data from the server side. Here is an example of how you can get the session inside an `.astro` file: ```astro --- const session = () => { if (Astro.locals.session) { return Astro.locals.session; } else { return Astro.redirect("/login"); } } --- <UserCard initialSession={session} /> ``` # integrations: Elysia Integration URL: /docs/integrations/elysia Source: https: Integrate Better Auth with Elysia. *** title: Elysia Integration description: Integrate Better Auth with Elysia. ----------------------------------------------- This integration guide is assuming you are using Elysia with bun server. Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation). ### Mount the handler We need to mount the handler to Elysia endpoint. ```ts const app = new Elysia().mount(auth.handler).listen(3000); console.log( `🦊 Elysia is running at ${app.server?.hostname}:${app.server?.port}`, ); ``` ### CORS To configure cors, you can use the `cors` plugin from `@elysiajs/cors`. ```ts const app = new Elysia() .use( cors({ origin: "http: methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"], credentials: true, allowedHeaders: ["Content-Type", "Authorization"], }), ) .mount(auth.handler) .listen(3000); console.log( `🦊 Elysia is running at ${app.server?.hostname}:${app.server?.port}`, ); ``` ### Macro You can use [macro](https: ```ts const betterAuth = new Elysia({ name: "better-auth" }) .mount(auth.handler) .macro({ auth: { async resolve({ status, request: { headers } }) { const session = await auth.api.getSession({ headers, }); if (!session) return status(401); return { user: session.user, session: session.session, }; }, }, }); const app = new Elysia() .use(betterAuth) .get("/user", ({ user }) => user, { auth: true, }) .listen(3000); console.log( `🦊 Elysia is running at ${app.server?.hostname}:${app.server?.port}`, ); ``` This will allow you to access the `user` and `session` object in all of your routes. # integrations: Expo Integration URL: /docs/integrations/expo Source: https: Integrate Better Auth with Expo. *** title: Expo Integration description: Integrate Better Auth with Expo. --------------------------------------------- Expo is a popular framework for building cross-platform apps with React Native. Better Auth supports both Expo native and web apps. ## Installation <Steps> <Step> ## Configure A Better Auth Backend Before using Better Auth with Expo, make sure you have a Better Auth backend set up. You can either use a separate server or leverage Expo's new [API Routes](https: To get started, check out our [installation](/docs/installation) guide for setting up Better Auth on your server. If you prefer to check out the full example, you can find it [here](https: To use the new API routes feature in Expo to host your Better Auth instance you can create a new API route in your Expo app and mount the Better Auth handler. ```ts title="app/api/auth/[...auth]+api.ts" import { auth } from "@/lib/auth"; const handler = auth.handler; export { handler as GET, handler as POST }; ``` </Step> <Step> ## Install Server Dependencies Install both the Better Auth package and Expo plugin into your server application. <Tabs items={}> <Tab value="npm"> ```bash npm install better-auth @better-auth/expo ``` </Tab> <Tab value="pnpm"> ```bash pnpm add better-auth @better-auth/expo ``` </Tab> <Tab value="yarn"> ```bash yarn add better-auth @better-auth/expo ``` </Tab> <Tab value="bun"> ```bash bun add better-auth @better-auth/expo ``` </Tab> </Tabs> </Step> <Step> ## Install Client Dependencies You also need to install both the Better Auth package and Expo plugin into your Expo application. <Tabs items={}> <Tab value="npm"> ```bash npm install better-auth @better-auth/expo ``` </Tab> <Tab value="pnpm"> ```bash pnpm add better-auth @better-auth/expo ``` </Tab> <Tab value="yarn"> ```bash yarn add better-auth @better-auth/expo ``` </Tab> <Tab value="bun"> ```bash bun add better-auth @better-auth/expo ``` </Tab> </Tabs> If you plan on using our social integrations (Google, Apple etc.) then there are a few more dependencies that are required in your Expo app. In the default Expo template these are already installed so you may be able to skip this step if you have these dependencies already. <Tabs items={}> <Tab value="npm"> ```bash npm install expo-linking expo-web-browser expo-constants ``` </Tab> <Tab value="pnpm"> ```bash pnpm add expo-linking expo-web-browser expo-constants ``` </Tab> <Tab value="yarn"> ```bash yarn add expo-linking expo-web-browser expo-constants ``` </Tab> <Tab value="bun"> ```bash bun add expo-linking expo-web-browser expo-constants ``` </Tab> </Tabs> </Step> <Step> ## Add the Expo Plugin on Your Server Add the Expo plugin to your Better Auth server. ```ts title="lib/auth.ts" import { betterAuth } from "better-auth"; import { expo } from "@better-auth/expo"; export const auth = betterAuth({ plugins: [expo()], emailAndPassword: { enabled: true, }, }); ``` </Step> <Step> ## Initialize Better Auth Client To initialize Better Auth in your Expo app, you need to call `createAuthClient` with the base URL of your Better Auth backend. Make sure to import the client from `/react`. Make sure you install the `expo-secure-store` package into your Expo app. This is used to store the session data and cookies securely. <Tabs items={}> <Tab value="npm"> ```bash npm install expo-secure-store ``` </Tab> <Tab value="pnpm"> ```bash pnpm add expo-secure-store ``` </Tab> <Tab value="yarn"> ```bash yarn add expo-secure-store ``` </Tab> <Tab value="bun"> ```bash bun add expo-secure-store ``` </Tab> </Tabs> You need to also import client plugin from `@better-auth/expo/client` and pass it to the `plugins` array when initializing the auth client. This is important because: * **Social Authentication Support:** enables social auth flows by handling authorization URLs and callbacks within the Expo web browser. * **Secure Cookie Management:** stores cookies securely and automatically adds them to the headers of your auth requests. ```ts title="lib/auth-client.ts" import { createAuthClient } from "better-auth/react"; import { expoClient } from "@better-auth/expo/client"; import * as SecureStore from "expo-secure-store"; export const authClient = createAuthClient({ baseURL: "http: plugins: [ expoClient({ scheme: "myapp", storagePrefix: "myapp", storage: SecureStore, }) ] }); ``` <Callout> Be sure to include the full URL, including the path, if you've changed the default path from `/api/auth`. </Callout> </Step> <Step> ## Scheme and Trusted Origins Better Auth uses deep links to redirect users back to your app after authentication. To enable this, you need to add your app's scheme to the `trustedOrigins` list in your Better Auth config. First, make sure you have a scheme defined in your `app.json` file. ```json title="app.json" { "expo": { "scheme": "myapp" } } ``` Then, update your Better Auth config to include the scheme in the `trustedOrigins` list. ```ts title="auth.ts" export const auth = betterAuth({ trustedOrigins: ["myapp: }) ``` If you have multiple schemes or need to support deep linking with various paths, you can use specific patterns or wildcards: ```ts title="auth.ts" export const auth = betterAuth({ trustedOrigins: [ "myapp: "myapp-prod: "myapp-staging: "myapp: ] }) ``` <Callout> The wildcard pattern can be particularly useful if your app uses different URL formats for deep linking based on features or screens. </Callout> </Step> <Step> ## Configure Metro Bundler To resolve Better Auth exports you'll need to enable `unstable_enablePackageExports` in your metro config. ```js title="metro.config.js" const { getDefaultConfig } = require("expo/metro-config"); const config = getDefaultConfig(__dirname) config.resolver.unstable_enablePackageExports = true; module.exports = config; ``` <Callout>In case you don't have a `metro.config.js` file in your project run `npx expo customize metro.config.js`.</Callout> If you can't enable `unstable_enablePackageExports` option, you can use [babel-plugin-module-resolver](https: ```ts title="babel.config.js" module.exports = function (api) { api.cache(true); return { presets: ["babel-preset-expo"], plugins: [ [ "module-resolver", { alias: { "better-auth/react": "./node_modules/better-auth/dist/client/react/index.cjs", "better-auth/client/plugins": "./node_modules/better-auth/dist/client/plugins/index.cjs", "@better-auth/expo/client": "./node_modules/@better-auth/expo/dist/client.cjs", }, }, ], ], } } ``` <Callout>In case you don't have a `babel.config.js` file in your project run `npx expo customize babel.config.js`.</Callout> Don't forget to clear the cache after making changes. ```bash npx expo start --clear ``` </Step> </Steps> ## Usage ### Authenticating Users With Better Auth initialized, you can now use the `authClient` to authenticate users in your Expo app. <Tabs items={["sign-in", "sign-up"]}> <Tab value="sign-in"> ```tsx title="app/sign-in.tsx" import { useState } from "react"; import { View, TextInput, Button } from "react-native"; import { authClient } from "@/lib/auth-client"; export default function SignIn() { const [email, setEmail] = useState(""); const [password, setPassword] = useState(""); const handleLogin = async () => { await authClient.signIn.email({ email, password, }) }; return ( <View> <TextInput placeholder="Email" value={email} onChangeText={setEmail} /> <TextInput placeholder="Password" value={password} onChangeText={setPassword} /> <Button title="Login" onPress={handleLogin} /> </View> ); } ``` </Tab> <Tab value="sign-up"> ```tsx title="app/sign-up.tsx" import { useState } from "react"; import { View, TextInput, Button } from "react-native"; import { authClient } from "@/lib/auth-client"; export default function SignUp() { const [email, setEmail] = useState(""); const [name, setName] = useState(""); const [password, setPassword] = useState(""); const handleLogin = async () => { await authClient.signUp.email({ email, password, name }) }; return ( <View> <TextInput placeholder="Name" value={name} onChangeText={setName} /> <TextInput placeholder="Email" value={email} onChangeText={setEmail} /> <TextInput placeholder="Password" value={password} onChangeText={setPassword} /> <Button title="Login" onPress={handleLogin} /> </View> ); } ``` </Tab> </Tabs> #### Social Sign-In For social sign-in, you can use the `authClient.signIn.social` method with the provider name and a callback URL. ```tsx title="app/social-sign-in.tsx" export default function SocialSignIn() { const handleLogin = async () => { await authClient.signIn.social({ provider: "google", callbackURL: "/dashboard" }) }; return <Button title="Login with Google" onPress={handleLogin} />; } ``` #### IdToken Sign-In If you want to make provider request on the mobile device and then verify the ID token on the server, you can use the `authClient.signIn.social` method with the `idToken` option. ```tsx title="app/social-sign-in.tsx" export default function SocialSignIn() { const handleLogin = async () => { await authClient.signIn.social({ provider: "google", idToken: { token: "...", nonce: "...", } callbackURL: "/dashboard" }) }; return <Button title="Login with Google" onPress={handleLogin} />; } ``` ### Session Better Auth provides a `useSession` hook to access the current user's session in your app. ```tsx title="app/index.tsx" export default function Index() { const { data: session } = authClient.useSession(); return <Text>Welcome, {session?.user.name}</Text>; } ``` On native, the session data will be cached in SecureStore. This will allow you to remove the need for a loading spinner when the app is reloaded. You can disable this behavior by passing the `disableCache` option to the client. ### Making Authenticated Requests to Your Server To make authenticated requests to your server that require the user's session, you have to retrieve the session cookie from `SecureStore` and manually add it to your request headers. ```tsx const makeAuthenticatedRequest = async () => { const cookies = authClient.getCookie(); const headers = { "Cookie": cookies, }; const response = await fetch("http: const data = await response.json(); return data; }; ``` **Example: Usage With TRPC** ```tsx title="lib/trpc-provider.tsx" export const api = createTRPCReact<AppRouter>(); export function TRPCProvider(props: { children: React.ReactNode }) { const [queryClient] = useState(() => new QueryClient()); const [trpcClient] = useState(() => api.createClient({ links: [ httpBatchLink({ headers() { const headers = new Map<string, string>(); const cookies = authClient.getCookie(); if (cookies) { headers.set("Cookie", cookies); } return Object.fromEntries(headers); }, }), ], }), ); return ( <api.Provider client={trpcClient} queryClient={queryClient}> <QueryClientProvider client={queryClient}> {props.children} </QueryClientProvider> </api.Provider> ); } ``` ## Options ### Expo Client **storage**: the storage mechanism used to cache the session data and cookies. ```ts title="lib/auth-client.ts" const authClient = createAuthClient({ baseURL: "http: storage: SecureStorage }); ``` **scheme**: scheme is used to deep link back to your app after a user has authenticated using oAuth providers. By default, Better Auth tries to read the scheme from the `app.json` file. If you need to override this, you can pass the scheme option to the client. ```ts title="lib/auth-client.ts" const authClient = createAuthClient({ baseURL: "http: scheme: "myapp" }); ``` **disableCache**: By default, the client will cache the session data in SecureStore. You can disable this behavior by passing the `disableCache` option to the client. ```ts title="lib/auth-client.ts" const authClient = createAuthClient({ baseURL: "http: disableCache: true }); ``` ### Expo Servers Server plugin options: **overrideOrigin**: Override the origin for Expo API routes (default: false). Enable this if you're facing cors origin issues with Expo API routes. # integrations: Express Integration URL: /docs/integrations/express Source: https: Integrate Better Auth with Express. *** title: Express Integration description: Integrate Better Auth with Express. ------------------------------------------------ This guide will show you how to integrate Better Auth with [express.js](https: Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation). <Callout> Note that CommonJS (cjs) isn't supported. Use ECMAScript Modules (ESM) by setting `"type": "module"` in your `package.json` or configuring your `tsconfig.json` to use ES modules. </Callout> ### Mount the handler To enable Better Auth to handle requests, we need to mount the handler to an API route. Create a catch-all route to manage all requests to `/api/auth export const requireAuth: EventHandler = async (event: H3Event) => { const headers = event.headers; const session = await auth.api.getSession({ headers: headers, }); if (!session) throw createError({ statusCode: 401, statusMessage: "Unauthorized", }); event.context.auth = session; }; ``` You can now use this event handler/middleware in your routes to protect them: ```ts title="server/routes/api/secret.get.ts" export default defineEventHandler({ onRequest: [requireAuth], handler: async (event) => { setResponseStatus(event, 201, "Secret data"); return { message: "Secret data" }; }, }); ``` ### Example You can find an example of a Nitro application integrated with Better Auth & Prisma [here](https: # integrations: Nuxt Integration URL: /docs/integrations/nuxt Source: https: Integrate Better Auth with Nuxt. *** title: Nuxt Integration description: Integrate Better Auth with Nuxt. --------------------------------------------- Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation). ### Create API Route We need to mount the handler to an API route. Create a file inside `/server/api/auth` called `[...all].ts` and add the following code: ```ts title="server/api/auth/[...all].ts" export default defineEventHandler((event) => { return auth.handler(toWebRequest(event)); }); ``` <Callout type="info"> You can change the path on your better-auth configuration but it's recommended to keep it as `/api/auth/[...all]` </Callout> ### Migrate the database Run the following command to create the necessary tables in your database: ```bash npx @better-auth/cli migrate ``` ## Create a client Create a client instance. You can name the file anything you want. Here we are creating `client.ts` file inside the `lib/` directory. ```ts title="auth-client.ts" export const authClient = createAuthClient({ }) ``` Once you have created the client, you can use it to sign up, sign in, and perform other actions. Some of the actions are reactive. ### Example usage ```vue title="index.vue" <script setup lang="ts"> const session = authClient.useSession() </script> <template> <div> <button v-if="!session?.data" @click="() => authClient.signIn.social({ provider: 'github' })"> Continue with GitHub </button> <div> <pre>{{ session.data }}</pre> <button v-if="session.data" @click="authClient.signOut()"> Sign out </button> </div> </div> </template> ``` ### Server Usage The `api` object exported from the auth instance contains all the actions that you can perform on the server. Every endpoint made inside Better Auth is a invocable as a function. Including plugins endpoints. **Example: Getting Session on a server API route** ```tsx title="server/api/example.ts" export default defineEventHandler((event) => { const session = await auth.api.getSession({ headers: event.headers }); if(session) { } }); ``` ### SSR Usage If you are using Nuxt with SSR, you can use the `useSession` function in the `setup` function of your page component and pass `useFetch` to make it work with SSR. ```vue title="index.vue" <script setup lang="ts"> const { data: session } = await authClient.useSession(useFetch); </script> <template> <p> {{ session }} </p> </template> ``` ### Middleware To add middleware to your Nuxt project, you can use the `useSession` method from the client. ```ts title="middleware/auth.global.ts" export default defineNuxtRouteMiddleware(async (to, from) => { const { data: session } = await authClient.useSession(useFetch); if (!session.value) { if (to.path === "/dashboard") { return navigateTo("/"); } } }); ``` ### Resources & Examples * [Nuxt and Nuxt Hub example](https: * [NuxtZzle is Nuxt,Drizzle ORM example](https: * [Nuxt example](https: * [NuxSaaS (Github)](https: * [NuxtOne (Github)](https: # integrations: Remix Integration URL: /docs/integrations/remix Source: https: Integrate Better Auth with Remix. *** title: Remix Integration description: Integrate Better Auth with Remix. ---------------------------------------------- Better Auth can be easily integrated with Remix. This guide will show you how to integrate Better Auth with Remix. You can follow the steps from [installation](/docs/installation) to get started or you can follow this guide to make it the Remix-way. If you have followed the installation steps, you can skip the first step. ## Create auth instance Create a file named `auth.server.ts` in one of these locations: * Project root * `lib/` folder * `utils/` folder You can also nest any of these folders under `app/` folder. (e.g. `app/lib/auth.server.ts`) And in this file, import Better Auth and create your instance. <Callout type="warn"> Make sure to export the auth instance with the variable name `auth` or as a `default` export. </Callout> ```ts title="app/lib/auth.server.ts" export const auth = betterAuth({ database: { provider: "postgres", url: process.env.DATABASE_URL, } }) ``` ## Create API Route We need to mount the handler to a API route. Create a resource route file `api.auth.$.ts` inside `app/routes/` directory. And add the following code: ```ts title="app/routes/api.auth.$.ts" export async function loader({ request }: LoaderFunctionArgs) { return auth.handler(request) } export async function action({ request }: ActionFunctionArgs) { return auth.handler(request) } ``` <Callout type="info"> You can change the path on your better-auth configuration but it's recommended to keep it as `routes/api.auth.$.ts` </Callout> ## Create a client Create a client instance. Here we are creating `auth-client.ts` file inside the `lib/` directory. ```ts title="app/lib/auth-client.ts" export const authClient = createAuthClient({ }) ``` Once you have created the client, you can use it to sign up, sign in, and perform other actions. ### Example usage #### Sign Up ```ts title="app/routes/signup.tsx" export default function SignUp() { const [email, setEmail] = useState("") const [name, setName] = useState("") const [password, setPassword] = useState("") const signUp = async () => { await authClient.signUp.email( { email, password, name, }, { onRequest: (ctx) => { }, onSuccess: (ctx) => { }, onError: (ctx) => { alert(ctx.error) }, }, ) } return ( <div> <h2> Sign Up </h2> <Form onSubmit={signUp} > <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Name" /> <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} placeholder="Email" /> <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} placeholder="Password" /> <button type="submit" > Sign Up </button> </Form> </div> ) } ``` #### Sign In ```ts title="app/routes/signin.tsx" export default function SignIn() { const [email, setEmail] = useState("") const [password, setPassword] = useState("") const signIn = async () => { await authClient.signIn.email( { email, password, }, { onRequest: (ctx) => { }, onSuccess: (ctx) => { }, onError: (ctx) => { alert(ctx.error) }, }, ) } return ( <div> <h2> Sign In </h2> <Form onSubmit={signIn}> <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} /> <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} /> <button type="submit" > Sign In </button> </Form> </div> ) } ``` # integrations: SolidStart Integration URL: /docs/integrations/solid-start Source: https: Integrate Better Auth with SolidStart. *** title: SolidStart Integration description: Integrate Better Auth with SolidStart. --------------------------------------------------- Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation). ### Mount the handler We need to mount the handler to SolidStart server. Put the following code in your `*auth.ts` file inside `/routes/api/auth` folder. ```ts title="*auth.ts" export const { GET, POST } = toSolidStartHandler(auth); ``` # integrations: SvelteKit Integration URL: /docs/integrations/svelte-kit Source: https: Integrate Better Auth with SvelteKit. *** title: SvelteKit Integration description: Integrate Better Auth with SvelteKit. -------------------------------------------------- Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation). ### Mount the handler We need to mount the handler to SvelteKit server hook. ```ts title="hooks.server.ts" export async function handle({ event, resolve }) { return svelteKitHandler({ event, resolve, auth, building }); } ``` ### Server Action Cookies To ensure cookies are properly set when you call functions like `signInEmail` or `signUpEmail` in a server action, you should use the `sveltekitCookies` plugin. This plugin will automatically handle setting cookies for you in SvelteKit. You need to add it as a plugin to your Better Auth instance. <Callout> The `getRequestEvent` function is available in SvelteKit `2.2.0` and later. Make sure you are using a compatible version. </Callout> ```ts title="lib/auth.ts" export const auth = betterAuth({ plugins: [sveltekitCookies(getRequestEvent)], }); ``` ## Create a client Create a client instance. You can name the file anything you want. Here we are creating `client.ts` file inside the `lib/` directory. ```ts title="auth-client.ts" export const authClient = createAuthClient({ }); ``` Once you have created the client, you can use it to sign up, sign in, and perform other actions. Some of the actions are reactive. The client use [nano-store](https: ### Example usage ```svelte <script lang="ts"> import { authClient } from "$lib/client"; const session = authClient.useSession(); </script> <div> {#if $session.data} <div> <p> {$session?.data?.user.name} </p> <button on:click={async () => { await authClient.signOut(); }} > Sign Out </button> </div> {:else} <button on:click={async () => { await authClient.signIn.social({ provider: "github", }); }} > Continue with GitHub </button> {/if} </div> ``` # integrations: TanStack Start Integration URL: /docs/integrations/tanstack Source: https: Integrate Better Auth with TanStack Start. *** title: TanStack Start Integration description: Integrate Better Auth with TanStack Start. ------------------------------------------------------- This integration guide is assuming you are using TanStack Start. Before you start, make sure you have a Better Auth instance configured. If you haven't done that yet, check out the [installation](/docs/installation). ### Mount the handler We need to mount the handler to a TanStack API endpoint/Server Route. Create a new file: `/src/routes/api/auth/$.ts` ```ts title="src/routes/api/auth/$.ts" export const ServerRoute = createServerFileRoute('/api/auth/$').methods({ GET: ({ request }) => { return auth.handler(request) }, POST: ({ request }) => { return auth.handler(request) }, }) ``` If you haven't created your server route handler yet, you can do so by creating a file: `/src/server.ts` ```ts title="src/server.ts" createStartHandler, defaultStreamHandler, } from '@tanstack/react-start/server' export default createStartHandler({ createRouter, })(defaultStreamHandler) ``` ### Usage tips * We recommend using the client SDK or `authClient` to handle authentication, rather than server actions with `auth.api`. * When you call functions that need to set cookies (like `signInEmail` or `signUpEmail`), you'll need to handle cookie setting for TanStack Start. Better Auth provides a `reactStartCookies` plugin to automatically handle this for you. ```ts title="src/lib/auth.ts" export const auth = betterAuth({ plugins: [reactStartCookies()] }) ``` Now, when you call functions that set cookies, they will be automatically set using TanStack Start's cookie handling system. ```ts const signIn = async () => { await auth.api.signInEmail({ body: { email: "user@email.com", password: "password", } }) } ``` # plugins: Two-Factor Authentication (2FA) URL: /docs/plugins/2fa Source: https: Enhance your app's security with two-factor authentication. *** title: Two-Factor Authentication (2FA) description: Enhance your app's security with two-factor authentication. ------------------------------------------------------------------------ `OTP` `TOTP` `Backup Codes` `Trusted Devices` Two-Factor Authentication (2FA) adds an extra security step when users log in. Instead of just using a password, they'll need to provide a second form of verification. This makes it much harder for unauthorized people to access accounts, even if they've somehow gotten the password. This plugin offers two main methods to do a second factor verification: 1. **OTP (One-Time Password)**: A temporary code sent to the user's email or phone. 2. **TOTP (Time-based One-Time Password)**: A code generated by an app on the user's device. **Additional features include:** * Generating backup codes for account recovery * Enabling/disabling 2FA * Managing trusted devices ## Installation <Steps> <Step> ### Add the plugin to your auth config Add the two-factor plugin to your auth configuration and specify your app name as the issuer. ```ts title="auth.ts" import { betterAuth } from "better-auth" import { twoFactor } from "better-auth/plugins" export const auth = betterAuth({ appName: "My App", plugins: [ twoFactor() ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin Add the client plugin and Specify where the user should be redirected if they need to verify 2nd factor ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { twoFactorClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ twoFactorClient() ] }) ``` </Step> </Steps> ## Usage ### Enabling 2FA To enable two-factor authentication, call `twoFactor.enable` with the user's password and issuer (optional): <APIMethod path="/two-factor/enable" method="POST" requireSession> ```ts type enableTwoFactor = { password: string = "secure-password" issuer?: string = "my-app-name" } ``` </APIMethod> When 2FA is enabled: * An encrypted `secret` and `backupCodes` are generated. * `enable` returns `totpURI` and `backupCodes`. Note: `twoFactorEnabled` won’t be set to `true` until the user verifies their TOTP code. Learn more about veryifying TOTP [here](#totp). You can skip verification by setting `skipVerificationOnEnable` to true in your plugin config. <Callout type="warn"> Two Factor can only be enabled for credential accounts at the moment. For social accounts, it's assumed the provider already handles 2FA. </Callout> ### Sign In with 2FA When a user with 2FA enabled tries to sign in via email, the response object will contain `twoFactorRedirect` set to `true`. This indicates that the user needs to verify their 2FA code. You can handle this in the `onSuccess` callback or by providing a `onTwoFactorRedirect` callback in the plugin config. ```ts title="sign-in.tsx" await authClient.signIn.email({ email: "user@example.com", password: "password123", }, { async onSuccess(context) { if (context.data.twoFactorRedirect) { } }, } ) ``` Using the `onTwoFactorRedirect` config: ```ts title="sign-in.ts" const authClient = createAuthClient({ plugins: [ twoFactorClient({ onTwoFactorRedirect(){ }, }), ], }); ``` <Callout type="warn"> **With `auth.api`** When you call `auth.api.signInEmail` on the server, and the user has 2FA enabled, it will return an object where `twoFactorRedirect` is set to `true`. This behavior isn’t inferred in TypeScript, which can be misleading. You can check using `in` instead to check if `twoFactorRedirect` is set to `true`. ```ts const response = await auth.api.signInEmail({ body: { email: "test@test.com", password: "test", }, }); if ("twoFactorRedirect" in response) { } ``` </Callout> ### Disabling 2FA To disable two-factor authentication, call `twoFactor.disable` with the user's password: <APIMethod path="/two-factor/disable" method="POST" requireSession> ```ts type disableTwoFactor = { password: string } ``` </APIMethod> ### TOTP TOTP (Time-Based One-Time Password) is an algorithm that generates a unique password for each login attempt using time as a counter. Every fixed interval (Better Auth defaults to 30 seconds), a new password is generated. This addresses several issues with traditional passwords: they can be forgotten, stolen, or guessed. OTPs solve some of these problems, but their delivery via SMS or email can be unreliable (or even risky, considering it opens new attack vectors). TOTP, however, generates codes offline, making it both secure and convenient. You just need an authenticator app on your phone. #### Getting TOTP URI After enabling 2FA, you can get the TOTP URI to display to the user. This URI is generated by the server using the `secret` and `issuer` and can be used to generate a QR code for the user to scan with their authenticator app. <APIMethod path="/two-factor/get-totp-uri" method="POST" requireSession> ```ts type getTOTPURI = { password: string } ``` </APIMethod> **Example: Using React** Once you have the TOTP URI, you can use it to generate a QR code for the user to scan with their authenticator app. ```tsx title="user-card.tsx" export default function UserCard({ password }: { password: string }){ const { data: session } = client.useSession(); const { data: qr } = useQuery({ queryKey: ["two-factor-qr"], queryFn: async () => { const res = await authClient.twoFactor.getTotpUri({ password }); return res.data; }, enabled: !!session?.user.twoFactorEnabled, }); return ( <QRCode value={qr?.totpURI || ""} /> ) } ``` <Callout> By default the issuer for TOTP is set to the app name provided in the auth config or if not provided it will be set to `Better Auth`. You can override this by passing `issuer` to the plugin config. </Callout> #### Verifying TOTP After the user has entered their 2FA code, you can verify it using `twoFactor.verifyTotp` method. `Better Auth` follows standard practice by accepting TOTP codes from one period before and one after the current code, ensuring users can authenticate even with minor time delays on their end. <APIMethod path="/two-factor/verify-totp" method="POST"> ```ts type verifyTOTP = { code: string = "012345" trustDevice?: boolean = true } ``` </APIMethod> ### OTP OTP (One-Time Password) is similar to TOTP but a random code is generated and sent to the user's email or phone. Before using OTP to verify the second factor, you need to configure `sendOTP` in your Better Auth instance. This function is responsible for sending the OTP to the user's email, phone, or any other method supported by your application. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ twoFactor({ otpOptions: { async sendOTP({ user, otp }, request) { }, }, }) ] }) ``` #### Sending OTP Sending an OTP is done by calling the `twoFactor.sendOtp` function. This function will trigger your sendOTP implementation that you provided in the Better Auth configuration. <APIMethod path="/two-factor/send-otp" method="POST"> ```ts type send2FaOTP = { trustDevice?: boolean = true } if (data) { } ``` </APIMethod> #### Verifying OTP After the user has entered their OTP code, you can verify it <APIMethod path="/two-factor/verify-otp" method="POST"> ```ts type verifyOTP = { code: string = "012345" trustDevice?: boolean = true } ``` </APIMethod> ### Backup Codes Backup codes are generated and stored in the database. This can be used to recover access to the account if the user loses access to their phone or email. #### Generating Backup Codes Generate backup codes for account recovery: <APIMethod path="/two-factor/generate-backup-codes" method="POST" requireSession> ```ts type generateBackupCodes = { password: string } if (data) { } ``` </APIMethod> <Callout type="warn"> When you generate backup codes, the old backup codes will be deleted and new ones will be generated. </Callout> #### Using Backup Codes You can now allow users to provider backup code as account recover method. <APIMethod path="/two-factor/verify-backup-code" method="POST"> ```ts type verifyBackupCode = { code: string = "123456" disableSession?: boolean = false trustDevice?: boolean = true } ``` </APIMethod> <Callout> Once a backup code is used, it will be removed from the database and can't be used again. </Callout> #### Viewing Backup Codes To display the backup codes to the user, you can call `viewBackupCodes` on the server. This will return the backup codes in the response. You should only this if the user has a fresh session - a session that was just created. <APIMethod path="/two-factor/view-backup-codes" method="GET" isServerOnly forceAsBody> ```ts type viewBackupCodes = { userId?: string | null = "user-id" } ``` </APIMethod> ### Trusted Devices You can mark a device as trusted by passing `trustDevice` to `verifyTotp` or `verifyOtp`. ```ts const verify2FA = async (code: string) => { const { data, error } = await authClient.twoFactor.verifyTotp({ code, callbackURL: "/dashboard", trustDevice: true }) if (data) { } } ``` When `trustDevice` is set to `true`, the current device will be remembered for 60 days. During this period, the user won't be prompted for 2FA on subsequent sign-ins from this device. The trust period is refreshed each time the user signs in successfully. ### Issuer By adding an `issuer` you can set your application name for the 2fa application. For example, if your user uses Google Auth, the default appName will show up as `Better Auth`. However, by using the following code, it will show up as `my-app-name`. ```ts twoFactor({ issuer: "my-app-name" }) ``` *** ## Schema The plugin requires 1 additional fields in the `user` table and 1 additional table to store the two factor authentication data. <DatabaseTable fields={[ { name: "twoFactorEnabled", type: "boolean", description: "Whether two factor authentication is enabled for the user.", isOptional: true }, ]} /> Table: `twoFactor` <DatabaseTable fields={[ { name: "id", type: "string", description: "The ID of the two factor authentication.", isPrimaryKey: true }, { name: "userId", type: "string", description: "The ID of the user", isForeignKey: true }, { name: "secret", type: "string", description: "The secret used to generate the TOTP code.", isOptional: true }, { name: "backupCodes", type: "string", description: "The backup codes used to recover access to the account if the user loses access to their phone or email.", isOptional: true }, ]} /> ## Options ### Server **twoFactorTable**: The name of the table that stores the two factor authentication data. Default: `twoFactor`. **skipVerificationOnEnable**: Skip the verification process before enabling two factor for a user. **Issuer**: The issuer is the name of your application. It's used to generate TOTP codes. It'll be displayed in the authenticator apps. **TOTP options** these are options for TOTP. <TypeTable type={{ digits:{ description: "The number of digits the otp to be", type: "number", default: 6, }, period: { description: "The period for totp in seconds.", type: "number", default: 30, }, }} /> **OTP options** these are options for OTP. <TypeTable type={{ sendOTP: { description: "a function that sends the otp to the user's email or phone number. It takes two parameters: user and otp", type: "function", }, period: { description: "The period for otp in minutes.", type: "number", default: 3, }, storeOTP: { description: "How to store the otp in the database. Whether to store it as plain text, encrypted or hashed. You can also provide a custom encryptor or hasher.", type: "string", default: "plain", }, }} /> **Backup Code Options** backup codes are generated and stored in the database when the user enabled two factor authentication. This can be used to recover access to the account if the user loses access to their phone or email. <TypeTable type={{ amount: { description: "The amount of backup codes to generate", type: "number", default: 10, }, length: { description: "The length of the backup codes", type: "number", default: 10, }, customBackupCodesGenerate: { description: "A function that generates custom backup codes. It takes no parameters and returns an array of strings.", type: "function", }, storeBackupCodes: { description: "How to store the backup codes in the database. Whether to store it as plain text or encrypted. You can also provide a custom encryptor.", type: "string", default: "plain", }, }} /> ### Client To use the two factor plugin in the client, you need to add it on your plugins list. ```ts title="auth-client.ts" const authClient = createAuthClient({ plugins: [ twoFactorClient({ onTwoFactorRedirect(){ window.location.href = "/2fa" } }) ] }) ``` **Options** `onTwoFactorRedirect`: A callback that will be called when the user needs to verify their 2FA code. This can be used to redirect the user to the 2FA page. # plugins: Admin URL: /docs/plugins/admin Source: https: Admin plugin for Better Auth *** title: Admin description: Admin plugin for Better Auth ----------------------------------------- The Admin plugin provides a set of administrative functions for user management in your application. It allows administrators to perform various operations such as creating users, managing user roles, banning/unbanning users, impersonating users, and more. ## Installation <Steps> <Step> ### Add the plugin to your auth config To use the Admin plugin, add it to your auth config. ```ts title="auth.ts" import { betterAuth } from "better-auth" import { admin } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ admin() ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin Next, include the admin client plugin in your authentication client instance. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { adminClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ adminClient() ] }) ``` </Step> </Steps> ## Usage Before performing any admin operations, the user must be authenticated with an admin account. An admin is any user assigned the `admin` role or any user whose ID is included in the `adminUserIds` option. ### Create User Allows an admin to create a new user. <APIMethod path="/admin/create-user" method="POST" resultVariable="newUser"> ```ts type createUser = { email: string = "user@example.com" password: string = "some-secure-password" name: string = "James Smith" role?: string | string[] = "user" data?: Record<string, any> = { customField: "customValue" } } ``` </APIMethod> ### List Users Allows an admin to list all users in the database. <APIMethod path="/admin/list-users" method="GET" requireSession note={"All properties are optional to configure. By default, 100 rows are returned, you can configure this by the `limit` property."} resultVariable={"users"}> ```ts type listUsers = { searchValue?: string = "some name" searchField?: "email" | "name" = "name" searchOperator?: "contains" | "starts_with" | "ends_with" = "contains" limit?: string | number = 100 offset?: string | number = 100 sortBy?: string = "name" sortDirection?: "asc" | "desc" = "desc" filterField?: string = "email" filterValue?: string | number | boolean = "hello@example.com" filterOperator?: "eq" | "ne" | "lt" | "lte" | "gt" | "gte" = "eq" } ``` </APIMethod> #### Query Filtering The `listUsers` function supports various filter operators including `eq`, `contains`, `starts_with`, and `ends_with`. #### Pagination The `listUsers` function supports pagination by returning metadata alongside the user list. The response includes the following fields: ```ts { users: User[], total: number, limit: number | undefined, offset: number | undefined } ``` ##### How to Implement Pagination To paginate results, use the `total`, `limit`, and `offset` values to calculate: * **Total pages:** `Math.ceil(total / limit)` * **Current page:** `(offset / limit) + 1` * **Next page offset:** `Math.min(offset + limit, (total - 1))` – The value to use as `offset` for the next page, ensuring it does not exceed the total number of pages. * **Previous page offset:** `Math.max(0, offset - limit)` – The value to use as `offset` for the previous page (ensuring it doesn’t go below zero). ##### Example Usage Fetching the second page with 10 users per page: ```ts title="admin.ts" const pageSize = 10; const currentPage = 2; const users = await authClient.admin.listUsers({ query: { limit: pageSize, offset: (currentPage - 1) * pageSize } }); const totalUsers = users.total; const totalPages = Math.ceil(totalUsers / limit) ``` ### Set User Role Changes the role of a user. <APIMethod path="/admin/set-role" method="POST" requireSession> ```ts type setRole = { userId?: string = "user-id" role: string | string[] = "admin" } ``` </APIMethod> ### Set User Password Changes the password of a user. <APIMethod path="/admin/set-user-password" method="POST" requireSession> ```ts type setUserPassword = { newPassword: string = 'new-password' userId: string = 'user-id' } ``` </APIMethod> ### Ban User Bans a user, preventing them from signing in and revokes all of their existing sessions. <APIMethod path="/admin/ban-user" method="POST" requireSession noResult> ```ts type banUser = { userId: string = "user-id" banReason?: string = "Spamming" banExpiresIn?: number = 60 * 60 * 24 * 7 } ``` </APIMethod> ### Unban User Removes the ban from a user, allowing them to sign in again. <APIMethod path="/admin/unban-user" method="POST" requireSession noResult> ```ts type unbanUser = { userId: string = "user-id" } ``` </APIMethod> ### List User Sessions Lists all sessions for a user. <APIMethod path="/admin/list-user-sessions" method="POST" requireSession> ```ts type listUserSessions = { userId: string = "user-id" } ``` </APIMethod> ### Revoke User Session Revokes a specific session for a user. <APIMethod path="/admin/revoke-user-session" method="POST" requireSession> ```ts type revokeUserSession = { sessionToken: string = "session_token_here" } ``` </APIMethod> ### Revoke All Sessions for a User Revokes all sessions for a user. <APIMethod path="/admin/revoke-user-sessions" method="POST" requireSession> ```ts type revokeUserSessions = { userId: string = "user-id" } ``` </APIMethod> ### Impersonate User This feature allows an admin to create a session that mimics the specified user. The session will remain active until either the browser session ends or it reaches 1 hour. You can change this duration by setting the `impersonationSessionDuration` option. <APIMethod path="/admin/impersonate-user" method="POST" requireSession> ```ts type impersonateUser = { userId: string = "user-id" } ``` </APIMethod> ### Stop Impersonating User To stop impersonating a user and continue with the admin account, you can use `stopImpersonating` <APIMethod path="/admin/stop-impersonating" method="POST" noResult requireSession> ```ts type stopImpersonating = { } ``` </APIMethod> ### Remove User Hard deletes a user from the database. <APIMethod path="/admin/remove-user" method="POST" requireSession resultVariable="deletedUser"> ```ts type removeUser = { userId: string = "user-id" } ``` </APIMethod> ## Access Control The admin plugin offers a highly flexible access control system, allowing you to manage user permissions based on their role. You can define custom permission sets to fit your needs. ### Roles By default, there are two roles: `admin`: Users with the admin role have full control over other users. `user`: Users with the user role have no control over other users. <Callout> A user can have multiple roles. Multiple roles are stored as string separated by comma (","). </Callout> ### Permissions By default, there are two resources with up to six permissions. **user**: `create` `list` `set-role` `ban` `impersonate` `delete` `set-password` **session**: `list` `revoke` `delete` Users with the admin role have full control over all the resources and actions. Users with the user role have no control over any of those actions. ### Custom Permissions The plugin provides an easy way to define your own set of permissions for each role. <Steps> <Step> #### Create Access Control You first need to create an access controller by calling the `createAccessControl` function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value. ```ts title="permissions.ts" import { createAccessControl } from "better-auth/plugins/access"; const statement = { project: ["create", "share", "update", "delete"], } as const; const ac = createAccessControl(statement); ``` </Step> <Step> #### Create Roles Once you have created the access controller you can create roles with the permissions you have defined. ```ts title="permissions.ts" import { createAccessControl } from "better-auth/plugins/access"; export const statement = { project: ["create", "share", "update", "delete"], } as const; const ac = createAccessControl(statement); export const user = ac.newRole({ project: ["create"], }); export const admin = ac.newRole({ project: ["create", "update"], }); export const myCustomRole = ac.newRole({ project: ["create", "update", "delete"], user: ["ban"], }); ``` When you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import `defaultStatements` and merge it with your new statement, plus merge the roles' permissions set with the default roles. ```ts title="permissions.ts" import { createAccessControl } from "better-auth/plugins/access"; import { defaultStatements, adminAc } from "better-auth/plugins/admin/access"; const statement = { ...defaultStatements, project: ["create", "share", "update", "delete"], } as const; const ac = createAccessControl(statement); const admin = ac.newRole({ project: ["create", "update"], ...adminAc.statements, }); ``` </Step> <Step> #### Pass Roles to the Plugin Once you have created the roles you can pass them to the admin plugin both on the client and the server. ```ts title="auth.ts" import { betterAuth } from "better-auth" import { admin as adminPlugin } from "better-auth/plugins" import { ac, admin, user } from "@/auth/permissions" export const auth = betterAuth({ plugins: [ adminPlugin({ ac, roles: { admin, user, myCustomRole } }), ], }); ``` You also need to pass the access controller and the roles to the client plugin. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { adminClient } from "better-auth/client/plugins" import { ac, admin, user, myCustomRole } from "@/auth/permissions" export const client = createAuthClient({ plugins: [ adminClient({ ac, roles: { admin, user, myCustomRole } }) ] }) ``` </Step> </Steps> ### Access Control Usage **Has Permission**: To check a user's permissions, you can use the `hasPermission` function provided by the client. <APIMethod path="/admin/has-permission" method="POST"> ```ts type userHasPermission = { userId?: string = "user-id" role?: string = "admin" permission?: Record<string, string[]> = { "project": ["create", "update"] } , permissions?: Record<string, string[]> } ``` </APIMethod> Example usage: ```ts title="auth-client.ts" const canCreateProject = await authClient.admin.hasPermission({ permissions: { project: ["create"], }, }); const canCreateProjectAndCreateSale = await authClient.admin.hasPermission({ permissions: { project: ["create"], sale: ["create"] }, }); ``` If you want to check a user's permissions server-side, you can use the `userHasPermission` action provided by the `api` to check the user's permissions. ```ts title="api.ts" await auth.api.userHasPermission({ body: { userId: 'id', permissions: { project: ["create"], }, }, }); await auth.api.userHasPermission({ body: { role: "admin", permissions: { project: ["create"], }, }, }); await auth.api.userHasPermission({ body: { role: "admin", permissions: { project: ["create"], sale: ["create"] }, }, }); ``` **Check Role Permission**: Use the `checkRolePermission` function on the client side to verify whether a given **role** has a specific **permission**. This is helpful after defining roles and their permissions, as it allows you to perform permission checks without needing to contact the server. Note that this function does **not** check the permissions of the currently logged-in user directly. Instead, it checks what permissions are assigned to a specified role. The function is synchronous, so you don't need to use `await` when calling it. ```ts title="auth-client.ts" const canCreateProject = authClient.admin.checkRolePermission({ permissions: { user: ["delete"], }, role: "admin", }); const canDeleteUserAndRevokeSession = authClient.admin.checkRolePermission({ permissions: { user: ["delete"], session: ["revoke"] }, role: "admin", }); ``` ## Schema This plugin adds the following fields to the `user` table: <DatabaseTable fields={[ { name: "role", type: "string", description: "The user's role. Defaults to `user`. Admins will have the `admin` role.", isOptional: true, }, { name: "banned", type: "boolean", description: "Indicates whether the user is banned.", isOptional: true, }, { name: "banReason", type: "string", description: "The reason for the user's ban.", isOptional: true, }, { name: "banExpires", type: "date", description: "The date when the user's ban will expire.", isOptional: true, }, ]} /> And adds one field in the `session` table: <DatabaseTable fields={[ { name: "impersonatedBy", type: "string", description: "The ID of the admin that is impersonating this session.", isOptional: true, }, ]} /> ## Options ### Default Role The default role for a user. Defaults to `user`. ```ts title="auth.ts" admin({ defaultRole: "regular", }); ``` ### Admin Roles The roles that are considered admin roles. Defaults to `["admin"]`. ```ts title="auth.ts" admin({ adminRoles: ["admin", "superadmin"], }); ``` <Callout type="warning"> Any role that isn't in the `adminRoles` list, even if they have the permission, will not be considered an admin. </Callout> ### Admin userIds You can pass an array of userIds that should be considered as admin. Default to `[]` ```ts title="auth.ts" admin({ adminUserIds: ["user_id_1", "user_id_2"] }) ``` If a user is in the `adminUserIds` list, they will be able to perform any admin operation. ### impersonationSessionDuration The duration of the impersonation session in seconds. Defaults to 1 hour. ```ts title="auth.ts" admin({ impersonationSessionDuration: 60 * 60 * 24, }); ``` ### Default Ban Reason The default ban reason for a user created by the admin. Defaults to `No reason`. ```ts title="auth.ts" admin({ defaultBanReason: "Spamming", }); ``` ### Default Ban Expires In The default ban expires in for a user created by the admin in seconds. Defaults to `undefined` (meaning the ban never expires). ```ts title="auth.ts" admin({ defaultBanExpiresIn: 60 * 60 * 24, }); ``` ### bannedUserMessage The message to show when a banned user tries to sign in. Defaults to "You have been banned from this application. Please contact support if you believe this is an error." ```ts title="auth.ts" admin({ bannedUserMessage: "Custom banned user message", }); ``` # plugins: Anonymous URL: /docs/plugins/anonymous Source: https: Anonymous plugin for Better Auth. *** title: Anonymous\ description: Anonymous plugin for Better Auth. ---------------------------------------------- The Anonymous plugin allows users to have an authenticated experience without requiring them to provide an email address, password, OAuth provider, or any other Personally Identifiable Information (PII). Users can later link an authentication method to their account when ready. ## Installation <Steps> <Step> ### Add the plugin to your auth config To enable anonymous authentication, add the anonymous plugin to your authentication configuration. ```ts title="auth.ts" import { betterAuth } from "better-auth" import { anonymous } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ anonymous() ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin Next, include the anonymous client plugin in your authentication client instance. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { anonymousClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ anonymousClient() ] }) ``` </Step> </Steps> ## Usage ### Sign In To sign in a user anonymously, use the `signIn.anonymous()` method. ```ts title="example.ts" const user = await authClient.signIn.anonymous() ``` ### Link Account If a user is already signed in anonymously and tries to `signIn` or `signUp` with another method, their anonymous activities can be linked to the new account. To do that you first need to provide `onLinkAccount` callback to the plugin. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ anonymous({ onLinkAccount: async ({ anonymousUser, newUser }) => { } }) ] ``` Then when you call `signIn` or `signUp` with another method, the `onLinkAccount` callback will be called. And the `anonymousUser` will be deleted by default. ```ts title="example.ts" const user = await authClient.signIn.email({ email, }) ``` ## Options * `emailDomainName`: The domain name to use when generating an email address for anonymous users. Defaults to the domain name of the current site. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ anonymous({ emailDomainName: "example.com" }) ] }) ``` * `onLinkAccount`: A callback function that is called when an anonymous user links their account to a new authentication method. The callback receives an object with the `anonymousUser` and the `newUser`. * `disableDeleteAnonymousUser`: By default, the anonymous user is deleted when the account is linked to a new authentication method. Set this option to `true` to disable this behavior. * `generateName`: A callback function that is called to generate a name for the anonymous user. Useful if you want to have random names for anonymous users, or if `name` is unique in your database. ## Schema The anonymous plugin requires an additional field in the user table: <DatabaseTable fields={[ { name: "isAnonymous", type: "boolean", description: "Indicates whether the user is anonymous.", isOptional: true }, ]} /> # plugins: API Key URL: /docs/plugins/api-key Source: https: API Key plugin for Better Auth. *** title: API Key description: API Key plugin for Better Auth. -------------------------------------------- The API Key plugin allows you to create and manage API keys for your application. It provides a way to authenticate and authorize API requests by verifying API keys. ## Features * Create, manage, and verify API keys * [Built-in rate limiting](/docs/plugins/api-key#rate-limiting) * [Custom expiration times, remaining count, and refill systems](/docs/plugins/api-key#remaining-refill-and-expiration) * [metadata for API keys](/docs/plugins/api-key#metadata) * Custom prefix * [Sessions from API keys](/docs/plugins/api-key#sessions-from-api-keys) ## Installation <Steps> <Step> ### Add Plugin to the server ```ts title="auth.ts" import { betterAuth } from "better-auth" import { apiKey } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ apiKey() ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { apiKeyClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ apiKeyClient() ] }) ``` </Step> </Steps> ## Usage You can view the list of API Key plugin options [here](/docs/plugins/api-key#api-key-plugin-options). ### Create an API key <APIMethod path="/api-key/create" method="POST" serverOnlyNote="If you're creating an API key on the server, without access to headers, you must pass the `userId` property. This is the ID of the user that the API key is associated with." clientOnlyNote="You can adjust more specific API key configurations by using the server method instead."> ```ts type createApiKey = { name?: string = 'project-api-key' expiresIn?: number = 60 * 60 * 24 * 7 userId?: string = "user-id" prefix?: string = 'project-api-key' remaining?: number = 100 metadata?: any | null = { someKey: 'someValue' } refillAmount?: number = 100 refillInterval?: number = 1000 rateLimitTimeWindow?: number = 1000 rateLimitMax?: number = 100 rateLimitEnabled?: boolean = true permissions?: Record<string, string[]> } ``` </APIMethod> <Callout>API keys are assigned to a user.</Callout> #### Result It'll return the `ApiKey` object which includes the `key` value for you to use. Otherwise if it throws, it will throw an `APIError`. *** ### Verify an API key <APIMethod path="/api-key/verify" method="POST" isServerOnly> ```ts const permissions = { projects: ["read", "read-write"], } type verifyApiKey = { key: string = "your_api_key_here" permissions?: Record<string, string[]> } ``` </APIMethod> #### Result ```ts type Result = { valid: boolean; error: { message: string; code: string } | null; key: Omit<ApiKey, "key"> | null; }; ``` *** ### Get an API key <APIMethod path="/api-key/get" method="GET" requireSession> ```ts type getApiKey = { id: string = "some-api-key-id" } ``` </APIMethod> #### Result You'll receive everything about the API key details, except for the `key` value itself. If it fails, it will throw an `APIError`. ```ts type Result = Omit<ApiKey, "key">; ``` *** ### Update an API key <APIMethod path="/api-key/update" method="POST"> ```ts type updateApiKey = { keyId: string = "some-api-key-id" userId?: string = "some-user-id" name?: string = "some-api-key-name" enabled?: boolean = true remaining?: number = 100 refillAmount?: number = 100 refillInterval?: number = 1000 metadata?: any | null = { "key": "value" } expiresIn?: number = 60 * 60 * 24 * 7 rateLimitEnabled?: boolean = true rateLimitTimeWindow?: number = 1000 rateLimitMax?: number = 100 permissions?: Record<string, string[]> } ``` </APIMethod> #### Result If fails, throws `APIError`. Otherwise, you'll receive the API Key details, except for the `key` value itself. *** ### Delete an API Key <APIMethod path="/api-key/delete" method="POST" requireSession note="This endpoint is attempting to delete the API key from the perspective of the user. It will check if the user's ID matches the key owner to be able to delete it. If you want to delete a key without these checks, we recommend you use an ORM to directly mutate your DB instead."> ```ts type deleteApiKey = { keyId: string = "some-api-key-id" } ``` </APIMethod> #### Result If fails, throws `APIError`. Otherwise, you'll receive: ```ts type Result = { success: boolean; }; ``` *** ### List API keys <APIMethod path="/api-key/list" method="GET" requireSession> ```ts type listApiKeys = { } ``` </APIMethod> #### Result If fails, throws `APIError`. Otherwise, you'll receive: ```ts type Result = ApiKey[]; ``` *** ### Delete all expired API keys This function will delete all API keys that have an expired expiration date. <APIMethod path="/api-key/delete-all-expired-api-keys" method="POST" isServerOnly> ```ts type deleteAllExpiredApiKeys = { } ``` </APIMethod> <Callout> We automatically delete expired API keys every time any apiKey plugin endpoints were called, however they are rate-limited to a 10 second cool down each call to prevent multiple calls to the database. </Callout> *** ## Sessions from API keys Any time an endpoint in Better Auth is called that has a valid API key in the headers, we will automatically create a mock session to represent the user. <Tabs items={['Server']}> <Tab value="Server"> ```ts const session = await auth.api.getSession({ headers: new Headers({ 'x-api-key': apiKey, }), }); ``` </Tab> </Tabs> The default header key is `x-api-key`, but this can be changed by setting the `apiKeyHeaders` option in the plugin options. ```ts export const auth = betterAuth({ plugins: [ apiKey({ apiKeyHeaders: ["x-api-key", "xyz-api-key"], }), ], }); ``` Or optionally, you can pass an `apiKeyGetter` function to the plugin options, which will be called with the `GenericEndpointContext`, and from there, you should return the API key, or `null` if the request is invalid. ```ts export const auth = betterAuth({ plugins: [ apiKey({ apiKeyGetter: (ctx) => { const has = ctx.request.headers.has("x-api-key"); if (!has) return null; return ctx.request.headers.get("x-api-key"); }, }), ], }); ``` ## Rate Limiting Every API key can have its own rate limit settings, however, the built-in rate-limiting only applies to the verification process for a given API key. For every other endpoint/method, you should utilize Better Auth's [built-in rate-limiting](/docs/concepts/rate-limit). You can refer to the rate-limit default configurations below in the API Key plugin options. An example default value: ```ts export const auth = betterAuth({ plugins: [ apiKey({ rateLimit: { enabled: true, timeWindow: 1000 * 60 * 60 * 24, maxRequests: 10, }, }), ], }); ``` For each API key, you can customize the rate-limit options on create. <Callout> You can only customize the rate-limit options on the server auth instance. </Callout> ```ts const apiKey = await auth.api.createApiKey({ body: { rateLimitEnabled: true, rateLimitTimeWindow: 1000 * 60 * 60 * 24, rateLimitMax: 10, }, headers: user_headers, }); ``` ### How does it work? For each request, a counter (internally called `requestCount`) is incremented.\ If the `rateLimitMax` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. ## Remaining, refill, and expiration The remaining count is the number of requests left before the API key is disabled.\ The refill interval is the interval in milliseconds where the `remaining` count is refilled by day.\ The expiration time is the expiration date of the API key. ### How does it work? #### Remaining: Whenever an API key is used, the `remaining` count is updated.\ If the `remaining` count is `null`, then there is no cap to key usage.\ Otherwise, the `remaining` count is decremented by 1.\ If the `remaining` count is 0, then the API key is disabled & removed. #### refillInterval & refillAmount: Whenever an API key is created, the `refillInterval` and `refillAmount` are set to `null`.\ This means that the API key will not be refilled automatically.\ However, if `refillInterval` & `refillAmount` are set, then the API key will be refilled accordingly. #### Expiration: Whenever an API key is created, the `expiresAt` is set to `null`.\ This means that the API key will never expire.\ However, if the `expiresIn` is set, then the API key will expire after the `expiresIn` time. ## Custom Key generation & verification You can customize the key generation and verification process straight from the plugin options. Here's an example: ```ts export const auth = betterAuth({ plugins: [ apiKey({ customKeyGenerator: (options: { length: number; prefix: string | undefined; }) => { const apiKey = mySuperSecretApiKeyGenerator( options.length, options.prefix ); return apiKey; }, customAPIKeyValidator: async ({ ctx, key }) => { const res = await keyService.verify(key) return res.valid }, }), ], }); ``` <Callout> If you're **not** using the `length` property provided by `customKeyGenerator`, you **must** set the `defaultKeyLength` property to how long generated keys will be. ```ts export const auth = betterAuth({ plugins: [ apiKey({ customKeyGenerator: () => { return crypto.randomUUID(); }, defaultKeyLength: 36, }), ], }); ``` </Callout> If an API key is validated from your `customAPIKeyValidator`, we still must match that against the database's key. However, by providing this custom function, you can improve the performance of the API key verification process, as all failed keys can be invalidated without having to query your database. ## Metadata We allow you to store metadata alongside your API keys. This is useful for storing information about the key, such as a subscription plan for example. To store metadata, make sure you haven't disabled the metadata feature in the plugin options. ```ts export const auth = betterAuth({ plugins: [ apiKey({ enableMetadata: true, }), ], }); ``` Then, you can store metadata in the `metadata` field of the API key object. ```ts const apiKey = await auth.api.createApiKey({ body: { metadata: { plan: "premium", }, }, }); ``` You can then retrieve the metadata from the API key object. ```ts const apiKey = await auth.api.getApiKey({ body: { keyId: "your_api_key_id_here", }, }); console.log(apiKey.metadata.plan); ``` ## API Key plugin options `apiKeyHeaders` <span className="opacity-70">`string | string[];`</span> The header name to check for API key. Default is `x-api-key`. `customAPIKeyGetter` <span className="opacity-70">`(ctx: GenericEndpointContext) => string | null`</span> A custom function to get the API key from the context. `customAPIKeyValidator` <span className="opacity-70">`(options: { ctx: GenericEndpointContext; key: string; }) => boolean | Promise<boolean>`</span> A custom function to validate the API key. `customKeyGenerator` <span className="opacity-70">`(options: { length: number; prefix: string | undefined; }) => string | Promise<string>`</span> A custom function to generate the API key. `startingCharactersConfig` <span className="opacity-70">`{ shouldStore?: boolean; charactersLength?: number; }`</span> Customize the starting characters configuration. <Accordions> <Accordion title="startingCharactersConfig Options"> `shouldStore` <span className="opacity-70">`boolean`</span> Wether to store the starting characters in the database. If false, we will set `start` to `null`. Default is `true`. `charactersLength` <span className="opacity-70">`number`</span> The length of the starting characters to store in the database. This includes the prefix length. Default is `6`. </Accordion> </Accordions> `defaultKeyLength` <span className="opacity-70">`number`</span> The length of the API key. Longer is better. Default is 64. (Doesn't include the prefix length) `defaultPrefix` <span className="opacity-70">`string`</span> The prefix of the API key. Note: We recommend you append an underscore to the prefix to make the prefix more identifiable. (eg `hello_`) `maximumPrefixLength` <span className="opacity-70">`number`</span> The maximum length of the prefix. `minimumPrefixLength` <span className="opacity-70">`number`</span> The minimum length of the prefix. `requireName` <span className="opacity-70">`boolean`</span> Whether to require a name for the API key. Default is `false`. `maximumNameLength` <span className="opacity-70">`number`</span> The maximum length of the name. `minimumNameLength` <span className="opacity-70">`number`</span> The minimum length of the name. `enableMetadata` <span className="opacity-70">`boolean`</span> Whether to enable metadata for an API key. `keyExpiration` <span className="opacity-70">`{ defaultExpiresIn?: number | null; disableCustomExpiresTime?: boolean; minExpiresIn?: number; maxExpiresIn?: number; }`</span> Customize the key expiration. <Accordions> <Accordion title="keyExpiration options"> `defaultExpiresIn` <span className="opacity-70">`number | null`</span> The default expires time in milliseconds. If `null`, then there will be no expiration time. Default is `null`. `disableCustomExpiresTime` <span className="opacity-70">`boolean`</span> Wether to disable the expires time passed from the client. If `true`, the expires time will be based on the default values. Default is `false`. `minExpiresIn` <span className="opacity-70">`number`</span> The minimum expiresIn value allowed to be set from the client. in days. Default is `1`. `maxExpiresIn` <span className="opacity-70">`number`</span> The maximum expiresIn value allowed to be set from the client. in days. Default is `365`. </Accordion> </Accordions> `rateLimit` <span className="opacity-70">`{ enabled?: boolean; timeWindow?: number; maxRequests?: number; }`</span> Customize the rate-limiting. <Accordions> <Accordion title="rateLimit options"> `enabled` <span className="opacity-70">`boolean`</span> Whether to enable rate limiting. (Default true) `timeWindow` <span className="opacity-70">`number`</span> The duration in milliseconds where each request is counted. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. `maxRequests` <span className="opacity-70">`number`</span> Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. </Accordion> </Accordions> `schema` <span className="opacity-70">`InferOptionSchema<ReturnType<typeof apiKeySchema>>`</span> Custom schema for the API key plugin. `disableSessionForAPIKeys` <span className="opacity-70">`boolean`</span> An API Key can represent a valid session, so we automatically mock a session for the user if we find a valid API key in the request headers. `permissions` <span className="opacity-70">`{ defaultPermissions?: Statements | ((userId: string, ctx: GenericEndpointContext) => Statements | Promise<Statements>) }`</span> Permissions for the API key. Read more about permissions [here](/docs/plugins/api-key#permissions). <Accordions> <Accordion title="permissions Options"> `defaultPermissions` <span className="opacity-70">`Statements | ((userId: string, ctx: GenericEndpointContext) => Statements | Promise<Statements>)`</span> The default permissions for the API key. </Accordion> </Accordions> `disableKeyHashing` <span className="opacity-70">`boolean`</span> Disable hashing of the API key. ⚠️ Security Warning: It's strongly recommended to not disable hashing. Storing API keys in plaintext makes them vulnerable to database breaches, potentially exposing all your users' API keys. *** ## Permissions API keys can have permissions associated with them, allowing you to control access at a granular level. Permissions are structured as a record of resource types to arrays of allowed actions. ### Setting Default Permissions You can configure default permissions that will be applied to all newly created API keys: ```ts export const auth = betterAuth({ plugins: [ apiKey({ permissions: { defaultPermissions: { files: ["read"], users: ["read"], }, }, }), ], }); ``` You can also provide a function that returns permissions dynamically: ```ts export const auth = betterAuth({ plugins: [ apiKey({ permissions: { defaultPermissions: async (userId, ctx) => { return { files: ["read"], users: ["read"], }; }, }, }), ], }); ``` ### Creating API Keys with Permissions When creating an API key, you can specify custom permissions: ```ts const apiKey = await auth.api.createApiKey({ body: { name: "My API Key", permissions: { files: ["read", "write"], users: ["read"], }, userId: "userId", }, }); ``` ### Verifying API Keys with Required Permissions When verifying an API key, you can check if it has the required permissions: ```ts const result = await auth.api.verifyApiKey({ body: { key: "your_api_key_here", permissions: { files: ["read"], }, }, }); if (result.valid) { } else { } ``` ### Updating API Key Permissions You can update the permissions of an existing API key: ```ts const apiKey = await auth.api.updateApiKey({ body: { keyId: existingApiKeyId, permissions: { files: ["read", "write", "delete"], users: ["read", "write"], }, }, headers: user_headers, }); ``` ### Permissions Structure Permissions follow a resource-based structure: ```ts type Permissions = { [resourceType: string]: string[]; }; const permissions = { files: ["read", "write", "delete"], users: ["read"], projects: ["read", "write"], }; ``` When verifying an API key, all required permissions must be present in the API key's permissions for validation to succeed. ## Schema Table: `apiKey` <DatabaseTable fields={[ { name: "id", type: "string", description: "The ID of the API key.", isUnique: true, isPrimaryKey: true, }, { name: "name", type: "string", description: "The name of the API key.", isOptional: true, }, { name: "start", type: "string", description: "The starting characters of the API key. Useful for showing the first few characters of the API key in the UI for the users to easily identify.", isOptional: true, }, { name: "prefix", type: "string", description: "The API Key prefix. Stored as plain text.", isOptional: true, }, { name: "key", type: "string", description: "The hashed API key itself.", }, { name: "userId", type: "string", description: "The ID of the user associated with the API key.", isForeignKey: true, }, { name: "refillInterval", type: "number", description: "The interval to refill the key in milliseconds.", isOptional: true, }, { name: "refillAmount", type: "number", description: "The amount to refill the remaining count of the key.", isOptional: true, }, { name: "lastRefillAt", type: "Date", description: "The date and time when the key was last refilled.", isOptional: true, }, { name: "enabled", type: "boolean", description: "Whether the API key is enabled.", }, { name: "rateLimitEnabled", type: "boolean", description: "Whether the API key has rate limiting enabled.", }, { name: "rateLimitTimeWindow", type: "number", description: "The time window in milliseconds for the rate limit.", isOptional: true, }, { name: "rateLimitMax", type: "number", description: "The maximum number of requests allowed within the `rateLimitTimeWindow`.", isOptional: true, }, { name: "requestCount", type: "number", description: "The number of requests made within the rate limit time window.", }, { name: "remaining", type: "number", description: "The number of requests remaining.", isOptional: true, }, { name: "lastRequest", type: "Date", description: "The date and time of the last request made to the key.", isOptional: true, }, { name: "expiresAt", type: "Date", description: "The date and time when the key will expire.", isOptional: true, }, { name: "createdAt", type: "Date", description: "The date and time the API key was created.", }, { name: "updatedAt", type: "Date", description: "The date and time the API key was updated.", }, { name: "permissions", type: "string", description: "The permissions of the key.", isOptional: true, }, { name: "metadata", type: "Object", isOptional: true, description: "Any additional metadata you want to store with the key.", }, ]} /> # plugins: Autumn Billing URL: /docs/plugins/autumn Source: https: Better Auth Plugin for Autumn Billing *** title: Autumn Billing description: Better Auth Plugin for Autumn Billing -------------------------------------------------- [Autumn](https: <Card href="https: We're online to help you with any questions you have. </Card> ## Features * One function for all checkout, subscription and payment flows * No webhooks required: query Autumn for the data you need * Manages your application's free and paid plans * Usage tracking for usage billing and periodic limits * Custom plans and pricing changes through Autumn's dashboard <Steps> <Step> ### Setup Autumn Account First, create your pricing plans in Autumn's [dashboard](https: </Step> <Step> ### Install Autumn SDK <Tabs items={}> <Tab value="npm"> ```bash npm install autumn-js ``` </Tab> <Tab value="pnpm"> ```bash pnpm add autumn-js ``` </Tab> <Tab value="yarn"> ```bash yarn add autumn-js ``` </Tab> <Tab value="bun"> ```bash bun add autumn-js ``` </Tab> </Tabs> <Callout> If you're using a separate client and server setup, make sure to install the plugin in both parts of your project. </Callout> </Step> <Step> ### Add `AUTUMN_SECRET_KEY` to your environment variables You can find it in Autumn's dashboard under "[Developer](https: ```bash title=".env" AUTUMN_SECRET_KEY=am_sk_xxxxxxxxxx ``` </Step> <Step> ### Add the Autumn plugin to your `auth` config ```ts title="auth.ts" import { autumn } from "autumn-js/better-auth"; export const auth = betterAuth({ plugins: [autumn()], }); ``` <Callout> Autumn will auto-create your customers when they sign up, and assign them any default plans you created (eg your Free plan) </Callout> </Step> <Step> ### Add `<AutumnProvider />` Client side, wrap your application with the AutumnProvider component, and pass in the `baseUrl` that you define within better-auth's `authClient`. ```tsx title="app/layout.tsx" import { AutumnProvider } from "autumn-js/react"; export default function RootLayout({ children, }: { children: React.ReactNode; }) { return ( <html> <body> {} <AutumnProvider betterAuthUrl={process.env.NEXT_PUBLIC_BETTER_AUTH_URL}> {children} </AutumnProvider> </body> </html> ); } ``` </Step> </Steps> ## Usage ### Handle payments Call `attach` to redirect the customer to a Stripe checkout page when they want to purchase the Pro plan. If their payment method is already on file, `AttachDialog` will open instead to let the customer confirm their new subscription or purchase, and handle the payment. <Callout type="warn"> {" "} Make sure you've pasted in your [Stripe test secret key](https: dashboard](https: </Callout> ```tsx export default function PurchaseButton() { const { attach } = useCustomer(); return ( <button onClick={async () => { await attach({ productId: "pro", dialog: AttachDialog, }); }} > Upgrade to Pro </button> ); } ``` The AttachDialog component can be used directly from the `autumn-js/react` library (as shown in the example above), or downloaded as a [shadcn/ui component](https: ### Integrate Pricing Logic Integrate your client and server pricing tiers logic with the following functions: * `check` to see if the customer is `allowed` to send a message. * `track` a usage event in Autumn (typically done server-side) * `customer` to display any relevant billing data in your UI (subscriptions, feature balances) Server-side, you can access Autumn's functions through the `auth` object. <Tabs items={["Client", "Server"]}> <Tab value="Client"> ```jsx import { useCustomer } from "autumn-js/react"; export default function SendChatMessage() { const { customer, allowed, refetch } = useCustomer(); return ( <> <button onClick={async () => { if (allowed({ featureId: "messages" })) { await refetch(); alert( "Remaining messages: " + customer?.features.messages?.balance ); } else { alert("You're out of messages"); } }} > Send Message </button> </> ); } ``` </Tab> <Tab value="Server"> ```typescript Server import { auth } from "@/lib/auth"; const { allowed } = await auth.api.check({ headers: await headers(), body: { feature_id: "messages", }, }); await auth.api.track({ headers: await headers(), body: { feature_id: "messages", value: 2, }, }); ``` </Tab> </Tabs> ### Additional Functions #### openBillingPortal() Opens a billing portal where the customer can update their payment method or cancel their plan. ```tsx export default function BillingSettings() { const { openBillingPortal } = useCustomer(); return ( <button onClick={async () => { await openBillingPortal({ returnUrl: "/settings/billing", }); }} > Manage Billing </button> ); } ``` #### cancel() Cancel a product or subscription. ```tsx export default function CancelSubscription() { const { cancel } = useCustomer(); return ( <button onClick={async () => { await cancel({ productId: "pro" }); }} > Cancel Subscription </button> ); } ``` #### Get invoice history Pass in an `expand` param into `useCustomer` to get additional information. You can expand `invoices`, `trials_used`, `payment_method`, or `rewards`. ```tsx export default function CustomerProfile() { const { customer } = useCustomer({ expand: ["invoices"] }); return ( <div> <h2>Customer Profile</h2> <p>Name: {customer?.name}</p> <p>Email: {customer?.email}</p> <p>Balance: {customer?.features.chat_messages?.balance}</p> </div> ); } ``` # plugins: Bearer Token Authentication URL: /docs/plugins/bearer Source: https: Authenticate API requests using Bearer tokens instead of browser cookies *** title: Bearer Token Authentication description: Authenticate API requests using Bearer tokens instead of browser cookies ------------------------------------------------------------------------------------- The Bearer plugin enables authentication using Bearer tokens as an alternative to browser cookies. It intercepts requests, adding the Bearer token to the Authorization header before forwarding them to your API. <Callout type="warn"> Use this cautiously; it is intended only for APIs that don't support cookies or require Bearer tokens for authentication. Improper implementation could easily lead to security vulnerabilities. </Callout> ## Installing the Bearer Plugin Add the Bearer plugin to your authentication setup: ```ts title="auth.ts" export const auth = betterAuth({ plugins: [bearer()] }); ``` ## How to Use Bearer Tokens ### 1. Obtain the Bearer Token After a successful sign-in, you'll receive a session token in the response headers. Store this token securely (e.g., in `localStorage`): ```ts title="auth-client.ts" const { data } = await authClient.signIn.email({ email: "user@example.com", password: "securepassword" }, { onSuccess: (ctx)=>{ const authToken = ctx.response.headers.get("set-auth-token") localStorage.setItem("bearer_token", authToken); } }); ``` You can also set this up globally in your auth client: ```ts title="auth-client.ts" export const authClient = createAuthClient({ fetchOptions: { onSuccess: (ctx) => { const authToken = ctx.response.headers.get("set-auth-token") if(authToken){ localStorage.setItem("bearer_token", authToken); } } } }); ``` You may want to clear the token based on the response status code or other conditions: ### 2. Configure the Auth Client Set up your auth client to include the Bearer token in all requests: ```ts title="auth-client.ts" export const authClient = createAuthClient({ fetchOptions: { auth: { type:"Bearer", token: () => localStorage.getItem("bearer_token") || "" } } }); ``` ### 3. Make Authenticated Requests Now you can make authenticated API calls: ```ts title="auth-client.ts" const { data } = await authClient.listSessions(); ``` ### 4. Per-Request Token (Optional) You can also provide the token for individual requests: ```ts title="auth-client.ts" const { data } = await authClient.listSessions({ fetchOptions: { headers: { Authorization: `Bearer ${token}` } } }); ``` ### 5. Using Bearer Tokens Outside the Auth Client The Bearer token can be used to authenticate any request to your API, even when not using the auth client: ```ts title="api-call.ts" const token = localStorage.getItem("bearer_token"); const response = await fetch("https: headers: { Authorization: `Bearer ${token}` } }); const data = await response.json(); ``` And in the server, you can use the `auth.api.getSession` function to authenticate requests: ```ts title="server.ts" export async function handler(req, res) { const session = await auth.api.getSession({ headers: req.headers }); if (!session) { return res.status(401).json({ error: "Unauthorized" }); } } ``` ## Options **requireSignature** (boolean): Require the token to be signed. Default: `false`. # plugins: Captcha URL: /docs/plugins/captcha Source: https: Captcha plugin *** title: Captcha description: Captcha plugin --------------------------- The **Captcha Plugin** integrates bot protection into your Better Auth system by adding captcha verification for key endpoints. This plugin ensures that only human users can perform actions like signing up, signing in, or resetting passwords. The following providers are currently supported: * [Google reCAPTCHA](https: * [Cloudflare Turnstile](https: * [hCaptcha](https: <Callout type="info"> This plugin works out of the box with <Link href="/docs/authentication/email-password">Email & Password</Link> authentication. To use it with other authentication methods, you will need to configure the <Link href="/docs/plugins/captcha#plugin-options">endpoints</Link> array in the plugin options. </Callout> ## Installation <Steps> <Step> ### Add the plugin to your **auth** config ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { captcha } from "better-auth/plugins"; export const auth = betterAuth({ plugins: [ captcha({ provider: "cloudflare-turnstile", secretKey: process.env.TURNSTILE_SECRET_KEY!, }), ], }); ``` </Step> <Step> ### Add the captcha token to your request headers Add the captcha token to your request headers for all protected endpoints. This example shows how to include it in a `signIn` request: ```ts await authClient.signIn.email({ email: "user@example.com", password: "secure-password", fetchOptions: { headers: { "x-captcha-response": turnstileToken, "x-captcha-user-remote-ip": userIp, }, }, }); ``` * To implement Cloudflare Turnstile on the client side, follow the official [Cloudflare Turnstile documentation](https: * To implement Google reCAPTCHA on the client side, follow the official [Google reCAPTCHA documentation](https: * To implement hCaptcha on the client side, follow the official [hCaptcha documentation](https: </Step> </Steps> ## How it works <Steps> <Step> The plugin acts as a middleware: it intercepts all `POST` requests to configured endpoints (see `endpoints` in the [Plugin Options](#plugin-options) section). </Step> <Step> it validates the captcha token on the server, by calling the captcha provider's `/siteverify`. </Step> <Step> * if the token is missing, gets rejected by the captcha provider, or if the `/siteverify` endpoint is unavailable, the plugin returns an error and interrupts the request. * if the token is accepted by the captcha provider, the middleware returns `undefined`, meaning the request is allowed to proceed. </Step> </Steps> ## Plugin Options * **`provider` (required)**: your captcha provider. * **`secretKey` (required)**: your provider's secret key used for the server-side validation. * `endpoints` (optional): overrides the default array of paths where captcha validation is enforced. Default is: `["/sign-up/email", "/sign-in/email", "/forget-password",]`. * `minScore` (optional - only *Google ReCAPTCHA v3*): minimum score threshold. Default is `0.5`. * `siteKey` (optional - only *hCaptcha*): prevents tokens issued on one sitekey from being redeemed elsewhere. * `siteVerifyURLOverride` (optional): overrides endpoint URL for the captcha verification request. # plugins: Community Plugins URL: /docs/plugins/community-plugins Source: https: A list of recommended community plugins. *** title: Community Plugins description: A list of recommended community plugins. ----------------------------------------------------- This page showcases a list of recommended community made plugins. We encourage you to create custom plugins and maybe get added to the list! To create your own custom plugin, get started by reading our [plugins documentation](/docs/concepts/plugins). And if you want to share your plugin with the community, please open a pull request to add it to this list. | <div className="w-[200px]">Plugin</div> | Description | <div className="w-[150px]">Author</div> | | ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | | [better-auth-harmony](https: | [validation-better-auth](https: | [better-auth-localization](https: # plugins: Dodo Payments URL: /docs/plugins/dodopayments Source: https: Better Auth Plugin for Dodo Payments *** title: Dodo Payments description: Better Auth Plugin for Dodo Payments ------------------------------------------------- [Dodo Payments](https: <Card href="https: This plugin is maintained by the Dodo Payments team.<br /> Have questions? Our team is available on Discord to assist you anytime. </Card> ## Features * Automatic customer creation on sign-up * Type-safe checkout flows with product slug mapping * Self-service customer portal * Real-time webhook event processing with signature verification <Card href="https: You need a Dodo Payments account and API keys to use this integration. </Card> ## Installation <Steps> <Step title="Install dependencies"> Run the following command in your project root: ```bash npm install @dodopayments/better-auth dodopayments better-auth zod ``` </Step> <Step title="Configure environment variables"> Add these to your `.env` file: ```env DODO_PAYMENTS_API_KEY=your_api_key_here DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here ``` </Step> <Step title="Set up server-side integration"> Create or update `src/lib/auth.ts`: ```typescript import { betterAuth } from "better-auth"; import { dodopayments, checkout, portal, webhooks, } from "@dodopayments/better-auth"; import DodoPayments from "dodopayments"; export const dodoPayments = new DodoPayments({ bearerToken: process.env.DODO_PAYMENTS_API_KEY!, environment: "test_mode" }); export const auth = betterAuth({ plugins: [ dodopayments({ client: dodoPayments, createCustomerOnSignUp: true, use: [ checkout({ products: [ { productId: "pdt_xxxxxxxxxxxxxxxxxxxxx", slug: "premium-plan", }, ], successUrl: "/dashboard/success", authenticatedUsersOnly: true, }), portal(), webhooks({ webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!, onPayload: async (payload) => { console.log("Received webhook:", payload.event_type); }, }), ], }), ], }); ``` <Card> Set `environment` to `live_mode` for production. </Card> </Step> <Step title="Set up client-side integration"> Create or update `src/lib/auth-client.ts`: ```typescript import { dodopaymentsClient } from "@dodopayments/better-auth"; export const authClient = createAuthClient({ baseURL: process.env.BETTER_AUTH_URL || "http: plugins: [dodopaymentsClient()], }); ``` </Step> </Steps> ## Usage ### Creating a Checkout Session ```typescript const { data: checkout, error } = await authClient.dodopayments.checkout({ slug: "premium-plan", customer: { email: "customer@example.com", name: "John Doe", }, billing: { city: "San Francisco", country: "US", state: "CA", street: "123 Market St", zipcode: "94103", }, referenceId: "order_123", }); if (checkout) { window.location.href = checkout.url; } ``` ### Accessing the Customer Portal ```typescript const { data: customerPortal, error } = await authClient.dodopayments.customer.portal(); if (customerPortal && customerPortal.redirect) { window.location.href = customerPortal.url; } ``` ### Listing Customer Data ```typescript const { data: subscriptions, error } = await authClient.dodopayments.customer.subscriptions.list({ query: { limit: 10, page: 1, active: true, }, }); const { data: payments, error } = await authClient.dodopayments.customer.payments.list({ query: { limit: 10, page: 1, status: "succeeded", }, }); ``` ### Webhooks <Card> The webhooks plugin processes real-time payment events from Dodo Payments with secure signature verification. The default endpoint is `/api/auth/dodopayments/webhooks`. </Card> <Steps> <Step title="Generate and set webhook secret"> Generate a webhook secret for your endpoint URL (e.g., `https: ```env DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here ``` </Step> <Step title="Handle webhook events"> Example handler: ```typescript webhooks({ webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!, onPayload: async (payload) => { console.log("Received webhook:", payload.event_type); }, }); ``` </Step> </Steps> ## Configuration Reference ### Plugin Options * **client** (required): DodoPayments client instance * **createCustomerOnSignUp** (optional): Auto-create customers on user signup * **use** (required): Array of plugins to enable (checkout, portal, webhooks) ### Checkout Plugin Options * **products**: Array of products or async function returning products * **successUrl**: URL to redirect after successful payment * **authenticatedUsersOnly**: Require user authentication (default: false) If you encounter any issues, please refer to the [Dodo Payments documentation](https: # plugins: Dub URL: /docs/plugins/dub Source: https: Better Auth Plugin for Lead Tracking using Dub links and OAuth Linking *** title: Dub description: Better Auth Plugin for Lead Tracking using Dub links and OAuth Linking ----------------------------------------------------------------------------------- [Dub](https: This plugins allows you to track leads when a user signs up using a Dub link. It also adds OAuth linking support to allow you to build integrations extending Dub's linking management infrastructure. ## Installation <Steps> <Step> ### Install the plugin First, install the plugin: <Tabs items={}> <Tab value="npm"> ```bash npm install @dub/better-auth ``` </Tab> <Tab value="pnpm"> ```bash pnpm add @dub/better-auth ``` </Tab> <Tab value="yarn"> ```bash yarn add @dub/better-auth ``` </Tab> <Tab value="bun"> ```bash bun add @dub/better-auth ``` </Tab> </Tabs> </Step> <Step> ### Install the Dub SDK Next, install the Dub SDK on your server: <Tabs items={}> <Tab value="npm"> ```bash npm install dub ``` </Tab> <Tab value="pnpm"> ```bash pnpm add dub ``` </Tab> <Tab value="yarn"> ```bash yarn add dub ``` </Tab> <Tab value="bun"> ```bash bun add dub ``` </Tab> </Tabs> </Step> <Step> ### Configure the plugin Add the plugin to your auth config: ```ts title="auth.ts" import { betterAuth } from "better-auth" import { dubAnalytics } from "@dub/better-auth" import { dub } from "dub" export const auth = betterAuth({ plugins: [ dubAnalytics({ dubClient: new Dub() }) ] }) ``` </Step> </Steps> ## Usage ### Lead Tracking By default, the plugin will track sign up events as leads. You can disable this by setting `disableLeadTracking` to `true`. ```ts const dub = new Dub(); const betterAuth = betterAuth({ plugins: [ dubAnalytics({ dubClient: dub, disableLeadTracking: true, }), ], }); ``` ### OAuth Linking The plugin supports OAuth for account linking. First, you need to setup OAuth app in Dub. Dub supports OAuth 2.0 authentication, which is recommended if you build integrations extending Dub’s functionality [Learn more about OAuth](https: Once you get the client ID and client secret, you can configure the plugin. ```ts dubAnalytics({ dubClient: dub, oauth: { clientId: "your-client-id", clientSecret: "your-client-secret", }, }); ``` And in the client, you need to use the `dubAnalyticsClient` plugin. ```ts const authClient = createAuthClient({ plugins: [dubAnalyticsClient()], }); ``` To link account with Dub, you need to use the `dub.link`. <APIMethod path="/dub/link" method="POST" requireSession> ```ts type dubLink = { callbackURL: string = "/dashboard" } ``` </APIMethod> ## Options You can pass the following options to the plugin: ### `dubClient` The Dub client instance. ### `disableLeadTracking` Disable lead tracking for sign up events. ### `leadEventName` Event name for sign up leads. ### `customLeadTrack` Custom lead track function. ### `oauth` Dub OAuth configuration. ### `oauth.clientId` Client ID for Dub OAuth. ### `oauth.clientSecret` Client secret for Dub OAuth. ### `oauth.pkce` Enable PKCE for Dub OAuth. # plugins: Email OTP URL: /docs/plugins/email-otp Source: https: Email OTP plugin for Better Auth. *** title: Email OTP description: Email OTP plugin for Better Auth. ---------------------------------------------- The Email OTP plugin allows user to sign in, verify their email, or reset their password using a one-time password (OTP) sent to their email address. ## Installation <Steps> <Step> ### Add the plugin to your auth config To enable email otp in your app, you need to add the `emailOTP` plugin to your auth config. ```ts title="auth.ts" import { betterAuth } from "better-auth" import { emailOTP } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ emailOTP({ async sendVerificationOTP({ email, otp, type}) { }, }) ] }) ``` </Step> <Step> ### Add the client plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { emailOTPClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ emailOTPClient() ] }) ``` </Step> </Steps> ## Usage ### Send OTP First, send an OTP to the user's email address. <APIMethod path="/email-otp/send-verification-otp" method="POST"> ```ts type sendVerificationOTP = { email: string = "user@example.com" type: "email-verification" | "sign-in" | "forget-password" = "sign-in" } ``` </APIMethod> ### Sign in with OTP Once the user provides the OTP, you can sign in the user using the `signIn.emailOtp()` method. <APIMethod path="/sign-in/email-otp" method="POST"> ```ts type signInEmailOTP = { email: string = "user@example.com" otp: string = "123456" } ``` </APIMethod> <Callout> If the user is not registered, they'll be automatically registered. If you want to prevent this, you can pass `disableSignUp` as `true` in the options. </Callout> ### Verify Email To verify the user's email address, use the `verifyEmail()` method. <APIMethod path="/email-otp/verify-email" method="POST"> ```ts type verifyEmailOTP = { email: string = "user@example.com" otp: string = "123456" } ``` </APIMethod> ### Forgot & Reset Password To reset the user's password, you must use the `forgotPassword` method: <APIMethod path="/forget-password/email-otp" method="POST"> ```ts type forgetPasswordEmailOTP = { email: string = "user@example.com" } ``` </APIMethod> After that, you may use the `resetPassword()` method to apply the password reset. <APIMethod path="/email-otp/reset-password" method="POST"> ```ts type resetPasswordEmailOTP = { email: string = "user@example.com" otp: string = "123456" password: string = "new-secure-password" } ``` </APIMethod> ### Override Default Email Verification To override the default email verification, pass `overrideDefaultEmailVerification: true` in the options. This will make the system use an email OTP instead of the default verification link whenever email verification is triggered. In other words, the user will verify their email using an OTP rather than clicking a link. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ emailOTP({ overrideDefaultEmailVerification: true, async sendVerificationOTP({ email, otp, type }) { }, }), ], }); ``` ## Options * `sendVerificationOTP`: A function that sends the OTP to the user's email address. The function receives an object with the following properties: * `email`: The user's email address. * `otp`: The OTP to send. * `type`: The type of OTP to send. Can be "sign-in", "email-verification", or "forget-password". ### Example ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ emailOTP({ async sendVerificationOTP({ email, otp, type }) { if (type === "sign-in") { } else if (type === "email-verification") { } else { } }, }) ] }) ``` * `otpLength`: The length of the OTP. Defaults to `6`. * `expiresIn`: The expiry time of the OTP in seconds. Defaults to `300` seconds. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ emailOTP({ otpLength: 8, expiresIn: 600 }) ] }) ``` * `sendVerificationOnSignUp`: A boolean value that determines whether to send the OTP when a user signs up. Defaults to `false`. * `disableSignUp`: A boolean value that determines whether to prevent automatic sign-up when the user is not registered. Defaults to `false`. * `generateOTP`: A function that generates the OTP. Defaults to a random 6-digit number. * `allowedAttempts`: The maximum number of attempts allowed for verifying an OTP. Defaults to `3`. After exceeding this limit, the OTP becomes invalid and the user needs to request a new one. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ emailOTP({ allowedAttempts: 5, expiresIn: 300 }) ] }) ``` When the maximum attempts are exceeded, the `verifyOTP`, `signIn.emailOtp`, `verifyEmail`, and `resetPassword` methods will return an error with code `MAX_ATTEMPTS_EXCEEDED`. * `storeOTP`: The method to store the OTP in your database, wether `encrypted`, `hashed` or `plain` text. Default is `plain` text. <Callout> Note: This will not affect the OTP sent to the user, it will only affect the OTP stored in your database. </Callout> Alternatively, you can pass a custom encryptor or hasher to store the OTP in your database. **Custom encryptor** ```ts title="auth.ts" emailOTP({ storeOTP: { encrypt: async (otp) => { return myCustomEncryptor(otp); }, decrypt: async (otp) => { return myCustomDecryptor(otp); }, } }) ``` **Custom hasher** ```ts title="auth.ts" emailOTP({ storeOTP: { hash: async (otp) => { return myCustomHasher(otp); }, } }) ``` # plugins: Generic OAuth URL: /docs/plugins/generic-oauth Source: https: Authenticate users with any OAuth provider *** title: Generic OAuth description: Authenticate users with any OAuth provider ------------------------------------------------------- The Generic OAuth plugin provides a flexible way to integrate authentication with any OAuth provider. It supports both OAuth 2.0 and OpenID Connect (OIDC) flows, allowing you to easily add social login or custom OAuth authentication to your application. ## Installation <Steps> <Step> ### Add the plugin to your auth config To use the Generic OAuth plugin, add it to your auth config. ```ts title="auth.ts" import { betterAuth } from "better-auth" import { genericOAuth } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ genericOAuth({ config: [ { providerId: "provider-id", clientId: "test-client-id", clientSecret: "test-client-secret", discoveryUrl: "https: }, ] }) ] }) ``` </Step> <Step> ### Add the client plugin Include the Generic OAuth client plugin in your authentication client instance. ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { genericOAuthClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ genericOAuthClient() ] }) ``` </Step> </Steps> ## Usage The Generic OAuth plugin provides endpoints for initiating the OAuth flow and handling the callback. Here's how to use them: ### Initiate OAuth Sign-In To start the OAuth sign-in process: <APIMethod path="/sign-in/oauth2" method="POST"> ```ts type signInWithOAuth2 = { providerId: string = "provider-id" callbackURL?: string = "/dashboard" errorCallbackURL?: string = "/error-page" newUserCallbackURL?: string = "/welcome" disableRedirect?: boolean = false scopes?: string[] = ["my-scope"] requestSignUp?: boolean = false } ``` </APIMethod> ### Linking OAuth Accounts To link an OAuth account to an existing user: <APIMethod path="/oauth2/link" method="POST" requireSession> ```ts type oAuth2LinkAccount = { providerId: string = "my-provider-id" callbackURL: string = "/successful-link" } ``` </APIMethod> ### Handle OAuth Callback The plugin mounts a route to handle the OAuth callback `/oauth2/callback/:providerId`. This means by default `${baseURL}/api/auth/oauth2/callback/:providerId` will be used as the callback URL. Make sure your OAuth provider is configured to use this URL. ## Configuration When adding the plugin to your auth config, you can configure multiple OAuth providers. Each provider configuration object supports the following options: ```ts interface GenericOAuthConfig { providerId: string; discoveryUrl?: string; authorizationUrl?: string; tokenUrl?: string; userInfoUrl?: string; clientId: string; clientSecret: string; scopes?: string[]; redirectURI?: string; responseType?: string; prompt?: string; pkce?: boolean; accessType?: string; getUserInfo?: (tokens: OAuth2Tokens) => Promise<User | null>; } ``` ### Other Provider Configurations **providerId**: A unique string to identify the OAuth provider configuration. **discoveryUrl**: (Optional) URL to fetch the provider's OAuth 2.0/OIDC configuration. If provided, endpoints like `authorizationUrl`, `tokenUrl`, and `userInfoUrl` can be auto-discovered. **authorizationUrl**: (Optional) The OAuth provider's authorization endpoint. Not required if using `discoveryUrl`. **tokenUrl**: (Optional) The OAuth provider's token endpoint. Not required if using `discoveryUrl`. **userInfoUrl**: (Optional) The endpoint to fetch user profile information. Not required if using `discoveryUrl`. **clientId**: The OAuth client ID issued by your provider. **clientSecret**: The OAuth client secret issued by your provider. **scopes**: (Optional) An array of scopes to request from the provider (e.g., `["openid", "email", "profile"]`). **redirectURI**: (Optional) The redirect URI to use for the OAuth flow. If not set, a default is constructed based on your app's base URL. **responseType**: (Optional) The OAuth response type. Defaults to `"code"` for authorization code flow. **responseMode**: (Optional) The response mode for the authorization code request, such as `"query"` or `"form_post"`. **prompt**: (Optional) Controls the authentication experience (e.g., force login, consent, etc.). **pkce**: (Optional) If true, enables PKCE (Proof Key for Code Exchange) for enhanced security. Defaults to `false`. **accessType**: (Optional) The access type for the authorization request. Use `"offline"` to request a refresh token. **getUserInfo**: (Optional) A custom function to fetch user info from the provider, given the OAuth tokens. If not provided, a default fetch is used. **mapProfileToUser**: (Optional) A function to map the provider's user profile to your app's user object. Useful for custom field mapping or transformations. **authorizationUrlParams**: (Optional) Additional query parameters to add to the authorization URL. These can override default parameters. **disableImplicitSignUp**: (Optional) If true, disables automatic sign-up for new users. Sign-in must be explicitly requested with sign-up intent. **disableSignUp**: (Optional) If true, disables sign-up for new users entirely. Only existing users can sign in. **authentication**: (Optional) The authentication method for token requests. Can be `'basic'` or `'post'`. Defaults to `'post'`. **discoveryHeaders**: (Optional) Custom headers to include in the discovery request. Useful for providers that require special headers. **authorizationHeaders**: (Optional) Custom headers to include in the authorization request. Useful for providers that require special headers. **overrideUserInfo**: (Optional) If true, the user's info in your database will be updated with the provider's info every time they sign in. Defaults to `false`. ## Advanced Usage ### Custom User Info Fetching You can provide a custom `getUserInfo` function to handle specific provider requirements: ```ts genericOAuth({ config: [ { providerId: "custom-provider", getUserInfo: async (tokens) => { const userInfo = await fetchUserInfoFromCustomProvider(tokens); return { id: userInfo.sub, email: userInfo.email, name: userInfo.name, }; } } ] }) ``` ### Map User Info Fields If the user info returned by the provider does not match the expected format, or you need to map additional fields, you can use the `mapProfileToUser`: ```ts genericOAuth({ config: [ { providerId: "custom-provider", mapProfileToUser: async (profile) => { return { firstName: profile.given_name, }; } } ] }) ``` ### Error Handling The plugin includes built-in error handling for common OAuth issues. Errors are typically redirected to your application's error page with an appropriate error message in the URL parameters. If the callback URL is not provided, the user will be redirected to Better Auth's default error page. # plugins: Have I Been Pwned URL: /docs/plugins/have-i-been-pwned Source: https: A plugin to check if a password has been compromised *** title: Have I Been Pwned description: A plugin to check if a password has been compromised ----------------------------------------------------------------- The Have I Been Pwned plugin helps protect user accounts by preventing the use of passwords that have been exposed in known data breaches. It uses the [Have I Been Pwned](https: ## Installation ### Add the plugin to your **auth** config ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ haveIBeenPwned() ] }) ``` ## Usage When a user attempts to create an account or update their password with a compromised password, they'll receive the following default error: ```json { "code": "PASSWORD_COMPROMISED", "message": "Password is compromised" } ``` ## Config You can customize the error message: ```ts haveIBeenPwned({ customPasswordCompromisedMessage: "Please choose a more secure password." }) ``` ## Security Notes * Only the first 5 characters of the password hash are sent to the API * The full password is never transmitted * Provides an additional layer of account security # plugins: JWT URL: /docs/plugins/jwt Source: https: Authenticate users with JWT tokens in services that can't use the session *** title: JWT description: Authenticate users with JWT tokens in services that can't use the session -------------------------------------------------------------------------------------- The JWT plugin provides endpoints to retrieve a JWT token and a JWKS endpoint to verify the token. <Callout type="info"> This plugin is not meant as a replacement for the session. It's meant to be used for services that require JWT tokens. If you're looking to use JWT tokens for authentication, check out the [Bearer Plugin](/docs/plugins/bearer). </Callout> ## Installation <Steps> <Step> ### Add the plugin to your **auth** config ```ts title="auth.ts" import { betterAuth } from "better-auth" import { jwt } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ jwt(), ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> </Steps> ## Usage Once you've installed the plugin, you can start using the JWT & JWKS plugin to get the token and the JWKS through their respective endpoints. ## JWT ### Retrieve the token 1. Using your session token To get the token, call the `/token` endpoint. This will return the following: ```json { "token": "ey..." } ``` Make sure to include the token in the `Authorization` header of your requests and the `bearer` plugin is added in your auth configuration. ```ts await fetch("/api/auth/token", { headers: { "Authorization": `Bearer ${token}` }, }) ``` 2. From `set-auth-jwt` header When you call `getSession` method, a JWT is returned in the `set-auth-jwt` header, which you can use to send to your services directly. ```ts await authClient.getSession({ fetchOptions: { onSuccess: (ctx)=>{ const jwt = ctx.response.headers.get("set-auth-jwt") } } }) ``` ### Verifying the token The token can be verified in your own service, without the need for an additional verify call or database check. For this JWKS is used. The public key can be fetched from the `/api/auth/jwks` endpoint. Since this key is not subject to frequent changes, it can be cached indefinitely. The key ID (`kid`) that was used to sign a JWT is included in the header of the token. In case a JWT with a different `kid` is received, it is recommended to fetch the JWKS again. ```json { "keys": [ { "crv": "Ed25519", "x": "bDHiLTt7u-VIU7rfmcltcFhaHKLVvWFy-_csKZARUEU", "kty": "OKP", "kid": "c5c7995d-0037-4553-8aee-b5b620b89b23" } ] } ``` #### Example using jose with remote JWKS ```ts async function validateToken(token: string) { try { const JWKS = createRemoteJWKSet( new URL('http: ) const { payload } = await jwtVerify(token, JWKS, { issuer: 'http: audience: 'http: }) return payload } catch (error) { console.error('Token validation failed:', error) throw error } } const token = 'your.jwt.token' const payload = await validateToken(token) ``` #### Example with local JWKS ```ts async function validateToken(token: string) { try { const storedJWKS = { keys: [{ }] }; const JWKS = createLocalJWKSet({ keys: storedJWKS.data?.keys!, }) const { payload } = await jwtVerify(token, JWKS, { issuer: 'http: audience: 'http: }) return payload } catch (error) { console.error('Token validation failed:', error) throw error } } const token = 'your.jwt.token' const payload = await validateToken(token) ``` ## Schema The JWT plugin adds the following tables to the database: ### JWKS Table Name: `jwks` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each web key", isPrimaryKey: true }, { name: "publicKey", type: "string", description: "The public part of the web key" }, { name: "privateKey", type: "string", description: "The private part of the web key" }, { name: "createdAt", type: "Date", description: "Timestamp of when the web key was created" }, ]} /> <Callout> You can customize the table name and fields for the `jwks` table. See the [Database concept documentation](/docs/concepts/database#custom-table-names) for more information on how to customize plugin schema. </Callout> ## Options ### Algorithm of the Key Pair The algorithm used for the generation of the key pair. The default is **EdDSA** with the **Ed25519** curve. Below are the available options: ```ts title="auth.ts" jwt({ jwks: { keyPairConfig: { alg: "EdDSA", crv: "Ed25519" } } }) ``` #### EdDSA * **Default Curve**: `Ed25519` * **Optional Property**: `crv` * Available options: `Ed25519`, `Ed448` * Default: `Ed25519` #### ES256 * No additional properties #### RSA256 * **Optional Property**: `modulusLength` * Expects a number * Default: `2048` #### PS256 * **Optional Property**: `modulusLength` * Expects a number * Default: `2048` #### ECDH-ES * **Optional Property**: `crv` * Available options: `P-256`, `P-384`, `P-521` * Default: `P-256` #### ES512 * No additional properties ### Disable private key encryption By default, the private key is encrypted using AES256 GCM. You can disable this by setting the `disablePrivateKeyEncryption` option to `true`. For security reasons, it's recommended to keep the private key encrypted. ```ts title="auth.ts" jwt({ jwks: { disablePrivateKeyEncryption: true } }) ``` ### Modify JWT payload By default the entire user object is added to the JWT payload. You can modify the payload by providing a function to the `definePayload` option. ```ts title="auth.ts" jwt({ jwt: { definePayload: ({user}) => { return { id: user.id, email: user.email, role: user.role } } } }) ``` ### Modify Issuer, Audience, Subject or Expiration time If none is given, the `BASE_URL` is used as the issuer and the audience is set to the `BASE_URL`. The expiration time is set to 15 minutes. ```ts title="auth.ts" jwt({ jwt: { issuer: "https: audience: "https: expirationTime: "1h", getSubject: (session) => { return session.user.email } } }) ``` # plugins: Magic link URL: /docs/plugins/magic-link Source: https: Magic link plugin *** title: Magic link description: Magic link plugin ------------------------------ Magic link or email link is a way to authenticate users without a password. When a user enters their email, a link is sent to their email. When the user clicks on the link, they are authenticated. ## Installation <Steps> <Step> ### Add the server Plugin Add the magic link plugin to your server: ```ts title="server.ts" import { betterAuth } from "better-auth"; import { magicLink } from "better-auth/plugins"; export const auth = betterAuth({ plugins: [ magicLink({ sendMagicLink: async ({ email, token, url }, request) => { } }) ] }) ``` </Step> <Step> ### Add the client Plugin Add the magic link plugin to your client: ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client"; import { magicLinkClient } from "better-auth/client/plugins"; export const authClient = createAuthClient({ plugins: [ magicLinkClient() ] }); ``` </Step> </Steps> ## Usage ### Sign In with Magic Link To sign in with a magic link, you need to call `signIn.magicLink` with the user's email address. The `sendMagicLink` function is called to send the magic link to the user's email. <APIMethod path="/sign-in/magic-link" method="POST" requireSession> ```ts type signInMagicLink = { email: string = "user@email.com" name?: string = "my-name" callbackURL?: string = "/dashboard" newUserCallbackURL?: string = "/welcome" errorCallbackURL?: string = "/error" } ``` </APIMethod> <Callout> If the user has not signed up, unless `disableSignUp` is set to `true`, the user will be signed up automatically. </Callout> ### Verify Magic Link When you send the URL generated by the `sendMagicLink` function to a user, clicking the link will authenticate them and redirect them to the `callbackURL` specified in the `signIn.magicLink` function. If an error occurs, the user will be redirected to the `callbackURL` with an error query parameter. <Callout type="warn"> If no `callbackURL` is provided, the user will be redirected to the root URL. </Callout> If you want to handle the verification manually, (e.g, if you send the user a different URL), you can use the `verify` function. <APIMethod path="/magic-link/verify" method="GET" requireSession> ```ts type magicLinkVerify = { token: string = "123456" callbackURL?: string = "/dashboard" } ``` </APIMethod> ## Configuration Options **sendMagicLink**: The `sendMagicLink` function is called when a user requests a magic link. It takes an object with the following properties: * `email`: The email address of the user. * `url`: The URL to be sent to the user. This URL contains the token. * `token`: The token if you want to send the token with custom URL. and a `request` object as the second parameter. **expiresIn**: specifies the time in seconds after which the magic link will expire. The default value is `300` seconds (5 minutes). **disableSignUp**: If set to `true`, the user will not be able to sign up using the magic link. The default value is `false`. **generateToken**: The `generateToken` function is called to generate a token which is used to uniquely identify the user. The default value is a random string. There is one parameter: * `email`: The email address of the user. <Callout type="warn"> When using `generateToken`, ensure that the returned string is hard to guess because it is used to verify who someone actually is in a confidential way. By default, we return a long and cryptographically secure string. </Callout> **storeToken**: The `storeToken` function is called to store the magic link token in the database. The default value is `"plain"`. The `storeToken` function can be one of the following: * `"plain"`: The token is stored in plain text. * `"hashed"`: The token is hashed using the default hasher. * `{ type: "custom-hasher", hash: (token: string) => Promise<string> }`: The token is hashed using a custom hasher. # plugins: MCP URL: /docs/plugins/mcp Source: https: MCP provider plugin for Better Auth *** title: MCP description: MCP provider plugin for Better Auth ------------------------------------------------ `OAuth` `MCP` The **MCP** plugin lets your app act as an OAuth provider for MCP clients. It handles authentication and makes it easy to issue and manage access tokens for MCP applications. ## Installation <Steps> <Step> ### Add the Plugin Add the MCP plugin to your auth configuration and specify the login page path. ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { mcp } from "better-auth/plugins"; export const auth = betterAuth({ plugins: [ mcp({ loginPage: "/sign-in" }) ] }); ``` <Callout> This doesn't have a client plugin, so you don't need to make any changes to your authClient. </Callout> </Step> <Step> ### Generate Schema Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> The MCP plugin uses the same schema as the OIDC Provider plugin. See the [OIDC Provider Schema](#schema) section for details. </Step> </Steps> ## Usage ### OAuth Discovery Metadata Add a route to expose OAuth metadata for MCP clients: ```ts title=".well-known/oauth-authorization-server/route.ts" export const GET = oAuthDiscoveryMetadata(auth); ``` ### MCP Session Handling You can use the helper function `withMcpAuth` to get the session and handle unauthenticated calls automatically. ```ts title="api/[transport]/route.ts" const handler = withMcpAuth(auth, (req, session) => { return createMcpHandler( (server) => { server.tool( "echo", "Echo a message", { message: z.string() }, async ({ message }) => { return { content: [{ type: "text", text: `Tool echo: ${message}` }], }; }, ); }, { capabilities: { tools: { echo: { description: "Echo a message", }, }, }, }, { redisUrl: process.env.REDIS_URL, basePath: "/api", verboseLogs: true, maxDuration: 60, }, )(req); }); export { handler as GET, handler as POST, handler as DELETE }; ``` You can also use `auth.api.getMcpSession` to get the session using the access token sent from the MCP client: ```ts title="api/[transport]/route.ts" const handler = async (req: Request) => { const session = await auth.api.getMcpSession({ headers: req.headers }) if(!session){ return new Response(null, { status: 401 }) } return createMcpHandler( (server) => { server.tool( "echo", "Echo a message", { message: z.string() }, async ({ message }) => { return { content: [{ type: "text", text: `Tool echo: ${message}` }], }; }, ); }, { capabilities: { tools: { echo: { description: "Echo a message", }, }, }, }, { redisUrl: process.env.REDIS_URL, basePath: "/api", verboseLogs: true, maxDuration: 60, }, )(req); } export { handler as GET, handler as POST, handler as DELETE }; ``` ## Configuration The MCP plugin accepts the following configuration options: <TypeTable type={{ loginPage: { description: "Path to the login page where users will be redirected for authentication", type: "string", required: true }, oidcConfig: { description: "Optional OIDC configuration options", type: "object", required: false } }} /> ### OIDC Configuration The plugin supports additional OIDC configuration options through the `oidcConfig` parameter: <TypeTable type={{ codeExpiresIn: { description: "Expiration time for authorization codes in seconds", type: "number", default: 600 }, accessTokenExpiresIn: { description: "Expiration time for access tokens in seconds", type: "number", default: 3600 }, refreshTokenExpiresIn: { description: "Expiration time for refresh tokens in seconds", type: "number", default: 604800 }, defaultScope: { description: "Default scope for OAuth requests", type: "string", default: "openid" }, scopes: { description: "Additional scopes to support", type: "string[]", default: '["openid", "profile", "email", "offline_access"]' } }} /> ## Schema The MCP plugin uses the same schema as the OIDC Provider plugin. See the [OIDC Provider Schema](#schema) section for details. # plugins: Multi Session URL: /docs/plugins/multi-session Source: https: Learn how to use multi-session plugin in Better Auth. *** title: Multi Session description: Learn how to use multi-session plugin in Better Auth. ------------------------------------------------------------------ The multi-session plugin allows users to maintain multiple active sessions across different accounts in the same browser. This plugin is useful for applications that require users to switch between multiple accounts without logging out. ## Installation <Steps> <Step> ### Add the plugin to your **auth** config ```ts title="auth.ts" import { betterAuth } from "better-auth" import { multiSession } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ multiSession(), ] }) ``` </Step> <Step> ### Add the client Plugin Add the client plugin and Specify where the user should be redirected if they need to verify 2nd factor ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { multiSessionClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ multiSessionClient() ] }) ``` </Step> </Steps> ## Usage Whenever a user logs in, the plugin will add additional cookie to the browser. This cookie will be used to maintain multiple sessions across different accounts. ### List all device sessions To list all active sessions for the current user, you can call the `listDeviceSessions` method. <APIMethod path="/multi-session/list-device-sessions" method="GET" requireSession> ```ts type listDeviceSessions = { } ``` </APIMethod> ### Set active session To set the active session, you can call the `setActive` method. <APIMethod path="/multi-session/set-active" method="POST" requireSession> ```ts type setActiveSession = { sessionToken: string = "some-session-token" } ``` </APIMethod> ### Revoke a session To revoke a session, you can call the `revoke` method. <APIMethod path="/multi-session/revoke" method="POST" requireSession> ```ts type revokeDeviceSession = { sessionToken: string = "some-session-token" } ``` </APIMethod> ### Signout and Revoke all sessions When a user logs out, the plugin will revoke all active sessions for the user. You can do this by calling the existing `signOut` method, which handles revoking all sessions automatically. ### Max Sessions You can specify the maximum number of sessions a user can have by passing the `maximumSessions` option to the plugin. By default, the plugin allows 5 sessions per device. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ multiSession({ maximumSessions: 3 }) ] }) ``` # plugins: OAuth Proxy URL: /docs/plugins/oauth-proxy Source: https: OAuth Proxy plugin for Better Auth *** title: OAuth Proxy description: OAuth Proxy plugin for Better Auth ----------------------------------------------- A proxy plugin, that allows you to proxy OAuth requests. Useful for development and preview deployments where the redirect URL can't be known in advance to add to the OAuth provider. ## Installation <Steps> <Step> ### Add the plugin to your **auth** config ```ts title="auth.ts" import { betterAuth } from "better-auth" import { oAuthProxy } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ oAuthProxy({ productionURL: "https: currentURL: "http: }), ] }) ``` </Step> <Step> ### Add redirect URL to your OAuth provider For the proxy server to work properly, you’ll need to pass the redirect URL of your main production app registered with the OAuth provider in your social provider config. This needs to be done for each social provider you want to proxy requests for. ```ts export const auth = betterAuth({ plugins: [ oAuthProxy(), ], socialProviders: { github: { clientId: "your-client-id", clientSecret: "your-client-secret", redirectURI: "https: } } }) ``` </Step> </Steps> ## How it works The plugin adds an endpoint to your server that proxies OAuth requests. When you initiate a social sign-in, it sets the redirect URL to this proxy endpoint. After the OAuth provider redirects back to your server, the plugin then forwards the user to the original callback URL. ```ts await authClient.signIn.social({ provider: "github", callbackURL: "/dashboard" }) ``` When the OAuth provider returns the user to your server, the plugin automatically redirects them to the intended callback URL. <Callout> To share cookies between the proxy server and your main server it uses URL query parameters to pass the cookies encrypted in the URL. This is secure as the cookies are encrypted and can only be decrypted by the server. </Callout> ## Options **currentURL**: The application's current URL is automatically determined by the plugin. It first checks for the request URL if invoked by a client, then it checks the base URL from popular hosting providers, and finally falls back to the `baseURL` in your auth config. If the URL isn’t inferred correctly, you can specify it manually here. **productionURL**: If this value matches the `baseURL` in your auth config, requests will not be proxied. Defaults to the `BETTER_AUTH_URL` environment variable. # plugins: OIDC Provider URL: /docs/plugins/oidc-provider Source: https: Open ID Connect plugin for Better Auth that allows you to have your own OIDC provider. *** title: OIDC Provider description: Open ID Connect plugin for Better Auth that allows you to have your own OIDC provider. --------------------------------------------------------------------------------------------------- The **OIDC Provider Plugin** enables you to build and manage your own OpenID Connect (OIDC) provider, granting full control over user authentication without relying on third-party services like Okta or Azure AD. It also allows other services to authenticate users through your OIDC provider. **Key Features**: * **Client Registration**: Register clients to authenticate with your OIDC provider. * **Dynamic Client Registration**: Allow clients to register dynamically. * **Trusted Clients**: Configure hard-coded trusted clients with optional consent bypass. * **Authorization Code Flow**: Support the Authorization Code Flow. * **Public Clients**: Support public clients for SPA, mobile apps, CLI tools, etc. * **JWKS Endpoint**: Publish a JWKS endpoint to allow clients to verify tokens. (Not fully implemented) * **Refresh Tokens**: Issue refresh tokens and handle access token renewal using the `refresh_token` grant. * **OAuth Consent**: Implement OAuth consent screens for user authorization, with an option to bypass consent for trusted applications. * **UserInfo Endpoint**: Provide a UserInfo endpoint for clients to retrieve user details. <Callout type="warn"> This plugin is in active development and may not be suitable for production use. Please report any issues or bugs on [GitHub](https: </Callout> ## Installation <Steps> <Step> ### Mount the Plugin Add the OIDC plugin to your auth config. See [OIDC Configuration](#oidc-configuration) on how to configure the plugin. ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { oidcProvider } from "better-auth/plugins"; const auth = betterAuth({ plugins: [oidcProvider({ loginPage: "/sign-in", })] }) ``` </Step> <Step> ### Migrate the Database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the Client Plugin Add the OIDC client plugin to your auth client config. ```ts import { createAuthClient } from "better-auth/client"; import { oidcClient } from "better-auth/client/plugins" const authClient = createAuthClient({ plugins: [oidcClient({ })] }) ``` </Step> </Steps> ## Usage Once installed, you can utilize the OIDC Provider to manage authentication flows within your application. ### Register a New Client To register a new OIDC client, use the `oauth2.register` method. #### Simple Example ```ts const application = await client.oauth2.register({ client_name: "My Client", redirect_uris: ["https: }); ``` #### Full Method <APIMethod path="/oauth2/register" method="POST"> ```ts type registerOAuthApplication = { redirect_uris: string[] = ["https: token_endpoint_auth_method?: "none" | "client_secret_basic" | "client_secret_post" = "client_secret_basic" grant_types?: ("authorization_code" | "implicit" | "password" | "client_credentials" | "refresh_token" | "urn:ietf:params:oauth:grant-type:jwt-bearer" | "urn:ietf:params:oauth:grant-type:saml2-bearer")[] = ["authorization_code"] response_types?: ("code" | "token")[] = ["code"] client_name?: string = "My App" client_uri?: string = "https: logo_uri?: string = "https: scope?: string = "profile email" contacts?: string[] = ["admin@example.com"] tos_uri?: string = "https: policy_uri?: string = "https: jwks_uri?: string = "https: jwks?: Record<string, any> = {"keys": [{"kty": "RSA", "alg": "RS256", "use": "sig", "n": "...", "e": "..."}]} metadata?: Record<string, any> = {"key": "value"} software_id?: string = "my-software" software_version?: string = "1.0.0" software_statement?: string } ``` </APIMethod> <Callout> This endpoint supports [RFC7591](https: </Callout> Once the application is created, you will receive a `client_id` and `client_secret` that you can display to the user. This Endpoint support [RFC7591](https: ### Trusted Clients For first-party applications and internal services, you can configure trusted clients directly in your OIDC provider configuration. Trusted clients bypass database lookups for better performance and can optionally skip consent screens for improved user experience. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ oidcProvider({ loginPage: "/sign-in", trustedClients: [ { clientId: "internal-dashboard", clientSecret: "secure-secret-here", name: "Internal Dashboard", type: "web", redirectURLs: ["https: disabled: false, skipConsent: true, metadata: { internal: true } }, { clientId: "mobile-app", clientSecret: "mobile-secret", name: "Company Mobile App", type: "native", redirectURLs: ["com.company.app: disabled: false, skipConsent: false, metadata: {} } ] })] }) ``` ### UserInfo Endpoint The OIDC Provider includes a UserInfo endpoint that allows clients to retrieve information about the authenticated user. This endpoint is available at `/oauth2/userinfo` and requires a valid access token. <Endpoint path="/oauth2/userinfo" method="GET" /> ```ts title="client-app.ts" const response = await fetch('https: headers: { 'Authorization': 'Bearer ACCESS_TOKEN' } }); const userInfo = await response.json(); ``` The UserInfo endpoint returns different claims based on the scopes that were granted during authorization: * With `openid` scope: Returns the user's ID (`sub` claim) * With `profile` scope: Returns name, picture, given\_name, family\_name * With `email` scope: Returns email and email\_verified The `getAdditionalUserInfoClaim` function receives the user object and the requested scopes array, allowing you to conditionally include claims based on the scopes granted during authorization. These additional claims will be included in both the UserInfo endpoint response and the ID token. ### Consent Screen When a user is redirected to the OIDC provider for authentication, they may be prompted to authorize the application to access their data. This is known as the consent screen. By default, Better Auth will display a sample consent screen. You can customize the consent screen by providing a `consentPage` option during initialization. **Note**: Trusted clients with `skipConsent: true` will bypass the consent screen entirely, providing a seamless experience for first-party applications. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [oidcProvider({ consentPage: "/path/to/consent/page" })] }) ``` The plugin will redirect the user to the specified path with a `client_id` and `scope` query parameter. You can use this information to display a custom consent screen. Once the user consents, you can call `oauth2.consent` to complete the authorization. <Endpoint path="/oauth2/consent" method="POST" /> ```ts title="server.ts" const res = await client.oauth2.consent({ accept: true, }); ``` The `client_id` and other necessary information are stored in the browser cookie, so you don't need to pass them in the request. If they don't exist in the cookie, the consent method will return an error. ### Handling Login When a user is redirected to the OIDC provider for authentication, if they are not already logged in, they will be redirected to the login page. You can customize the login page by providing a `loginPage` option during initialization. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [oidcProvider({ loginPage: "/sign-in" })] }) ``` You don't need to handle anything from your side; when a new session is created, the plugin will handle continuing the authorization flow. ## Configuration ### OIDC Metadata Customize the OIDC metadata by providing a configuration object during initialization. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [oidcProvider({ metadata: { issuer: "https: authorization_endpoint: "/custom/oauth2/authorize", token_endpoint: "/custom/oauth2/token", } })] }) ``` ### JWKS Endpoint The OIDC Provider plugin can integrate with the JWT plugin to provide proper asymmetric key signing for ID tokens. When enabled, ID tokens will be signed using RSA/EdDSA keys and can be verified using the JWKS endpoint. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ jwt(), oidcProvider({ useJWTPlugin: true, loginPage: "/sign-in", }) ] }) ``` <Callout type="info"> When `useJWTPlugin: false` (default), ID tokens are signed with the application secret. </Callout> ### Dynamic Client Registration If you want to allow clients to register dynamically, you can enable this feature by setting the `allowDynamicClientRegistration` option to `true`. ```ts title="auth.ts" const auth = betterAuth({ plugins: [oidcProvider({ allowDynamicClientRegistration: true, })] }) ``` This will allow clients to register using the `/register` endpoint to be publicly available. ## Schema The OIDC Provider plugin adds the following tables to the database: ### OAuth Application Table Name: `oauthApplication` <DatabaseTable fields={[ { name: "id", type: "string", description: "Database ID of the OAuth client", isPrimaryKey: true }, { name: "clientId", type: "string", description: "Unique identifier for each OAuth client", isPrimaryKey: true }, { name: "clientSecret", type: "string", description: "Secret key for the OAuth client. Optional for public clients using PKCE.", isOptional: true }, { name: "name", type: "string", description: "Name of the OAuth client", isRequired: true }, { name: "redirectURLs", type: "string", description: "Comma-separated list of redirect URLs", isRequired: true }, { name: "metadata", type: "string", description: "Additional metadata for the OAuth client", isOptional: true }, { name: "type", type: "string", description: "Type of OAuth client (e.g., web, mobile)", isRequired: true }, { name: "disabled", type: "boolean", description: "Indicates if the client is disabled", isRequired: true }, { name: "userId", type: "string", description: "ID of the user who owns the client. (optional)", isOptional: true }, { name: "createdAt", type: "Date", description: "Timestamp of when the OAuth client was created" }, { name: "updatedAt", type: "Date", description: "Timestamp of when the OAuth client was last updated" } ]} /> ### OAuth Access Token Table Name: `oauthAccessToken` <DatabaseTable fields={[ { name: "id", type: "string", description: "Database ID of the access token", isPrimaryKey: true }, { name: "accessToken", type: "string", description: "Access token issued to the client", }, { name: "refreshToken", type: "string", description: "Refresh token issued to the client", isRequired: true }, { name: "accessTokenExpiresAt", type: "Date", description: "Expiration date of the access token", isRequired: true }, { name: "refreshTokenExpiresAt", type: "Date", description: "Expiration date of the refresh token", isRequired: true }, { name: "clientId", type: "string", description: "ID of the OAuth client", isForeignKey: true, references: { model: "oauthClient", field: "clientId" } }, { name: "userId", type: "string", description: "ID of the user associated with the token", isForeignKey: true, references: { model: "user", field: "id" } }, { name: "scopes", type: "string", description: "Comma-separated list of scopes granted", isRequired: true }, { name: "createdAt", type: "Date", description: "Timestamp of when the access token was created" }, { name: "updatedAt", type: "Date", description: "Timestamp of when the access token was last updated" } ]} /> ### OAuth Consent Table Name: `oauthConsent` <DatabaseTable fields={[ { name: "id", type: "string", description: "Database ID of the consent", isPrimaryKey: true }, { name: "userId", type: "string", description: "ID of the user who gave consent", isForeignKey: true, references: { model: "user", field: "id" } }, { name: "clientId", type: "string", description: "ID of the OAuth client", isForeignKey: true, references: { model: "oauthClient", field: "clientId" } }, { name: "scopes", type: "string", description: "Comma-separated list of scopes consented to", isRequired: true }, { name: "consentGiven", type: "boolean", description: "Indicates if consent was given", isRequired: true }, { name: "createdAt", type: "Date", description: "Timestamp of when the consent was given" }, { name: "updatedAt", type: "Date", description: "Timestamp of when the consent was last updated" } ]} /> ## Options **allowDynamicClientRegistration**: `boolean` - Enable or disable dynamic client registration. **metadata**: `OIDCMetadata` - Customize the OIDC provider metadata. **loginPage**: `string` - Path to the custom login page. **consentPage**: `string` - Path to the custom consent page. **trustedClients**: `(Client & { skipConsent?: boolean })[]` - Array of trusted clients that are configured directly in the provider options. These clients bypass database lookups and can optionally skip consent screens. **getAdditionalUserInfoClaim**: `(user: User, scopes: string[]) => Record<string, any>` - Function to get additional user info claims. **useJWTPlugin**: `boolean` - When `true`, ID tokens are signed using the JWT plugin's asymmetric keys. When `false` (default), ID tokens are signed with HMAC-SHA256 using the application secret. # plugins: One Tap URL: /docs/plugins/one-tap Source: https: One Tap plugin for Better Auth *** title: One Tap description: One Tap plugin for Better Auth ------------------------------------------- The One Tap plugin allows users to log in with a single tap using Google's One Tap API. The plugin provides a simple way to integrate One Tap into your application, handling the client-side and server-side logic for you. ## Installation ### Add the Server Plugin Add the One Tap plugin to your auth configuration: ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ oneTap(), ] }); ``` ### Add the Client Plugin Add the client plugin and specify where the user should be redirected after sign-in or if additional verification (like 2FA) is needed. ```ts export const authClient = createAuthClient({ plugins: [ oneTapClient({ clientId: "YOUR_CLIENT_ID", autoSelect: false, cancelOnTapOutside: true, context: "signin", additionalOptions: { }, promptOptions: { baseDelay: 1000, maxAttempts: 5 } }) ] }); ``` ### Usage To display the One Tap popup, simply call the oneTap method on your auth client: ```ts await authClient.oneTap(); ``` ### Customizing Redirect Behavior By default, after a successful login the plugin will hard redirect the user to `/`. You can customize this behavior as follows: #### Avoiding a Hard Redirect Pass fetchOptions with an onSuccess callback to handle the login response without a page reload: ```ts await authClient.oneTap({ fetchOptions: { onSuccess: () => { router.push("/dashboard"); } } }); ``` #### Specifying a Custom Callback URL To perform a hard redirect to a different page after login, use the callbackURL option: ```ts await authClient.oneTap({ callbackURL: "/dashboard" }); ``` #### Handling Prompt Dismissals with Exponential Backoff If the user dismisses or skips the prompt, the plugin will retry showing the One Tap prompt using exponential backoff based on your configured promptOptions. If the maximum number of attempts is reached without a successful sign-in, you can use the onPromptNotification callback to be notified—allowing you to render an alternative UI (e.g., a traditional Google Sign-In button) so users can restart the process manually: ```ts await authClient.oneTap({ onPromptNotification: (notification) => { console.warn("Prompt was dismissed or skipped. Consider displaying an alternative sign-in option.", notification); } }); ``` ### Client Options * **clientId**: The client ID for your Google One Tap API. * **autoSelect**: Automatically select the account if the user is already signed in. Default is false. * **context**: The context in which the One Tap API should be used (e.g., "signin"). Default is "signin". * **cancelOnTapOutside**: Cancel the One Tap popup when the user taps outside it. Default is true. * additionalOptions: Extra options to pass to Google's initialize method as per the [Google Identity Services docs](https: * **promptOptions**: Configuration for the prompt behavior and exponential backoff: * **baseDelay**: Base delay in milliseconds for retries. Default is 1000. * **maxAttempts**: Maximum number of prompt attempts before invoking the onPromptNotification callback. Default is 5. ### Server Options * **disableSignUp**: Disable the sign-up option, allowing only existing users to sign in. Default is `false`. * **ClientId**: Optionally, pass a client ID here if it is not provided in your social provider configuration. # plugins: One-Time Token Plugin URL: /docs/plugins/one-time-token Source: https: Generate and verify single-use token *** title: One-Time Token Plugin description: Generate and verify single-use token ------------------------------------------------- The One-Time Token (OTT) plugin provides functionality to generate and verify secure, single-use session tokens. These are commonly used for across domains authentication. ## Installation ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ oneTimeToken() ] }); ``` ## Usage ### 1. Generate a Token Generate a token using `auth.api.generateOneTimeToken` or `authClient.oneTimeToken.generate` <APIMethod path="/one-time-token/generate" method="GET" requireSession> ```ts type generateOneTimeToken = { } ``` </APIMethod> This will return a `token` that is attached to the current session which can be used to verify the one-time token. By default, the token will expire in 3 minutes. ### 2. Verify the Token When the user clicks the link or submits the token, use the `auth.api.verifyOneTimeToken` or `authClient.oneTimeToken.verify` method in another API route to validate it. <APIMethod path="/one-time-token/verify" method="POST"> ```ts type verifyOneTimeToken = { token: string = "some-token" } ``` </APIMethod> This will return the session that was attached to the token. ## Options These options can be configured when adding the `oneTimeToken` plugin: * **`disableClientRequest`** (boolean): Optional. If `true`, the token will only be generated on the server side. Default: `false`. * **`expiresIn`** (number): Optional. The duration for which the token is valid in minutes. Default: `3`. ```ts oneTimeToken({ expiresIn: 10 }) ``` * **`generateToken`**: A custom token generator function that takes `session` object and a `ctx` as paramters. * **`storeToken`**: Optional. This option allows you to configure how the token is stored in your database. * **`plain`**: The token is stored in plain text. (Default) * **`hashed`**: The token is hashed using the default hasher. * **`custom-hasher`**: A custom hasher function that takes a token and returns a hashed token. <Callout type="info"> Note: It will not affect the token that's sent, it will only affect the token stored in your database. </Callout> Examples: ```ts title="No hashing (default)" oneTimeToken({ storeToken: "plain" }) ``` ```ts title="built-in hasher" oneTimeToken({ storeToken: "hashed" }) ``` ```ts title="custom hasher" oneTimeToken({ storeToken: { type: "custom-hasher", hash: async (token) => { return myCustomHasher(token); } } }) ``` # plugins: Open API URL: /docs/plugins/open-api Source: https: Open API reference for Better Auth. *** title: Open API description: Open API reference for Better Auth. ------------------------------------------------ This is a plugin that provides an Open API reference for Better Auth. It shows all endpoints added by plugins and the core. It also provides a way to test the endpoints. It uses [Scalar](https: <Callout> This plugin is still in the early stages of development. We are working on adding more features to it and filling in the gaps. </Callout> ## Installation <Steps> <Step> ### Add the plugin to your **auth** config ```ts title="auth.ts" import { betterAuth } from "better-auth" import { openAPI } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ openAPI(), ] }) ``` </Step> <Step> ### Navigate to `/api/auth/reference` to view the Open API reference Each plugin endpoints are grouped by the plugin name. The core endpoints are grouped under the `Default` group. And Model schemas are grouped under the `Models` group. ![Open API reference](/open-api-reference.png) </Step> </Steps> ## Usage The Open API reference is generated using the [OpenAPI 3.0](https: The reference is generated using the [Scalar](https: ![Open API reference](/open-api-reference.png) ### Generated Schema To get the generated Open API schema directly as JSON, you can do `auth.api.generateOpenAPISchema()`. This will return the Open API schema as a JSON object. ```ts const openAPISchema = await auth.api.generateOpenAPISchema() console.log(openAPISchema) ``` ## Configuration `path` - The path where the Open API reference is served. Default is `/api/auth/reference`. You can change it to any path you like, but keep in mind that it will be appended to the base path of your auth server. `disableDefaultReference` - If set to `true`, the default Open API reference UI by Scalar will be disabled. Default is `false`. # plugins: Organization URL: /docs/plugins/organization Source: https: The organization plugin allows you to manage your organization's members and teams. *** title: Organization description: The organization plugin allows you to manage your organization's members and teams. ------------------------------------------------------------------------------------------------ Organizations simplifies user access and permissions management. Assign roles and permissions to streamline project management, team coordination, and partnerships. ## Installation <Steps> <Step> ### Add the plugin to your **auth** config ```ts title="auth.ts" import { betterAuth } from "better-auth" import { organization } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ organization() ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { organizationClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ organizationClient() ] }) ``` </Step> </Steps> ## Usage Once you've installed the plugin, you can start using the organization plugin to manage your organization's members and teams. The client plugin will provide you methods under the `organization` namespace. And the server `api` will provide you with the necessary endpoints to manage your organization and gives you easier way to call the functions on your own backend. ## Organization ### Create an organization <APIMethod path="/organization/create" method="POST" requireSession> ```ts const metadata = { someKey: "someValue" }; type createOrganization = { name: string = "My Organization" slug: string = "my-org" logo?: string = "https: metadata?: Record<string, any> userId?: string = "some_user_id" keepCurrentActiveOrganization?: boolean = false } ``` </APIMethod> #### Restrict who can create an organization By default, any user can create an organization. To restrict this, set the `allowUserToCreateOrganization` option to a function that returns a boolean, or directly to `true` or `false`. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ organization({ allowUserToCreateOrganization: async (user) => { const subscription = await getSubscription(user.id) return subscription.plan === "pro" } }) ] }) ``` #### Check if organization slug is taken To check if an organization slug is taken or not you can use the `checkSlug` function provided by the client. The function takes an object with the following properties: <APIMethod path="/organization/check-slug" method="POST"> ```ts type checkOrganizationSlug = { slug: string = "my-org" } ``` </APIMethod> #### Organization Creation Hooks You can customize the organization creation process using hooks that run before and after an organization is created. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ organization({ organizationCreation: { disabled: false, beforeCreate: async ({ organization, user }, request) => { return { data: { ...organization, metadata: { customField: "value" } } } }, afterCreate: async ({ organization, member, user }, request) => { await setupDefaultResources(organization.id) } } }) ] }) ``` The `beforeCreate` hook runs before an organization is created. It receives: * `organization`: The organization data (without ID) * `user`: The user creating the organization * `request`: The HTTP request object (optional) Return an object with `data` property to modify the organization data that will be created. The `afterCreate` hook runs after an organization is successfully created. It receives: * `organization`: The created organization (with ID) * `member`: The member record for the creator * `user`: The user who created the organization * `request`: The HTTP request object (optional) ### List User's Organizations To list the organizations that a user is a member of, you can use `useListOrganizations` hook. It implements a reactive way to get the organizations that the user is a member of. <Tabs items={["React", "Vue", "Svelte"]} defaultValue="React"> <Tab value="React"> ```tsx title="client.tsx" import { authClient } from "@/lib/auth-client" function App(){ const { data: organizations } = authClient.useListOrganizations() return ( <div> {organizations.map(org => <p>{org.name}</p>)} </div> ) } ``` </Tab> <Tab value="Svelte"> ```svelte title="page.svelte" <script lang="ts"> import { authClient } from "$lib/auth-client"; const organizations = authClient.useListOrganizations(); </script> <h1>Organizations</h1>s {#if $organizations.isPending} <p>Loading...</p> {:else if $organizations.data === null} <p>No organizations found.</p> {:else} <ul> {#each $organizations.data as organization} <li>{organization.name}</li> {/each} </ul> {/if} ``` </Tab> <Tab value="Vue"> ```vue title="organization.vue" <script lang="ts">; export default { setup() { const organizations = authClient.useListOrganizations() return { organizations }; } }; </script> <template> <div> <h1>Organizations</h1> <div v-if="organizations.isPending">Loading...</div> <div v-else-if="organizations.data === null">No organizations found.</div> <ul v-else> <li v-for="organization in organizations.data" :key="organization.id"> {{ organization.name }} </li> </ul> </div> </template> ``` </Tab> </Tabs> Or alternatively, you can call `organization.list` if you don't want to use a hook. <APIMethod path="/organization/list" method="GET"> ```ts type listOrganizations = { } ``` </APIMethod> ### Active Organization Active organization is the workspace the user is currently working on. By default when the user is signed in the active organization is set to `null`. You can set the active organization to the user session. <Callout type="info"> It's not always you want to persist the active organization in the session. You can manage the active organization in the client side only. For example, multiple tabs can have different active organizations. </Callout> #### Set Active Organization You can set the active organization by calling the `organization.setActive` function. It'll set the active organization for the user session. <Callout> In some applications, you may want the ability to un-set an active organization. In this case, you can call this endpoint with `organizationId` set to `null`. </Callout> <APIMethod path="/organization/set-active" method="POST"> ```ts type setActiveOrganization = { organizationId?: string | null = "org-id" organizationSlug?: string = "org-slug" } ``` </APIMethod> To set active organization when a session is created you can use [database hooks](/docs/concepts/database#database-hooks). ```ts title="auth.ts" export const auth = betterAuth({ databaseHooks: { session: { create: { before: async(session)=>{ const organization = await getActiveOrganization(session.userId) return { data: { ...session, activeOrganizationId: organization.id } } } } } } }) ``` #### Use Active Organization To retrieve the active organization for the user, you can call the `useActiveOrganization` hook. It returns the active organization for the user. Whenever the active organization changes, the hook will re-evaluate and return the new active organization. <Tabs items={['React', 'Vue', 'Svelte']}> <Tab value="React"> ```tsx title="client.tsx" import { authClient } from "@/lib/auth-client" function App(){ const { data: activeOrganization } = authClient.useActiveOrganization() return ( <div> {activeOrganization ? <p>{activeOrganization.name}</p> : null} </div> ) } ``` </Tab> <Tab value="Svelte"> ```tsx title="client.tsx" <script lang="ts"> import { authClient } from "$lib/auth-client"; const activeOrganization = authClient.useActiveOrganization(); </script> <h2>Active Organization</h2> {#if $activeOrganization.isPending} <p>Loading...</p> {:else if $activeOrganization.data === null} <p>No active organization found.</p> {:else} <p>{$activeOrganization.data.name}</p> {/if} ``` </Tab> <Tab value="Vue"> ```vue title="organization.vue" <script lang="ts">; export default { setup() { const activeOrganization = authClient.useActiveOrganization(); return { activeOrganization }; } }; </script> <template> <div> <h2>Active organization</h2> <div v-if="activeOrganization.isPending">Loading...</div> <div v-else-if="activeOrganization.data === null">No active organization.</div> <div v-else> {{ activeOrganization.data.name }} </div> </div> </template> ``` </Tab> </Tabs> ### Get Full Organization To get the full details of an organization, you can use the `getFullOrganization` function. By default, if you don't pass any properties, it will use the active organization. <APIMethod path="/organization/get-full-organization" method="GET" requireSession> ```ts type getFullOrganization = { organizationId?: string = "org-id" organizationSlug?: string = "org-slug" membersLimit?: number = 100 } ``` </APIMethod> ### Update Organization To update organization info, you can use `organization.update` <APIMethod path="/organization/update" method="POST" requireSession> ```ts type updateOrganization = { data: { name?: string = "updated-name" slug?: string = "updated-slug" logo?: string = "new-logo.url" metadata?: Record<string, any> | null = { customerId: "test" } } organizationId?: string = "org-id" } ``` </APIMethod> ### Delete Organization To remove user owned organization, you can use `organization.delete` <APIMethod path="/organization/delete" method="POST" requireSession> ```ts type deleteOrganization = { organizationId: string = "org-id" } ``` </APIMethod> If the user has the necessary permissions (by default: role is owner) in the specified organization, all members, invitations and organization information will be removed. You can configure how organization deletion is handled through `organizationDeletion` option: ```ts const auth = betterAuth({ plugins: [ organization({ organizationDeletion: { disabled: true, beforeDelete: async (data, request) => { }, afterDelete: async (data, request) => { }, }, }), ], }); ``` ## Invitations To add a member to an organization, we first need to send an invitation to the user. The user will receive an email/sms with the invitation link. Once the user accepts the invitation, they will be added to the organization. ### Setup Invitation Email For member invitation to work we first need to provide `sendInvitationEmail` to the `better-auth` instance. This function is responsible for sending the invitation email to the user. You'll need to construct and send the invitation link to the user. The link should include the invitation ID, which will be used with the acceptInvitation function when the user clicks on it. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ organization({ async sendInvitationEmail(data) { const inviteLink = `https: sendOrganizationInvitation({ email: data.email, invitedByUsername: data.inviter.user.name, invitedByEmail: data.inviter.user.email, teamName: data.organization.name, inviteLink }) }, }), ], }); ``` ### Send Invitation To invite users to an organization, you can use the `invite` function provided by the client. The `invite` function takes an object with the following properties: <APIMethod path="/organization/invite-member" method="POST"> ```ts type createInvitation = { email: string = "example@gmail.com" role: string | string[] = "member" organizationId?: string = "org-id" resend?: boolean = true teamId?: string = "team-id" } ``` </APIMethod> <Callout> * If the user is already a member of the organization, the invitation will be canceled. * If the user is already invited to the organization, unless `resend` is set to `true`, the invitation will not be sent again. * If `cancelPendingInvitationsOnReInvite` is set to `true`, the invitation will be canceled if the user is already invited to the organization and a new invitation is sent. </Callout> ### Accept Invitation When a user receives an invitation email, they can click on the invitation link to accept the invitation. The invitation link should include the invitation ID, which will be used to accept the invitation. Make sure to call the `acceptInvitation` function after the user is logged in. <APIMethod path="/organization/accept-invitation" method="POST"> ```ts type acceptInvitation = { invitationId: string = "invitation-id" } ``` </APIMethod> ### Cancel Invitation If a user has sent out an invitation, you can use this method to cancel it. If you're looking for how a user can reject an invitation, you can find that [here](#reject-invitation). <APIMethod path="/organization/cancel-invitation" method="POST" noResult> ```ts type cancelInvitation = { invitationId: string = "invitation-id" } ``` </APIMethod> ### Reject Invitation If this user has received an invitation, but wants to decline it, this method will allow you to do so by rejecting it. <APIMethod path="/organization/reject-invitation" method="POST" noResult> ```ts type rejectInvitation = { invitationId: string = "invitation-id" } ``` </APIMethod> ### Get Invitation To get an invitation you can use the `organization.getInvitation` function provided by the client. You need to provide the invitation id as a query parameter. <APIMethod path="/organization/get-invitation" method="GET" requireSession> ```ts type getInvitation = { id: string = "invitation-id" } ``` </APIMethod> ### List Invitations To list all invitations for a given organization you can use the `listInvitations` function provided by the client. <APIMethod path="/organization/list-invitations" method="GET"> ```ts type listInvitations = { organizationId?: string = "organization-id" } ``` </APIMethod> ### List user invitations To list all invitations for a given user you can use the `listUserInvitations` function provided by the client. ```ts title="auth-client.ts" const invitations = await authClient.organization.listUserInvitations() ``` On the server, you can pass the user ID as a query parameter. ```ts title="api.ts" const invitations = await auth.api.listUserInvitations({ query: { email: "user@example.com" } }) ``` <Callout type="warn"> The `email` query parameter is only available on the server to query for invitations for a specific user. </Callout> ## Members ### List Members To list all members of an organization you can use the `listMembers` function. <APIMethod path="/organization/list-members" method="GET"> ```ts type listMembers = { organizationId?: string = "organization-id" limit?: number = 100 offset?: number = 0 sortBy?: string = "createdAt" sortDirection?: "asc" | "desc" = "desc" filterField?: string = "createdAt" filterOperator?: "eq" | "ne" | "gt" | "gte" | "lt" | "lte" | "in" | "nin" | "contains" = "eq" filterValue?: string = "value" memberIdOrEmail: string = "user@example.com" organizationId?: string = "org-id" } ``` </APIMethod> ### Update Member Role To update the role of a member in an organization, you can use the `organization.updateMemberRole`. If the user has the permission to update the role of the member, the role will be updated. <APIMethod path="/organization/update-member-role" method="POST" noResult> ```ts type updateMemberRole = { role: string | string[] = ["admin", "sale"] memberId: string = "member-id" organizationId?: string = "organization-id" } ``` </APIMethod> ### Get Active Member To get the current member of the active organization you can use the `organization.getActiveMember` function. This function will return the user's member details in their active organization. <APIMethod path="/organization/get-active-member" method="GET" requireSession resultVariable="member"> ```ts type getActiveMember = { } ``` </APIMethod> ### Add Member If you want to add a member directly to an organization without sending an invitation, you can use the `addMember` function which can only be invoked on the server. <APIMethod path="/organization/add-member" method="POST" isServerOnly> ```ts type addMember = { userId?: string | null = "user-id" role: string | string[] = ["admin", "sale"] organizationId?: string = "org-id" teamId?: string = "team-id" } ``` </APIMethod> ### Leave Organization To leave organization you can use `organization.leave` function. This function will remove the current user from the organization. <APIMethod path="/organization/leave" method="POST" requireSession noResult> ```ts type leaveOrganization = { organizationId: string = "organization-id" } ``` </APIMethod> ## Access Control The organization plugin providers a very flexible access control system. You can control the access of the user based on the role they have in the organization. You can define your own set of permissions based on the role of the user. ### Roles By default, there are three roles in the organization: `owner`: The user who created the organization by default. The owner has full control over the organization and can perform any action. `admin`: Users with the admin role have full control over the organization except for deleting the organization or changing the owner. `member`: Users with the member role have limited control over the organization. They can create projects, invite users, and manage projects they have created. <Callout> A user can have multiple roles. Multiple roles are stored as string separated by comma (","). </Callout> ### Permissions By default, there are three resources, and these have two to three actions. **organization**: `update` `delete` **member**: `create` `update` `delete` **invitation**: `create` `cancel` The owner has full control over all the resources and actions. The admin has full control over all the resources except for deleting the organization or changing the owner. The member has no control over any of those actions other than reading the data. ### Custom Permissions The plugin provides an easy way to define your own set of permissions for each role. <Steps> <Step> #### Create Access Control You first need to create access controller by calling `createAccessControl` function and passing the statement object. The statement object should have the resource name as the key and the array of actions as the value. ```ts title="permissions.ts" import { createAccessControl } from "better-auth/plugins/access"; const statement = { project: ["create", "share", "update", "delete"], } as const; const ac = createAccessControl(statement); ``` </Step> <Step> #### Create Roles Once you have created the access controller you can create roles with the permissions you have defined. ```ts title="permissions.ts" import { createAccessControl } from "better-auth/plugins/access"; const statement = { project: ["create", "share", "update", "delete"], } as const; const ac = createAccessControl(statement); const member = ac.newRole({ project: ["create"], }); const admin = ac.newRole({ project: ["create", "update"], }); const owner = ac.newRole({ project: ["create", "update", "delete"], }); const myCustomRole = ac.newRole({ project: ["create", "update", "delete"], organization: ["update"], }); ``` When you create custom roles for existing roles, the predefined permissions for those roles will be overridden. To add the existing permissions to the custom role, you need to import `defaultStatements` and merge it with your new statement, plus merge the roles' permissions set with the default roles. ```ts title="permissions.ts" import { createAccessControl } from "better-auth/plugins/access"; import { defaultStatements, adminAc } from 'better-auth/plugins/organization/access' const statement = { ...defaultStatements, project: ["create", "share", "update", "delete"], } as const; const ac = createAccessControl(statement); const admin = ac.newRole({ project: ["create", "update"], ...adminAc.statements, }); ``` </Step> <Step> #### Pass Roles to the Plugin Once you have created the roles you can pass them to the organization plugin both on the client and the server. ```ts title="auth.ts" import { betterAuth } from "better-auth" import { organization } from "better-auth/plugins" import { ac, owner, admin, member } from "@/auth/permissions" export const auth = betterAuth({ plugins: [ organization({ ac, roles: { owner, admin, member, myCustomRole } }), ], }); ``` You also need to pass the access controller and the roles to the client plugin. ```ts title="auth-client" import { createAuthClient } from "better-auth/client" import { organizationClient } from "better-auth/client/plugins" import { ac, owner, admin, member, myCustomRole } from "@/auth/permissions" export const authClient = createAuthClient({ plugins: [ organizationClient({ ac, roles: { owner, admin, member, myCustomRole } }) ] }) ``` </Step> </Steps> ### Access Control Usage **Has Permission**: You can use the `hasPermission` action provided by the `api` to check the permission of the user. ```ts title="api.ts" await auth.api.hasPermission({ headers: await headers(), body: { permissions: { project: ["create"] } } }); await auth.api.hasPermission({ headers: await headers(), body: { permissions: { project: ["create"], sale: ["create"] } } }); ``` If you want to check the permission of the user on the client from the server you can use the `hasPermission` function provided by the client. ```ts title="auth-client.ts" const canCreateProject = await authClient.organization.hasPermission({ permissions: { project: ["create"] } }) const canCreateProjectAndCreateSale = await authClient.organization.hasPermission({ permissions: { project: ["create"], sale: ["create"] } }) ``` **Check Role Permission**: Once you have defined the roles and permissions to avoid checking the permission from the server you can use the `checkRolePermission` function provided by the client. ```ts title="auth-client.ts" const canCreateProject = authClient.organization.checkRolePermission({ permissions: { organization: ["delete"], }, role: "admin", }); const canCreateProjectAndCreateSale = authClient.organization.checkRolePermission({ permissions: { organization: ["delete"], member: ["delete"] }, role: "admin", }); ``` ## Teams Teams allow you to group members within an organization. The teams feature provides additional organization structure and can be used to manage permissions at a more granular level. ### Enabling Teams To enable teams, pass the `teams` configuration option to both server and client plugins: ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ organization({ teams: { enabled: true, maximumTeams: 10, allowRemovingAllTeams: false } }) ] }) ``` ```ts title="auth-client.ts" export const authClient = createAuthClient({ plugins: [ organizationClient({ teams: { enabled: true } }) ] }) ``` ### Managing Teams #### Create Team Create a new team within an organization: <APIMethod path="/organization/create-team" method="POST"> ```ts type createTeam = { name: string = "my-team" organizationId?: string = "organization-id" } ``` </APIMethod> #### List Teams Get all teams in an organization: <APIMethod path="/organization/list-teams" method="GET" requireSession> ```ts type listOrganizationTeams = { organizationId?: string = "organziation-id" } ``` </APIMethod> #### Update Team Update a team's details: <APIMethod path="/organization/update-team" method="POST" requireSession> ```ts type updateTeam = { teamId: string = "team-id" data: { name?: string = "My new team name" organizationId?: string = "My new organization ID for this team" createdAt?: Date = new Date() updatedAt?: Date = new Date() } } ``` </APIMethod> #### Remove Team Delete a team from an organization: <APIMethod path="/organization/remove-team" method="POST"> ```ts type removeTeam = { teamId: string = "team-id" organizationId?: string = "organization-id" } ``` </APIMethod> #### Set Active Team Sets the given team as the current active team. If `teamId` is `null` the current active team is unset. <APIMethod path="/organization/set-active-team" method="POST"> ```ts type setActiveTeam = { teamId?: string = "team-id" } ``` </APIMethod> #### List User Teams List all teams that the current user is a part of. <APIMethod path="/organization/list-user-teams" method="GET"> ```ts type listUserTeams = { } ``` </APIMethod> #### List Team Members List the members of the given team. <APIMethod path="/organization/list-team-members" method="POST"> ```ts type listTeamMembers = { teamId?: string = "team-id" } ``` </APIMethod> #### Add Team Member Add a member to a team. <APIMethod path="/organization/add-team-member" method="POST"> ```ts type addTeamMember = { teamId: string = "team-id" userId: string = "user-id" } ``` </APIMethod> #### Remove Team Member Remove a member from a team. <APIMethod path="/organization/remove-team-member" method="POST"> ```ts type removeTeamMember = { teamId: string = "team-id" userId: string = "user-id" } ``` </APIMethod> ### Team Permissions Teams follow the organization's permission system. To manage teams, users need the following permissions: * `team:create` - Create new teams * `team:update` - Update team details * `team:delete` - Remove teams By default: * Organization owners and admins can manage teams * Regular members cannot create, update, or delete teams ### Team Configuration Options The teams feature supports several configuration options: * `maximumTeams`: Limit the number of teams per organization ```ts teams: { enabled: true, maximumTeams: 10 maximumTeams: async ({ organizationId, session }, request) => { const plan = await getPlan(organizationId) return plan === 'pro' ? 20 : 5 }, maximumMembersPerTeam: 10 maximumMembersPerTeam: async ({ teamId, session, organizationId }, request) => { const plan = await getPlan(organizationId, teamId) return plan === 'pro' ? 50 : 10 }, } ``` * `allowRemovingAllTeams`: Control whether the last team can be removed ```ts teams: { enabled: true, allowRemovingAllTeams: false } ``` ### Team Members When inviting members to an organization, you can specify a team: ```ts await authClient.organization.inviteMember({ email: "user@example.com", role: "member", teamId: "team-id" }) ``` The invited member will be added to the specified team upon accepting the invitation. ### Database Schema When teams are enabled, new `team` and `teamMember` tables are added to the database. Table Name: `team` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each team", isPrimaryKey: true }, { name: "name", type: "string", description: "The name of the team" }, { name: "organizationId", type: "string", description: "The ID of the organization", isForeignKey: true }, { name: "createdAt", type: "Date", description: "Timestamp of when the team was created" }, { name: "updatedAt", type: "Date", isOptional: true, description: "Timestamp of when the team was created" }, ]} /> Table Name: `teamMember` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each team member", isPrimaryKey: true }, { name: "teamId", type: "string", description: "Unique identifier for each team", isForeignKey: true }, { name: "userId", type: "string", description: "The ID of the user", isForeignKey: true }, { name: "createdAt", type: "Date", description: "Timestamp of when the team member was created" }, ]} /> ## Schema The organization plugin adds the following tables to the database: ### Organization Table Name: `organization` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each organization", isPrimaryKey: true }, { name: "name", type: "string", description: "The name of the organization" }, { name: "slug", type: "string", description: "The slug of the organization" }, { name: "logo", type: "string", description: "The logo of the organization", isOptional: true }, { name: "metadata", type: "string", description: "Additional metadata for the organization", isOptional: true }, { name: "createdAt", type: "Date", description: "Timestamp of when the organization was created" }, ]} /> ### Member Table Name: `member` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each member", isPrimaryKey: true }, { name: "userId", type: "string", description: "The ID of the user", isForeignKey: true }, { name: "organizationId", type: "string", description: "The ID of the organization", isForeignKey: true }, { name: "role", type: "string", description: "The role of the user in the organization" }, { name: "createdAt", type: "Date", description: "Timestamp of when the member was added to the organization" }, ]} /> ### Invitation Table Name: `invitation` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each invitation", isPrimaryKey: true }, { name: "email", type: "string", description: "The email address of the user" }, { name: "inviterId", type: "string", description: "The ID of the inviter", isForeignKey: true }, { name: "organizationId", type: "string", description: "The ID of the organization", isForeignKey: true }, { name: "role", type: "string", description: "The role of the user in the organization" }, { name: "status", type: "string", description: "The status of the invitation" }, { name: "expiresAt", type: "Date", description: "Timestamp of when the invitation expires" }, ]} /> If teams are enabled, you need to add the following fields to the invitation table: <DatabaseTable fields={[ { name: "teamId", type: "string", description: "The ID of the team", isOptional: true }, ]} /> ### Session Table Name: `session` You need to add two more fields to the session table to store the active organization ID and the active team ID. <DatabaseTable fields={[ { name: "activeOrganizationId", type: "string", description: "The ID of the active organization", isOptional: true }, { name: "activeTeamId", type: "string", description: "The ID of the active team", isOptional: true }, ]} /> ### Teams (optional) Table Name: `team` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each team", isPrimaryKey: true }, { name: "name", type: "string", description: "The name of the team" }, { name: "organizationId", type: "string", description: "The ID of the organization", isForeignKey: true }, { name: "createdAt", type: "Date", description: "Timestamp of when the team was created" }, { name: "updatedAt", type: "Date", isOptional: true, description: "Timestamp of when the team was created" }, ]} /> Table Name: `teamMember` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each team member", isPrimaryKey: true }, { name: "teamId", type: "string", description: "Unique identifier for each team", isForeignKey: true }, { name: "userId", type: "string", description: "The ID of the user", isForeignKey: true }, { name: "createdAt", type: "Date", description: "Timestamp of when the team member was created" }, ]} /> Table Name: `invitation` <DatabaseTable fields={[ { name: "teamId", type: "string", description: "The ID of the team", isOptional: true }, ]} /> ### Customizing the Schema To change the schema table name or fields, you can pass `schema` option to the organization plugin. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ organization({ schema: { organization: { modelName: "organizations", fields: { name: "title" }, additionalFields: { myCustomField: { type: "string", input: true, required: false } } } } }) ] }) ``` #### Additional Fields Starting with [Better Auth v1.3](https: When you add extra fields to a model, the relevant API endpoints will automatically accept and return these new properties. For instance, if you add a custom field to the `organization` table, the `createOrganization` endpoint will include this field in its request and response payloads as needed. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ organization({ schema: { organization: { additionalFields: { myCustomField: { type: "string", input: true, required: false } } } } }) ] }) ``` For inferring the additional fields, you can use the `inferOrgAdditionalFields` function. This function will infer the additional fields from the auth object type. ```ts title="auth-client.ts" const client = createAuthClient({ plugins: [organizationClient({ schema: inferOrgAdditionalFields<typeof auth>() })] }) ``` if you can't import the auth object type, you can use the `inferOrgAdditionalFields` function without the generic. This function will infer the additional fields from the schema object. ```ts title="auth-client.ts" const client = createAuthClient({ plugins: [organizationClient({ schema: inferOrgAdditionalFields({ organization: { additionalFields: { newField: { type: "string", }, }, }, }) })] }) await client.organization.create({ name: "Test", slug: "test", newField: "123", unavalibleField: "123", }) ``` ## Options **allowUserToCreateOrganization**: `boolean` | `((user: User) => Promise<boolean> | boolean)` - A function that determines whether a user can create an organization. By default, it's `true`. You can set it to `false` to restrict users from creating organizations. **organizationLimit**: `number` | `((user: User) => Promise<boolean> | boolean)` - The maximum number of organizations allowed for a user. By default, it's `5`. You can set it to any number you want or a function that returns a boolean. **creatorRole**: `admin | owner` - The role of the user who creates the organization. By default, it's `owner`. You can set it to `admin`. **membershipLimit**: `number` - The maximum number of members allowed in an organization. By default, it's `100`. You can set it to any number you want. **sendInvitationEmail**: `async (data) => Promise<void>` - A function that sends an invitation email to the user. **invitationExpiresIn** : `number` - How long the invitation link is valid for in seconds. By default, it's 48 hours (2 days). **cancelPendingInvitationsOnReInvite**: `boolean` - Whether to cancel pending invitations if the user is already invited to the organization. By default, it's `false`. **invitationLimit**: `number` | `((user: User) => Promise<boolean> | boolean)` - The maximum number of invitations allowed for a user. By default, it's `100`. You can set it to any number you want or a function that returns a boolean. # plugins: Passkey URL: /docs/plugins/passkey Source: https: Passkey *** title: Passkey description: Passkey -------------------- Passkeys are a secure, passwordless authentication method using cryptographic key pairs, supported by WebAuthn and FIDO2 standards in web browsers. They replace passwords with unique key pairs: a private key stored on the user's device and a public key shared with the website. Users can log in using biometrics, PINs, or security keys, providing strong, phishing-resistant authentication without traditional passwords. The passkey plugin implementation is powered by [SimpleWebAuthn](https: ## Installation <Steps> <Step> ### Add the plugin to your auth config To add the passkey plugin to your auth config, you need to import the plugin and pass it to the `plugins` option of the auth instance. **Options** `rpID`: A unique identifier for your website. 'localhost' is okay for local dev `rpName`: Human-readable title for your website `origin`: The URL at which registrations and authentications should occur. `http: `authenticatorSelection`: Allows customization of WebAuthn authenticator selection criteria. Leave unspecified for default settings. * `authenticatorAttachment`: Specifies the type of authenticator * `platform`: Authenticator is attached to the platform (e.g., fingerprint reader) * `cross-platform`: Authenticator is not attached to the platform (e.g., security key) * Default: `not set` (both platform and cross-platform allowed, with platform preferred) * `residentKey`: Determines credential storage behavior. * `required`: User MUST store credentials on the authenticator (highest security) * `preferred`: Encourages credential storage but not mandatory * `discouraged`: No credential storage required (fastest experience) * Default: `preferred` * `userVerification`: Controls biometric/PIN verification during authentication: * `required`: User MUST verify identity (highest security) * `preferred`: Verification encouraged but not mandatory * `discouraged`: No verification required (fastest experience) * Default: `preferred` ```ts title="auth.ts" import { betterAuth } from "better-auth" import { passkey } from "better-auth/plugins/passkey" export const auth = betterAuth({ plugins: [ passkey(), ], }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { passkeyClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ passkeyClient() ] }) ``` </Step> </Steps> ## Usage ### Add/Register a passkey To add or register a passkey make sure a user is authenticated and then call the `passkey.addPasskey` function provided by the client. <APIMethod path="/passkey/add-passkey" method="POST" isClientOnly> ```ts type addPasskey = { name?: string = "example-passkey-name" authenticatorAttachment?: "platform" | "cross-platform" = "cross-platform" } ``` </APIMethod> ### Sign in with a passkey To sign in with a passkey you can use the `signIn.passkey` method. This will prompt the user to sign in with their passkey. <APIMethod path="/sign-in/passkey" method="POST" isClientOnly> ```ts type signInPasskey = { email: string = "example@gmail.com" autoFill?: boolean = true callbackURL?: string = "/dashboard" } ``` </APIMethod> ### List passkeys You can list all of the passkeys for the authenticated user by calling `passkey.listUserPasskeys`: <APIMethod path="/passkey/list-user-passkeys" method="GET" requireSession resultVariable="passkeys"> ```ts type listPasskeys = { } ``` </APIMethod> ### Deleting passkeys You can delete a passkey by calling `passkey.delete` and providing the passkey ID. <APIMethod path="/passkey/delete-passkey" method="POST" requireSession> ```ts type deletePasskey = { id: string = "some-passkey-id" } ``` </APIMethod> ### Updating passkey names <APIMethod path="/passkey/update-passkey" method="POST" requireSession> ```ts type updatePasskey = { id: string = "id of passkey" name: string = "my-new-passkey-name" } ``` </APIMethod> ### Conditional UI The plugin supports conditional UI, which allows the browser to autofill the passkey if the user has already registered a passkey. There are two requirements for conditional UI to work: <Steps> <Step> #### Update input fields Add the `autocomplete` attribute with the value `webauthn` to your input fields. You can add this attribute to multiple input fields, but at least one is required for conditional UI to work. The `webauthn` value should also be the last entry of the `autocomplete` attribute. ```html <label for="name">Username:</label> <input type="text" name="name" autocomplete="username webauthn"> <label for="password">Password:</label> <input type="password" name="password" autocomplete="current-password webauthn"> ``` </Step> <Step> #### Preload the passkeys When your component mounts, you can preload the user's passkeys by calling the `authClient.signIn.passkey` method with the `autoFill` option set to `true`. To prevent unnecessary calls, we will also add a check to see if the browser supports conditional UI. <Tabs items={["React"]}> <Tab value="React"> ```ts useEffect(() => { if (!PublicKeyCredential.isConditionalMediationAvailable || !PublicKeyCredential.isConditionalMediationAvailable()) { return; } void authClient.signIn.passkey({ autoFill: true }) }, []) ``` </Tab> </Tabs> </Step> </Steps> Depending on the browser, a prompt will appear to autofill the passkey. If the user has multiple passkeys, they can select the one they want to use. Some browsers also require the user to first interact with the input field before the autofill prompt appears. ### Debugging To test your passkey implementation you can use [emulated authenticators](https: ## Schema The plugin require a new table in the database to store passkey data. Table Name: `passkey` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each passkey", isPrimaryKey: true }, { name: "name", type: "string", description: "The name of the passkey", isOptional: true }, { name: "publicKey", type: "string", description: "The public key of the passkey", }, { name: "userId", type: "string", description: "The ID of the user", isForeignKey: true }, { name: "credentialID", type: "string", description: "The unique identifier of the registered credential", }, { name: "counter", type: "number", description: "The counter of the passkey", }, { name: "deviceType", type: "string", description: "The type of device used to register the passkey", }, { name: "backedUp", type: "boolean", description: "Whether the passkey is backed up", }, { name: "transports", type: "string", description: "The transports used to register the passkey", }, { name: "createdAt", type: "Date", description: "The time when the passkey was created", }, { name: "aaguid", type: "string", description: "Authenticator's Attestation GUID indicating the type of the authenticator", isOptional: true }, ]} /> ## Options **rpID**: A unique identifier for your website. 'localhost' is okay for local dev. **rpName**: Human-readable title for your website. **origin**: The URL at which registrations and authentications should occur. `http: **authenticatorSelection**: Allows customization of WebAuthn authenticator selection criteria. When unspecified, both platform and cross-platform authenticators are allowed with `preferred` settings for `residentKey` and `userVerification`. **aaguid**: (optional) Authenticator Attestation GUID. This is a unique identifier for the passkey provider (device or authenticator type) and can be used to identify the type of passkey device used during registration or authentication. # plugins: Phone Number URL: /docs/plugins/phone-number Source: https: Phone number plugin *** title: Phone Number description: Phone number plugin -------------------------------- The phone number plugin extends the authentication system by allowing users to sign in and sign up using their phone number. It includes OTP (One-Time Password) functionality to verify phone numbers. ## Installation <Steps> <Step> ### Add Plugin to the server ```ts title="auth.ts" import { betterAuth } from "better-auth" import { phoneNumber } from "better-auth/plugins" const auth = betterAuth({ plugins: [ phoneNumber({ sendOTP: ({ phoneNumber, code }, request) => { } }) ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { phoneNumberClient } from "better-auth/client/plugins" const authClient = createAuthClient({ plugins: [ phoneNumberClient() ] }) ``` </Step> </Steps> ## Usage ### Send OTP for Verification To send an OTP to a user's phone number for verification, you can use the `sendVerificationCode` endpoint. <APIMethod path="/phone-number/send-otp" method="POST"> ```ts type sendPhoneNumberOTP = { phoneNumber: string = "+1234567890" } ``` </APIMethod> ### Verify Phone Number After the OTP is sent, users can verify their phone number by providing the code. <APIMethod path="/phone-number/verify" method="POST"> ```ts type verifyPhoneNumber = { phoneNumber: string = "+1234567890" code: string = "123456" disableSession?: boolean = false updatePhoneNumber?: boolean = true } ``` </APIMethod> <Callout> When the phone number is verified, the `phoneNumberVerified` field in the user table is set to `true`. If `disableSession` is not set to `true`, a session is created for the user. Additionally, if `callbackOnVerification` is provided, it will be called. </Callout> ### Allow Sign-Up with Phone Number To allow users to sign up using their phone number, you can pass `signUpOnVerification` option to your plugin configuration. It requires you to pass `getTempEmail` function to generate a temporary email for the user. ```ts title="auth.ts" export const auth = betterAuth({ plugins: [ phoneNumber({ sendOTP: ({ phoneNumber, code }, request) => { }, signUpOnVerification: { getTempEmail: (phoneNumber) => { return `${phoneNumber}@my-site.com` }, getTempName: (phoneNumber) => { return phoneNumber } } }) ] }) ``` ### Sign In with Phone Number In addition to signing in a user using send-verify flow, you can also use phone number as an identifier and sign in a user using phone number and password. <APIMethod path="/sign-in/phone-number" method="POST"> ```ts type signInPhoneNumber = { phoneNumber: string = "+1234567890" password: string rememberMe?: boolean = true } ``` </APIMethod> ### Update Phone Number Updating phone number uses the same process as verifying a phone number. The user will receive an OTP code to verify the new phone number. ```ts title="auth-client.ts" await authClient.phoneNumber.sendOtp({ phoneNumber: "+1234567890" }) ``` Then verify the new phone number with the OTP code. ```ts title="auth-client.ts" const isVerified = await authClient.phoneNumber.verify({ phoneNumber: "+1234567890", code: "123456", updatePhoneNumber: true }) ``` If a user session exist the phone number will be updated automatically. ### Disable Session Creation By default, the plugin creates a session for the user after verifying the phone number. You can disable this behavior by passing `disableSession: true` to the `verify` method. ```ts title="auth-client.ts" const isVerified = await authClient.phoneNumber.verify({ phoneNumber: "+1234567890", code: "123456", disableSession: true }) ``` ### Request Password Reset To initiate a request password reset flow using `phoneNumber`, you can start by calling `requestPasswordReset` on the client to send an OTP code to the user's phone number. <APIMethod path="/phone-number/request-password-reset" method="POST"> ```ts type requestPasswordResetPhoneNumber = { phoneNumber: string = "+1234567890" } ``` </APIMethod> Then, you can reset the password by calling `resetPassword` on the client with the OTP code and the new password. <APIMethod path="/phone-number/reset-password" method="POST"> ```ts type resetPasswordPhoneNumber = { otp: string = "123456" phoneNumber: string = "+1234567890" newPassword: string = "new-and-secure-password" } ``` </APIMethod> ## Options * `otpLength`: The length of the OTP code to be generated. Default is `6`. * `sendOTP`: A function that sends the OTP code to the user's phone number. It takes the phone number and the OTP code as arguments. * `expiresIn`: The time in seconds after which the OTP code expires. Default is `300` seconds. * `callbackOnVerification`: A function that is called after the phone number is verified. It takes the phone number and the user object as the first argument and a request object as the second argument. ```ts export const auth = betterAuth({ plugins: [ phoneNumber({ sendOTP: ({ phoneNumber, code }, request) => { }, callbackOnVerification: async ({ phoneNumber, user }, request) => { } }) ] }) ``` * `sendPasswordResetOTP`: A function that sends the OTP code to the user's phone number for password reset. It takes the phone number and the OTP code as arguments. * `phoneNumberValidator`: A custom function to validate the phone number. It takes the phone number as an argument and returns a boolean indicating whether the phone number is valid. * `signUpOnVerification`: An object with the following properties: * `getTempEmail`: A function that generates a temporary email for the user. It takes the phone number as an argument and returns the temporary email. * `getTempName`: A function that generates a temporary name for the user. It takes the phone number as an argument and returns the temporary name. * `requireVerification`: When enabled, users cannot sign in with their phone number until it has been verified. If an unverified user attempts to sign in, the server will respond with a 401 error (PHONE\_NUMBER\_NOT\_VERIFIED) and automatically trigger an OTP send to start the verification process. ## Schema The plugin requires 2 fields to be added to the user table ### User Table <DatabaseTable fields={[ { name: "phoneNumber", type: "string", description: "The phone number of the user", isUnique: true, isOptional: true }, { name: "phoneNumberVerified", type: "boolean", description: "Whether the phone number is verified or not", defaultValue: false, isOptional: true }, ]} /> ### OTP Verification Attempts The phone number plugin includes a built-in protection against brute force attacks by limiting the number of verification attempts for each OTP code. ```typescript phoneNumber({ allowedAttempts: 3, }) ``` When a user exceeds the allowed number of verification attempts: * The OTP code is automatically deleted * Further verification attempts will return a 403 (Forbidden) status with "Too many attempts" message * The user will need to request a new OTP code to continue Example error response after exceeding attempts: ```json { "error": { "status": 403, "message": "Too many attempts" } } ``` <Callout type="warning"> When receiving a 403 status, prompt the user to request a new OTP code </Callout> # plugins: Polar URL: /docs/plugins/polar Source: https: Better Auth Plugin for Payment and Checkouts using Polar *** title: Polar description: Better Auth Plugin for Payment and Checkouts using Polar --------------------------------------------------------------------- [Polar](https: <Callout> This plugin is maintained by Polar team. For bugs, issues or feature requests, please visit the [Polar GitHub repo](https: </Callout> ## Features * Checkout Integration * Customer Portal * Automatic Customer creation on signup * Event Ingestion & Customer Meters for flexible Usage Based Billing * Handle Polar Webhooks securely with signature verification * Reference System to associate purchases with organizations ## Installation ```bash pnpm add better-auth @polar-sh/better-auth @polar-sh/sdk ``` ## Preparation Go to your Polar Organization Settings, and create an Organization Access Token. Add it to your environment. ```bash # .env POLAR_ACCESS_TOKEN=... ``` ### Configuring BetterAuth Server The Polar plugin comes with a handful additional plugins which adds functionality to your stack. * Checkout - Enables a seamless checkout integration * Portal - Makes it possible for your customers to manage their orders, subscriptions & granted benefits * Usage - Simple extension for listing customer meters & ingesting events for Usage Based Billing * Webhooks - Listen for relevant Polar webhooks ```typescript const polarClient = new Polar({ accessToken: process.env.POLAR_ACCESS_TOKEN, server: 'sandbox' }); const auth = betterAuth({ plugins: [ polar({ client: polarClient, createCustomerOnSignUp: true, use: [ checkout({ products: [ { productId: "123-456-789", slug: "pro" } ], successUrl: "/success?checkout_id={CHECKOUT_ID}", authenticatedUsersOnly: true }), portal(), usage(), webhooks({ secret: process.env.POLAR_WEBHOOK_SECRET, onCustomerStateChanged: (payload) => onOrderPaid: (payload) => ... onPayload: (payload) => }) ], }) ] }); ``` ### Configuring BetterAuth Client You will be using the BetterAuth Client to interact with the Polar functionalities. ```typescript export const authClient = createAuthClient({ plugins: [polarClient()], }); ``` ## Configuration Options ```typescript polar, checkout, portal, usage, webhooks, } from "@polar-sh/better-auth"; const polarClient = new Polar({ accessToken: process.env.POLAR_ACCESS_TOKEN, server: "sandbox", }); const auth = betterAuth({ plugins: [ polar({ client: polarClient, createCustomerOnSignUp: true, getCustomerCreateParams: ({ user }, request) => ({ metadata: { myCustomProperty: 123, }, }), use: [ ], }), ], }); ``` ### Required Options * `client`: Polar SDK client instance ### Optional Options * `createCustomerOnSignUp`: Automatically create a Polar customer when a user signs up * `getCustomerCreateParams`: Custom function to provide additional customer creation metadata ### Customers When `createCustomerOnSignUp` is enabled, a new Polar Customer is automatically created when a new User is added in the Better-Auth Database. All new customers are created with an associated `externalId`, which is the ID of your User in the Database. This allows us to skip any Polar to User mapping in your Database. ## Checkout Plugin To support checkouts in your app, simply pass the Checkout plugin to the use-property. ```typescript const auth = betterAuth({ plugins: [ polar({ ... use: [ checkout({ products: [ { productId: "123-456-789", slug: "pro" } ], successUrl: "/success?checkout_id={CHECKOUT_ID}", authenticatedUsersOnly: true }) ], }) ] }); ``` When checkouts are enabled, you're able to initialize Checkout Sessions using the checkout-method on the BetterAuth Client. This will redirect the user to the Product Checkout. ```typescript await authClient.checkout({ products: ["e651f46d-ac20-4f26-b769-ad088b123df2"], slug: "pro", }); ``` Checkouts will automatically carry the authenticated User as the customer to the checkout. Email-address will be "locked-in". If `authenticatedUsersOnly` is `false` - then it will be possible to trigger checkout sessions without any associated customer. ### Organization Support This plugin supports the Organization plugin. If you pass the organization ID to the Checkout referenceId, you will be able to keep track of purchases made from organization members. ```typescript const organizationId = (await authClient.organization.list())?.data?.[0]?.id, await authClient.checkout({ products: ["e651f46d-ac20-4f26-b769-ad088b123df2"], slug: 'pro', referenceId: organizationId }); ``` ## Portal Plugin A plugin which enables customer management of their purchases, orders and subscriptions. ```typescript const auth = betterAuth({ plugins: [ polar({ ... use: [ checkout(...), portal() ], }) ] }); ``` The portal-plugin gives the BetterAuth Client a set of customer management methods, scoped under `authClient.customer`. ### Customer Portal Management The following method will redirect the user to the Polar Customer Portal, where they can see orders, purchases, subscriptions, benefits, etc. ```typescript await authClient.customer.portal(); ``` ### Customer State The portal plugin also adds a convenient state-method for retrieving the general Customer State. ```typescript const { data: customerState } = await authClient.customer.state(); ``` The customer state object contains: * All the data about the customer. * The list of their active subscriptions * Note: This does not include subscriptions done by a parent organization. See the subscription list-method below for more information. * The list of their granted benefits. * The list of their active meters, with their current balance. Thus, with that single object, you have all the required information to check if you should provision access to your service or not. [You can learn more about the Polar Customer State in the Polar Docs](https: ### Benefits, Orders & Subscriptions The portal plugin adds 3 convenient methods for listing benefits, orders & subscriptions relevant to the authenticated user/customer. [All of these methods use the Polar CustomerPortal APIs](https: #### Benefits This method only lists granted benefits for the authenticated user/customer. ```typescript const { data: benefits } = await authClient.customer.benefits.list({ query: { page: 1, limit: 10, }, }); ``` #### Orders This method lists orders like purchases and subscription renewals for the authenticated user/customer. ```typescript const { data: orders } = await authClient.customer.orders.list({ query: { page: 1, limit: 10, productBillingType: "one_time", }, }); ``` #### Subscriptions This method lists the subscriptions associated with authenticated user/customer. ```typescript const { data: subscriptions } = await authClient.customer.subscriptions.list({ query: { page: 1, limit: 10, active: true, }, }); ``` **Important** - Organization Support This will **not** return subscriptions made by a parent organization to the authenticated user. However, you can pass a `referenceId` to this method. This will return all subscriptions associated with that referenceId instead of subscriptions associated with the user. So in order to figure out if a user should have access, pass the user's organization ID to see if there is an active subscription for that organization. ```typescript const organizationId = (await authClient.organization.list())?.data?.[0]?.id, const { data: subscriptions } = await authClient.customer.orders.list({ query: { page: 1, limit: 10, active: true, referenceId: organizationId }, }); const userShouldHaveAccess = subscriptions.some( sub => ) ``` ## Usage Plugin A simple plugin for Usage Based Billing. ```typescript const auth = betterAuth({ plugins: [ polar({ ... use: [ checkout(...), portal(), usage() ], }) ] }); ``` ### Event Ingestion Polar's Usage Based Billing builds entirely on event ingestion. Ingest events from your application, create Meters to represent that usage, and add metered prices to Products to charge for it. [Learn more about Usage Based Billing in the Polar Docs.](https: ```typescript const { data: ingested } = await authClient.usage.ingest({ event: "file-uploads", metadata: { uploadedFiles: 12, }, }); ``` The authenticated user is automatically associated with the ingested event. ### Customer Meters A simple method for listing the authenticated user's Usage Meters, or as we call them, Customer Meters. Customer Meter's contains all information about their consumtion on your defined meters. * Customer Information * Meter Information * Customer Meter Information * Consumed Units * Credited Units * Balance ```typescript const { data: customerMeters } = await authClient.usage.meters.list({ query: { page: 1, limit: 10, }, }); ``` ## Webhooks Plugin The Webhooks plugin can be used to capture incoming events from your Polar organization. ```typescript const auth = betterAuth({ plugins: [ polar({ ... use: [ webhooks({ secret: process.env.POLAR_WEBHOOK_SECRET, onCustomerStateChanged: (payload) => onOrderPaid: (payload) => ... onPayload: (payload) => }) ], }) ] }); ``` Configure a Webhook endpoint in your Polar Organization Settings page. Webhook endpoint is configured at /polar/webhooks. Add the secret to your environment. ```bash # .env POLAR_WEBHOOK_SECRET=... ``` The plugin supports handlers for all Polar webhook events: * `onPayload` - Catch-all handler for any incoming Webhook event * `onCheckoutCreated` - Triggered when a checkout is created * `onCheckoutUpdated` - Triggered when a checkout is updated * `onOrderCreated` - Triggered when an order is created * `onOrderPaid` - Triggered when an order is paid * `onOrderRefunded` - Triggered when an order is refunded * `onRefundCreated` - Triggered when a refund is created * `onRefundUpdated` - Triggered when a refund is updated * `onSubscriptionCreated` - Triggered when a subscription is created * `onSubscriptionUpdated` - Triggered when a subscription is updated * `onSubscriptionActive` - Triggered when a subscription becomes active * `onSubscriptionCanceled` - Triggered when a subscription is canceled * `onSubscriptionRevoked` - Triggered when a subscription is revoked * `onSubscriptionUncanceled` - Triggered when a subscription cancellation is reversed * `onProductCreated` - Triggered when a product is created * `onProductUpdated` - Triggered when a product is updated * `onOrganizationUpdated` - Triggered when an organization is updated * `onBenefitCreated` - Triggered when a benefit is created * `onBenefitUpdated` - Triggered when a benefit is updated * `onBenefitGrantCreated` - Triggered when a benefit grant is created * `onBenefitGrantUpdated` - Triggered when a benefit grant is updated * `onBenefitGrantRevoked` - Triggered when a benefit grant is revoked * `onCustomerCreated` - Triggered when a customer is created * `onCustomerUpdated` - Triggered when a customer is updated * `onCustomerDeleted` - Triggered when a customer is deleted * `onCustomerStateChanged` - Triggered when a customer is created # plugins: Sign In With Ethereum (SIWE) URL: /docs/plugins/siwe Source: https: Sign in with Ethereum plugin for Better Auth *** title: Sign In With Ethereum (SIWE) description: Sign in with Ethereum plugin for Better Auth --------------------------------------------------------- The Sign in with Ethereum (SIWE) plugin allows users to authenticate using their Ethereum wallets following the [ERC-4361 standard](https: ## Installation <Steps> <Step> ### Add the Server Plugin Add the SIWE plugin to your auth configuration: ```ts title="auth.ts" import { betterAuth } from "better-auth"; import { siwe } from "better-auth/plugins"; export const auth = betterAuth({ plugins: [ siwe({ domain: "example.com", emailDomainName: "example.com", anonymous: false, getNonce: async () => { return "your-secure-random-nonce"; }, verifyMessage: async (args) => { return true; }, ensLookup: async (args) => { return { name: "user.eth", avatar: "https: }; }, }), ], }); ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the Client Plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client"; import { siweClient } from "better-auth/client/plugins"; export const authClient = createAuthClient({ plugins: [siweClient()], }); ``` </Step> </Steps> ## Usage ### Generate a Nonce Before signing a SIWE message, you need to generate a nonce for the wallet address: ```ts title="generate-nonce.ts" const { data, error } = await authClient.siwe.nonce({ walletAddress: "0x1234567890abcdef1234567890abcdef12345678", chainId: 1, }); if (data) { console.log("Nonce:", data.nonce); } ``` ### Sign In with Ethereum After generating a nonce and creating a SIWE message, verify the signature to authenticate: ```ts title="sign-in-siwe.ts" const { data, error } = await authClient.siwe.verify({ message: "Your SIWE message string", signature: "0x...", walletAddress: "0x1234567890abcdef1234567890abcdef12345678", chainId: 1, email: "user@example.com", }); if (data) { console.log("Authentication successful:", data.user); } ``` ## Configuration Options ### Server Options The SIWE plugin accepts the following configuration options: * **domain**: The domain name of your application (required for SIWE message generation) * **emailDomainName**: The email domain name for creating user accounts when not using anonymous mode. Defaults to the domain from your base URL * **anonymous**: Whether to allow anonymous sign-ins without requiring an email. Default is `true` * **getNonce**: Function to generate a unique nonce for each sign-in attempt. You must implement this function to return a cryptographically secure random string. Must return a `Promise<string>` * **verifyMessage**: Function to verify the signed SIWE message. Receives message details and should return `Promise<boolean>` * **ensLookup**: Optional function to lookup ENS names and avatars for Ethereum addresses ### Client Options The SIWE client plugin doesn't require any configuration options, but you can pass them if needed for future extensibility: ```ts title="auth-client.ts" export const authClient = createAuthClient({ plugins: [ siweClient({ }), ], }); ``` ## Schema The SIWE plugin adds a `walletAddress` table to store user wallet associations: | Field | Type | Description | | --------- | ------- | ----------------------------------------- | | id | string | Primary key | | userId | string | Reference to user.id | | address | string | Ethereum wallet address | | chainId | number | Chain ID (e.g., 1 for Ethereum mainnet) | | isPrimary | boolean | Whether this is the user's primary wallet | | createdAt | date | Creation timestamp | ## Example Implementation Here's a complete example showing how to implement SIWE authentication: ```ts title="auth.ts" export const auth = betterAuth({ database: { }, plugins: [ siwe({ domain: "myapp.com", emailDomainName: "myapp.com", anonymous: false, getNonce: async () => { return generateRandomString(32); }, verifyMessage: async ({ message, signature, address }) => { try { const isValid = await verifyMessage({ address: address as `0x${string}`, message, signature: signature as `0x${string}`, }); return isValid; } catch (error) { console.error("SIWE verification failed:", error); return false; } }, ensLookup: async ({ walletAddress }) => { try { const client = createPublicClient({ chain: mainnet, transport: http(), }); const ensName = await client.getEnsName({ address: walletAddress as `0x${string}`, }); const ensAvatar = ensName ? await client.getEnsAvatar({ name: ensName, }) : null; return { name: ensName || walletAddress, avatar: ensAvatar || "", }; } catch { return { name: walletAddress, avatar: "", }; } }, }), ], }); ``` # plugins: Single Sign-On (SSO) URL: /docs/plugins/sso Source: https: Integrate Single Sign-On (SSO) with your application. *** title: Single Sign-On (SSO) description: Integrate Single Sign-On (SSO) with your application. ------------------------------------------------------------------ `OIDC` `OAuth2` `SSO` `SAML` Single Sign-On (SSO) allows users to authenticate with multiple applications using a single set of credentials. This plugin supports OpenID Connect (OIDC), OAuth2 providers, and SAML 2.0. ## Installation <Steps> <Step> ### Install the plugin ```bash npm install @better-auth/sso ``` </Step> <Step> ### Add Plugin to the server ```ts title="auth.ts" import { betterAuth } from "better-auth" import { sso } from "@better-auth/sso"; const auth = betterAuth({ plugins: [ sso() ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { ssoClient } from "@better-auth/sso/client" const authClient = createAuthClient({ plugins: [ ssoClient() ] }) ``` </Step> </Steps> ## Usage ### Register an OIDC Provider To register an OIDC provider, use the `registerSSOProvider` endpoint and provide the necessary configuration details for the provider. A redirect URL will be automatically generated using the provider ID. For instance, if the provider ID is `hydra`, the redirect URL would be `{baseURL}/api/auth/sso/callback/hydra`. Note that `/api/auth` may vary depending on your base path configuration. #### Example <Tabs items={["client", "server"]}> <Tab value="client"> ```ts title="register-oidc-provider.ts" import { authClient } from "@/lib/auth-client"; await authClient.sso.register({ providerId: "example-provider", issuer: "https: domain: "example.com", oidcConfig: { clientId: "client-id", clientSecret: "client-secret", authorizationEndpoint: "https: tokenEndpoint: "https: jwksEndpoint: "https: discoveryEndpoint: "https: scopes: ["openid", "email", "profile"], pkce: true, }, mapping: { id: "sub", email: "email", emailVerified: "email_verified", name: "name", image: "picture", }, }); ``` </Tab> <Tab value="server"> ```ts title="register-oidc-provider.ts" const { headers } = await signInWithTestUser(); await auth.api.registerSSOProvider({ body: { providerId: "example-provider", issuer: "https: domain: "example.com", oidcConfig: { clientId: "your-client-id", clientSecret: "your-client-secret", authorizationEndpoint: "https: tokenEndpoint: "https: jwksEndpoint: "https: discoveryEndpoint: "https: scopes: ["openid", "email", "profile"], pkce: true, }, mapping: { id: "sub", email: "email", emailVerified: "email_verified", name: "name", image: "picture", }, }, headers, }); ``` </Tab> </Tabs> ### Register a SAML Provider To register a SAML provider, use the `registerSSOProvider` endpoint with SAML configuration details. The provider will act as a Service Provider (SP) and integrate with your Identity Provider (IdP). <Tabs items={["client", "server"]}> <Tab value="client"> ```ts title="register-saml-provider.ts" import { authClient } from "@/lib/auth-client"; await authClient.sso.register({ providerId: "saml-provider", issuer: "https: domain: "example.com", samlConfig: { entryPoint: "https: cert: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----", callbackUrl: "https: audience: "https: wantAssertionsSigned: true, signatureAlgorithm: "sha256", digestAlgorithm: "sha256", identifierFormat: "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", idpMetadata: { metadata: "<!-- IdP Metadata XML -->", privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----", privateKeyPass: "your-private-key-password", isAssertionEncrypted: true, encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----", encPrivateKeyPass: "your-encryption-key-password" }, spMetadata: { metadata: "<!-- SP Metadata XML -->", binding: "post", privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----", privateKeyPass: "your-sp-private-key-password", isAssertionEncrypted: true, encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----", encPrivateKeyPass: "your-sp-encryption-key-password" } }, mapping: { id: "nameID", email: "email", name: "displayName", firstName: "givenName", lastName: "surname", extraFields: { department: "department", role: "role" } }, }); ``` </Tab> <Tab value="server"> ```ts title="register-saml-provider.ts" const { headers } = await signInWithTestUser(); await auth.api.registerSSOProvider({ body: { providerId: "saml-provider", issuer: "https: domain: "example.com", samlConfig: { entryPoint: "https: cert: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----", callbackUrl: "https: audience: "https: wantAssertionsSigned: true, signatureAlgorithm: "sha256", digestAlgorithm: "sha256", identifierFormat: "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", idpMetadata: { metadata: "<!-- IdP Metadata XML -->", privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----", privateKeyPass: "your-private-key-password", isAssertionEncrypted: true, encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----", encPrivateKeyPass: "your-encryption-key-password" }, spMetadata: { metadata: "<!-- SP Metadata XML -->", binding: "post", privateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----", privateKeyPass: "your-sp-private-key-password", isAssertionEncrypted: true, encPrivateKey: "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----", encPrivateKeyPass: "your-sp-encryption-key-password" } }, mapping: { id: "nameID", email: "email", name: "displayName", firstName: "givenName", lastName: "surname", extraFields: { department: "department", role: "role" } }, }, headers, }); ``` </Tab> </Tabs> ### Get Service Provider Metadata For SAML providers, you can retrieve the Service Provider metadata XML that needs to be configured in your Identity Provider: ```ts title="get-sp-metadata.ts" const response = await auth.api.spMetadata({ query: { providerId: "saml-provider", format: "xml" } }); const metadataXML = await response.text(); console.log(metadataXML); ``` ### Sign In with SSO To sign in with an SSO provider, you can call `signIn.sso` You can sign in using the email with domain matching: ```ts title="sign-in.ts" const res = await authClient.signIn.sso({ email: "user@example.com", callbackURL: "/dashboard", }); ``` or you can specify the domain: ```ts title="sign-in-domain.ts" const res = await authClient.signIn.sso({ domain: "example.com", callbackURL: "/dashboard", }); ``` You can also sign in using the organization slug if a provider is associated with an organization: ```ts title="sign-in-org.ts" const res = await authClient.signIn.sso({ organizationSlug: "example-org", callbackURL: "/dashboard", }); ``` Alternatively, you can sign in using the provider's ID: ```ts title="sign-in-provider-id.ts" const res = await authClient.signIn.sso({ providerId: "example-provider-id", callbackURL: "/dashboard", }); ``` To use the server API you can use `signInSSO` ```ts title="sign-in-org.ts" const res = await auth.api.signInSSO({ body: { organizationSlug: "example-org", callbackURL: "/dashboard", } }); ``` #### Full method <APIMethod path="/sign-in/sso" method="POST"> ```ts type signInSSO = { email?: string = "john@example.com" organizationSlug?: string = "example-org" providerId?: string = "example-provider" domain?: string = "example.com" callbackURL: string = "https: errorCallbackURL?: string = "https: newUserCallbackURL?: string = "https: scopes?: string[] = ["openid", "email", "profile", "offline_access"] requestSignUp?: boolean = true } ``` </APIMethod> When a user is authenticated, if the user does not exist, the user will be provisioned using the `provisionUser` function. If the organization provisioning is enabled and a provider is associated with an organization, the user will be added to the organization. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ sso({ provisionUser: async (user) => { }, organizationProvisioning: { disabled: false, defaultRole: "member", getRole: async (user) => { }, }, }), ], }); ``` ## Provisioning The SSO plugin provides powerful provisioning capabilities to automatically set up users and manage their organization memberships when they sign in through SSO providers. ### User Provisioning User provisioning allows you to run custom logic whenever a user signs in through an SSO provider. This is useful for: * Setting up user profiles with additional data from the SSO provider * Synchronizing user attributes with external systems * Creating user-specific resources * Logging SSO sign-ins * Updating user information from the SSO provider ```ts title="auth.ts" const auth = betterAuth({ plugins: [ sso({ provisionUser: async ({ user, userInfo, token, provider }) => { await updateUserProfile(user.id, { department: userInfo.attributes?.department, jobTitle: userInfo.attributes?.jobTitle, manager: userInfo.attributes?.manager, lastSSOLogin: new Date(), }); await createUserWorkspace(user.id); await syncUserWithCRM(user.id, userInfo); await auditLog.create({ userId: user.id, action: 'sso_signin', provider: provider.providerId, metadata: { email: userInfo.email, ssoProvider: provider.issuer, }, }); }, }), ], }); ``` The `provisionUser` function receives: * **user**: The user object from the database * **userInfo**: User information from the SSO provider (includes attributes, email, name, etc.) * **token**: OAuth2 tokens (for OIDC providers) - may be undefined for SAML * **provider**: The SSO provider configuration ### Organization Provisioning Organization provisioning automatically manages user memberships in organizations when SSO providers are linked to specific organizations. This is particularly useful for: * Enterprise SSO where each company/domain maps to an organization * Automatic role assignment based on SSO attributes * Managing team memberships through SSO #### Basic Organization Provisioning ```ts title="auth.ts" const auth = betterAuth({ plugins: [ sso({ organizationProvisioning: { disabled: false, defaultRole: "member", }, }), ], }); ``` #### Advanced Organization Provisioning with Custom Roles ```ts title="auth.ts" const auth = betterAuth({ plugins: [ sso({ organizationProvisioning: { disabled: false, defaultRole: "member", getRole: async ({ user, userInfo, provider }) => { const department = userInfo.attributes?.department; const jobTitle = userInfo.attributes?.jobTitle; if (jobTitle?.toLowerCase().includes('manager') || jobTitle?.toLowerCase().includes('director') || jobTitle?.toLowerCase().includes('vp')) { return "admin"; } if (department?.toLowerCase() === 'it') { return "admin"; } return "member"; }, }, }), ], }); ``` #### Linking SSO Providers to Organizations When registering an SSO provider, you can link it to a specific organization: ```ts title="register-org-provider.ts" await auth.api.registerSSOProvider({ body: { providerId: "acme-corp-saml", issuer: "https: domain: "acmecorp.com", organizationId: "org_acme_corp_id", samlConfig: { }, }, headers, }); ``` Now when users from `acmecorp.com` sign in through this provider, they'll automatically be added to the "Acme Corp" organization with the appropriate role. #### Multiple Organizations Example You can set up multiple SSO providers for different organizations: ```ts title="multi-org-setup.ts" await auth.api.registerSSOProvider({ body: { providerId: "acme-corp", issuer: "https: domain: "acmecorp.com", organizationId: "org_acme_id", samlConfig: { }, }, headers, }); await auth.api.registerSSOProvider({ body: { providerId: "techstart-google", issuer: "https: domain: "techstart.io", organizationId: "org_techstart_id", oidcConfig: { }, }, headers, }); ``` #### Organization Provisioning Flow 1. **User signs in** through an SSO provider linked to an organization 2. **User is authenticated** and either found or created in the database 3. **Organization membership is checked** - if the user isn't already a member of the linked organization 4. **Role is determined** using either the `defaultRole` or `getRole` function 5. **User is added** to the organization with the determined role 6. **User provisioning runs** (if configured) for additional setup ### Provisioning Best Practices #### 1. Idempotent Operations Make sure your provisioning functions can be safely run multiple times: ```ts provisionUser: async ({ user, userInfo }) => { const existingProfile = await getUserProfile(user.id); if (!existingProfile.ssoProvisioned) { await createUserResources(user.id); await markAsProvisioned(user.id); } await updateUserAttributes(user.id, userInfo.attributes); }, ``` #### 2. Error Handling Handle errors gracefully to avoid blocking user sign-in: ```ts provisionUser: async ({ user, userInfo }) => { try { await syncWithExternalSystem(user, userInfo); } catch (error) { console.error('Failed to sync user with external system:', error); await logProvisioningError(user.id, error); } }, ``` #### 3. Conditional Provisioning Only run certain provisioning steps when needed: ```ts organizationProvisioning: { disabled: false, getRole: async ({ user, userInfo, provider }) => { if (provider.providerId.includes('enterprise')) { return determineEnterpriseRole(userInfo); } return "member"; }, }, ``` ## SAML Configuration ### Service Provider Configuration When registering a SAML provider, you need to provide Service Provider (SP) metadata configuration: * **metadata**: XML metadata for the Service Provider * **binding**: The binding method, typically "post" or "redirect" * **privateKey**: Private key for signing (optional) * **privateKeyPass**: Password for the private key (if encrypted) * **isAssertionEncrypted**: Whether assertions should be encrypted * **encPrivateKey**: Private key for decryption (if encryption is enabled) * **encPrivateKeyPass**: Password for the encryption private key ### Identity Provider Configuration You also need to provide Identity Provider (IdP) configuration: * **metadata**: XML metadata from your Identity Provider * **privateKey**: Private key for the IdP communication (optional) * **privateKeyPass**: Password for the IdP private key (if encrypted) * **isAssertionEncrypted**: Whether assertions from IdP are encrypted * **encPrivateKey**: Private key for IdP assertion decryption * **encPrivateKeyPass**: Password for the IdP decryption key ### SAML Attribute Mapping Configure how SAML attributes map to user fields: ```ts mapping: { id: "nameID", email: "email", name: "displayName", firstName: "givenName", lastName: "surname", extraFields: { department: "department", role: "jobTitle", phone: "telephoneNumber" } } ``` ### SAML Endpoints The plugin automatically creates the following SAML endpoints: * **SP Metadata**: `/api/auth/sso/saml2/sp/metadata?providerId={providerId}` * **SAML Callback**: `/api/auth/sso/saml2/callback/{providerId}` ## Schema The plugin requires additional fields in the `ssoProvider` table to store the provider's configuration. <DatabaseTable fields={[ { name: "id", type: "string", description: "A database identifier", isRequired: true, isPrimaryKey: true, }, { name: "issuer", type: "string", description: "The issuer identifier", isRequired: true }, { name: "domain", type: "string", description: "The domain of the provider", isRequired: true }, { name: "oidcConfig", type: "string", description: "The OIDC configuration (JSON string)", isRequired: false }, { name: "samlConfig", type: "string", description: "The SAML configuration (JSON string)", isRequired: false }, { name: "userId", type: "string", description: "The user ID", isRequired: true, references: { model: "user", field: "id" } }, { name: "providerId", type: "string", description: "The provider ID. Used to identify a provider and to generate a redirect URL.", isRequired: true, isUnique: true }, { name: "organizationId", type: "string", description: "The organization Id. If provider is linked to an organization.", isRequired: false }, ]} /> ## Options ### Server **provisionUser**: A custom function to provision a user when they sign in with an SSO provider. **organizationProvisioning**: Options for provisioning users to an organization. **defaultOverrideUserInfo**: Override user info with the provider info by default. **disableImplicitSignUp**: Disable implicit sign up for new users. **trustEmailVerified**: Trust the email verified flag from the provider. <TypeTable type={{ provisionUser: { description: "A custom function to provision a user when they sign in with an SSO provider.", type: "function", }, organizationProvisioning: { description: "Options for provisioning users to an organization.", type: "object", properties: { disabled: { description: "Disable organization provisioning.", type: "boolean", default: false, }, defaultRole: { description: "The default role for new users.", type: "string", enum: ["member", "admin"], default: "member", }, getRole: { description: "A custom function to determine the role for new users.", type: "function", }, }, }, defaultOverrideUserInfo: { description: "Override user info with the provider info by default.", type: "boolean", default: false, }, disableImplicitSignUp: { description: "Disable implicit sign up for new users. When set to true, sign-in needs to be called with requestSignUp as true to create new users.", type: "boolean", default: false, }, providersLimit: { description: "Configure the maximum number of SSO providers a user can register. Set to 0 to disable SSO provider registration.", type: "number | function", default: 10, }, }} /> # plugins: Stripe URL: /docs/plugins/stripe Source: https: Stripe plugin for Better Auth to manage subscriptions and payments. *** title: Stripe description: Stripe plugin for Better Auth to manage subscriptions and payments. -------------------------------------------------------------------------------- The Stripe plugin integrates Stripe's payment and subscription functionality with Better Auth. Since payment and authentication are often tightly coupled, this plugin simplifies the integration of Stripe into your application, handling customer creation, subscription management, and webhook processing. ## Features * Create Stripe Customers automatically when users sign up * Manage subscription plans and pricing * Process subscription lifecycle events (creation, updates, cancellations) * Handle Stripe webhooks securely with signature verification * Expose subscription data to your application * Support for trial periods and subscription upgrades * Flexible reference system to associate subscriptions with users or organizations * Team subscription support with seats management ## Installation <Steps> <Step> ### Install the plugin First, install the plugin: <Tabs items={}> <Tab value="npm"> ```bash npm install @better-auth/stripe ``` </Tab> <Tab value="pnpm"> ```bash pnpm add @better-auth/stripe ``` </Tab> <Tab value="yarn"> ```bash yarn add @better-auth/stripe ``` </Tab> <Tab value="bun"> ```bash bun add @better-auth/stripe ``` </Tab> </Tabs> <Callout> If you're using a separate client and server setup, make sure to install the plugin in both parts of your project. </Callout> </Step> <Step> ### Install the Stripe SDK Next, install the Stripe SDK on your server: <Tabs items={}> <Tab value="npm"> ```bash npm install stripe@^18.0.0 ``` </Tab> <Tab value="pnpm"> ```bash pnpm add stripe@^18.0.0 ``` </Tab> <Tab value="yarn"> ```bash yarn add stripe@^18.0.0 ``` </Tab> <Tab value="bun"> ```bash bun add stripe@^18.0.0 ``` </Tab> </Tabs> </Step> <Step> ### Add the plugin to your auth config ```ts title="auth.ts" import { betterAuth } from "better-auth" import { stripe } from "@better-auth/stripe" import Stripe from "stripe" const stripeClient = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2025-02-24.acacia", }) export const auth = betterAuth({ plugins: [ stripe({ stripeClient, stripeWebhookSecret: process.env.STRIPE_WEBHOOK_SECRET!, createCustomerOnSignUp: true, }) ] }) ``` </Step> <Step> ### Add the client plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { stripeClient } from "@better-auth/stripe/client" export const client = createAuthClient({ plugins: [ stripeClient({ subscription: true }) ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the tables manually. </Step> <Step> ### Set up Stripe webhooks Create a webhook endpoint in your Stripe dashboard pointing to: ``` https: ``` `/api/auth` is the default path for the auth server. Make sure to select at least these events: * `checkout.session.completed` * `customer.subscription.updated` * `customer.subscription.deleted` Save the webhook signing secret provided by Stripe and add it to your environment variables as `STRIPE_WEBHOOK_SECRET`. </Step> </Steps> ## Usage ### Customer Management You can use this plugin solely for customer management without enabling subscriptions. This is useful if you just want to link Stripe customers to your users. By default, when a user signs up, a Stripe customer is automatically created if you set `createCustomerOnSignUp: true`. This customer is linked to the user in your database. You can customize the customer creation process: ```ts title="auth.ts" stripe({ createCustomerOnSignUp: true, onCustomerCreate: async ({ customer, stripeCustomer, user }, request) => { console.log(`Customer ${customer.id} created for user ${user.id}`); }, getCustomerCreateParams: async ({ user, session }, request) => { return { metadata: { referralSource: user.metadata?.referralSource } }; } }) ``` ### Subscription Management #### Defining Plans You can define your subscription plans either statically or dynamically: ```ts title="auth.ts" subscription: { enabled: true, plans: [ { name: "basic", priceId: "price_1234567890", annualDiscountPriceId: "price_1234567890", limits: { projects: 5, storage: 10 } }, { name: "pro", priceId: "price_0987654321", limits: { projects: 20, storage: 50 }, freeTrial: { days: 14, } } ] } subscription: { enabled: true, plans: async () => { const plans = await db.query("SELECT * FROM plans"); return plans.map(plan => ({ name: plan.name, priceId: plan.stripe_price_id, limits: JSON.parse(plan.limits) })); } } ``` see [plan configuration](#plan-configuration) for more. #### Creating a Subscription To create a subscription, use the `subscription.upgrade` method: <APIMethod path="/subscription/upgrade" method="POST" requireSession> ```ts type upgradeSubscription = { plan: string = "pro" annual?: boolean = true referenceId?: string = "123" subscriptionId?: string = "sub_123" metadata?: Record<string, any> seats?: number = 1 successUrl: string cancelUrl: string returnUrl?: string disableRedirect: boolean = true } ``` </APIMethod> **Simple Example:** ```ts title="client.ts" await client.subscription.upgrade({ plan: "pro", successUrl: "/dashboard", cancelUrl: "/pricing", annual: true, referenceId: "org_123" seats: 5 }); ``` This will create a Checkout Session and redirect the user to the Stripe Checkout page. <Callout type="warn"> If the user already has an active subscription, you *must* provide the `subscriptionId` parameter. Otherwise, the user will be subscribed to (and pay for) both plans. </Callout> > **Important:** The `successUrl` parameter will be internally modified to handle race conditions between checkout completion and webhook processing. The plugin creates an intermediate redirect that ensures subscription status is properly updated before redirecting to your success page. ```ts const { error } = await client.subscription.upgrade({ plan: "pro", successUrl: "/dashboard", cancelUrl: "/pricing", }); if(error) { alert(error.message); } ``` <Callout type="warn"> For each reference ID (user or organization), only one active or trialing subscription is supported at a time. The plugin doesn't currently support multiple concurrent active subscriptions for the same reference ID. </Callout> #### Switching Plans To switch a subscription to a different plan, use the `subscription.upgrade` method: ```ts title="client.ts" await client.subscription.upgrade({ plan: "pro", successUrl: "/dashboard", cancelUrl: "/pricing", subscriptionId: "sub_123", }); ``` This ensures that the user only pays for the new plan, and not both. #### Listing Active Subscriptions To get the user's active subscriptions: <APIMethod path="/subscription/list" method="GET" requireSession resultVariable="subscriptions"> ```ts type listActiveSubscriptions = { referenceId?: string = '123' } const activeSubscription = subscriptions.find( sub => sub.status === "active" || sub.status === "trialing" ); const projectLimit = subscriptions?.limits?.projects || 0; ``` </APIMethod> #### Canceling a Subscription To cancel a subscription: <APIMethod path="/subscription/cancel" method="POST" requireSession> ```ts type cancelSubscription = { referenceId?: string = 'org_123' subscriptionId?: string = 'sub_123' returnUrl: string = '/account' } ``` </APIMethod> This will redirect the user to the Stripe Billing Portal where they can cancel their subscription. #### Restoring a Canceled Subscription If a user changes their mind after canceling a subscription (but before the subscription period ends), you can restore the subscription: <APIMethod path="/subscription/restore" method="POST" requireSession> ```ts type restoreSubscription = { referenceId?: string = '123' subscriptionId?: string = 'sub_123' } ``` </APIMethod> This will reactivate a subscription that was previously set to cancel at the end of the billing period (`cancelAtPeriodEnd: true`). The subscription will continue to renew automatically. > **Note:** This only works for subscriptions that are still active but marked to cancel at the end of the period. It cannot restore subscriptions that have already ended. #### Creating Billing Portal Sessions To create a [Stripe billing portal session](https: <APIMethod path="/subscription/billing-portal" method="POST" requireSession> ```ts type createBillingPortal = { referenceId?: string = "123" returnUrl?: string } ``` </APIMethod> This endpoint creates a Stripe billing portal session and returns a URL in the response as `data.url`. You can redirect users to this URL to allow them to manage their subscription, payment methods, and billing history. ### Reference System By default, subscriptions are associated with the user ID. However, you can use a custom reference ID to associate subscriptions with other entities, such as organizations: ```ts title="client.ts" await client.subscription.upgrade({ plan: "pro", referenceId: "org_123456", successUrl: "/dashboard", cancelUrl: "/pricing", seats: 5 }); const { data: subscriptions } = await client.subscription.list({ query: { referenceId: "org_123456" } }); ``` #### Team Subscriptions with Seats For team or organization plans, you can specify the number of seats: ```ts await client.subscription.upgrade({ plan: "team", referenceId: "org_123456", seats: 10, successUrl: "/org/billing/success", cancelUrl: "/org/billing" }); ``` The `seats` parameter is passed to Stripe as the quantity for the subscription item. You can use this value in your application logic to limit the number of members in a team or organization. To authorize reference IDs, implement the `authorizeReference` function: ```ts title="auth.ts" subscription: { authorizeReference: async ({ user, session, referenceId, action }) => { if (action === "upgrade-subscription" || action === "cancel-subscription" || action === "restore-subscription") { const org = await db.member.findFirst({ where: { organizationId: referenceId, userId: user.id } }); return org?.role === "owner" } return true; } } ``` ### Webhook Handling The plugin automatically handles common webhook events: * `checkout.session.completed`: Updates subscription status after checkout * `customer.subscription.updated`: Updates subscription details when changed * `customer.subscription.deleted`: Marks subscription as canceled You can also handle custom events: ```ts title="auth.ts" stripe({ onEvent: async (event) => { switch (event.type) { case "invoice.paid": break; case "payment_intent.succeeded": break; } } }) ``` ### Subscription Lifecycle Hooks You can hook into various subscription lifecycle events: ```ts title="auth.ts" subscription: { onSubscriptionComplete: async ({ event, subscription, stripeSubscription, plan }) => { await sendWelcomeEmail(subscription.referenceId, plan.name); }, onSubscriptionUpdate: async ({ event, subscription }) => { console.log(`Subscription ${subscription.id} updated`); }, onSubscriptionCancel: async ({ event, subscription, stripeSubscription, cancellationDetails }) => { await sendCancellationEmail(subscription.referenceId); }, onSubscriptionDeleted: async ({ event, subscription, stripeSubscription }) => { console.log(`Subscription ${subscription.id} deleted`); } } ``` ### Trial Periods You can configure trial periods for your plans: ```ts title="auth.ts" { name: "pro", priceId: "price_0987654321", freeTrial: { days: 14, onTrialStart: async (subscription) => { await sendTrialStartEmail(subscription.referenceId); }, onTrialEnd: async ({ subscription, user }, request) => { await sendTrialEndEmail(user.email); }, onTrialExpired: async (subscription) => { await sendTrialExpiredEmail(subscription.referenceId); } } } ``` ## Schema The Stripe plugin adds the following tables to your database: ### User Table Name: `user` <DatabaseTable fields={[ { name: "stripeCustomerId", type: "string", description: "The Stripe customer ID", isOptional: true }, ]} /> ### Subscription Table Name: `subscription` <DatabaseTable fields={[ { name: "id", type: "string", description: "Unique identifier for each subscription", isPrimaryKey: true }, { name: "plan", type: "string", description: "The name of the subscription plan" }, { name: "referenceId", type: "string", description: "The ID this subscription is associated with (user ID by default)", isUnique: true }, { name: "stripeCustomerId", type: "string", description: "The Stripe customer ID", isOptional: true }, { name: "stripeSubscriptionId", type: "string", description: "The Stripe subscription ID", isOptional: true }, { name: "status", type: "string", description: "The status of the subscription (active, canceled, etc.)", defaultValue: "incomplete" }, { name: "periodStart", type: "Date", description: "Start date of the current billing period", isOptional: true }, { name: "periodEnd", type: "Date", description: "End date of the current billing period", isOptional: true }, { name: "cancelAtPeriodEnd", type: "boolean", description: "Whether the subscription will be canceled at the end of the period", defaultValue: false, isOptional: true }, { name: "seats", type: "number", description: "Number of seats for team plans", isOptional: true }, { name: "trialStart", type: "Date", description: "Start date of the trial period", isOptional: true }, { name: "trialEnd", type: "Date", description: "End date of the trial period", isOptional: true } ]} /> ### Customizing the Schema To change the schema table names or fields, you can pass a `schema` option to the Stripe plugin: ```ts title="auth.ts" stripe({ schema: { subscription: { modelName: "stripeSubscriptions", fields: { plan: "planName" } } } }) ``` ## Options ### Main Options **stripeClient**: `Stripe` - The Stripe client instance. Required. **stripeWebhookSecret**: `string` - The webhook signing secret from Stripe. Required. **createCustomerOnSignUp**: `boolean` - Whether to automatically create a Stripe customer when a user signs up. Default: `false`. **onCustomerCreate**: `(data: { customer: Customer, stripeCustomer: Stripe.Customer, user: User }, request?: Request) => Promise<void>` - A function called after a customer is created. **getCustomerCreateParams**: `(data: { user: User, session: Session }, request?: Request) => Promise<{}>` - A function to customize the Stripe customer creation parameters. **onEvent**: `(event: Stripe.Event) => Promise<void>` - A function called for any Stripe webhook event. ### Subscription Options **enabled**: `boolean` - Whether to enable subscription functionality. Required. **plans**: `Plan[] | (() => Promise<Plan[]>)` - An array of subscription plans or a function that returns plans. Required if subscriptions are enabled. **requireEmailVerification**: `boolean` - Whether to require email verification before allowing subscription upgrades. Default: `false`. **authorizeReference**: `(data: { user: User, session: Session, referenceId: string, action: "upgrade-subscription" | "list-subscription" | "cancel-subscription" | "restore-subscription"}, request?: Request) => Promise<boolean>` - A function to authorize reference IDs. ### Plan Configuration Each plan can have the following properties: **name**: `string` - The name of the plan. Required. **priceId**: `string` - The Stripe price ID. Required unless using `lookupKey`. **lookupKey**: `string` - The Stripe price lookup key. Alternative to `priceId`. **annualDiscountPriceId**: `string` - A price ID for annual billing. **annualDiscountLookupKey**: `string` - The Stripe price lookup key for annual billing. Alternative to `annualDiscountPriceId`. **limits**: `Record<string, number>` - Limits associated with the plan (e.g., `{ projects: 10, storage: 5 }`). **group**: `string` - A group name for the plan, useful for categorizing plans. **freeTrial**: Object containing trial configuration: * **days**: `number` - Number of trial days. * **onTrialStart**: `(subscription: Subscription) => Promise<void>` - Called when a trial starts. * **onTrialEnd**: `(data: { subscription: Subscription, user: User }, request?: Request) => Promise<void>` - Called when a trial ends. * **onTrialExpired**: `(subscription: Subscription) => Promise<void>` - Called when a trial expires without conversion. ## Advanced Usage ### Using with Organizations The Stripe plugin works well with the organization plugin. You can associate subscriptions with organizations instead of individual users: ```ts title="client.ts" const { data: activeOrg } = client.useActiveOrganization(); await client.subscription.upgrade({ plan: "team", referenceId: activeOrg.id, seats: 10, annual: true, successUrl: "/org/billing/success", cancelUrl: "/org/billing" }); ``` Make sure to implement the `authorizeReference` function to verify that the user has permission to manage subscriptions for the organization: ```ts title="auth.ts" authorizeReference: async ({ user, referenceId, action }) => { const member = await db.members.findFirst({ where: { userId: user.id, organizationId: referenceId } }); return member?.role === "owner" || member?.role === "admin"; } ``` ### Custom Checkout Session Parameters You can customize the Stripe Checkout session with additional parameters: ```ts title="auth.ts" getCheckoutSessionParams: async ({ user, session, plan, subscription }, request) => { return { params: { allow_promotion_codes: true, tax_id_collection: { enabled: true }, billing_address_collection: "required", custom_text: { submit: { message: "We'll start your subscription right away" } }, metadata: { planType: "business", referralCode: user.metadata?.referralCode } }, options: { idempotencyKey: `sub_${user.id}_${plan.name}_${Date.now()}` } }; } ``` ### Tax Collection To collect tax IDs from the customer, set `tax_id_collection` to true: ```ts title="auth.ts" subscription: { getCheckoutSessionParams: async ({ user, session, plan, subscription }, request) => { return { params: { tax_id_collection: { enabled: true } } }; } } ``` ### Automatic Tax Calculation To enable automatic tax calculation using the customer’s location, set `automatic_tax` to true. Enabling this parameter causes Checkout to collect any billing address information necessary for tax calculation. You need to have tax registration setup and configured in the Stripe dashboard first for this to work. ```ts title="auth.ts" subscription: { getCheckoutSessionParams: async ({ user, session, plan, subscription }, request) => { return { params: { automatic_tax: { enabled: true } } }; } } ``` ## Troubleshooting ### Webhook Issues If webhooks aren't being processed correctly: 1. Check that your webhook URL is correctly configured in the Stripe dashboard 2. Verify that the webhook signing secret is correct 3. Ensure you've selected all the necessary events in the Stripe dashboard 4. Check your server logs for any errors during webhook processing ### Subscription Status Issues If subscription statuses aren't updating correctly: 1. Make sure the webhook events are being received and processed 2. Check that the `stripeCustomerId` and `stripeSubscriptionId` fields are correctly populated 3. Verify that the reference IDs match between your application and Stripe ### Testing Webhooks Locally For local development, you can use the Stripe CLI to forward webhooks to your local environment: ```bash stripe listen --forward-to localhost:3000/api/auth/stripe/webhook ``` This will provide you with a webhook signing secret that you can use in your local environment. # plugins: Username URL: /docs/plugins/username Source: https: Username plugin *** title: Username description: Username plugin ---------------------------- The username plugin wraps the email and password authenticator and adds username support. This allows users to sign in and sign up with their username instead of their email. ## Installation <Steps> <Step> ### Add Plugin to the server ```ts title="auth.ts" import { betterAuth } from "better-auth" import { username } from "better-auth/plugins" export const auth = betterAuth({ plugins: [ username() ] }) ``` </Step> <Step> ### Migrate the database Run the migration or generate the schema to add the necessary fields and tables to the database. <Tabs items={["migrate", "generate"]}> <Tab value="migrate"> ```bash npx @better-auth/cli migrate ``` </Tab> <Tab value="generate"> ```bash npx @better-auth/cli generate ``` </Tab> </Tabs> See the [Schema](#schema) section to add the fields manually. </Step> <Step> ### Add the client plugin ```ts title="auth-client.ts" import { createAuthClient } from "better-auth/client" import { usernameClient } from "better-auth/client/plugins" export const authClient = createAuthClient({ plugins: [ usernameClient() ] }) ``` </Step> </Steps> ## Usage ### Sign up To sign up a user with username, you can use the existing `signUp.email` function provided by the client. The `signUp` function should take a new `username` property in the object. ```ts title="auth-client.ts" const data = await authClient.signUp.email({ email: "email@domain.com", name: "Test User", password: "password1234", username: "test" }) ``` ### Sign in To sign in a user with username, you can use the `signIn.username` function provided by the client. The `signIn` function takes an object with the following properties: * `username`: The username of the user. * `password`: The password of the user. ```ts title="auth-client.ts" const data = await authClient.signIn.username({ username: "test", password: "password1234", }) ``` ### Update username To update the username of a user, you can use the `updateUser` function provided by the client. ```ts title="auth-client.ts" const data = await authClient.updateUser({ username: "new-username" }) ``` ### Check if username is available To check if a username is available, you can use the `isUsernameAvailable` function provided by the client. ```ts title="auth-client.ts" const response = await authClient.isUsernameAvailable({ username: "new-username" }); if(response.data?.available) { console.log("Username is available"); } else { console.log("Username is not available"); } ``` ## Schema The plugin requires 2 fields to be added to the user table: <DatabaseTable fields={[ { name: "username", type: "string", description: "The username of the user", isUnique: true }, { name: "displayUsername", type: "string", description: "Non normalized username of the user", isUnique: true }, ]} /> ## Options **Min Username Length** The minimum length of the username. Default is `3`. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ username({ minUsernameLength: 5 }) ] }) ``` **Max Username Length** The maximum length of the username. Default is `30`. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ username({ maxUsernameLength: 100 }) ] }) ``` **Username Validator** A function that validates the username. The function should return false if the username is invalid. By default, the username should only contain alphanumeric characters, underscores, and dots. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ username({ usernameValidator: (username) => { if (username === "admin") { return false } return true } }) ] }) ``` ### Username Normalization A function that normalizes the username, or `false` if you want to disable normalization. By default, usernames are case-insensitive, so "TestUser" and "testuser", for example, are considered the same username. The `username` field will contain the normalized (lower case) username, while `displayUsername` will contain the original `username`. ```ts title="auth.ts" const auth = betterAuth({ plugins: [ username({ usernameNormalization: (username) => { return username.toLowerCase() .replaceAll("0", "o") .replaceAll("3", "e") .replaceAll("4", "a"); } }) ] }) ``` # reference: Contributing to BetterAuth URL: /docs/reference/contributing Source: https: A concise guide to contributing to BetterAuth *** title: Contributing to BetterAuth description: A concise guide to contributing to BetterAuth ---------------------------------------------------------- Thank you for your interest in contributing to Better Auth! This guide is a concise guide to contributing to Better Auth. ## Getting Started Before diving in, here are a few important resources: * Take a look at our existing <Link href="https: * Join our community discussions in <Link href="https: ## Development Setup To get started with development: <Callout type="warn"> Make sure you have <Link href="https: installed, preferably on LTS. </Callout> <Steps> <Step> ### 1. Fork the repository Visit [https: Click the "Fork" button in the top right. </Step> <Step> ### 2. Clone your fork ```bash # Replace YOUR-USERNAME with your GitHub username git clone https: cd better-auth ``` </Step> <Step> ### 3. Install dependencies Make sure you have <Link href="https: ```bash pnpm install ``` </Step> <Step> ### 4. Prepare ENV files Copy the example env file to create your new `.env` file. ```bash cp -n ./docs/.env.example ./docs/.env ``` </Step> </Steps> ## Making changes Once you have an idea of what you want to contribute, you can start making changes. Here are some steps to get started: <Steps> <Step> ### 1. Create a new branch ```bash # Make sure you're on main git checkout main # Pull latest changes git pull upstream main # Create and switch to a new branch git checkout -b feature/your-feature-name ``` </Step> <Step> ### 2. Start development server Start the development server: ```bash pnpm dev ``` To start the docs server: ```bash pnpm -F docs dev ``` </Step> <Step> ### 3. Make Your Changes * Make your changes to the codebase. * Write tests if needed. (Read more about testing <Link href="/docs/reference/contribute/testing">here</Link>) * Update documentation. (Read more about documenting <Link href="/docs/reference/contribute/documenting">here</Link>) </Step> </Steps> ### Issues and Bug Fixes * Check our [GitHub issues](https: * When reporting bugs, include steps to reproduce and expected behavior * Comment on issues you'd like to work on to avoid duplicate efforts ### Framework Integrations We welcome contributions to support more frameworks: * Focus on framework-agnostic solutions where possible * Keep integrations minimal and maintainable * All integrations currently live in the main package ### Plugin Development * For core plugins: Open an issue first to discuss your idea * For community plugins: Feel free to develop independently * Follow our plugin architecture guidelines ### Documentation * Fix typos and errors * Add examples and clarify existing content * Ensure documentation is up to date with code changes ## Testing We use Vitest for testing. Place test files next to the source files they test: ```ts describe("Feature", () => { it("should work as expected", async () => { const { client } = getTestInstance(); expect(result).toBeDefined(); }); }); ``` ### Testing Best Practices * Write clear commit messages * Update documentation to reflect your changes * Add tests for new features * Follow our coding standards * Keep pull requests focused on a single change ## Need Help? Don't hesitate to ask for help! You can: * Open an <Link href="https: * Join our <Link href="https: * Reach out to project maintainers Thank you for contributing to Better Auth! # reference: FAQ URL: /docs/reference/faq Source: https: Frequently asked questions about Better Auth. *** title: FAQ description: Frequently asked questions about Better Auth. ---------------------------------------------------------- This page contains frequently asked questions, common issues, and other helpful information about Better Auth. <Accordions> <Accordion title="Auth client not working"> When encountering `createAuthClient` related errors, make sure to have the correct import path as it varies based on environment. If you're using the auth client on react front-end, you'll need to import it from `/react`: ```ts title="component.ts" import { createAuthClient } from "better-auth/react"; ``` Where as if you're using the auth client in Next.js middleware, server-actions, server-components or anything server-related, you'll likely need to import it from `/client`: ```ts title="server.ts" import { createAuthClient } from "better-auth/client"; ``` </Accordion> <Accordion title="getSession not working"> If you try to call `authClient.getSession` on a server environment (e.g, a Next.js server component), it doesn't work since it can't access the cookies. You can use the `auth.api.getSession` instead and pass the request headers to it. ```tsx title="server.tsx" import { auth } from "./auth"; import { headers } from "next/headers"; const session = await auth.api.getSession({ headers: await headers() }) ``` if you need to use the auth client on the server for different purposes, you still can pass the request headers to it: ```tsx title="server.tsx" import { authClient } from "./auth-client"; import { headers } from "next/headers"; const session = await authClient.getSession({ fetchOptions:{ headers: await headers() } }) ``` </Accordion> <Accordion title="Adding custom fields to the users table"> Better Auth provides a type-safe way to extend the user and session schemas, take a look at our docs on <Link href="/docs/concepts/database#extending-core-schema">extending core schema</Link>. </Accordion> <Accordion title="Difference between getSession and useSession"> Both `useSession` and `getSession` instances are used fundamentally different based on the situation. `useSession` is a hook, meaning it can trigger re-renders whenever session data changes. If you have UI you need to change based on user or session data, you can use this hook. <Callout type="warn"> For performance reasons, do not use this hook on your `layout.tsx` file. We recommend using RSC and use your server auth instance to get the session data via `auth.api.getSession`. </Callout> `getSession` returns a promise containing data and error. For all other situations where you shouldn't use `useSession`, is when you should be using `getSession`. <Callout type="info"> `getSession` is available on both server and client auth instances. Not just the latter. </Callout> </Accordion> <Accordion title="Common TypeScript Errors"> If you're facing typescript errors, make sure your tsconfig has `strict` set to `true`: ```json title="tsconfig.json" { "compilerOptions": { "strict": true, } } ``` if you can't set strict to true, you can enable strictNullChecks: ```json title="tsconfig.json" { "compilerOptions": { "strictNullChecks": true, } } ``` You can learn more in our <Link href="/docs/concepts/typescript#typescript-config">TypeScript docs</Link>. </Accordion> <Accordion title="Can I remove `name`, `image`, or `email` fields from the user table?"> At this time, you can't remove the `name`, `image`, or `email` fields from the user table. We do plan to have more customizability in the future in this regard, but for now, you can't remove these fields. </Accordion> </Accordions> # reference: Options URL: /docs/reference/options Source: https: Better Auth configuration options reference. *** title: Options description: Better Auth configuration options reference. --------------------------------------------------------- List of all the available options for configuring Better Auth. See [Better Auth Options](https: ## `appName` The name of the application. ```ts export const auth = betterAuth({ appName: "My App", }) ``` ## `baseURL` Base URL for Better Auth. This is typically the root URL where your application server is hosted. Note: If you include a path in the baseURL, it will take precedence over the default path. ```ts export const auth = betterAuth({ baseURL: "https: }) ``` If not explicitly set, the system will check for the environment variable `process.env.BETTER_AUTH_URL` ## `basePath` Base path for Better Auth. This is typically the path where the Better Auth routes are mounted. It will be overridden if there is a path component within `baseURL`. ```ts export const auth = betterAuth({ basePath: "/api/auth", }) ``` Default: `/api/auth` ## `trustedOrigins` List of trusted origins. You can provide a static array of origins, a function that returns origins dynamically, or use wildcard patterns to match multiple domains. ### Static Origins You can provide a static array of origins: ```ts export const auth = betterAuth({ trustedOrigins: ["http: }) ``` ### Dynamic Origins You can provide a function that returns origins dynamically: ```ts export const auth = betterAuth({ trustedOrigins: async (request: Request) => { return ["https: } }) ``` ### Wildcard Support You can use wildcard patterns in trusted origins: ```ts export const auth = betterAuth({ trustedOrigins: [ "*.example.com", "https: "http: ] }) ``` ## `secret` The secret used for encryption, signing, and hashing. ```ts export const auth = betterAuth({ secret: "your-secret-key", }) ``` By default, Better Auth will look for the following environment variables: * `process.env.BETTER_AUTH_SECRET` * `process.env.AUTH_SECRET` If none of these environment variables are set, it will default to `"better-auth-secret-123456789"`. In production, if it's not set, it will throw an error. You can generate a good secret using the following command: ```bash openssl rand -base64 32 ``` ## `database` Database configuration for Better Auth. ```ts export const auth = betterAuth({ database: { dialect: "postgres", type: "postgres", casing: "camel" }, }) ``` Better Auth supports various database configurations including [PostgreSQL](/docs/adapters/postgresql), [MySQL](/docs/adapters/mysql), and [SQLite](/docs/adapters/sqlite). Read more about databases [here](/docs/concepts/database). ## `secondaryStorage` Secondary storage configuration used to store session and rate limit data. ```ts export const auth = betterAuth({ secondaryStorage: { }, }) ``` Read more about secondary storage [here](/docs/concepts/database#secondary-storage). ## `emailVerification` Email verification configuration. ```ts export const auth = betterAuth({ emailVerification: { sendVerificationEmail: async ({ user, url, token }) => { }, sendOnSignUp: true, autoSignInAfterVerification: true, expiresIn: 3600 }, }) ``` * `sendVerificationEmail`: Function to send verification email * `sendOnSignUp`: Send verification email automatically after sign up (default: `false`) * `sendOnSignIn`: Send verification email automatically on sign in when the user's email is not verified (default: `false`) * `autoSignInAfterVerification`: Auto sign in the user after they verify their email * `expiresIn`: Number of seconds the verification token is valid for (default: `3600` seconds) ## `emailAndPassword` Email and password authentication configuration. ```ts export const auth = betterAuth({ emailAndPassword: { enabled: true, disableSignUp: false, requireEmailVerification: true, minPasswordLength: 8, maxPasswordLength: 128, autoSignIn: true, sendResetPassword: async ({ user, url, token }) => { }, resetPasswordTokenExpiresIn: 3600, password: { hash: async (password) => { return hashedPassword; }, verify: async ({ hash, password }) => { return isValid; } } }, }) ``` * `enabled`: Enable email and password authentication (default: `false`) * `disableSignUp`: Disable email and password sign up (default: `false`) * `requireEmailVerification`: Require email verification before a session can be created * `minPasswordLength`: Minimum password length (default: `8`) * `maxPasswordLength`: Maximum password length (default: `128`) * `autoSignIn`: Automatically sign in the user after sign up * `sendResetPassword`: Function to send reset password email * `resetPasswordTokenExpiresIn`: Number of seconds the reset password token is valid for (default: `3600` seconds) * `password`: Custom password hashing and verification functions ## `socialProviders` Configure social login providers. ```ts export const auth = betterAuth({ socialProviders: { google: { clientId: "your-client-id", clientSecret: "your-client-secret", redirectUri: "https: }, github: { clientId: "your-client-id", clientSecret: "your-client-secret", redirectUri: "https: } }, }) ``` ## `plugins` List of Better Auth plugins. ```ts export const auth = betterAuth({ plugins: [ emailOTP({ sendVerificationOTP: async ({ email, otp, type }) => { } }) ], }) ``` ## `user` User configuration options. ```ts export const auth = betterAuth({ user: { modelName: "users", fields: { email: "emailAddress", name: "fullName" }, additionalFields: { customField: { type: "string", } }, changeEmail: { enabled: true, sendChangeEmailVerification: async ({ user, newEmail, url, token }) => { } }, deleteUser: { enabled: true, sendDeleteAccountVerification: async ({ user, url, token }) => { }, beforeDelete: async (user) => { }, afterDelete: async (user) => { } } }, }) ``` * `modelName`: The model name for the user (default: `"user"`) * `fields`: Map fields to different column names * `additionalFields`: Additional fields for the user table * `changeEmail`: Configuration for changing email * `deleteUser`: Configuration for user deletion ## `session` Session configuration options. ```ts export const auth = betterAuth({ session: { modelName: "sessions", fields: { userId: "user_id" }, expiresIn: 604800, updateAge: 86400, disableSessionRefresh: true, additionalFields: { customField: { type: "string", } }, storeSessionInDatabase: true, preserveSessionInDatabase: false, cookieCache: { enabled: true, maxAge: 300 } }, }) ``` * `modelName`: The model name for the session (default: `"session"`) * `fields`: Map fields to different column names * `expiresIn`: Expiration time for the session token in seconds (default: `604800` - 7 days) * `updateAge`: How often the session should be refreshed in seconds (default: `86400` - 1 day) * `additionalFields`: Additional fields for the session table * `storeSessionInDatabase`: Store session in database when secondary storage is provided (default: `false`) * `preserveSessionInDatabase`: Preserve session records in database when deleted from secondary storage (default: `false`) * `cookieCache`: Enable caching session in cookie ## `account` Account configuration options. ```ts export const auth = betterAuth({ account: { modelName: "accounts", fields: { userId: "user_id" }, encryptOAuthTokens: true, accountLinking: { enabled: true, trustedProviders: ["google", "github", "email-password"], allowDifferentEmails: false } }, }) ``` * `modelName`: The model name for the account * `fields`: Map fields to different column names ### `encryptOAuthTokens` Encrypt OAuth tokens before storing them in the database. Default: `false`. ### `updateAccountOnSignIn` If enabled (true), the user account data (accessToken, idToken, refreshToken, etc.) will be updated on sign in with the latest data from the provider. ### `accountLinking` Configuration for account linking. * `enabled`: Enable account linking (default: `false`) * `trustedProviders`: List of trusted providers * `allowDifferentEmails`: Allow users to link accounts with different email addresses * `allowUnlinkingAll`: Allow users to unlink all accounts ## `verification` Verification configuration options. ```ts export const auth = betterAuth({ verification: { modelName: "verifications", fields: { userId: "user_id" }, disableCleanup: false }, }) ``` * `modelName`: The model name for the verification table * `fields`: Map fields to different column names * `disableCleanup`: Disable cleaning up expired values when a verification value is fetched ## `rateLimit` Rate limiting configuration. ```ts export const auth = betterAuth({ rateLimit: { enabled: true, window: 10, max: 100, customRules: { "/example/path": { window: 10, max: 100 } }, storage: "memory", modelName: "rateLimit" } }) ``` * `enabled`: Enable rate limiting (defaults: `true` in production, `false` in development) * `window`: Time window to use for rate limiting. The value should be in seconds. (default: `10`) * `max`: The default maximum number of requests allowed within the window. (default: `100`) * `customRules`: Custom rate limit rules to apply to specific paths. * `storage`: Storage configuration. If you passed a secondary storage, rate limiting will be stored in the secondary storage. (options: `"memory", "database", "secondary-storage"`, default: `"memory"`) * `modelName`: The name of the table to use for rate limiting if database is used as storage. (default: `"rateLimit"`) ## `advanced` Advanced configuration options. ```ts export const auth = betterAuth({ advanced: { ipAddress: { ipAddressHeaders: ["x-client-ip", "x-forwarded-for"], disableIpTracking: false }, useSecureCookies: true, disableCSRFCheck: false, crossSubDomainCookies: { enabled: true, additionalCookies: ["custom_cookie"], domain: "example.com" }, cookies: { session_token: { name: "custom_session_token", attributes: { httpOnly: true, secure: true } } }, defaultCookieAttributes: { httpOnly: true, secure: true }, cookiePrefix: "myapp", database: { useNumberId: false, generateId: (((options: { model: LiteralUnion<Models, string>; size?: number; }) => { return "my-super-unique-id"; })) | false, defaultFindManyLimit: 100, } }, }) ``` * `ipAddress`: IP address configuration for rate limiting and session tracking * `useSecureCookies`: Use secure cookies (default: `false`) * `disableCSRFCheck`: Disable trusted origins check (⚠️ security risk) * `crossSubDomainCookies`: Configure cookies to be shared across subdomains * `cookies`: Customize cookie names and attributes * `defaultCookieAttributes`: Default attributes for all cookies * `cookiePrefix`: Prefix for cookies * `generateId`: Function to generate a unique ID for a model ## `logger` Logger configuration for Better Auth. ```ts export const auth = betterAuth({ logger: { disabled: false, level: "error", log: (level, message, ...args) => { console.log(`[${level}] ${message}`, ...args); } } }) ``` The logger configuration allows you to customize how Better Auth handles logging. It supports the following options: * `disabled`: Disable all logging when set to `true` (default: `false`) * `level`: Set the minimum log level to display. Available levels are: * `"info"`: Show all logs * `"warn"`: Show warnings and errors * `"error"`: Show only errors * `"debug"`: Show all logs including debug information * `log`: Custom logging function that receives: * `level`: The log level (`"info"`, `"warn"`, `"error"`, or `"debug"`) * `message`: The log message * `...args`: Additional arguments passed to the logger Example with custom logging: ```ts export const auth = betterAuth({ logger: { level: "info", log: (level, message, ...args) => { myLoggingService.log({ level, message, metadata: args, timestamp: new Date().toISOString() }); } } }) ``` ## `databaseHooks` Database lifecycle hooks for core operations. ```ts export const auth = betterAuth({ databaseHooks: { user: { create: { before: async (user) => { return { data: { ...user, customField: "value" } }; }, after: async (user) => { } }, update: { before: async (userData) => { return { data: { ...userData, updatedAt: new Date() } }; }, after: async (user) => { } } }, session: { }, account: { }, verification: { } }, }) ``` ## `onAPIError` API error handling configuration. ```ts export const auth = betterAuth({ onAPIError: { throw: true, onError: (error, ctx) => { console.error("Auth error:", error); }, errorURL: "/auth/error" }, }) ``` * `throw`: Throw an error on API error (default: `false`) * `onError`: Custom error handler * `errorURL`: URL to redirect to on error (default: `/api/auth/error`) ## `hooks` Request lifecycle hooks. ```ts export const auth = betterAuth({ hooks: { before: createAuthMiddleware(async (ctx) => { console.log("Request path:", ctx.path); }), after: createAuthMiddleware(async (ctx) => { console.log("Response:", ctx.context.returned); }) }, }) ``` For more details and examples, see the [Hooks documentation](/docs/concepts/hooks). ## `disabledPaths` Disable specific auth paths. ```ts export const auth = betterAuth({ disabledPaths: ["/sign-up/email", "/sign-in/email"], }) ``` # reference: Resources URL: /docs/reference/resources Source: https: A curated collection of resources to help you learn and master Better Auth. *** title: Resources description: A curated collection of resources to help you learn and master Better Auth. ---------------------------------------------------------------------------------------- A curated collection of resources to help you learn and master Better Auth. From blog posts to video tutorials, find everything you need to get started. ## Video tutorials <Resource resources={ [ { title: "The State of Authentication", description: "<strong>Theo(t3.gg)</strong> explores the current landscape of authentication, discussing trends, challenges, and where the industry is heading.", href: "https: tags: ["trends", "showcase", "review"], }, { title: "Last Authentication You Will Ever Need", description: "A comprehensive tutorial demonstrating why Better Auth could be the final authentication solution you'll need for your projects.", href: "https: tags: ["implementation", "showcase"], }, { title: "This Might Be My New Favourite Auth Library", description: "<strong>developedbyed</strong> explores the features and capabilities of Better Auth, explaining why it stands out among authentication libraries.", href: "https: tags: ["review", "showcase"], }, { title: "Best authentication framework for next.js", description: "A detailed comparison of authentication frameworks for Next.js, highlighting why Better Auth might be your best choice.", href: "https: tags: ["nextjs", "comparison"], }, { title: "Better-Auth: A First Look", description: "An introductory overview and demonstration of Better Auth's core features and capabilities.", href: "https: tags: ["implementation", "showcase"], }, { title: "Stripe was never so easy (with better auth)", description: "A tutorial on how to integrate Stripe with Better Auth.", href: "https: tags: [ "implementation"], }, { title: "Nextjs 15 Authentication Made EASY with Better Auth", description: "A practical guide showing how to seamlessly integrate Better Auth with Next.js 15 for robust authentication.", href: "https: tags: ["nextjs", "implementation", "tutorial"], }, { title: "Better Auth: Headless Authentication for Your TanStack Start App", description: "<strong>Jack</strong> demonstrates how to implement headless authentication in your TanStack Start application using Better Auth, providing a modern approach to auth.", href: "https: tags: ["tanstack" , "implementation"], }, { title: "Goodbye Clerk, Hello Better Auth – Full Migration Guide!", description: "A comprehensive guide showing how to migrate your authentication from Clerk to Better Auth, with step-by-step instructions and best practices.", href: "https: tags: ["migration", "clerk", "tutorial"], }, ] } /> ## Blog posts <Resource resources={ [ { title: "Better Auth with Hono, Bun, TypeScript, React and Vite", description: "You'll learn how to implement authentication with Better Auth in a client - server architecture, where the frontend is separate from the backend.", href: "https: tags: ["typescript", "react", "bun", "vite"], }, { title: "Polar.sh + BetterAuth for Organizations", description: "Polar.sh is a platform for building payment integrations. This article will show you how to use Better Auth to authenticate your users.", href: "https: tags: ["organizations", "integration", "payments"], }, { title: "Authenticating users in Astro with Better Auth", description: "Step by step guide on how to authenticate users in Astro with Better Auth.", href: "https: tags: ["astro", "integration", "tutorial"], }, { title: "Building Multi-Tenant Apps With Better-Auth and ZenStack", description: "Learn how to build multi-tenant apps with Better-Auth and ZenStack.", href: "https: tags: ["multi-tenant", "zenstack", "architecture"], }, ] } /> # reference: Security URL: /docs/reference/security Source: https: Better Auth security features. *** title: Security description: Better Auth security features. ------------------------------------------- This page contains information about security features of Better Auth. ## Password Hashing Better Auth uses the `scrypt` algorithm to hash passwords by default. This algorithm is designed to be memory-hard and CPU-intensive, making it resistant to brute-force attacks. You can customize the password hashing function by setting the `password` option in the configuration. This option should include a `hash` function to hash passwords and a `verify` function to verify them. ## Session Management ### Session Expiration Better Auth uses secure session management to protect user data. Sessions are stored in the database or a secondary storage, if configured, to prevent unauthorized access. By default, sessions expire after 7 days, but you can customize this value in the configuration. Additionally, each time a session is used, if it reaches the `updateAge` threshold, the expiration date is extended, which by default is set to 1 day. ### Session Revocation Better Auth allows you to revoke sessions to enhance security. When a session is revoked, the user is logged out and can no longer access the application. A logged in user can also revoke their own sessions to log out from different devices or browsers. See the [session management](/docs/concepts/session-management) for more details. ## CSRF Protection Better Auth ensures CSRF protection by validating the Origin header in requests. This check confirms that requests originate from the application or a trusted source. If a request comes from an untrusted origin, it is blocked to prevent potential CSRF attacks. By default, the origin matching the base URL is trusted, but you can set a list of trusted origins in the trustedOrigins configuration option. ## OAuth State and PKCE To secure OAuth flows, Better Auth stores the OAuth state and PKCE (Proof Key for Code Exchange) in the database. The state helps prevent CSRF attacks, while PKCE protects against code injection threats. Once the OAuth process completes, these values are removed from the database. ## Cookies Better Auth assigns secure cookies by default when the base URL uses `https`. These secure cookies are encrypted and only sent over secure connections, adding an extra layer of protection. They are also set with the `sameSite` attribute to `lax` by default to prevent cross-site request forgery attacks. And the `httpOnly` attribute is enabled to prevent client-side JavaScript from accessing the cookie. For Cross-Subdomain Cookies, you can set the `crossSubDomainCookies` option in the configuration. This option allows cookies to be shared across subdomains, enabling seamless authentication across multiple subdomains. ### Customizing Cookies You can customize cookie names to minimize the risk of fingerprinting attacks and set specific cookie options as needed for additional control. For more information, refer to the [cookie options](/docs/concepts/cookies). Plugins can also set custom cookie options to align with specific security needs. If you're using Better Auth in non-browser environments, plugins offer ways to manage cookies securely in those contexts as well. ## Rate Limiting Better Auth includes built-in rate limiting to safeguard against brute-force attacks. Rate limits are applied across all routes by default, with specific routes subject to stricter limits based on potential risk. ## IP Address Headers Better Auth uses client IP addresses for rate limiting and security monitoring. By default, it reads the IP address from the standard `X-Forwarded-For` header. However, you can configure a specific trusted header to ensure accurate IP address detection and prevent IP spoofing attacks. You can configure the IP address header in your Better Auth configuration: ```typescript { advanced: { ipAddress: { ipAddressHeaders: ['cf-connecting-ip'] } } } ``` This ensures that Better Auth only accepts IP addresses from your trusted proxy's header, making it more difficult for attackers to bypass rate limiting or other IP-based security measures by spoofing headers. > **Important**: When setting a custom IP address header, ensure that your proxy or load balancer is properly configured to set this header, and that it cannot be set by end users directly. ## Trusted Origins Trusted origins prevent CSRF attacks and block open redirects. You can set a list of trusted origins in the `trustedOrigins` configuration option. Requests from origins not on this list are automatically blocked. ### Basic Usage The most basic usage is to specify exact origins: ```typescript { trustedOrigins: [ "https: "https: "http: ] } ``` ### Wildcard Domains Better Auth supports wildcard patterns in trusted origins, which allows you to trust multiple subdomains with a single entry: ```typescript { trustedOrigins: [ "*.example.com", "https: "http: ] } ``` #### Protocol-specific wildcards When using a wildcard pattern with a protocol prefix (like `https: * The protocol must match exactly * The domain can have any subdomain in place of the `*` * Requests using a different protocol will be rejected, even if the domain matches #### Protocol-agnostic wildcards When using a wildcard pattern without a protocol prefix (like `*.example.com`): * Any protocol (http, https, etc.) will be accepted * The domain must match the wildcard pattern ### Custom Schemes Trusted origins also support custom schemes for mobile apps and browser extensions: ```typescript { trustedOrigins: [ "myapp: "chrome-extension: ] } ``` ## Reporting Vulnerabilities If you discover a security vulnerability in Better Auth, please report it to us at [security@better-auth.com](mailto:security@better-auth.com). We address all reports promptly, and credits will be given for validated discoveries.

// --- Ruta: src/routes/+page.svelte ---
<!-- Fichero: src/routes/+page.svelte --> <script lang="ts"> import RecipeCard from '$lib/components/recipes/RecipeCard.svelte'; import EditQuantitiesDialog from '$lib/components/recipes/EditQuantitiesDialog.svelte'; import DeleteRecipeDialog from '$lib/components/recipes/DeleteRecipeDialog.svelte'; import { Button } from '$lib/components/ui/button/index.js'; import { Input } from '$lib/components/ui/input/index.js'; import Plus from 'lucide-svelte/icons/plus'; import SlidersHorizontal from 'lucide-svelte/icons/sliders-horizontal'; const RECIPES_PER_PAGE = 50; let { data } = $props(); type Recipe = (typeof data.recipes)[number]; let recipes = $state(data.recipes); let searchQuery = $state(''); let isLoading = $state(false); let hasMore = $state(data.hasMore); let sentinel: HTMLDivElement | undefined = $state(); let controller: AbortController; let selectedRecipe = $state<Recipe | null>(null); let isEditDialogOpen = $state(false); let isDeleteDialogOpen = $state(false); const isAdmin = $derived(!!data.user?.isAdmin); async function fetchRecipes(isNewSearch = false) { if (isLoading && !isNewSearch) return; isLoading = true; const offset = isNewSearch ? 0 : recipes.length; if (isNewSearch) { controller?.abort(); controller = new AbortController(); } const signal = controller?.signal; const url = `/api/recipes?q=${encodeURIComponent(searchQuery)}&limit=${RECIPES_PER_PAGE}&offset=${offset}`; try { const response = await fetch(url, { signal }); const result = await response.json(); if (signal?.aborted) return; if (isNewSearch) { recipes = result.recipes; } else { recipes.push(...result.recipes); } hasMore = result.hasMore; } catch (error) { if (error instanceof DOMException && error.name === 'AbortError') { return; } console.error('Error al cargar recetas:', error); } finally { if (!signal?.aborted) { isLoading = false; } } } $effect(() => { searchQuery; const handler = setTimeout(() => { fetchRecipes(true); }, 300); return () => clearTimeout(handler); }); $effect(() => { if (!sentinel) return; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting && hasMore && !isLoading) { fetchRecipes(); } }); observer.observe(sentinel); return () => observer.disconnect(); }); function handleOpenEditDialog(recipe: Recipe) { selectedRecipe = recipe; isEditDialogOpen = true; } function handleOpenDeleteDialog(recipe: Recipe) { selectedRecipe = recipe; isDeleteDialogOpen = true; } </script> <div class="container mx-auto p-4 md:px-24 mt-16 md:mt-0"> <header class="flex items-center justify-between gap-2 mb-8"> <div class="relative flex-grow"> <Input bind:value={searchQuery} placeholder="Buscar por receta o producto..." /> </div> <Button href="/recetas/busqueda-avanzada" variant="ghost" size="icon" aria-label="Búsqueda avanzada"> <SlidersHorizontal class="h-4 w-4" /> </Button> <Button href="/recetas/nueva"> <Plus class="h-4 w-4" /> </Button> </header> <main class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"> {#each recipes as recipe, i (recipe.id)} <div> <RecipeCard {recipe} {isAdmin} onEditQuantities={() => handleOpenEditDialog(recipe)} onDelete={() => handleOpenDeleteDialog(recipe)} /> </div> {/each} </main> {#if hasMore} <div bind:this={sentinel} class="h-10 flex justify-center items-center text-muted-foreground"> {#if isLoading} <span>Cargando...</span> {/if} </div> {/if} {#if recipes.length === 0 && !isLoading} <div class="col-span-full text-center py-16 text-muted-foreground"> <p class="text-lg font-medium">No se encontraron recetas.</p> <p>Prueba con otro término de búsqueda o añade una nueva receta.</p> </div> {/if} </div> <EditQuantitiesDialog recipe={selectedRecipe} bind:open={isEditDialogOpen} onOpenChange={(isOpen: boolean) => (isEditDialogOpen = isOpen)} /> <DeleteRecipeDialog recipe={selectedRecipe} bind:open={isDeleteDialogOpen} onOpenChange={(isOpen: boolean) => (isDeleteDialogOpen = isOpen)} />

// --- Ruta: src/routes/+page.server.ts ---
const RECIPES_PER_PAGE = 50; export const load: PageServerLoad = async () => { const recipesPlusOne = await recipeService.findPaginated(null, RECIPES_PER_PAGE + 1, 0); const hasMore = recipesPlusOne.length > RECIPES_PER_PAGE; const recipes = recipesPlusOne.slice(0, RECIPES_PER_PAGE); return { recipes, hasMore }; }; export const actions: Actions = { logout: async ({ cookies }) => { cookies.delete('session', { path: '/' }); throw redirect(303, '/'); }, delete: async ({ request }) => { const data = await request.formData(); const id = data.get('id'); if (typeof id !== 'string' || !id) { return fail(400, { message: 'ID de receta no válido' }); } try { await recipeService.deleteById(id); return { status: 200, message: 'Receta eliminada correctamente' }; } catch (error) { console.error('Error al eliminar la receta:', error); return fail(500, { message: 'No se pudo eliminar la receta. Por favor, inténtelo de nuevo.' }); } } };

// --- Ruta: src/routes/+layout.svelte ---
<!-- Fichero: src/routes/+layout.svelte --> <script lang="ts"> import { browser } from '$app/environment'; import { themeStore } from '$lib/stores/theme.svelte'; import '../app.css'; import ThemeToggle from '$lib/components/ThemeToggle.svelte'; import type { Snippet } from 'svelte'; import { Utensils, LogOut, LogIn, Menu, ChefHat, NotebookPen } from 'lucide-svelte'; import * as Popover from '$lib/components/ui/popover'; import { Button, buttonVariants } from '$lib/components/ui/button'; import { cn } from '$lib/utils'; import { Toaster, toast } from 'svelte-sonner'; import { page } from '$app/state'; import { fade } from 'svelte/transition'; import { invalidateAll, goto } from '$app/navigation'; import { authClient } from '$lib/auth-client'; import type { LayoutData } from './$types'; let { children, data }: { children: Snippet; data: LayoutData } = $props(); let isMenuOpen = $state(false); $effect(() => { if (!browser) return; const currentTheme = themeStore.value; localStorage.setItem('theme', currentTheme); const applyTheme = () => { const themeToApply = currentTheme === 'system' ? window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light' : currentTheme; document.documentElement.classList.toggle('dark', themeToApply === 'dark'); }; applyTheme(); const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)'); mediaQuery.addEventListener('change', applyTheme); return () => mediaQuery.removeEventListener('change', applyTheme); }); async function handleLogout() { const toastId = toast.loading('Cerrando sesión...'); try { await authClient.signOut(); await invalidateAll(); toast.success('Sesión cerrada correctamente.', { id: toastId }); isMenuOpen = false; } catch (error) { let description = 'Ocurrió un error inesperado.'; if (error instanceof Error) { description = error.message; } toast.error('Error al cerrar sesión', { id: toastId, description }); } } </script> <div class="min-h-screen bg-background font-sans text-foreground antialiased"> <div class="fixed top-4 left-4 z-50"> <Popover.Root bind:open={isMenuOpen}> <Popover.Trigger> {#snippet child({ props })} <button {...props} class={cn(buttonVariants({ variant: 'outline', size: 'icon' }))} aria-label="Abrir menú" > <Menu class="h-[1.2rem] w-[1.2rem]" /> </button> {/snippet} </Popover.Trigger> <Popover.Content class="w-auto p-2" onOpenAutoFocus={(e) => { e.preventDefault(); }} > <div class="flex flex-col items-center gap-2"> <!-- Acción: Inicio --> <Button variant="ghost" size="icon" title="Ir a Inicio" aria-label="Ir a la página de inicio" onclick={() => { goto('/'); isMenuOpen = false; }} > <ChefHat class="h-[1.2rem] w-[1.2rem]" /> </Button> {#if data.user} <!-- Acción: Diario (para todos los usuarios logueados) --> <Button variant="ghost" size="icon" title="Ir al Diario" aria-label="Ir al Diario de Consumo" onclick={() => { goto('/diario'); isMenuOpen = false; }} > <NotebookPen class="h-[1.2rem] w-[1.2rem]" /> </Button> {#if data.user.role === 'admin'} <!-- Para el botón de Administrar Productos --> <Button variant="ghost" size="icon" title="Administrar productos" aria-label="Administrar productos" onclick={() => { goto('/admin/products'); isMenuOpen = false; }} > <Utensils class="h-[1.2rem] w-[1.2rem]" /> </Button> {/if} <!-- Acción: Cerrar Sesión --> <Button onclick={handleLogout} variant="ghost" size="icon" title="Cerrar sesión" aria-label="Cerrar sesión" > <LogOut class="h-[1.2rem] w-[1.2rem]" /> </Button> {:else} <!-- Acción: Iniciar Sesión --> <Button variant="ghost" size="icon" aria-label="Iniciar sesión" title="Iniciar sesión" onclick={() => { goto('/login'); isMenuOpen = false; }} > <LogIn class="h-[1.2rem] w-[1.2rem]" /> </Button> {/if} </div> </Popover.Content> </Popover.Root> </div> <div class="fixed bottom-4 left-4 z-50"> <ThemeToggle /> </div> {#key page.url.pathname} <div transition:fade={{ duration: 200 }}> {@render children()} </div> {/key} <Toaster richColors closeButton /> </div>

// --- Ruta: src/routes/+layout.server.ts ---
export const load: LayoutServerLoad = async ({ locals }) => { return { user: locals.session?.user, session: locals.session?.session }; };

// --- Ruta: src/lib/utils.ts ---
type DiaryEntryLike = { date: Date | string; calories: number; protein: number; fat: number; carbs: number; }; export type AggregatedNutrients = { total: { calories: number; protein: number; fat: number; carbs: number; }; average: { calories: number; protein: number; fat: number; carbs: number; }; daysWithEntries: number; }; export function calculateAggregatedNutrients( entries: DiaryEntryLike[], timezone: string ): AggregatedNutrients { const totals = entries.reduce( (acc, entry) => { acc.calories += entry.calories; acc.protein += entry.protein; acc.fat += entry.fat; acc.carbs += entry.carbs; return acc; }, { calories: 0, protein: 0, fat: 0, carbs: 0 } ); const uniqueDays = new Set( entries.map((e) => formatInTimeZone(new Date(e.date), timezone, 'yyyy-MM-dd')) ); const daysWithEntries = uniqueDays.size > 0 ? uniqueDays.size : 1; const average = { calories: totals.calories / daysWithEntries, protein: totals.protein / daysWithEntries, fat: totals.fat / daysWithEntries, carbs: totals.carbs / daysWithEntries }; return { total: totals, average, daysWithEntries }; } export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)); } export function normalizeText(text: string): string { return text .toLowerCase() .normalize('NFD') .replace(/[\u0300-\u036f]/g, ''); } export type WithoutChild<T> = T extends { child?: any } ? Omit<T, 'child'> : T; export type WithoutChildren<T> = T extends { children?: any } ? Omit<T, 'children'> : T; export type WithoutChildrenOrChild<T> = WithoutChildren<WithoutChild<T>>; export type WithElementRef<T, U extends HTMLElement = HTMLElement> = T & { ref?: U | null };

// --- Ruta: src/lib/recipeCalculator.ts ---
export type CalculableProduct = { quantity: number; calories?: number | null; protein?: number | null; fat?: number | null; carbs?: number | null; }; export type NutritionalInfo = { totalCalories: number; totalProtein: number; totalFat: number; totalCarbs: number; }; export function calculateNutritionalInfo(products: CalculableProduct[]): NutritionalInfo { const totals: NutritionalInfo = { totalCalories: 0, totalProtein: 0, totalFat: 0, totalCarbs: 0 }; for (const product of products) { const factor = product.quantity / 100; totals.totalCalories += (product.calories || 0) * factor; totals.totalProtein += (product.protein || 0) * factor; totals.totalFat += (product.fat || 0) * factor; totals.totalCarbs += (product.carbs || 0) * factor; } return { totalCalories: Math.round(totals.totalCalories * 100) / 100, totalProtein: Math.round(totals.totalProtein * 100) / 100, totalFat: Math.round(totals.totalFat * 100) / 100, totalCarbs: Math.round(totals.totalCarbs * 100) / 100 }; }

// --- Ruta: src/lib/auth-client.ts ---
export const authClient = createAuthClient();

// --- Ruta: prisma/migrations/migration_lock.toml ---
# Please do not edit this file manually # It should be added in your version-control system (e.g., Git) provider = "postgresql"

// --- Ruta: src/routes/signup/+page.svelte ---
<!-- Ruta: src/routes/signup/+page.svelte --> <script lang="ts"> import { authClient } from '$lib/auth-client'; import { goto } from '$app/navigation'; import * as Card from '$lib/components/ui/card'; import { Button } from '$lib/components/ui/button'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import { toast } from 'svelte-sonner'; let name = ''; let email = ''; let password = ''; let loading = false; let errorMessage: string | null = null; async function handleSignup() { loading = true; errorMessage = null; await authClient.signUp.email( { name, email, password }, { onSuccess: () => { toast.success('¡Cuenta creada con éxito!', { description: 'Te hemos redirigido a la página principal.' }); goto('/', { invalidateAll: true }); }, onError: (ctx) => { errorMessage = ctx.error.message; toast.error('Error en el registro', { description: ctx.error.message }); }, onSettled: () => { loading = false; } } ); } </script> <div class="flex min-h-screen items-center justify-center bg-muted/40"> <Card.Root class="w-full max-w-sm"> <Card.Header class="space-y-1 text-center"> <Card.Title class="text-2xl font-bold mt-4">Crear Cuenta</Card.Title> <Card.Description>Introduce tus datos para registrarte</Card.Description> </Card.Header> <Card.Content> <form on:submit|preventDefault={handleSignup} class="space-y-4"> <div class="space-y-2"> <Label for="name">Nombre</Label> <Input bind:value={name} id="name" name="name" type="text" required /> </div> <div class="space-y-2"> <Label for="email">Email</Label> <Input bind:value={email} id="email" name="email" type="email" required /> </div> <div class="space-y-2"> <Label for="password">Contraseña</Label> <Input bind:value={password} id="password" name="password" type="password" required minlength={8} /> </div> {#if errorMessage} <p class="text-sm font-medium text-destructive">{errorMessage}</p> {/if} <Button type="submit" class="w-full" disabled={loading}> {loading ? 'Creando cuenta...' : 'Crear cuenta'} </Button> <div class="mt-4 text-center text-sm"> ¿Ya tienes una cuenta? <a href="/login" class="underline"> Inicia sesión </a> </div> </form> </Card.Content> </Card.Root> </div>

// --- Ruta: src/routes/login/+page.svelte ---
<!-- Ruta: src/routes/login/+page.svelte --> <script lang="ts"> import { authClient } from '$lib/auth-client'; import { goto } from '$app/navigation'; import { page } from '$app/stores'; import * as Card from '$lib/components/ui/card'; import { Button } from '$lib/components/ui/button'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import { toast } from 'svelte-sonner'; let email = ''; let password = ''; let loading = false; let errorMessage: string | null = null; async function handleLogin() { loading = true; errorMessage = null; await authClient.signIn.email( { email, password }, { onSuccess: () => { toast.success('¡Bienvenido de nuevo!'); const redirectTo = $page.url.searchParams.get('redirectTo'); goto(redirectTo || '/', { invalidateAll: true }); }, onError: (ctx) => { errorMessage = ctx.error.message; toast.error('Error al iniciar sesión', { description: ctx.error.message }); }, onSettled: () => { loading = false; } } ); } </script> <div class="flex min-h-screen items-center justify-center bg-muted/40"> <Card.Root class="w-full max-w-sm"> <Card.Header class="space-y-1 text-center"> <Card.Title class="text-2xl font-bold mt-4">Login</Card.Title> <Card.Description>Introduce tus credenciales para acceder</Card.Description> </Card.Header> <Card.Content> <!-- El formulario ahora llama a una función del lado del cliente en lugar de usar una form action. Esto nos da más control sobre la UI. --> <form on:submit|preventDefault={handleLogin} class="space-y-4"> <div class="space-y-2"> <Label for="email">Email</Label> <Input bind:value={email} id="email" name="email" type="email" required /> </div> <div class="space-y-2"> <Label for="password">Contraseña</Label> <Input bind:value={password} id="password" name="password" type="password" required /> </div> {#if errorMessage} <p class="text-sm font-medium text-destructive">{errorMessage}</p> {/if} <Button type="submit" class="w-full" disabled={loading}> {loading ? 'Entrando...' : 'Entrar'} </Button> </form> </Card.Content> </Card.Root> </div>

// --- Ruta: src/routes/diario/+page.svelte ---
<!-- Ruta: src/routes/diario/+page.svelte --> <script lang="ts"> import type { PageData } from './$types'; import { RangeCalendar } from '$lib/components/ui/range-calendar/index.js'; import * as Popover from '$lib/components/ui/popover/index.js'; import { Calendar as CalendarIcon } from 'lucide-svelte'; import { DateFormatter, getLocalTimeZone, today } from '@internationalized/date'; import { cn, calculateAggregatedNutrients } from '$lib/utils.js'; import type { DateRange } from 'bits-ui'; import { buttonVariants } from '$lib/components/ui/button/index.js'; import NutritionalSummary from '$lib/components/diary/NutritionalSummary.svelte'; import DiaryEntryList from '$lib/components/diary/DiaryEntryList.svelte'; import AddItemPanel from '$lib/components/diary/AddItemPanel.svelte'; import type { DiaryEntry, Product } from '@prisma/client'; import type { FullRecipe } from '$lib/models/recipe'; import { calculateNutritionalInfo } from '$lib/recipeCalculator'; import type { NewDiaryEntryData } from '$lib/server/services/diaryService'; type SearchResult = (Product & { type: 'PRODUCT' }) | (FullRecipe & { type: 'RECIPE' }); let { data: initialData }: { data: PageData } = $props(); let entries = $state<DiaryEntry[]>(initialData.entries); let isLoading = $state(false); const df = new DateFormatter('es-ES', { dateStyle: 'long' }); let value: DateRange | undefined = $state({ start: today(getLocalTimeZone()), end: today(getLocalTimeZone()) }); let aggregatedNutrients = $derived(calculateAggregatedNutrients(entries, getLocalTimeZone())); async function fetchEntries(range: DateRange | undefined) { if (!range?.start) return; isLoading = true; entries = []; const start = range.start; const end = range.end ?? start; const startDateStr = `${start.year}-${String(start.month).padStart(2, '0')}-${String(start.day).padStart(2, '0')}`; const endDateStr = `${end.year}-${String(end.month).padStart(2, '0')}-${String(end.day).padStart(2, '0')}`; const apiUrl = `/api/diary/${startDateStr}/${endDateStr}`; try { const response = await fetch(apiUrl, { cache: 'no-store' }); if (response.ok) { entries = await response.json(); } else { console.error('[Frontend] Error fetching entries:', await response.text()); } } catch (error) { console.error('[Frontend] Fetch error:', error); } finally { isLoading = false; } } async function handleAddItem({ item, date }: { item: SearchResult; date: Date }) { const selectedDate = date; let newEntryData: Omit<NewDiaryEntryData, 'userId'>; if (item.type === 'PRODUCT') { newEntryData = { date: selectedDate, type: 'PRODUCT', name: item.name, quantity: 100, calories: item.calories, protein: item.protein, fat: item.fat, carbs: item.carbs, baseProductId: item.id }; } else { const recipeIngredients = item.ingredients.map((ing) => ({ quantity: ing.quantity, calories: ing.product.calories, protein: ing.product.protein, fat: ing.product.fat, carbs: ing.product.carbs })); const totals = calculateNutritionalInfo(recipeIngredients); newEntryData = { date: selectedDate, type: 'RECIPE', name: item.title, quantity: recipeIngredients.reduce((sum, ing) => sum + ing.quantity, 0), calories: totals.totalCalories, protein: totals.totalProtein, fat: totals.totalFat, carbs: totals.totalCarbs, ingredients: item.ingredients.map((ing) => ({ id: ing.product.id, name: ing.product.name, quantity: ing.quantity, baseValues: { calories: ing.product.calories, protein: ing.product.protein, fat: ing.product.fat, carbs: ing.product.carbs } })) as any, baseRecipeId: item.id }; } try { const response = await fetch('/api/diary', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(newEntryData) }); if (response.ok) { await fetchEntries(value); } else { console.error('Error al guardar la entrada:', await response.text()); } } catch (error) { console.error('Error de red al guardar:', error); } } async function handleDeleteEntry(entryToDelete: DiaryEntry) { try { const response = await fetch(`/api/diary/${entryToDelete.id}`, { method: 'DELETE' }); if (response.ok) { entries = entries.filter((e) => e.id !== entryToDelete.id); } else { console.error('Error al eliminar la entrada:', await response.text()); } } catch (error) { console.error('Error de red al eliminar:', error); } } $effect(() => { fetchEntries(value); }); </script> <div class="container mx-auto p-4 md:py-8 md:px-24"> <h1 class="text-3xl font-bold mb-6">Diario</h1> <div class="flex flex-col lg:flex-row gap-8"> <!-- Columna principal (2/3) --> <div class="lg:w-2/3 order-1 lg:order-1"> <!-- Selector de Fecha --> <div class="mb-6"> <Popover.Root> <Popover.Trigger class={cn( buttonVariants({ variant: 'outline' }), 'w-full lg:w-[360px] justify-start text-left font-normal h-11', !value && 'text-muted-foreground' )} > <CalendarIcon class="mr-2 h-4 w-4" /> {#if value?.start} {#if value.end} {df.format(value.start.toDate(getLocalTimeZone()))} - {df.format( value.end.toDate(getLocalTimeZone()) )} {:else} {df.format(value.start.toDate(getLocalTimeZone()))} {/if} {:else} <span>Selecciona un rango</span> {/if} </Popover.Trigger> <Popover.Content class="w-auto p-0" align="start"> <RangeCalendar bind:value /> </Popover.Content> </Popover.Root> </div> <!-- Panel de Añadir Elemento --> <div class="mb-6 p-4 border rounded-lg bg-card text-card-foreground"> <AddItemPanel onAddItem={handleAddItem} /> </div> <!-- Lista de entradas --> <DiaryEntryList {entries} {isLoading} onDelete={handleDeleteEntry} /> </div> <!-- Columna lateral (1/3) --> <div class="lg:w-1/3 order-2 lg:order-2 lg:sticky top-4"> <NutritionalSummary {isLoading} nutrients={aggregatedNutrients} days={aggregatedNutrients.daysWithEntries} /> </div> </div> </div>

// --- Ruta: src/routes/diario/+page.server.ts ---
export const load: PageServerLoad = async () => { const userId = 'test-user'; const today = new Date(); const startDate = new Date(today.setHours(0, 0, 0, 0)); const endDate = new Date(today.setHours(23, 59, 59, 999)); const entries = await diaryService.getDiaryEntries(userId, startDate, endDate); const aggregatedNutrients = diaryService.getAggregatedNutrients(entries); return { entries, aggregatedNutrients }; };

// --- Ruta: src/lib/stores/theme.svelte.ts ---
type Theme = 'light' | 'dark' | 'system'; const initialTheme: Theme = browser ? (localStorage.getItem('theme') as Theme) ?? 'system' : 'system'; let theme = $state<Theme>(initialTheme); export const themeStore = { get value() { return theme; }, set(newTheme: Theme) { theme = newTheme; } };

// --- Ruta: src/lib/server/zodErrors.ts ---
export function createFailResponse(message: string, error?: ZodError) { const response: { message: string; errors: Record<string, string | undefined> } = { message, errors: {} }; if (error) { for (const issue of error.issues) { if (issue.path.length > 0) { const field = issue.path.join('.'); if (!response.errors[field]) { response.errors[field] = issue.message; } } } } return response; }

// --- Ruta: src/lib/server/slug.ts ---
export async function generateUniqueSlug(title: string): Promise<string> { const baseSlug = slugify(title, { lower: true, strict: true }); let uniqueSlug = baseSlug; let counter = 2; while (await prisma.recipe.findUnique({ where: { slug: uniqueSlug } })) { uniqueSlug = `${baseSlug}-${counter}`; counter++; } return uniqueSlug; }

// --- Ruta: src/lib/server/prisma.ts ---
const prisma = new PrismaClient(); export default prisma;

// --- Ruta: src/lib/server/auth.ts ---
const prisma = new PrismaClient(); export const auth = betterAuth({ database: prismaAdapter(prisma, { provider: 'postgresql' }), emailAndPassword: { enabled: true, passwordHashing: { hash: async (password: string) => { return await hash(password, { timeCost: 3, memoryCost: 12288, parallelism: 1 }); }, verify: async (password: string, hash: string) => { return await verify(hash, password); } } }, user: { additionalFields: { role: { type: "string", required: false, defaultValue: "user", input: false, }, } } });

// --- Ruta: src/lib/schemas/searchSchema.ts ---
const RangeFilterSchema = z.object({ min: z.coerce.number().optional(), max: z.coerce.number().optional() }); const GramsFilterSchema = z.object({ calories: RangeFilterSchema.optional(), protein: RangeFilterSchema.optional(), carbs: RangeFilterSchema.optional(), fat: RangeFilterSchema.optional() }); const PercentFilterSchema = z.object({ protein: RangeFilterSchema.optional(), carbs: RangeFilterSchema.optional(), fat: RangeFilterSchema.optional() }); const SortByEnum = z.enum([ 'title_asc', 'title_desc', 'calories_asc', 'calories_desc', 'protein_grams_asc', 'protein_grams_desc', 'fat_grams_asc', 'fat_grams_desc', 'carbs_grams_asc', 'carbs_grams_desc', 'protein_percent_asc', 'protein_percent_desc', 'fat_percent_asc', 'fat_percent_desc', 'carbs_percent_asc', 'carbs_percent_desc' ]); export const SearchFiltersSchema = z.object({ ingredients: z.array(z.string()).optional(), grams: GramsFilterSchema.optional(), percent: PercentFilterSchema.optional(), sortBy: SortByEnum.default('title_asc'), limit: z.coerce.number().default(50), offset: z.coerce.number().default(0) }); export type SearchFilters = z.infer<typeof SearchFiltersSchema>;

// --- Ruta: src/lib/schemas/recipeSchema.ts ---
const RecipeIngredientSchema = z.object({ id: z.string(), quantity: z.coerce.number().positive({ message: 'La cantidad debe ser mayor que cero.' }), source: z.enum(['local', 'off']) }); export const RecipeSchema = z.object({ title: z.string().min(1, { message: 'El título no puede estar vacío.' }), steps: z .array(z.string().min(1, { message: 'El paso no puede estar vacío.' })) .min(1, { message: 'Debe haber al menos un paso.' }), ingredients: z .array(RecipeIngredientSchema) .min(1, { message: 'La receta debe tener al menos un ingrediente.' }), imageUrl: z.string().optional(), urls: z.array(z.string().url({ message: 'La URL no es válida.' })).optional() }); export type RecipeIngredient = z.infer<typeof RecipeIngredientSchema>; export type RecipeData = z.infer<typeof RecipeSchema>;

// --- Ruta: src/lib/schemas/productSchema.ts ---
export const ProductSchema = z.object({ name: z.string().min(1, { message: 'El nombre no puede estar vacío.' }), calories: z.coerce.number().min(0, { message: 'Las calorías no pueden ser negativas.' }), fat: z.coerce.number().min(0, { message: 'La grasa no puede ser negativa.' }), protein: z.coerce.number().min(0, { message: 'La proteína no puede ser negativa.' }), carbs: z.coerce.number().min(0, { message: 'Los carbohidratos no pueden ser negativos.' }), imageUrl: z.string().url({ message: 'Debe ser una URL válida' }).nullable().optional() }); export type Product = z.infer<typeof ProductSchema>;

// --- Ruta: src/lib/schemas/diarySchema.ts ---
export const DiaryEntrySchema = z.object({ date: z.coerce.date(), type: z.enum(['PRODUCT', 'RECIPE']), name: z.string().min(1, 'El nombre no puede estar vacío.'), quantity: z.number().positive('La cantidad debe ser un número positivo.'), calories: z.number().min(0, 'Las calorías no pueden ser negativas.'), protein: z.number().min(0, 'La proteína no puede ser negativa.'), fat: z.number().min(0, 'La grasa no puede ser negativa.'), carbs: z.number().min(0, 'Los carbohidratos no pueden ser negativos.'), ingredients: z.any().optional(), baseProductId: z.string().optional(), baseRecipeId: z.string().optional() });

// --- Ruta: src/lib/runes/useDebounce.svelte.ts ---
export function useDebounce<T>(value: () => T, delay: number): () => T { let debouncedValue = $state(value()); let timeoutId: ReturnType<typeof setTimeout> | null = null; $effect(() => { const currentValue = value(); if (timeoutId) { clearTimeout(timeoutId); } timeoutId = setTimeout(() => { debouncedValue = currentValue; }, delay); return () => { if (timeoutId) { clearTimeout(timeoutId); } }; }); return () => debouncedValue; }

// --- Ruta: src/lib/runes/useAutosave.svelte.ts ---
export function hasData(key: string): boolean { if (!browser) return false; return localStorage.getItem(key) !== null; } export function load<T>(key: string): T | null { if (!browser) return null; const savedData = localStorage.getItem(key); if (!savedData) return null; try { return JSON.parse(savedData) as T; } catch (e) { console.error('Failed to parse autosaved data from localStorage', e); return null; } } function save(key: string, data: unknown): { success: boolean } { if (!browser) return { success: false }; try { const serializedData = JSON.stringify(data); localStorage.setItem(key, serializedData); return { success: true }; } catch (e) { console.error('Failed to save data to localStorage', e); return { success: false }; } } export function clear(key: string): void { if (!browser) return; localStorage.removeItem(key); } export type AutosaveStatus = 'idle' | 'saving' | 'saved' | 'error'; export function createAutosave( key: string, data: () => unknown, options: { enabled: () => boolean; isDirty: () => boolean; debounceMs?: number; } ) { const { enabled, isDirty, debounceMs = 1500 } = options; let status = $state<AutosaveStatus>('idle'); let debounceTimer: number | ReturnType<typeof setTimeout> | undefined; $effect(() => { const currentData = data(); if (!enabled() || !isDirty()) { return; } clearTimeout(debounceTimer); status = 'saving'; debounceTimer = setTimeout(() => { const { success } = save(key, currentData); if (success) { status = 'saved'; setTimeout(() => (status = 'idle'), 2000); } else { status = 'error'; } }, debounceMs); return () => clearTimeout(debounceTimer); }); return { get status() { return status; } }; }

// --- Ruta: src/lib/models/recipe.ts ---
export const recipeInclude = { ingredients: { include: { product: true } }, urls: true } satisfies Prisma.RecipeInclude; export type FullRecipe = Prisma.RecipeGetPayload<{ include: typeof recipeInclude; }>;

// --- Ruta: src/lib/models/RecipeFormState.svelte.ts ---
export type IngredientWithDetails = CalculableProduct & { id: string; name: string; source: 'local' | 'off'; imageUrl?: string | null; }; export type RecipeStep = { id: string; text: string }; type InitialData = { title: string; steps: string[] | string; imageUrl: string | null; urls: { url: string }[]; ingredients: { quantity: number; product: (Omit<CalculableProduct, 'quantity'> & { id: string; name: string; imageUrl: string | null; }) | null; }[]; }; export type FormState = { title: string; steps: RecipeStep[]; imageUrl: string | null; urls: string[]; ingredients: IngredientWithDetails[]; }; const getRecipeSteps = (stepsData: unknown): RecipeStep[] => { let stepsArray: string[] = []; if (Array.isArray(stepsData)) { stepsArray = stepsData.map(String); } else if (browser && typeof stepsData === 'string') { try { const parsed = JSON.parse(stepsData); stepsArray = Array.isArray(parsed) ? parsed.map(String) : [String(stepsData)]; } catch { stepsArray = [String(stepsData)]; } } else if (stepsArray.length === 0) { stepsArray = ['']; } return stepsArray.map((text) => ({ id: crypto.randomUUID(), text })); }; const mapInitialIngredients = (ingredientsData: InitialData['ingredients'] | undefined) => { if (!ingredientsData) return []; return ingredientsData .map((ing): IngredientWithDetails | null => { const product = ing.product; if (!product) return null; return { ...product, id: product.id, quantity: ing.quantity, source: 'local' }; }) .filter((ing): ing is IngredientWithDetails => ing !== null); }; export function createRecipeState(initialData: InitialData | null) { const state: FormState = $state({ title: initialData?.title ?? '', steps: getRecipeSteps(initialData?.steps ?? ['']), imageUrl: initialData?.imageUrl ?? null, urls: initialData?.urls?.map((u) => u.url) ?? [], ingredients: mapInitialIngredients(initialData?.ingredients) }); function addStep() { state.steps.push({ id: crypto.randomUUID(), text: '' }); } function removeStep(id: string) { state.steps = state.steps.filter((step) => step.id !== id); } function updateStepText(id: string, text: string) { const step = state.steps.find((s) => s.id === id); if (step) { step.text = text; } } function addIngredient(ingredient: IngredientWithDetails) { if (!state.ingredients.some((i) => i.id === ingredient.id)) { state.ingredients.push(ingredient); } } function removeIngredient(id: string) { state.ingredients = state.ingredients.filter((i) => i.id !== id); } function reorderIngredients(sourceIndex: number, targetIndex: number) { const reordered = [...state.ingredients]; const [removed] = reordered.splice(sourceIndex, 1); reordered.splice(targetIndex, 0, removed); state.ingredients = reordered; } return { get state() { return state; }, addStep, removeStep, updateStepText, addIngredient, removeIngredient, reorderIngredients, get initialFormState(): FormState { return { title: initialData?.title ?? '', steps: getRecipeSteps(initialData?.steps), imageUrl: initialData?.imageUrl ?? null, urls: initialData?.urls?.map((u) => u.url) ?? [], ingredients: mapInitialIngredients(initialData?.ingredients) }; } }; }

// --- Ruta: src/lib/components/ThemeToggle.svelte ---
<!-- --> <script lang="ts"> import { Sun, Moon, SunMoon } from 'lucide-svelte'; import * as Popover from '$lib/components/ui/popover'; import { themeStore } from '$lib/stores/theme.svelte'; import { buttonVariants, type ButtonVariant } from '$lib/components/ui/button'; import { cn } from '$lib/utils'; let { variant = 'outline' }: { variant?: ButtonVariant } = $props(); let isOpen = $state(false); </script> <Popover.Root bind:open={isOpen}> <Popover.Trigger> {#snippet child({ props })} <button {...props} class={cn(buttonVariants({ variant, size: 'icon' }))} aria-label="Cambiar tema" > <Sun class="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" /> <Moon class="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" /> <span class="sr-only">Cambiar tema</span> </button> {/snippet} </Popover.Trigger> <Popover.Content align="start" side="top" sideOffset={8} class="w-fit p-1" style="min-width: unset !important;" > <div class="flex flex-col gap-1"> <button class="w-8 h-8 flex items-center justify-center hover:bg-accent rounded transition-colors" onclick={() => { themeStore.set('light'); isOpen = false; }} aria-label="Tema claro" > <Sun class="h-4 w-4" /> </button> <button class="w-8 h-8 flex items-center justify-center hover:bg-accent rounded transition-colors" onclick={() => { themeStore.set('dark'); isOpen = false; }} aria-label="Tema oscuro" > <Moon class="h-4 w-4" /> </button> <button class="w-8 h-8 flex items-center justify-center hover:bg-accent rounded transition-colors" onclick={() => { themeStore.set('system'); isOpen = false; }} aria-label="Tema del sistema" > <SunMoon class="h-4 w-4" /> </button> </div> </Popover.Content> </Popover.Root>

// --- Ruta: prisma/migrations/20250812221433_changed_role_to_string/migration.sql ---
-- AlterTable ALTER TABLE "public"."user" DROP COLUMN "role", ADD COLUMN "role" TEXT NOT NULL DEFAULT 'user'; -- DropEnum DROP TYPE "public"."Role";

// --- Ruta: prisma/migrations/20250812181013_better_auth_migration/migration.sql ---
-- CreateEnum CREATE TYPE "public"."Role" AS ENUM ('ADMIN', 'USER'); -- CreateTable CREATE TABLE "public"."user" ( "id" TEXT NOT NULL, "name" TEXT, "email" TEXT, "image" TEXT, "role" "public"."Role" NOT NULL DEFAULT 'USER', "emailVerified" BOOLEAN NOT NULL, "createdAt" TIMESTAMP(3) NOT NULL, "updatedAt" TIMESTAMP(3) NOT NULL, CONSTRAINT "user_pkey" PRIMARY KEY ("id") ); -- CreateTable CREATE TABLE "public"."session" ( "id" TEXT NOT NULL, "expiresAt" TIMESTAMP(3) NOT NULL, "token" TEXT NOT NULL, "createdAt" TIMESTAMP(3) NOT NULL, "updatedAt" TIMESTAMP(3) NOT NULL, "ipAddress" TEXT, "userAgent" TEXT, "userId" TEXT NOT NULL, CONSTRAINT "session_pkey" PRIMARY KEY ("id") ); -- CreateTable CREATE TABLE "public"."account" ( "id" TEXT NOT NULL, "accountId" TEXT NOT NULL, "providerId" TEXT NOT NULL, "userId" TEXT NOT NULL, "accessToken" TEXT, "refreshToken" TEXT, "idToken" TEXT, "accessTokenExpiresAt" TIMESTAMP(3), "refreshTokenExpiresAt" TIMESTAMP(3), "scope" TEXT, "password" TEXT, "createdAt" TIMESTAMP(3) NOT NULL, "updatedAt" TIMESTAMP(3) NOT NULL, CONSTRAINT "account_pkey" PRIMARY KEY ("id") ); -- CreateTable CREATE TABLE "public"."verification" ( "id" TEXT NOT NULL, "identifier" TEXT NOT NULL, "value" TEXT NOT NULL, "expiresAt" TIMESTAMP(3) NOT NULL, "createdAt" TIMESTAMP(3), "updatedAt" TIMESTAMP(3), CONSTRAINT "verification_pkey" PRIMARY KEY ("id") ); -- CreateIndex CREATE UNIQUE INDEX "user_email_key" ON "public"."user"("email"); -- CreateIndex CREATE UNIQUE INDEX "session_token_key" ON "public"."session"("token"); -- AddForeignKey ALTER TABLE "public"."session" ADD CONSTRAINT "session_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE CASCADE ON UPDATE CASCADE; -- AddForeignKey ALTER TABLE "public"."account" ADD CONSTRAINT "account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE CASCADE ON UPDATE CASCADE;

// --- Ruta: prisma/migrations/20250810132331_add_diary_entries/migration.sql ---
-- CreateTable CREATE TABLE "public"."DiaryEntry" ( "id" TEXT NOT NULL, "date" TIMESTAMP(3) NOT NULL, "userId" TEXT, "type" TEXT NOT NULL, "name" TEXT NOT NULL, "quantity" DOUBLE PRECISION NOT NULL, "calories" DOUBLE PRECISION NOT NULL, "protein" DOUBLE PRECISION NOT NULL, "fat" DOUBLE PRECISION NOT NULL, "carbs" DOUBLE PRECISION NOT NULL, "ingredients" JSONB, "baseProductId" TEXT, "baseRecipeId" TEXT, "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" TIMESTAMP(3) NOT NULL, CONSTRAINT "DiaryEntry_pkey" PRIMARY KEY ("id") ); -- CreateIndex CREATE INDEX "DiaryEntry_userId_idx" ON "public"."DiaryEntry"("userId"); -- CreateIndex CREATE INDEX "DiaryEntry_date_idx" ON "public"."DiaryEntry"("date"); -- AddForeignKey ALTER TABLE "public"."DiaryEntry" ADD CONSTRAINT "DiaryEntry_baseProductId_fkey" FOREIGN KEY ("baseProductId") REFERENCES "public"."Product"("id") ON DELETE SET NULL ON UPDATE CASCADE; -- AddForeignKey ALTER TABLE "public"."DiaryEntry" ADD CONSTRAINT "DiaryEntry_baseRecipeId_fkey" FOREIGN KEY ("baseRecipeId") REFERENCES "public"."Recipe"("id") ON DELETE SET NULL ON UPDATE CASCADE;

// --- Ruta: prisma/migrations/20250808184734_init/migration.sql ---
-- CreateTable CREATE TABLE "public"."Product" ( "id" TEXT NOT NULL, "barcode" TEXT, "name" TEXT NOT NULL, "normalizedName" TEXT NOT NULL, "imageUrl" TEXT, "calories" DOUBLE PRECISION NOT NULL, "fat" DOUBLE PRECISION NOT NULL, "protein" DOUBLE PRECISION NOT NULL, "carbs" DOUBLE PRECISION NOT NULL, "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" TIMESTAMP(3) NOT NULL, CONSTRAINT "Product_pkey" PRIMARY KEY ("id") ); -- CreateTable CREATE TABLE "public"."Recipe" ( "id" TEXT NOT NULL, "title" TEXT NOT NULL, "slug" TEXT NOT NULL, "normalizedTitle" TEXT NOT NULL, "steps" JSONB NOT NULL, "imageUrl" TEXT, "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" TIMESTAMP(3) NOT NULL, CONSTRAINT "Recipe_pkey" PRIMARY KEY ("id") ); -- CreateTable CREATE TABLE "public"."RecipeUrl" ( "id" TEXT NOT NULL, "url" TEXT NOT NULL, "recipeId" TEXT NOT NULL, CONSTRAINT "RecipeUrl_pkey" PRIMARY KEY ("id") ); -- CreateTable CREATE TABLE "public"."RecipeIngredient" ( "id" TEXT NOT NULL, "recipeId" TEXT NOT NULL, "productId" TEXT NOT NULL, "quantity" DOUBLE PRECISION NOT NULL, CONSTRAINT "RecipeIngredient_pkey" PRIMARY KEY ("id") ); -- CreateIndex CREATE UNIQUE INDEX "Product_barcode_key" ON "public"."Product"("barcode"); -- CreateIndex CREATE INDEX "Product_normalizedName_idx" ON "public"."Product"("normalizedName"); -- CreateIndex CREATE UNIQUE INDEX "Recipe_slug_key" ON "public"."Recipe"("slug"); -- CreateIndex CREATE INDEX "Recipe_normalizedTitle_idx" ON "public"."Recipe"("normalizedTitle"); -- CreateIndex CREATE INDEX "Recipe_slug_idx" ON "public"."Recipe"("slug"); -- CreateIndex CREATE INDEX "RecipeUrl_recipeId_idx" ON "public"."RecipeUrl"("recipeId"); -- CreateIndex CREATE UNIQUE INDEX "RecipeUrl_recipeId_url_key" ON "public"."RecipeUrl"("recipeId", "url"); -- CreateIndex CREATE INDEX "RecipeIngredient_recipeId_idx" ON "public"."RecipeIngredient"("recipeId"); -- CreateIndex CREATE INDEX "RecipeIngredient_productId_idx" ON "public"."RecipeIngredient"("productId"); -- AddForeignKey ALTER TABLE "public"."RecipeUrl" ADD CONSTRAINT "RecipeUrl_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "public"."Recipe"("id") ON DELETE CASCADE ON UPDATE CASCADE; -- AddForeignKey ALTER TABLE "public"."RecipeIngredient" ADD CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "public"."Recipe"("id") ON DELETE CASCADE ON UPDATE CASCADE; -- AddForeignKey ALTER TABLE "public"."RecipeIngredient" ADD CONSTRAINT "RecipeIngredient_productId_fkey" FOREIGN KEY ("productId") REFERENCES "public"."Product"("id") ON DELETE CASCADE ON UPDATE CASCADE;

// --- Ruta: src/routes/recetas/nueva/+page.svelte ---
<!-- Ruta: src/routes/recetas/nueva/+page.svelte --> <script lang="ts"> import RecipeForm from '$lib/components/recipes/RecipeForm.svelte'; import type { ActionData } from './$types'; let { form }: { form: ActionData } = $props(); </script> <div class="container mx-auto p-4 md:px-24 mt-16 md:mt-0"> <RecipeForm {form} /> </div>

// --- Ruta: src/routes/recetas/nueva/+page.server.ts ---
export const actions: Actions = { default: async ({ request }) => { const formData = await request.formData(); const data = Object.fromEntries(formData.entries()); const dataToValidate = { ...data, ingredients: JSON.parse(data.ingredients as string), urls: JSON.parse(data.urls as string), steps: JSON.parse(data.steps as string) }; const validation = RecipeSchema.safeParse(dataToValidate); if (!validation.success) { const response = createFailResponse( 'La validación falló. Revisa los campos.', validation.error ); return fail(400, response); } try { const newRecipe = await recipeService.create(validation.data); if (newRecipe) { throw redirect(303, `/recetas/${newRecipe.slug}`); } return fail(500, createFailResponse('La receta no se pudo crear.')); } catch (err) { if ((err as { status?: number })?.status === 303) { throw err; } console.error(err); const response = createFailResponse('No se pudo crear la receta en el servidor.'); return fail(500, response); } } };

// --- Ruta: src/routes/recetas/[slug]/+page.svelte ---
<!-- Ruta: src/routes/recetas/[slug]/+page.svelte Implementación del nuevo diseño de la página de detalles de la receta (v2). --> <script lang="ts"> import { Button } from '$lib/components/ui/button/index.js'; import * as Card from '$lib/components/ui/card/index.js'; import { Separator } from '$lib/components/ui/separator/index.js'; import { calculateNutritionalInfo, type CalculableProduct } from '$lib/recipeCalculator'; import { ArrowLeft } from 'lucide-svelte'; import type { PageData } from './$types'; import { fly } from 'svelte/transition'; let { data }: { data: PageData } = $props(); const { recipe } = data; const calculableProducts = $derived( recipe.ingredients.map((ing) => { const source = ing.product; return { quantity: ing.quantity, calories: source?.calories, protein: source?.protein, fat: source?.fat, carbs: source?.carbs } as CalculableProduct; }) ); const totals = $derived(calculateNutritionalInfo(calculableProducts)); const totalGrams = $derived(totals.totalProtein + totals.totalCarbs + totals.totalFat); const proteinPercentage = $derived(totalGrams > 0 ? (totals.totalProtein / totalGrams) * 100 : 0); const carbsPercentage = $derived(totalGrams > 0 ? (totals.totalCarbs / totalGrams) * 100 : 0); const fatPercentage = $derived(totalGrams > 0 ? (totals.totalFat / totalGrams) * 100 : 0); const { steps } = recipe; </script> <div class="container mx-auto p-4 md:py-8 md:px-24"> <h1 class="font-heading font-light text-3xl md:text-4xl mb-8">{recipe.title}</h1> <!-- Sección Superior: Nutrición y Productos --> <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8"> <Card.Root> <Card.Header> <Card.Title class="font-heading mt-4">Información Nutricional</Card.Title> <Card.Description>Valores totales para la receta</Card.Description> </Card.Header> <Card.Content class="space-y-4"> <div class="text-center"> <span class="text-4xl font-bold">{totals.totalCalories.toFixed(0)}</span> <span class="text-muted-foreground">kcal</span> </div> <div> <div class="flex h-2 w-full overflow-hidden rounded-full bg-muted mb-2"> <div class="bg-blue-500" style="width: {proteinPercentage}%" title="Proteínas: {totals.totalProtein.toFixed(1)}g" ></div> <div class="bg-green-500" style="width: {carbsPercentage}%" title="Carbohidratos: {totals.totalCarbs.toFixed(1)}g" ></div> <div class="bg-red-500" style="width: {fatPercentage}%" title="Grasas: {totals.totalFat.toFixed(1)}g" ></div> </div> <div class="flex justify-between text-sm text-muted-foreground"> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-blue-500"></span> Proteínas: {totals.totalProtein.toFixed(1)}g </span> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-green-500"></span> Carbs: {totals.totalCarbs.toFixed(1)}g </span> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-red-500"></span> Grasas: {totals.totalFat.toFixed(1)}g </span> </div> </div> </Card.Content> </Card.Root> <Card.Root> <Card.Header> <Card.Title class="font-heading mt-4">Ingredientes</Card.Title> </Card.Header> <Card.Content> <ul class="space-y-2 text-muted-foreground"> {#each recipe.ingredients as ing} {@const name = ing.product?.name} <li class="flex justify-between"> <span>{name}</span> <span class="font-medium">{ing.quantity.toLocaleString('es-ES')} g</span> </li> {/each} </ul> </Card.Content> </Card.Root> </div> <!-- Sección Inferior: Preparación e Imagen --> <div class="grid grid-cols-1 lg:grid-cols-3 lg:gap-x-12 gap-y-8"> <main class="lg:col-span-2"> <Card.Root> <Card.Header> <Card.Title class="font-heading text-xl mt-4">Preparación</Card.Title> </Card.Header> <Card.Content> <div class="space-y-6"> {#each steps as step, i} <div class="flex items-start gap-4"> <span class="text-2xl md:text-3xl font-bold text-primary mt-[-2px]">{i + 1}.</span> <div class="prose prose-sm sm:prose-base max-w-none flex-1"> {@html step} </div> </div> {#if i < steps.length - 1} <Separator /> {/if} {/each} {#if steps.length === 0} <p class="text-muted-foreground">No hay pasos de preparación definidos.</p> {/if} </div> </Card.Content> </Card.Root> </main> <aside class="lg:col-start-3"> {#if recipe.imageUrl} <img src={recipe.imageUrl} alt="Imagen de {recipe.title}" class="w-full rounded-lg object-cover shadow-lg sticky top-8" /> {/if} </aside> </div> <!-- Sección de Referencias --> {#if recipe.urls.length > 0} <div class="mt-8"> <Card.Root> <Card.Header> <Card.Title class="mt-4">Referencias</Card.Title> </Card.Header> <Card.Content> <ul class="list-disc pl-5 space-y-2"> {#each recipe.urls as ref} <li> <a href={ref.url} target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline break-all" > {ref.url} </a> </li> {/each} </ul> </Card.Content> </Card.Root> </div> {/if} <!-- Botones de Acción --> <div class="mt-12 flex items-center gap-4"> <Button variant="outline" href="/"> <ArrowLeft class="mr-2 h-4 w-4" /> Volver a todas las recetas </Button> {#if data.user?.isAdmin} <Button href="/recetas/{recipe.slug}/editar">Editar Receta</Button> {/if} </div> </div>

// --- Ruta: src/routes/recetas/[slug]/+page.server.ts ---
export const load: PageServerLoad = async ({ params }) => { const recipe = await recipeService.getBySlug(params.slug); if (!recipe) { throw error(404, 'Receta no encontrada'); } const window = new JSDOM('').window; const sanitizer = createDOMPurify(window as any); const processedSteps = await Promise.all( Array.isArray(recipe.steps) ? recipe.steps.map(async (step) => { const rawHtml = await marked.parse(String(step ?? '')); return sanitizer.sanitize(rawHtml); }) : [] ); return { recipe: { ...recipe, steps: processedSteps } }; }; export const actions: Actions = { default: async ({ request, params }) => { const formData = await request.formData(); const data = Object.fromEntries(formData.entries()); const dataToValidate = { ...data, ingredients: JSON.parse(data.ingredients as string), urls: JSON.parse(data.urls as string), steps: JSON.parse(data.steps as string) }; const validation = RecipeSchema.safeParse(dataToValidate); if (!validation.success) { const response = createFailResponse('La validación falló. Revisa los campos.', validation.error); return fail(400, response); } try { const originalRecipe = await recipeService.getBySlug(params.slug); if (!originalRecipe) { throw error(404, 'Receta no encontrada para actualizar'); } const updatedRecipe = await recipeService.update(originalRecipe.id, validation.data); return { status: 200, body: { recipe: updatedRecipe } }; } catch (err) { console.error(err); const response = createFailResponse('No se pudo actualizar la receta.'); return fail(500, response); } } };

// --- Ruta: src/routes/api/scrape-image/+server.ts ---
export const POST: RequestHandler = async ({ request }) => { try { const { url } = await request.json(); if (!url || !url.startsWith('http')) { throw error(400, 'URL no válida'); } const imageUrl = await imageService.getImageFromPageUrl(url); if (!imageUrl) { throw error(404, 'No se pudo encontrar una imagen en la URL proporcionada'); } return json({ imageUrl }); } catch (e) { if (typeof e === 'object' && e !== null && 'status' in e) { throw e; } console.error('Error scraping image:', e); throw error(500, 'Error interno al procesar la imagen'); } };

// --- Ruta: src/routes/api/recipes/+server.ts ---
const DEFAULT_LIMIT = 50; export const GET: RequestHandler = async ({ url }) => { try { const searchTerm = url.searchParams.get('q'); const limit = parseInt(url.searchParams.get('limit') ?? `${DEFAULT_LIMIT}`, 10); const offset = parseInt(url.searchParams.get('offset') ?? '0', 10); const recipesPlusOne = await recipeService.findPaginated(searchTerm, limit + 1, offset); const hasMore = recipesPlusOne.length > limit; const recipes = recipesPlusOne.slice(0, limit); return json({ recipes, hasMore }); } catch (error) { console.error('Error en el endpoint de búsqueda de recetas:', error); return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

// --- Ruta: src/routes/api/diary/+server.ts ---
export const POST: RequestHandler = async ({ request }) => { try { const body = await request.json(); const validatedData = DiaryEntrySchema.parse(body); const userId = 'juanjocerero'; const dataWithUser = { ...validatedData, userId }; const newEntry = await diaryService.addDiaryEntry(dataWithUser); return json(newEntry, { status: 201 }); } catch (error) { if (error instanceof ZodError) { return json(createFailResponse('La validación de los datos falló', error), { status: 400 }); } console.error('Error al crear la entrada del diario:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/routes/api/products/+server.ts ---
export const GET: RequestHandler = async ({ url }) => { try { const search = url.searchParams.get('search') ?? undefined; const sort = url.searchParams.get('sort') ?? 'name'; const order = url.searchParams.get('order') ?? 'asc'; const products = await productService.getAll(search, sort, order); return json(products); } catch (error) { console.error('Error fetching products:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const POST: RequestHandler = async ({ request }) => { try { const body = await request.json(); const validatedData = ProductSchema.parse(body); const newProduct = await productService.create(validatedData); return json(newProduct, { status: 201 }); } catch (error) { if (error instanceof ZodError) { return json(createFailResponse('La validación falló', error), { status: 400 }); } console.error('Error creating product:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const DELETE: RequestHandler = async ({ request }) => { try { const { id } = await request.json(); if (!id || typeof id !== 'string') { return json(createFailResponse('Falta el campo "id"'), { status: 400 }); } await productService.delete(id); return json({ success: true, message: 'Producto eliminado con éxito' }, { status: 200 }); } catch (error) { console.error('Error al eliminar el producto:', error); if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') { return json( createFailResponse('No se puede eliminar el producto porque está en uso en una receta.'), { status: 409 } ); } return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/routes/admin/products/+page.svelte ---
<script lang="ts"> import type { ActionData, PageData } from './$types'; import { goto } from '$app/navigation'; import { page } from '$app/state'; import ProductsDesktopView from '$lib/components/admin/ProductsDesktopView.svelte'; import ProductsMobileView from '$lib/components/admin/ProductsMobileView.svelte'; let { data, form } = $props<{ data: PageData; form: ActionData }>(); let searchTerm = $state(data.search ?? ''); $effect(() => { const currentSearchTerm = searchTerm; const handler = setTimeout(() => { const url = new URL(page.url); if (currentSearchTerm) { url.searchParams.set('search', currentSearchTerm); } else { url.searchParams.delete('search'); } if (url.search !== page.url.search) { goto(url, { keepFocus: true, noScroll: true, replaceState: true }); } }, 300); return () => { clearTimeout(handler); }; }); let editingProductName = $state(''); let editingProductId = $state<string | null>(null); </script> <div class="container mx-auto p-4 md:py-8 md:px-24"> <ProductsDesktopView {data} {form} bind:searchTerm bind:editingProductName bind:editingProductId /> <ProductsMobileView {data} {form} bind:searchTerm bind:editingProductName bind:editingProductId /> </div>

// --- Ruta: src/routes/admin/products/+page.server.ts ---
export const load: PageServerLoad = async ({ url }) => { const search = url.searchParams.get('search') ?? ''; const sort = url.searchParams.get('sort') ?? 'name'; const order = url.searchParams.get('order') ?? 'asc'; try { const products = await productService.getAll(search, sort, order); return { products, search, sort, order }; } catch (error) { console.error('Error al cargar los productos:', error); return { products: [], search, sort, order, error: 'No se pudieron cargar los productos' }; } }; export const actions: Actions = { addCustom: async ({ request }) => { const formData = Object.fromEntries(await request.formData()); const validation = ProductSchema.safeParse(formData); if (!validation.success) { return fail(400, { data: formData, ...createFailResponse('La validación falló', validation.error) }); } try { await productService.create(validation.data); return { success: true, message: 'Producto añadido con éxito' }; } catch (error) { console.error('Error al crear el producto:', error); return fail(500, { data: formData, message: 'No se pudo crear el producto.' }); } }, update: async ({ request }) => { const formData = Object.fromEntries(await request.formData()); const id = formData.id as string; const validation = ProductSchema.partial().safeParse(formData); if (!validation.success) { return fail(400, { data: formData, ...createFailResponse('La validación falló', validation.error) }); } try { await productService.update(id, validation.data); return { success: true, message: 'Producto actualizado con éxito' }; } catch (error) { console.error(`Error al actualizar el producto ${id}:`, error); return fail(500, { data: formData, message: 'No se pudo actualizar el producto.' }); } }, delete: async ({ request }) => { const formData = Object.fromEntries(await request.formData()); const id = formData.id as string; if (!id) { return fail(400, { message: 'ID de producto no proporcionado.' }); } try { await productService.delete(id); return { success: true, message: 'Producto eliminado con éxito' }; } catch (error) { console.error(`Error al eliminar el producto ${id}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') { return fail(409, { message: 'No se puede eliminar el producto porque está siendo usado en una o más recetas.' }); } return fail(500, { message: 'No se pudo eliminar el producto.' }); } }, updateImage: async ({ request }) => { const formData = await request.formData(); const id = formData.get('id') as string; const imageUrl = formData.get('imageUrl') as string; if (!id) { return fail(400, { message: 'ID de producto no proporcionado.' }); } const dataToUpdate = { imageUrl: imageUrl || null }; const validation = ProductSchema.partial().safeParse(dataToUpdate); if (!validation.success) { return fail(400, { ...createFailResponse('La validación falló', validation.error) }); } try { let finalImageUrl = validation.data.imageUrl ?? null; if (finalImageUrl && !finalImageUrl.startsWith('data:image/webp;base64,')) { const processedImage = await imageService.process(finalImageUrl); if (!processedImage) { return fail(400, { message: 'La imagen proporcionada no pudo ser procesada.' }); } finalImageUrl = processedImage; } await productService.update(id, { imageUrl: finalImageUrl }); return { success: true, message: 'Imagen actualizada con éxito' }; } catch (error) { console.error(`Error al actualizar la imagen del producto ${id}:`, error); return fail(500, { message: 'No se pudo actualizar la imagen.' }); } } };

// --- Ruta: src/routes/recetas/busqueda-avanzada/+page.svelte ---
<script lang="ts"> import { browser } from '$app/environment'; import IngredientCombobox from '$lib/components/recipes/IngredientCombobox.svelte'; import MacroFilters from '$lib/components/recipes/MacroFilters.svelte'; import SortOptions from '$lib/components/recipes/SortOptions.svelte'; import type { SortField, SortDirection } from '$lib/components/recipes/SortOptions.svelte'; import type { GramFilters, PercentFilters } from '$lib/components/recipes/MacroFilters.svelte'; import RecipeCard from '$lib/components/recipes/RecipeCard.svelte'; import * as Collapsible from '$lib/components/ui/collapsible'; import { buttonVariants } from '$lib/components/ui/button'; import { Badge } from '$lib/components/ui/badge'; import X from 'lucide-svelte/icons/x'; import ChevronsUpDown from 'lucide-svelte/icons/chevrons-up-down'; import { cn } from '$lib/utils'; type Ingredient = { id: string; name: string; type: 'product' | 'custom'; source: 'local' | 'off'; imageUrl: string | null; }; type Recipe = any; type SearchPayload = { ingredients: string[]; grams: GramFilters; percent: PercentFilters; sortBy: string; }; let filters = $state({ selectedIngredients: [] as Ingredient[], gramFilters: { calories: {}, protein: {}, carbs: {}, fat: {} } as GramFilters, percentFilters: { protein: {}, carbs: {}, fat: {} } as PercentFilters, sortBy: 'title_asc' }); let sortField = $state<SortField>('title'); let sortDirection = $state<SortDirection>('asc'); $effect(() => { const newSortBy = `${sortField}_${sortDirection}`; if (filters.sortBy !== newSortBy) { filters.sortBy = newSortBy; } }); let recipes = $state<Recipe[]>([]); let isLoading = $state(false); let hasMore = $state(false); let sentinel: HTMLDivElement | undefined = $state(); let controller: AbortController | undefined; let pageHeader: HTMLElement | undefined = $state(); let isDesktop = $state(false); $effect(() => { if (!browser) return; const mediaQuery = window.matchMedia('(min-width: 1024px)'); isDesktop = mediaQuery.matches; const listener = (e: MediaQueryListEvent) => (isDesktop = e.matches); mediaQuery.addEventListener('change', listener); return () => mediaQuery.removeEventListener('change', listener); }); export const snapshot = { capture: () => { return { filters: JSON.parse(JSON.stringify(filters)), recipes: JSON.parse(JSON.stringify(recipes)) }; }, restore: (data: any) => { if (data && data.filters && data.recipes) { filters = data.filters; recipes = data.recipes; } } }; function areFiltersActive() { const hasMacroGrams = Object.values(filters.gramFilters).some( (range) => range && (range.min != null || range.max != null) ); const hasMacroPercent = Object.values(filters.percentFilters).some( (range) => range && (range.min != null || range.max != null) ); return filters.selectedIngredients.length > 0 || hasMacroGrams || hasMacroPercent; } async function performSearch(payload: SearchPayload) { if (!areFiltersActive()) { recipes = []; hasMore = false; return; } isLoading = true; const signal = controller?.signal; try { const body = { ...payload, offset: 0 }; const response = await fetch('/api/recipes/search', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body), signal }); const result = await response.json(); if (signal?.aborted) return; recipes = result.recipes; hasMore = result.hasMore; pageHeader?.scrollIntoView({ behavior: 'smooth' }); } catch (error) { if (error instanceof DOMException && error.name === 'AbortError') return; console.error('Error en la búsqueda:', error); } finally { if (!signal?.aborted) isLoading = false; } } async function loadMore(payload: SearchPayload) { if (!areFiltersActive() || isLoading) return; isLoading = true; try { const body = { ...payload, offset: recipes.length }; const response = await fetch('/api/recipes/search', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) }); const result = await response.json(); recipes.push(...result.recipes); hasMore = result.hasMore; } catch (error) { console.error('Error al cargar más recetas:', error); } finally { isLoading = false; } } $effect(() => { if (!browser) return; if (!areFiltersActive()) { recipes = []; hasMore = false; return; } controller?.abort(); controller = new AbortController(); const payload: SearchPayload = { ingredients: filters.selectedIngredients.map((i) => i.id), grams: filters.gramFilters, percent: filters.percentFilters, sortBy: filters.sortBy }; const timerId = setTimeout(() => { performSearch(payload); }, 350); return () => clearTimeout(timerId); }); $effect(() => { if (!sentinel) return; const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting && hasMore && !isLoading && areFiltersActive()) { const payload: SearchPayload = { ingredients: filters.selectedIngredients.map((i) => i.id), grams: filters.gramFilters, percent: filters.percentFilters, sortBy: filters.sortBy }; loadMore(payload); } }); observer.observe(sentinel); return () => observer.disconnect(); }); function handleAddIngredient(ingredient: Ingredient) { if (!filters.selectedIngredients.some((i) => i.id === ingredient.id)) { filters.selectedIngredients = [...filters.selectedIngredients, ingredient]; } } function handleRemoveIngredient(ingredientId: string) { filters.selectedIngredients = filters.selectedIngredients.filter((i) => i.id !== ingredientId); } function clearIngredients() { filters.selectedIngredients = []; } function handleGramsChange(macro: keyof GramFilters, key: 'min' | 'max', value: number | undefined) { filters.gramFilters = { ...filters.gramFilters, [macro]: { ...filters.gramFilters[macro], [key]: value } }; } function handlePercentChange( macro: keyof PercentFilters, key: 'min' | 'max', value: number | undefined ) { filters.percentFilters = { ...filters.percentFilters, [macro]: { ...filters.percentFilters[macro], [key]: value } }; } function handleClearMacros() { filters.gramFilters = { calories: {}, protein: {}, carbs: {}, fat: {} }; filters.percentFilters = { protein: {}, carbs: {}, fat: {} }; } </script> <div class="container mx-auto p-4 md:py-8 md:px-24"> <header class="mb-8 flex items-center justify-between" bind:this={pageHeader}> <div> <h1 class="text-3xl font-bold tracking-tight">Búsqueda Avanzada</h1> <p class="text-muted-foreground"> Filtra por productos, macronutrientes y más. </p> </div> </header> <div class="grid grid-cols-1 gap-8 lg:grid-cols-3"> <aside class="lg:col-span-1 space-y-6 sticky top-4"> <Collapsible.Root open={isDesktop} class="border rounded-lg p-4"> <div class="flex items-center justify-between"> <h3 class="text-xl font-semibold">Filtros</h3> <Collapsible.Trigger class={cn(buttonVariants({ variant: 'ghost', size: 'sm' }), 'w-9 p-0')} > <ChevronsUpDown class="h-4 w-4" /> <span class="sr-only">Toggle Filtros</span> </Collapsible.Trigger> </div> <Collapsible.Content class="mt-4"> <div class="space-y-6"> <div class="space-y-2"> <h3 class="text-lg font-semibold">Productos</h3> <IngredientCombobox onSelect={handleAddIngredient} selectedIds={filters.selectedIngredients.map((i) => i.id)} onClear={clearIngredients} /> <div class="flex flex-wrap gap-2 pt-2 min-h-[24px]"> {#each filters.selectedIngredients as ingredient (ingredient.id)} <Badge variant="secondary" class="flex items-center gap-2"> {ingredient.name} <button onclick={() => handleRemoveIngredient(ingredient.id)} class="focus:ring-ring rounded-sm focus:outline-none focus:ring-2 focus:ring-offset-2" > <X class="h-3 w-3" /> </button> </Badge> {/each} </div> </div> <hr /> <MacroFilters gramFilters={filters.gramFilters} percentFilters={filters.percentFilters} onGramsChange={handleGramsChange} onPercentChange={handlePercentChange} onClear={handleClearMacros} /> </div> </Collapsible.Content> </Collapsible.Root> <Collapsible.Root open={isDesktop} class="border rounded-lg p-4"> <div class="flex items-center justify-between"> <h3 class="text-xl font-semibold">Ordenar por</h3> <Collapsible.Trigger class={cn(buttonVariants({ variant: 'ghost', size: 'sm' }), 'w-9 p-0')} > <ChevronsUpDown class="h-4 w-4" /> <span class="sr-only">Toggle Ordenar</span> </Collapsible.Trigger> </div> <Collapsible.Content class="mt-4"> <SortOptions field={sortField} direction={sortDirection} onFieldChange={(value) => (sortField = value)} onDirectionChange={(value) => (sortDirection = value)} /> </Collapsible.Content> </Collapsible.Root> </aside> <main class="lg:col-span-2"> <div class="space-y-4"> {#if recipes.length > 0} <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"> {#each recipes as recipe, i (recipe.id)} <div> <RecipeCard {recipe} isAdmin={false} onEditQuantities={() => {}} onDelete={() => {}} /> </div> {/each} </div> {:else if !isLoading} <div class="rounded-lg border p-8 text-center"> <p class="text-muted-foreground"> {#if areFiltersActive()} No se encontraron recetas con estos criterios. {:else} Selecciona uno o más filtros para empezar a buscar. {/if} </p> </div> {/if} {#if hasMore} <div bind:this={sentinel} class="h-10 flex justify-center items-center text-muted-foreground"> {#if isLoading} <span>Cargando...</span> {/if} </div> {/if} </div> </main> </div> </div>

// --- Ruta: src/lib/server/services/recipeService.ts ---
export type MacroFilter = { min?: number; max?: number; }; export type AdvancedSearchFilters = ZodSearchFilters; type RawRecipeQueryResult = { id: string; title: string; imageUrl: string | null; }; export const recipeService = { async getAll(): Promise<FullRecipe[]> { return await prisma.recipe.findMany({ include: recipeInclude, orderBy: { title: 'asc' } }); }, async getById(id: string): Promise<FullRecipe | null> { return await prisma.recipe.findUnique({ where: { id }, include: recipeInclude }); }, async getBySlug(slug: string): Promise<FullRecipe | null> { return await prisma.recipe.findUnique({ where: { slug }, include: recipeInclude }); }, async create(data: RecipeData): Promise<FullRecipe> { const { title, steps, ingredients, urls, imageUrl } = data; const slug = await generateUniqueSlug(title); const createdRecipe = await prisma.recipe.create({ data: { title, slug, normalizedTitle: normalizeText(title), steps, imageUrl, urls: { create: urls?.map((url: string) => ({ url })) }, ingredients: { create: ingredients.map((ingredient) => ({ quantity: ingredient.quantity, productId: ingredient.id })) } } }); const fullNewRecipe = await prisma.recipe.findUnique({ where: { id: createdRecipe.id }, include: recipeInclude }); if (!fullNewRecipe) { throw new Error('No se pudo encontrar la receta recién creada.'); } return fullNewRecipe; }, async update(id: string, data: RecipeData) { const { title, steps, ingredients, urls, imageUrl } = data; const originalRecipe = await prisma.recipe.findUnique({ where: { id } }); let slug: string | undefined; if (originalRecipe && originalRecipe.title !== title) { slug = await generateUniqueSlug(title); } return await prisma.$transaction(async (tx) => { await tx.recipe.update({ where: { id }, data: { title, slug, normalizedTitle: normalizeText(title), steps, imageUrl } }); await tx.recipeIngredient.deleteMany({ where: { recipeId: id } }); await tx.recipeIngredient.createMany({ data: ingredients.map((ingredient) => ({ recipeId: id, quantity: ingredient.quantity, productId: ingredient.id })) }); await tx.recipeUrl.deleteMany({ where: { recipeId: id } }); if (urls && urls.length > 0) { await tx.recipeUrl.createMany({ data: urls.map((url: string) => ({ recipeId: id, url })) }); } return await tx.recipe.findUnique({ where: { id }, include: recipeInclude }); }); }, async deleteById(id: string) { return await prisma.recipe.delete({ where: { id } }); }, async findPaginated(searchTerm: string | null, limit: number, offset: number) { const normalizedSearchTerm = searchTerm ? normalizeText(searchTerm) : undefined; if (!normalizedSearchTerm) { return prisma.recipe.findMany({ include: recipeInclude, orderBy: { updatedAt: 'desc' }, take: limit, skip: offset }); } const recipesByTitle = await prisma.recipe.findMany({ where: { normalizedTitle: { contains: normalizedSearchTerm } }, select: { id: true } }); const recipesByIngredient = await prisma.recipe.findMany({ where: { ingredients: { some: { product: { normalizedName: { contains: normalizedSearchTerm } } } } }, select: { id: true } }); const allIds = [...recipesByTitle.map((r) => r.id), ...recipesByIngredient.map((r) => r.id)]; const uniqueIds = [...new Set(allIds)]; const recipes = await prisma.recipe.findMany({ where: { id: { in: uniqueIds } }, include: recipeInclude, orderBy: { updatedAt: 'desc' }, take: limit, skip: offset }); return Array.from(new Map(recipes.map((r) => [r.id, r])).values()); }, async findAdvanced(filters: AdvancedSearchFilters): Promise<FullRecipe[]> { const { ingredients, grams, percent, sortBy, limit, offset } = filters; const withClause = Prisma.sql` WITH "RecipeTotals" AS ( SELECT ri."recipeId", SUM(p.calories * ri.quantity / 100.0) AS "totalCalories", SUM(p.protein * ri.quantity / 100.0) AS "totalProtein", SUM(p.carbs * ri.quantity / 100.0) AS "totalCarbs", SUM(p.fat * ri.quantity / 100.0) AS "totalFat" FROM "RecipeIngredient" ri JOIN "Product" p ON ri."productId" = p.id GROUP BY ri."recipeId" ), "RecipePercentages" AS ( SELECT "recipeId", "totalCalories", "totalProtein", "totalCarbs", "totalFat", "totalProtein" * 4 * 100.0 / NULLIF("totalCalories", 0) AS "percentProtein", "totalCarbs" * 4 * 100.0 / NULLIF("totalCalories", 0) AS "percentCarbs", "totalFat" * 9 * 100.0 / NULLIF("totalCalories", 0) AS "percentFat" FROM "RecipeTotals" ) `; const selectClause = Prisma.sql` SELECT r.id, r.title, r."imageUrl" FROM "Recipe" r JOIN "RecipePercentages" rt ON r.id = rt."recipeId" `; const whereConditions: Prisma.Sql[] = []; if (ingredients && ingredients.length > 0) { ingredients.forEach((ingredientId) => { whereConditions.push(Prisma.sql` EXISTS ( SELECT 1 FROM "RecipeIngredient" ri WHERE ri."recipeId" = r.id AND ri."productId" = ${ingredientId} ) `); }); } if (grams?.calories?.min != null) whereConditions.push(Prisma.sql`rt."totalCalories" >= ${grams.calories.min}`); if (grams?.calories?.max != null) whereConditions.push(Prisma.sql`rt."totalCalories" <= ${grams.calories.max}`); if (grams?.protein?.min != null) whereConditions.push(Prisma.sql`rt."totalProtein" >= ${grams.protein.min}`); if (grams?.protein?.max != null) whereConditions.push(Prisma.sql`rt."totalProtein" <= ${grams.protein.max}`); if (grams?.carbs?.min != null) whereConditions.push(Prisma.sql`rt."totalCarbs" >= ${grams.carbs.min}`); if (grams?.carbs?.max != null) whereConditions.push(Prisma.sql`rt."totalCarbs" <= ${grams.carbs.max}`); if (grams?.fat?.min != null) whereConditions.push(Prisma.sql`rt."totalFat" >= ${grams.fat.min}`); if (grams?.fat?.max != null) whereConditions.push(Prisma.sql`rt."totalFat" <= ${grams.fat.max}`); if (percent?.protein?.min != null) whereConditions.push(Prisma.sql`rt."percentProtein" >= ${percent.protein.min}`); if (percent?.protein?.max != null) whereConditions.push(Prisma.sql`rt."percentProtein" <= ${percent.protein.max}`); if (percent?.carbs?.min != null) whereConditions.push(Prisma.sql`rt."percentCarbs" >= ${percent.carbs.min}`); if (percent?.carbs?.max != null) whereConditions.push(Prisma.sql`rt."percentCarbs" <= ${percent.carbs.max}`); if (percent?.fat?.min != null) whereConditions.push(Prisma.sql`rt."percentFat" >= ${percent.fat.min}`); if (percent?.fat?.max != null) whereConditions.push(Prisma.sql`rt."percentFat" <= ${percent.fat.max}`); const whereClause = whereConditions.length > 0 ? Prisma.sql`WHERE ${Prisma.join(whereConditions, ' AND ')}` : Prisma.empty; let orderByClause: Prisma.Sql; switch (sortBy) { case 'title_asc': orderByClause = Prisma.sql`ORDER BY r.title ASC`; break; case 'title_desc': orderByClause = Prisma.sql`ORDER BY r.title DESC`; break; case 'calories_asc': orderByClause = Prisma.sql`ORDER BY rt."totalCalories" ASC`; break; case 'calories_desc': orderByClause = Prisma.sql`ORDER BY rt."totalCalories" DESC`; break; case 'protein_grams_asc': orderByClause = Prisma.sql`ORDER BY rt."totalProtein" ASC`; break; case 'protein_grams_desc': orderByClause = Prisma.sql`ORDER BY rt."totalProtein" DESC`; break; case 'fat_grams_asc': orderByClause = Prisma.sql`ORDER BY rt."totalFat" ASC`; break; case 'fat_grams_desc': orderByClause = Prisma.sql`ORDER BY rt."totalFat" DESC`; break; case 'carbs_grams_asc': orderByClause = Prisma.sql`ORDER BY rt."totalCarbs" ASC`; break; case 'carbs_grams_desc': orderByClause = Prisma.sql`ORDER BY rt."totalCarbs" DESC`; break; case 'protein_percent_asc': orderByClause = Prisma.sql`ORDER BY rt."percentProtein" ASC`; break; case 'protein_percent_desc': orderByClause = Prisma.sql`ORDER BY rt."percentProtein" DESC`; break; case 'fat_percent_asc': orderByClause = Prisma.sql`ORDER BY rt."percentFat" ASC`; break; case 'fat_percent_desc': orderByClause = Prisma.sql`ORDER BY rt."percentFat" DESC`; break; case 'carbs_percent_asc': orderByClause = Prisma.sql`ORDER BY rt."percentCarbs" ASC`; break; case 'carbs_percent_desc': orderByClause = Prisma.sql`ORDER BY rt."percentCarbs" DESC`; break; default: orderByClause = Prisma.sql`ORDER BY r.title ASC`; } const paginationClause = Prisma.sql`LIMIT ${limit} OFFSET ${offset}`; const fullQuery = Prisma.sql`${withClause} ${selectClause} ${whereClause} ${orderByClause} ${paginationClause}`; const result = await prisma.$queryRaw<RawRecipeQueryResult[]>(fullQuery); const recipeIds = result.map((r) => r.id); if (recipeIds.length === 0) return []; const recipesInOrder = await prisma.recipe.findMany({ where: { id: { in: recipeIds } }, include: recipeInclude }); return recipeIds .map((id) => recipesInOrder.find((r) => r.id === id)) .filter((r): r is FullRecipe => !!r); } };

// --- Ruta: src/lib/server/services/productService.ts ---
type OpenFoodFactsProduct = { code: string; product_name: string; image_url?: string; nutriments: { 'energy-kcal_100g'?: number; fat_100g?: number; proteins_100g?: number; carbohydrates_100g?: number; }; }; type OpenFoodFactsResponse = { status: number; product?: OpenFoodFactsProduct; }; export const productService = { async searchByName(query: string) { const normalizedQuery = normalizeText(query); return prisma.product.findMany({ where: { normalizedName: { contains: normalizedQuery } } }); }, async getAll(search?: string, sort: string = 'name', order: string = 'asc') { const whereClause = search ? { normalizedName: { contains: normalizeText(search) } } : {}; const orderByClause = { [sort]: order }; return prisma.product.findMany({ where: whereClause, orderBy: orderByClause }); }, async create(data: Product, barcode?: string) { const normalizedName = normalizeText(data.name); return prisma.product.create({ data: { ...data, normalizedName, barcode } }); }, async update(id: string, data: Partial<Product>) { const updateData: Partial<Product> & { normalizedName?: string } = { ...data }; if (data.name) { updateData.normalizedName = normalizeText(data.name); } return prisma.product.update({ where: { id }, data: updateData }); }, async delete(id: string) { return prisma.product.delete({ where: { id } }); }, async getByIds(ids: string[]) { if (ids.length === 0) { return []; } return prisma.product.findMany({ where: { id: { in: ids } } }); }, async findByBarcodeInDbOnly(barcode: string) { if (!barcode) return null; return prisma.product.findUnique({ where: { barcode } }); }, async findByBarcode(barcode: string) { const cachedProduct = await prisma.product.findUnique({ where: { barcode } }); if (cachedProduct) { return cachedProduct; } const url = `https: try { const response = await ky.get(url).json<OpenFoodFactsResponse>(); if (response.status === 0 || !response.product) { return null; } const productFromApi = response.product; const productName = productFromApi.product_name; const parseNutriment = (value: unknown): number => { if (typeof value === 'number') return value; if (typeof value === 'string') { const parsed = parseFloat(value); return isNaN(parsed) ? 0 : parsed; } return 0; }; const newProduct = await prisma.product.create({ data: { name: productName, normalizedName: normalizeText(productName), barcode: productFromApi.code, imageUrl: productFromApi.image_url, calories: parseNutriment(productFromApi.nutriments['energy-kcal_100g']), fat: parseNutriment(productFromApi.nutriments.fat_100g), protein: parseNutriment(productFromApi.nutriments.proteins_100g), carbs: parseNutriment(productFromApi.nutriments.carbohydrates_100g) } }); return newProduct; } catch (error) { console.error(`[OFF] Error fetching product ${barcode}:`, error); return null; } } };

// --- Ruta: src/lib/server/services/imageService.ts ---
const MAX_IMAGE_WIDTH = 768; async function getImageUrlFromPage(url: string): Promise<string | null> { try { const response = await fetch(url, { headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' } }); if (!response.ok) { console.error(`Error fetching page ${url}: ${response.statusText}`); return null; } const html = await response.text(); const $ = cheerio.load(html); const ogImage = $('meta[property="og:image"]').attr('content'); if (ogImage) return ogImage; const twitterImage = $('meta[name="twitter:image"]').attr('content'); if (twitterImage) return twitterImage; return null; } catch (error) { console.error(`Failed to fetch or parse page at ${url}`, error); return null; } } async function processImage(imageSource: string | Buffer): Promise<string | null> { try { const imageBuffer = typeof imageSource === 'string' && imageSource.startsWith('data:') ? Buffer.from(imageSource.split(',')[1], 'base64') : imageSource; const optimizedImageBuffer = await sharp(imageBuffer) .resize(MAX_IMAGE_WIDTH, null, { withoutEnlargement: true }) .webp({ quality: 60 }) .toBuffer(); const base64Image = optimizedImageBuffer.toString('base64'); return `data:image/webp;base64,${base64Image}`; } catch (error) { console.error(`Failed to process image`, error); return null; } } async function fetchImageAsBuffer(imageUrl: string): Promise<Buffer | null> { try { const imageResponse = await fetch(imageUrl); if (!imageResponse.ok) { console.error(`Error fetching image ${imageUrl}: ${imageResponse.statusText}`); return null; } return Buffer.from(await imageResponse.arrayBuffer()); } catch (error) { console.error(`Failed to fetch image buffer from ${imageUrl}`, error); return null; } } export const imageService = { getImageFromPageUrl: async (pageUrl: string): Promise<string | null> => { const imageUrl = await getImageUrlFromPage(pageUrl); if (!imageUrl) { return null; } const imageBuffer = await fetchImageAsBuffer(imageUrl); if (!imageBuffer) { return null; } return processImage(imageBuffer); }, process: processImage };

// --- Ruta: src/lib/server/services/diaryService.ts ---
export type NewDiaryEntryData = { userId?: string; date: Date; type: 'PRODUCT' | 'RECIPE'; name: string; quantity: number; calories: number; protein: number; fat: number; carbs: number; ingredients?: Prisma.JsonValue; baseProductId?: string; baseRecipeId?: string; }; export type UpdateDiaryEntryData = Partial<Omit<NewDiaryEntryData, 'userId' | 'type'>>; export const diaryService = { async getDiaryEntries( userId: string, startDate: Date, endDate: Date ): Promise<DiaryEntry[]> { return prisma.diaryEntry.findMany({ where: { userId, date: { gte: startDate, lte: endDate } }, orderBy: { date: 'asc' } }); }, async addDiaryEntry(data: NewDiaryEntryData): Promise<DiaryEntry> { return prisma.diaryEntry.create({ data: { userId: data.userId, date: data.date, type: data.type, name: data.name, quantity: data.quantity, calories: data.calories, protein: data.protein, fat: data.fat, carbs: data.carbs, ingredients: data.ingredients ?? Prisma.JsonNull, baseProductId: data.baseProductId, baseRecipeId: data.baseRecipeId } }); }, async updateDiaryEntry( entryId: string, updates: UpdateDiaryEntryData ): Promise<DiaryEntry | null> { const { ingredients, ...rest } = updates; const data: Prisma.DiaryEntryUpdateInput = { ...rest }; if (ingredients !== undefined) { data.ingredients = ingredients ?? Prisma.JsonNull; } return prisma.diaryEntry.update({ where: { id: entryId }, data }); }, async deleteDiaryEntry(entryId: string): Promise<DiaryEntry | null> { return prisma.diaryEntry.delete({ where: { id: entryId } }); }, getAggregatedNutrients(entries: DiaryEntry[]): AggregatedNutrients { return calculateAggregatedNutrients(entries); } };

// --- Ruta: src/lib/components/shared/MacroBar.svelte ---
<script lang="ts"> type Props = { protein: number | null; carbs: number | null; fat: number | null; }; const { protein, carbs, fat }: Props = $props(); const p = $derived(protein ?? 0); const c = $derived(carbs ?? 0); const f = $derived(fat ?? 0); const totalGrams = $derived(p + c + f); const proteinPercentage = $derived(totalGrams > 0 ? (p / totalGrams) * 100 : 0); const carbsPercentage = $derived(totalGrams > 0 ? (c / totalGrams) * 100 : 0); const fatPercentage = $derived(totalGrams > 0 ? (f / totalGrams) * 100 : 0); </script> <div class="w-full"> <div class="flex h-2 w-full overflow-hidden rounded-full bg-muted"> <div class="bg-blue-500" style="width: {proteinPercentage}%" title="Proteínas: {p.toFixed(1)}g" ></div> <div class="bg-green-500" style="width: {carbsPercentage}%" title="Carbohidratos: {c.toFixed(1)}g" ></div> <div class="bg-red-500" style="width: {fatPercentage}%" title="Grasas: {f.toFixed(1)}g" ></div> </div> <div class="mt-2 flex justify-between text-xs text-muted-foreground"> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-blue-500"></span> P ({p.toFixed(1)}) </span> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-green-500"></span> C ({c.toFixed(1)}) </span> <span class="flex items-center"> <span class="mr-1.5 h-2 w-2 rounded-full bg-red-500"></span> G ({f.toFixed(1)}) </span> </div> </div>

// --- Ruta: src/lib/components/shared/ImageManager.svelte ---
<!-- src/lib/components/shared/ImageManager.svelte --> <script lang="ts"> import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import { Button } from '$lib/components/ui/button'; import { LoaderCircle } from 'lucide-svelte'; import { toast } from 'svelte-sonner'; import { useDebounce } from '$lib/runes/useDebounce.svelte'; let { imageUrl = $bindable<string | null>(), inputName = 'imageUrl' } = $props<{ imageUrl: string | null; inputName?: string }>(); let remoteUrl = $state(''); let isLoading = $state(false); const debouncedUrl = useDebounce(() => remoteUrl, 500); function handleImageUpload(event: Event) { const target = event.target as HTMLInputElement; const file = target.files?.[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { const result = e.target?.result; imageUrl = typeof result === 'string' ? result : null; }; reader.readAsDataURL(file); } } $effect(() => { const urlToFetch = debouncedUrl(); if (!urlToFetch || !urlToFetch.startsWith('http')) { return; } const fetchImage = async () => { isLoading = true; const toastId = toast.loading('Buscando imagen en la URL...'); try { const response = await fetch('/api/scrape-image', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url: urlToFetch }) }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.message || `Error ${response.status}`); } const data = await response.json(); imageUrl = data.imageUrl; toast.success('Imagen encontrada y asignada.', { id: toastId }); } catch (error: any) { toast.error(error.message || 'No se pudo obtener la imagen.', { id: toastId }); imageUrl = null; } finally { isLoading = false; } }; fetchImage(); }); </script> <div class="space-y-4 rounded-lg border p-4"> <input type="hidden" name={inputName} value={imageUrl ?? ''} /> <div class="grid grid-cols-1 gap-4 md:grid-cols-3"> <div class="md:col-span-1"> <Label>Previsualización</Label> <div class="mt-2 flex h-32 w-full items-center justify-center rounded-md border bg-muted/50 text-sm text-muted-foreground" > {#if imageUrl} <img src={imageUrl} alt="Previsualización" class="h-full w-full rounded-md object-cover" /> {:else} Sin imagen {/if} </div> </div> <div class="space-y-4 md:col-span-2"> <div> <Label for="image-upload">Subir un archivo</Label> <Input id="image-upload" type="file" onchange={handleImageUpload} accept="image/*" /> </div> <div class="relative"> <Label for="image-url">O pegar URL de una imagen</Label> <div class="relative flex items-center"> <Input id="image-url" type="url" placeholder="https: bind:value={remoteUrl} class="pr-10" /> {#if isLoading} <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3"> <LoaderCircle class="h-5 w-5 animate-spin text-muted-foreground" /> </div> {/if} </div> </div> </div> </div> </div>

// --- Ruta: src/lib/components/shared/DatePicker.svelte ---
<!-- Ruta: src/lib/components/shared/DatePicker.svelte --> <script lang="ts"> import { Calendar as CalendarIcon } from 'lucide-svelte'; import { DateFormatter, getLocalTimeZone, type DateValue, today } from '@internationalized/date'; import { cn } from '$lib/utils'; import { buttonVariants } from '$lib/components/ui/button'; import { Calendar } from '$lib/components/ui/calendar'; import * as Popover from '$lib/components/ui/popover'; type Props = { value?: DateValue | undefined; }; let { value: date = $bindable(today(getLocalTimeZone())) }: Props = $props(); const df = new DateFormatter('es-ES', { dateStyle: 'long' }); </script> <Popover.Root> <Popover.Trigger class={cn( buttonVariants({ variant: 'outline' }), 'w-full justify-start text-left font-normal', !date && 'text-muted-foreground' )} > <CalendarIcon class="mr-2 h-4 w-4" /> {date ? df.format(date.toDate(getLocalTimeZone())) : 'Selecciona una fecha'} </Popover.Trigger> <Popover.Content class="w-auto p-0"> <Calendar bind:value={date} type="single" initialFocus /> </Popover.Content> </Popover.Root>

// --- Ruta: src/lib/components/shared/AddCustomProductDialog.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import * as Dialog from '$lib/components/ui/dialog'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import { enhance } from '$app/forms'; import { toast } from 'svelte-sonner'; import { invalidateAll } from '$app/navigation'; let { open = $bindable(), form = $bindable(), action = '?/addCustom' } = $props<{ open: boolean; form: any; action?: string; }>(); let name = $state(form?.data?.name ?? ''); let calories = $state(form?.data?.calories ?? ''); let protein = $state(form?.data?.protein ?? ''); let fat = $state(form?.data?.fat ?? ''); let carbs = $state(form?.data?.carbs ?? ''); $effect(() => { if (form?.data) { name = form.data.name ?? ''; calories = form.data.calories ?? ''; protein = form.data.protein ?? ''; fat = form.data.fat ?? ''; carbs = form.data.carbs ?? ''; } }); function clearForm() { name = ''; calories = ''; protein = ''; fat = ''; carbs = ''; form = null; } function closeDialog() { open = false; } </script> <Dialog.Root bind:open onOpenChange={(isOpen) => !isOpen && closeDialog()}> <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Añadir nuevo producto</Dialog.Title> <Dialog.Description>Añade un nuevo producto con sus macros por 100g.</Dialog.Description> </Dialog.Header> <form method="POST" {action} use:enhance={() => { const toastId = toast.loading('Añadiendo producto...'); return async ({ result }) => { if (result.type === 'success') { toast.success('Producto añadido con éxito.', { id: toastId, duration: 2000 }); closeDialog(); clearForm(); await invalidateAll(); } else if (result.type === 'failure') { form = result.data; toast.error('Error al añadir el producto.', { id: toastId }); } else if (result.type !== 'error') { toast.dismiss(toastId); } if (result.type === 'error') { toast.error('Error inesperado del servidor.', { id: toastId }); } }; }} > <div class="grid gap-4 py-4"> <div class="grid grid-cols-4 items-center gap-4"> <Label for="name" class="text-right">Nombre</Label> <Input id="name" name="name" class="col-span-3" required bind:value={name} /> </div> {#if form?.errors?.name} <p class="col-span-3 col-start-2 text-sm text-red-500">{form.errors.name[0]}</p> {/if} <div class="grid grid-cols-4 items-center gap-4"> <Label for="calories" class="text-right">Calorías</Label> <Input id="calories" name="calories" type="number" step="0.01" class="col-span-3 hide-arrows" required bind:value={calories} /> </div> {#if form?.errors?.calories} <p class="col-span-3 col-start-2 text-sm text-red-500">{form.errors.calories[0]}</p> {/if} <div class="grid grid-cols-4 items-center gap-4"> <Label for="fat" class="text-right">Grasas</Label> <Input id="fat" name="fat" type="number" step="0.01" class="col-span-3 hide-arrows" required bind:value={fat} /> </div> {#if form?.errors?.fat} <p class="col-span-3 col-start-2 text-sm text-red-500">{form.errors.fat[0]}</p> {/if} <div class="grid grid-cols-4 items-center gap-4"> <Label for="carbs" class="text-right">Carbs</Label> <Input id="carbs" name="carbs" type="number" step="0.01" class="col-span-3 hide-arrows" required bind:value={carbs} /> </div> {#if form?.errors?.carbs} <p class="col-span-3 col-start-2 text-sm text-red-500">{form.errors.carbs[0]}</p> {/if} <div class="grid grid-cols-4 items-center gap-4"> <Label for="protein" class="text-right">Proteínas</Label> <Input id="protein" name="protein" type="number" step="0.01" class="col-span-3 hide-arrows" required bind:value={protein} /> </div> {#if form?.errors?.protein} <p class="col-span-3 col-start-2 text-sm text-red-500">{form.errors.protein[0]}</p> {/if} </div> <Dialog.Footer> <Dialog.Close class={buttonVariants({ variant: 'outline' })} onclick={closeDialog} >Cancelar</Dialog.Close > <Button type="submit">Guardar</Button> </Dialog.Footer> </form> </Dialog.Content> </Dialog.Root>

// --- Ruta: src/lib/components/recipes/UrlImageFetcher.svelte ---
<!-- Ruta: src/lib/components/recipes/UrlImageFetcher.svelte --> <script lang="ts"> import { Input } from '$lib/components/ui/input'; import { Button } from '$lib/components/ui/button'; import { Trash2, Loader, BadgeCheck, TriangleAlert } from 'lucide-svelte'; type UrlState = { status: 'idle' | 'loading' | 'success' | 'error'; message: string; }; let { urls = $bindable(), imageUrl = $bindable() } = $props<{ urls?: string[]; imageUrl?: string | null; }>(); let urlStates: UrlState[] = $state([]); $effect(() => { const newStates = (urls ?? []).map((_, i) => { return urlStates[i] ?? { status: 'idle', message: '' }; }); if (JSON.stringify(newStates) !== JSON.stringify(urlStates)) { urlStates = newStates; } }); function addUrlField() { if (urls) { urls.push(''); urls = urls; urlStates.push({ status: 'idle', message: '' }); } } function removeUrlField(index: number) { if (urls) { urls.splice(index, 1); urls = urls; urlStates.splice(index, 1); } } async function handleUrlBlur(index: number) { const url = urls?.[index]; if (!url || !url.startsWith('http')) { urlStates[index] = { status: 'idle', message: '' }; return; } if (imageUrl) return; urlStates[index] = { status: 'loading', message: '' }; try { const response = await fetch('/api/scrape-image', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url }) }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.message || 'Error desconocido'); } const data = await response.json(); if (data.imageUrl) { imageUrl = data.imageUrl; urlStates[index] = { status: 'success', message: 'Imagen encontrada' }; } else { throw new Error('No se encontró una imagen en la URL.'); } } catch (error) { urlStates[index] = { status: 'error', message: error instanceof Error ? error.message : 'No se pudo obtener la imagen' }; } } </script> <div class="space-y-2"> {#each urls as _, i} <div class="flex items-center gap-2"> <div class="relative flex-grow"> <Input type="url" placeholder="https: bind:value={urls[i]} onblur={() => handleUrlBlur(i)} class="pr-10" /> <div class="absolute inset-y-0 right-0 flex items-center pr-3"> {#if urlStates[i]?.status === 'loading'} <Loader class="h-5 w-5 animate-spin text-gray-400" /> {:else if urlStates[i]?.status === 'success'} <BadgeCheck class="h-5 w-5 text-green-500" /> {:else if urlStates[i]?.status === 'error'} <TriangleAlert class="h-5 w-5 text-red-500" /> {/if} </div> </div> <Button type="button" variant="ghost" size="icon" onclick={() => removeUrlField(i)}> <Trash2 class="h-4 w-4" /> </Button> </div> {#if urlStates[i]?.status === 'error'} <p class="text-sm text-red-500 ml-1">{urlStates[i].message}</p> {/if} {/each} <Button type="button" variant="outline" size="sm" onclick={addUrlField}> Añadir URL </Button> </div>

// --- Ruta: src/lib/components/recipes/SortOptions.svelte ---
<script lang="ts"> import { Button } from '$lib/components/ui/button/index.js'; import * as Select from '$lib/components/ui/select/index.js'; import ArrowUp from 'lucide-svelte/icons/arrow-up'; import ArrowDown from 'lucide-svelte/icons/arrow-down'; export type SortField = | 'title' | 'calories' | 'protein_grams' | 'fat_grams' | 'carbs_grams' | 'protein_percent' | 'fat_percent' | 'carbs_percent'; export type SortDirection = 'asc' | 'desc'; let { field = 'title', direction = 'asc', onFieldChange, onDirectionChange }: { field: SortField; direction: SortDirection; onFieldChange: (value: SortField) => void; onDirectionChange: (value: SortDirection) => void; } = $props(); const sortOptions: { value: SortField; label: string }[] = [ { value: 'title', label: 'Nombre' }, { value: 'calories', label: 'Calorías' }, { value: 'protein_grams', label: 'Proteínas (g)' }, { value: 'fat_grams', label: 'Grasas (g)' }, { value: 'carbs_grams', label: 'Carbohidratos (g)' }, { value: 'protein_percent', label: 'Proteínas (%)' }, { value: 'fat_percent', label: 'Grasas (%)' }, { value: 'carbs_percent', label: 'Carbohidratos (%)' } ]; const triggerContent = $derived( sortOptions.find((opt) => opt.value === field)?.label ?? 'Seleccionar...' ); </script> <div class="space-y-2"> <label for="sort-by" class="text-sm font-medium">Ordenar por</label> <div class="flex items-center gap-2"> <Select.Root type="single" value={field} onValueChange={(value: string | undefined) => { if (value) { onFieldChange(value as SortField); } }} > <Select.Trigger id="sort-by" class="flex-grow"> {triggerContent} </Select.Trigger> <Select.Content> {#each sortOptions as option (option.value)} <Select.Item value={option.value} label={option.label}>{option.label}</Select.Item> {/each} </Select.Content> </Select.Root> <Button variant={direction === 'asc' ? 'secondary' : 'ghost'} size="icon" onclick={() => onDirectionChange('asc')} aria-label="Orden ascendente" > <ArrowUp class="h-4 w-4" /> </Button> <Button variant={direction === 'desc' ? 'secondary' : 'ghost'} size="icon" onclick={() => onDirectionChange('desc')} aria-label="Orden descendente" > <ArrowDown class="h-4 w-4" /> </Button> </div> </div>

// --- Ruta: src/lib/components/recipes/RecipeStepsManager.svelte ---
<!-- src/lib/components/recipes/RecipeStepsManager.svelte --> <script lang="ts"> import { Button } from '$lib/components/ui/button'; import { Label } from '$lib/components/ui/label'; import { Textarea } from '$lib/components/ui/textarea'; import { Trash2 } from 'lucide-svelte'; import type { RecipeStep } from '$lib/models/RecipeFormState.svelte'; let { steps, onAdd, onRemove, onUpdateText, errors }: { steps: RecipeStep[]; onAdd: () => void; onRemove: (id: string) => void; onUpdateText: (id: string, text: string) => void; errors?: string; } = $props(); </script> <div class="space-y-4"> <Label class="text-lg font-medium">Pasos de la Receta</Label> {#each steps as step, i (step.id)} <div class="flex items-start gap-2"> <div class="flex-1 space-y-1"> <Label for={step.id} class="text-sm font-normal text-gray-600">Paso {i + 1}</Label> <Textarea id={step.id} name={`step-${step.id}`} value={step.text} oninput={(e) => onUpdateText(step.id, e.currentTarget.value)} rows={3} placeholder="Describe este paso... (soporta Markdown)" /> </div> <Button type="button" variant="ghost" size="icon" onclick={() => onRemove(step.id)} class="mt-6" aria-label="Eliminar paso" > <Trash2 class="h-4 w-4" /> </Button> </div> {/each} <Button type="button" variant="outline" onclick={onAdd}>Añadir Paso</Button> {#if errors} <p class="text-sm text-red-500">{errors}</p> {/if} </div>

// --- Ruta: src/lib/components/recipes/RecipeForm.svelte ---
<!-- Ruta: src/lib/components/recipes/RecipeForm.svelte --> <script lang="ts"> import { enhance, applyAction } from '$app/forms'; import { onMount } from 'svelte'; import { toast } from 'svelte-sonner'; import { fly } from 'svelte/transition'; import { Save, X, Check, LoaderCircle } from 'lucide-svelte'; import { createRecipeState, type FormState } from '$lib/models/RecipeFormState.svelte'; import { calculateNutritionalInfo } from '$lib/recipeCalculator'; import * as autosave from '$lib/runes/useAutosave.svelte'; import { Button } from '$lib/components/ui/button'; import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import * as Alert from '$lib/components/ui/alert'; import ImageManager from '../shared/ImageManager.svelte'; import RecipeStepsManager from './RecipeStepsManager.svelte'; import IngredientsList from './IngredientsList.svelte'; import IngredientSearch from './IngredientSearch.svelte'; import NutritionalInfoPanel from './NutritionalInfoPanel.svelte'; let { initialData = null, form = null, cardTitle = 'Crear Nueva Receta', submitButtonText = 'Guardar Receta', onSuccess = async () => {}, recipeId = null }: { initialData?: any | null; form?: { message?: string; errors?: Record<string, string | undefined> } | null; cardTitle?: string; submitButtonText?: string; onSuccess?: () => Promise<void>; recipeId?: string | null; } = $props(); const recipe = createRecipeState(initialData); const formData = recipe.state; const autosaveKey = recipeId ? `recipe-draft-${recipeId}` : 'recipe-draft-new'; let status = $state<'initializing' | 'awaitingDecision' | 'editing'>('initializing'); const isFormDirty = $derived( JSON.stringify(recipe.initialFormState) !== JSON.stringify(formData) ); const autosaveManager = autosave.createAutosave( autosaveKey, () => { const { imageUrl, ...rest } = formData; return rest; }, { enabled: () => status === 'editing', isDirty: () => isFormDirty } ); onMount(() => { if (autosave.hasData(autosaveKey)) { const savedDraft = autosave.load<Omit<FormState, 'imageUrl'>>(autosaveKey); const { imageUrl, ...initialDraft } = recipe.initialFormState; if (savedDraft && JSON.stringify(savedDraft) !== JSON.stringify(initialDraft)) { status = 'awaitingDecision'; } else { autosave.clear(autosaveKey); status = 'editing'; } } else { status = 'editing'; } }); function handleRestore() { const savedDraft = autosave.load<Omit<FormState, 'imageUrl'>>(autosaveKey); if (savedDraft) { const { title, steps, urls, ingredients } = savedDraft; Object.assign(formData, { title, steps, urls, ingredients }); } status = 'editing'; } function handleDiscard() { autosave.clear(autosaveKey); status = 'editing'; } function handleImageUpload(event: Event) { const target = event.target as HTMLInputElement; const file = target.files?.[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { const result = e.target?.result; formData.imageUrl = typeof result === 'string' ? result : null; }; reader.readAsDataURL(file); } } let nutritionalInfo = $derived(calculateNutritionalInfo(formData.ingredients)); let isSubmitting = $state(false); </script> <Card class="max-w-4xl mx-auto"> <CardHeader class="flex flex-row items-center justify-between"> <CardTitle class="mt-4">{cardTitle}</CardTitle> </CardHeader> <CardContent> {#if status === 'awaitingDecision'} <Alert.Root class="mb-6"> <Save class="h-4 w-4" /> <Alert.Title>¡Borrador encontrado!</Alert.Title> <Alert.Description class="flex items-center justify-between"> <p>Hemos encontrado un borrador guardado. ¿Quieres continuar donde lo dejaste?</p> <div class="flex gap-2 mt-2 md:mt-0"> <Button type="button" size="sm" onclick={handleRestore}>Restaurar</Button> <Button type="button" variant="destructive" size="sm" onclick={handleDiscard}> <X class="h-4 w-4 mr-2" /> Descartar </Button> </div> </Alert.Description> </Alert.Root> {/if} <form method="POST" use:enhance={() => { isSubmitting = true; const toastId = toast.loading('Guardando receta...'); return async ({ result }) => { await applyAction(result); isSubmitting = false; if (result.type === 'success') { toast.success('Receta guardada con éxito.', { id: toastId }); autosave.clear(autosaveKey); await onSuccess(); } else if (result.type === 'failure') { const message = form?.message || 'Error al guardar la receta. Revisa los campos.'; toast.error(message, { id: toastId }); } else { toast.dismiss(toastId); } }; }} class="space-y-6" > <!-- Campos ocultos --> <input type="hidden" name="ingredients" value={JSON.stringify( formData.ingredients.map(({ id, quantity, source }) => ({ id, quantity, source })) )} /> <input type="hidden" name="urls" value={JSON.stringify(formData.urls.filter((u) => u.trim() !== ''))} /> <input type="hidden" name="steps" value={JSON.stringify(formData.steps.map((s) => s.text).filter((s) => s.trim() !== ''))} /> <input type="hidden" name="imageUrl" value={formData.imageUrl ?? ''} /> <!-- Campos del formulario --> <div class="space-y-2"> <Label for="title">Título</Label> <Input id="title" name="title" bind:value={formData.title} required /> {#if form?.errors?.title} <p class="text-sm text-red-500">{form.errors.title}</p> {/if} </div> <div class="space-y-2"> <Label>Imagen de la Receta</Label> <ImageManager bind:imageUrl={formData.imageUrl} /> </div> <RecipeStepsManager steps={formData.steps} onAdd={recipe.addStep} onRemove={recipe.removeStep} onUpdateText={recipe.updateStepText} errors={form?.errors?.steps} /> <div class="space-y-4"> <div class="space-y-2"> <Label>Añadir Ingrediente</Label> <IngredientSearch onAdd={recipe.addIngredient} /> </div> <IngredientsList ingredients={formData.ingredients} onRemove={recipe.removeIngredient} onReorder={recipe.reorderIngredients} errors={form?.errors?.ingredients} /> </div> <NutritionalInfoPanel info={nutritionalInfo} /> <div class="flex justify-end"> <Button type="submit" disabled={isSubmitting}>{submitButtonText}</Button> </div> {#if form?.message} <p class="text-sm text-red-500 text-right">{form.message}</p> {/if} </form> </CardContent> </Card> {#if ['saving', 'saved', 'error'].includes(autosaveManager.status)} <div class="fixed bottom-4 right-4 z-50 flex items-center gap-2 rounded-lg border bg-background p-3 text-sm text-muted-foreground shadow-lg" transition:fly={{ y: 20, duration: 300 }} > {#if autosaveManager.status === 'saving'} <LoaderCircle class="h-4 w-4 animate-spin" /> Guardando borrador... {:else if autosaveManager.status === 'saved'} <Check class="h-4 w-4 text-green-500" /> Borrador guardado {:else if autosaveManager.status === 'error'} <X class="h-4 w-4 text-red-500" /> Error al guardar {/if} </div> {/if} <style> :global(.hide-arrows::-webkit-inner-spin-button), :global(.hide-arrows::-webkit-outer-spin-button) { -webkit-appearance: none; margin: 0; } :global(.hide-arrows) { -moz-appearance: textfield; appearance: textfield; } </style>

// --- Ruta: src/lib/components/recipes/RecipeCard.svelte ---
<!-- --> <script lang="ts"> import { calculateNutritionalInfo } from '$lib/recipeCalculator'; import type { CalculableProduct } from '$lib/recipeCalculator'; import * as Card from '$lib/components/ui/card/index.js'; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator, DropdownMenuTrigger } from '$lib/components/ui/dropdown-menu'; import { Button } from '$lib/components/ui/button/index.js'; import MoreVertical from 'lucide-svelte/icons/more-vertical'; import MacroBar from '$lib/components/shared/MacroBar.svelte'; type Recipe = { id: string; slug: string; title: string; imageUrl: string | null; ingredients: { quantity: number; product: { calories: number | null; protein: number | null; fat: number | null; carbs: number | null; }; }[]; }; let { recipe, isAdmin, onEditQuantities, onDelete }: { recipe: Recipe; isAdmin: boolean; onEditQuantities: (recipe: Recipe) => void; onDelete: (recipe: Recipe) => void; } = $props(); let menuOpen = $state(false); const calculableProducts = $derived( recipe.ingredients.map((ing) => { const source = ing.product; return { quantity: ing.quantity, calories: source.calories, protein: source.protein, fat: source.fat, carbs: source.carbs } as CalculableProduct; }) ); const totals = $derived(calculateNutritionalInfo(calculableProducts)); function handleEditQuantities(event: MouseEvent) { event.preventDefault(); onEditQuantities(recipe); menuOpen = false; } function handleDelete(event: MouseEvent) { event.preventDefault(); onDelete(recipe); menuOpen = false; } </script> <Card.Root class="flex flex-col break-inside-avoid"> <a href="/recetas/{recipe.slug}" class="flex flex-col h-full" aria-label="Ver receta: {recipe.title}"> <div class="relative"> {#if recipe.imageUrl} <img src={recipe.imageUrl} alt="Imagen de {recipe.title}" class="aspect-video w-full rounded-t-lg object-cover" /> {/if} {#if isAdmin} <div class="absolute top-2 right-2"> <DropdownMenu bind:open={menuOpen}> <DropdownMenuTrigger class="bg-background/60 hover:bg-background/80 backdrop-blur-sm rounded-full h-8 w-8 inline-flex items-center justify-center" onclick={(e: MouseEvent) => { e.stopPropagation(); e.preventDefault(); }} aria-label="Abrir menú de acciones para {recipe.title}" > <MoreVertical class="h-4 w-4" /> </DropdownMenuTrigger> <DropdownMenuContent class="w-48" align="end" onclick={(e: MouseEvent) => e.stopPropagation()} > <DropdownMenuItem onclick={handleEditQuantities}> Editar cantidades </DropdownMenuItem> <DropdownMenuItem> <a href="/recetas/{recipe.slug}/editar" class="w-full">Editar receta</a> </DropdownMenuItem> <DropdownMenuSeparator /> <DropdownMenuItem onclick={handleDelete} class="text-destructive focus:text-destructive"> Eliminar </DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> </div> {/if} </div> <Card.Header> <Card.Title class="font-heading text-lg text-light pt-2">{recipe.title}</Card.Title> <Card.Description class="py-2">{totals.totalCalories.toFixed(0)} kcal</Card.Description> </Card.Header> <Card.Content class="flex-grow"> <MacroBar protein={totals.totalProtein} carbs={totals.totalCarbs} fat={totals.totalFat} /> </Card.Content> </a> </Card.Root>

// --- Ruta: src/lib/components/recipes/NutritionalInfoPanel.svelte ---
<!-- src/lib/components/recipes/NutritionalInfoPanel.svelte --> <script lang="ts"> import type { NutritionalInfo } from '$lib/recipeCalculator'; let { info }: { info: NutritionalInfo } = $props(); </script> <div class="space-y-2 p-4 border rounded-lg bg-muted/20"> <h3 class="text-lg font-medium">Información Nutricional</h3> <div class="grid grid-cols-2 md:grid-cols-4 gap-4"> <div> <p class="font-bold text-xl">{info.totalCalories.toFixed(1)}</p> <p class="text-sm text-muted-foreground">Calorías (kcal)</p> </div> <div> <p class="font-bold text-xl">{info.totalProtein.toFixed(1)} g</p> <p class="text-sm font-semibold text-blue-500">Proteínas</p> </div> <div> <p class="font-bold text-xl">{info.totalFat.toFixed(1)} g</p> <p class="text-sm font-semibold text-red-500">Grasas</p> </div> <div> <p class="font-bold text-xl">{info.totalCarbs.toFixed(1)} g</p> <p class="text-sm font-semibold text-green-500">Carbohidratos</p> </div> </div> </div>

// --- Ruta: src/lib/components/recipes/MacroFilters.svelte ---
<script lang="ts"> import { Input } from '$lib/components/ui/input/index.js'; import { Label } from '$lib/components/ui/label/index.js'; import { Button } from '$lib/components/ui/button/index.js'; import Trash2 from 'lucide-svelte/icons/trash-2'; type RangeFilter = { min?: number; max?: number }; export type GramFilters = { calories: RangeFilter; protein: RangeFilter; carbs: RangeFilter; fat: RangeFilter; }; export type PercentFilters = { protein: RangeFilter; carbs: RangeFilter; fat: RangeFilter; }; let { gramFilters, percentFilters, onGramsChange, onPercentChange, onClear }: { gramFilters: GramFilters; percentFilters: PercentFilters; onGramsChange: (macro: keyof GramFilters, key: 'min' | 'max', value: number | undefined) => void; onPercentChange: (macro: keyof PercentFilters, key: 'min' | 'max', value: number | undefined) => void; onClear: () => void; } = $props(); function handleGramsInput(macro: keyof GramFilters, key: 'min' | 'max', e: Event) { const target = e.currentTarget as HTMLInputElement; const value = target.valueAsNumber; onGramsChange(macro, key, isNaN(value) ? undefined : value); } function handlePercentInput(macro: keyof PercentFilters, key: 'min' | 'max', e: Event) { const target = e.currentTarget as HTMLInputElement; const value = target.valueAsNumber; onPercentChange(macro, key, isNaN(value) ? undefined : value); } </script> <div class="space-y-4"> <div class="flex items-center justify-between"> <h3 class="text-lg font-semibold">Macronutrientes</h3> <Button onclick={onClear} variant="ghost" size="icon" aria-label="Limpiar filtros de macros"> <Trash2 class="h-4 w-4" /> </Button> </div> <!-- Filtros de Gramos y Calorías --> <div class="space-y-4"> <div class="space-y-2"> <Label for="calories-min">Calorías (kcal)</Label> <div class="flex gap-2"> <Input id="calories-min" type="number" placeholder="Min" class="hide-arrows" value={gramFilters.calories.min ?? ''} oninput={(e) => handleGramsInput('calories', 'min', e)} /> <Input id="calories-max" type="number" placeholder="Max" class="hide-arrows" value={gramFilters.calories.max ?? ''} oninput={(e) => handleGramsInput('calories', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="protein-grams-min">Proteínas (g)</Label> <div class="flex gap-2"> <Input id="protein-grams-min" type="number" placeholder="Min" class="hide-arrows" value={gramFilters.protein.min ?? ''} oninput={(e) => handleGramsInput('protein', 'min', e)} /> <Input id="protein-grams-max" type="number" placeholder="Max" class="hide-arrows" value={gramFilters.protein.max ?? ''} oninput={(e) => handleGramsInput('protein', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="carbs-grams-min">Carbohidratos (g)</Label> <div class="flex gap-2"> <Input id="carbs-grams-min" type="number" placeholder="Min" class="hide-arrows" value={gramFilters.carbs.min ?? ''} oninput={(e) => handleGramsInput('carbs', 'min', e)} /> <Input id="carbs-grams-max" type="number" placeholder="Max" class="hide-arrows" value={gramFilters.carbs.max ?? ''} oninput={(e) => handleGramsInput('carbs', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="fat-grams-min">Grasas (g)</Label> <div class="flex gap-2"> <Input id="fat-grams-min" type="number" placeholder="Min" class="hide-arrows" value={gramFilters.fat.min ?? ''} oninput={(e) => handleGramsInput('fat', 'min', e)} /> <Input id="fat-grams-max" type="number" placeholder="Max" class="hide-arrows" value={gramFilters.fat.max ?? ''} oninput={(e) => handleGramsInput('fat', 'max', e)} /> </div> </div> </div> <hr/> <!-- Filtros de Porcentaje --> <div class="space-y-4"> <div class="space-y-2"> <Label for="protein-percent-min">Proteínas (%)</Label> <div class="flex gap-2"> <Input id="protein-percent-min" type="number" placeholder="Min" class="hide-arrows" value={percentFilters.protein.min ?? ''} oninput={(e) => handlePercentInput('protein', 'min', e)} /> <Input id="protein-percent-max" type="number" placeholder="Max" class="hide-arrows" value={percentFilters.protein.max ?? ''} oninput={(e) => handlePercentInput('protein', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="carbs-percent-min">Carbohidratos (%)</Label> <div class="flex gap-2"> <Input id="carbs-percent-min" type="number" placeholder="Min" class="hide-arrows" value={percentFilters.carbs.min ?? ''} oninput={(e) => handlePercentInput('carbs', 'min', e)} /> <Input id="carbs-percent-max" type="number" placeholder="Max" class="hide-arrows" value={percentFilters.carbs.max ?? ''} oninput={(e) => handlePercentInput('carbs', 'max', e)} /> </div> </div> <div class="space-y-2"> <Label for="fat-percent-min">Grasas (%)</Label> <div class="flex gap-2"> <Input id="fat-percent-min" type="number" placeholder="Min" class="hide-arrows" value={percentFilters.fat.min ?? ''} oninput={(e) => handlePercentInput('fat', 'min', e)} /> <Input id="fat-percent-max" type="number" placeholder="Max" class="hide-arrows" value={percentFilters.fat.max ?? ''} oninput={(e) => handlePercentInput('fat', 'max', e)} /> </div> </div> </div> </div> <style> :global(.hide-arrows::-webkit-inner-spin-button), :global(.hide-arrows::-webkit-outer-spin-button) { -webkit-appearance: none; margin: 0; } :global(.hide-arrows) { -moz-appearance: textfield; appearance: textfield; } </style>

// --- Ruta: src/lib/components/recipes/IngredientsList.svelte ---
<!-- src/lib/components/recipes/IngredientsList.svelte --> <script lang="ts"> import { Input } from '$lib/components/ui/input'; import { Button } from '$lib/components/ui/button'; import { Table, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table'; import { GripVertical, Trash2 } from 'lucide-svelte'; import { draggable, droppable, type DragDropState } from '@thisux/sveltednd'; import type { IngredientWithDetails } from '$lib/models/RecipeFormState.svelte'; let { ingredients, onRemove, onReorder, errors }: { ingredients: IngredientWithDetails[]; onRemove: (id: string) => void; onReorder: (sourceIndex: number, targetIndex: number) => void; errors?: string; } = $props(); function handleDrop(state: DragDropState<IngredientWithDetails>) { const { draggedItem, targetElement } = state; if (!draggedItem || !targetElement) return; const sourceIndex = ingredients.findIndex((item) => item.id === draggedItem.id); const targetRow = (targetElement as HTMLElement).closest('tr'); if (!targetRow || !targetRow.parentElement) return; const targetIndex = Array.from(targetRow.parentElement.children).indexOf(targetRow); if (sourceIndex === -1 || targetIndex === -1) return; onReorder(sourceIndex, targetIndex); } </script> <div class="space-y-2"> <h3 class="text-lg font-medium">Productos de la Receta</h3> <Table> <TableHeader> <TableRow> <TableHead class="w-[50px] hidden md:table-cell"></TableHead> <TableHead>Nombre</TableHead> <TableHead class="w-[100px]">Cantidad (g)</TableHead> <TableHead class="w-[80px] text-right">Acciones</TableHead> </TableRow> </TableHeader> <tbody use:droppable={{ container: 'ingredients', callbacks: { onDrop: handleDrop } }}> {#each ingredients as ingredient, i (ingredient.id)} <tr use:draggable={{ container: 'ingredients', dragData: ingredient, interactive: ['[data-quitar-btn]'] }} class="hover:[&,&>svelte-css-wrapper]:[&>th,td]:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors" > <TableCell class="cursor-grab hidden md:table-cell"> <div class="flex items-center gap-2 text-muted-foreground"> <GripVertical class="h-5 w-5" /> <span class="text-sm font-medium">{i + 1}</span> </div> </TableCell> <TableCell class="max-w-[170px] whitespace-normal md:max-w-none"> {ingredient.name} </TableCell> <TableCell> <Input type="number" bind:value={ingredient.quantity} min="0.1" step="any" class="w-full hide-arrows" /> </TableCell> <TableCell class="text-right"> <Button type="button" variant="destructive" size="icon" data-quitar-btn onclick={() => onRemove(ingredient.id)} aria-label="Quitar ingrediente" > <Trash2 class="h-4 w-4" /> </Button> </TableCell> </tr> {/each} {#if ingredients.length === 0} <tr class="hover:[&,&>svelte-css-wrapper]:[&>th,td]:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors"> <TableCell colspan={4} class="text-center text-gray-500"> Añade productos usando el buscador. </TableCell> </tr> {/if} </tbody> </Table> {#if errors} <p class="text-sm text-red-500">{errors}</p> {/if} </div>

// --- Ruta: src/lib/components/recipes/IngredientSearch.svelte ---
<!-- src/lib/components/recipes/IngredientSearch.svelte --> <script lang="ts"> import { browser } from '$app/environment'; import { ChevronsUpDown, Database } from 'lucide-svelte'; import { toast } from 'svelte-sonner'; import * as Popover from '$lib/components/ui/popover'; import * as Command from '$lib/components/ui/command'; import { cn } from '$lib/utils'; import type { CalculableProduct } from '$lib/recipeCalculator'; type IngredientWithDetails = CalculableProduct & { id: string; name: string; source: 'local' | 'off'; imageUrl?: string | null; }; type SearchResult = { id: string; name: string; source: 'local' | 'off'; imageUrl: string | null; }; let { onAdd }: { onAdd: (ingredient: IngredientWithDetails) => void } = $props(); let searchResults: SearchResult[] = $state([]); let isSearching = $state(false); let open = $state(false); let inputValue = $state(''); let searchTerm = $state(''); let triggerWrapperEl: HTMLDivElement | null = $state(null); $effect(() => { if (browser && open && triggerWrapperEl) { const contentEl = document.querySelector<HTMLDivElement>('[data-slot="popover-content"]'); if (contentEl) { const rect = triggerWrapperEl.getBoundingClientRect(); contentEl.style.width = `${rect.width}px`; } } }); $effect(() => { let eventSource: EventSource | null = null; if (searchTerm.length < 3) { searchResults = []; isSearching = false; } else { const currentSearchTerm = searchTerm; isSearching = true; searchResults = []; eventSource = new EventSource(`/api/products/search?q=${encodeURIComponent(currentSearchTerm)}`); eventSource.addEventListener('message', (e) => { if (currentSearchTerm === searchTerm) { const newResults = JSON.parse(e.data) as SearchResult[]; const combinedResults = [...searchResults, ...newResults]; const uniqueNames = new Set<string>(); const uniqueResults = combinedResults.filter((result) => { const key = result.name + result.source; if (uniqueNames.has(key)) { return false; } uniqueNames.add(key); return true; }); searchResults = uniqueResults; } }); eventSource.addEventListener('local_results', (e) => { if (currentSearchTerm === searchTerm) { const newResults = JSON.parse(e.data) as SearchResult[]; const combinedResults = [...searchResults, ...newResults]; const uniqueNames = new Set<string>(); const uniqueResults = combinedResults.filter((result) => { const key = result.name + result.source; if (uniqueNames.has(key)) { return false; } uniqueNames.add(key); return true; }); searchResults = uniqueResults; } }); eventSource.addEventListener('stream_error', (e) => { if (currentSearchTerm === searchTerm) { console.error('Error de stream:', e); } }); eventSource.onerror = (err) => { console.error('Error en EventSource:', err); if (currentSearchTerm === searchTerm) { isSearching = false; } eventSource?.close(); }; eventSource.addEventListener('close', () => { if (currentSearchTerm === searchTerm) { isSearching = false; } eventSource?.close(); }); } return () => { eventSource?.close(); }; }); async function handleSelect(result: SearchResult) { try { const response = await fetch(`/api/products/details/${result.id}?source=${result.source}`); if (!response.ok) throw new Error('Failed to fetch ingredient details'); const details: Omit<IngredientWithDetails, 'id' | 'source'> = await response.json(); onAdd({ ...details, id: result.id, source: result.source }); } catch (error) { console.error('Error adding ingredient:', error); toast.error('No se pudieron obtener los detalles del ingrediente.'); } finally { open = false; searchResults = []; searchTerm = ''; inputValue = ''; } } </script> <div bind:this={triggerWrapperEl}> <Popover.Root bind:open> <Popover.Trigger class="inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0 bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border w-full justify-between h-9 px-4 py-2" role="combobox" aria-expanded={open} > <div class="flex items-center justify-between w-full"> {inputValue || 'Seleccionar ingrediente...'} <ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" /> </div> </Popover.Trigger> <Popover.Content class="p-0"> <Command.Root filter={() => 1}> <Command.Input bind:value={searchTerm} placeholder="Buscar ingrediente..." /> <Command.List> {#if searchResults.length > 0} {#each searchResults as result (result.id + result.source)} <Command.Item value={result.name} onSelect={() => { inputValue = result.name; handleSelect(result); }} class={cn( 'flex items-center justify-between w-full', result.source === 'local' ? 'bg-muted/50' : '' )} > <div class="flex items-center gap-2"> <img src={result.imageUrl || 'https: alt={result.name} class="h-8 w-8 rounded-sm object-cover" /> <span>{result.name}</span> </div> {#if result.source === 'local'} <Database class="h-4 w-4 text-muted-foreground" /> {/if} </Command.Item> {/each} {:else} <div class="p-4 text-sm text-center text-gray-500"> {#if isSearching} Buscando... {:else if searchTerm.length < 3} Escribe al menos 3 caracteres para buscar... {:else} No se encontraron resultados. {/if} </div> {/if} </Command.List> </Command.Root> </Popover.Content> </Popover.Root> </div>

// --- Ruta: src/lib/components/recipes/IngredientCombobox.svelte ---
<script lang="ts"> import { Button } from '$lib/components/ui/button/index.js'; import * as Popover from '$lib/components/ui/popover/index.js'; import * as Command from '$lib/components/ui/command/index.js'; import ChevronsUpDown from 'lucide-svelte/icons/chevrons-up-down'; import Trash2 from 'lucide-svelte/icons/trash-2'; import { browser } from '$app/environment'; type Ingredient = { id: string; name: string; type: 'product' | 'custom'; source: 'local' | 'off'; imageUrl: string | null; }; let { onSelect, selectedIds = [], onClear }: { onSelect: (ingredient: Ingredient) => void; selectedIds: string[]; onClear: () => void; } = $props(); let open = $state(false); let searchValue = $state(''); let searchResults = $state<Ingredient[]>([]); let isLoading = $state(false); let controller: AbortController; let triggerWrapperEl: HTMLDivElement | null = $state(null); $effect(() => { if (browser && open && triggerWrapperEl) { const contentEl = document.querySelector<HTMLDivElement>('[data-slot="popover-content"]'); if (contentEl) { const rect = triggerWrapperEl.getBoundingClientRect(); contentEl.style.width = `${rect.width}px`; } } }); $effect(() => { controller?.abort(); const query = searchValue; if (query.length < 2 || !open) { searchResults = []; isLoading = false; return; } controller = new AbortController(); async function search() { isLoading = true; try { const response = await fetch(`/api/products/autocomplete?q=${encodeURIComponent(query)}`, { signal: controller.signal }); const allResults: Ingredient[] = await response.json(); searchResults.length = 0; searchResults.push(...allResults.filter((r) => !selectedIds.includes(r.id))); } catch (e) { if (e instanceof DOMException && e.name === 'AbortError') { return; } console.error('Failed to search ingredients', e); searchResults = []; } finally { isLoading = false; } } search(); }); function handleSelect(ingredient: Ingredient) { onSelect(ingredient); searchValue = ''; open = false; } </script> <div class="flex items-center gap-2"> <div class="flex-grow" bind:this={triggerWrapperEl}> <Popover.Root bind:open> <Popover.Trigger role="combobox" class="flex h-10 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 hover:bg-accent hover:text-accent-foreground" > Seleccionar ingrediente... <ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" /> </Popover.Trigger> <Popover.Content data-slot="popover-content" class="p-0"> {#key searchValue} <Command.Root> <Command.Input bind:value={searchValue} placeholder="Buscar ingrediente..." /> <Command.Empty> {#if isLoading} Buscando... {:else if searchValue.length < 2} Escribe al menos 2 letras. {:else} No se encontraron productos. {/if} </Command.Empty> <Command.Group> {#each searchResults as ingredient (ingredient.id)} <Command.Item onSelect={() => handleSelect(ingredient)}> {ingredient.name} </Command.Item> {/each} </Command.Group> </Command.Root> {/key} </Popover.Content> </Popover.Root> </div> {#if selectedIds.length > 0} <Button onclick={onClear} variant="ghost" size="icon" aria-label="Limpiar productos seleccionados"> <Trash2 class="h-4 w-4" /> </Button> {/if} </div>

// --- Ruta: src/lib/components/recipes/EditQuantitiesDialog.svelte ---
<!-- Fichero: src/lib/components/recipes/EditQuantitiesDialog.svelte --> <script lang="ts"> import { calculateNutritionalInfo, type CalculableProduct } from '$lib/recipeCalculator'; import * as Dialog from '$lib/components/ui/dialog/index.js'; import { Input } from '$lib/components/ui/input/index.js'; import { Label } from '$lib/components/ui/label/index.js'; import { Button } from '$lib/components/ui/button/index.js'; type Recipe = { id: string; title: string; ingredients: { quantity: number; product: { id: string; name: string; calories: number | null; protein: number | null; fat: number | null; carbs: number | null; }; }[]; }; let { recipe, open = $bindable(), onOpenChange }: { recipe: Recipe | null; open?: boolean; onOpenChange: (isOpen: boolean) => void; } = $props(); let editableIngredients = $state< { id: string; name: string; quantity: number; baseValues: Omit<CalculableProduct, 'quantity'>; }[] >([]); $effect(() => { if (open && recipe) { editableIngredients = recipe.ingredients.map((ing) => { const source = ing.product; const id = source.id; const name = source.name; return { id, name, quantity: ing.quantity, baseValues: { calories: source.calories, protein: source.protein, fat: source.fat, carbs: source.carbs } }; }); } else { editableIngredients = []; } }); const originalTotals = $derived( recipe ? calculateNutritionalInfo( recipe.ingredients.map((ing) => { const source = ing.product; return { quantity: ing.quantity, calories: source.calories, protein: source.protein, fat: source.fat, carbs: source.carbs }; }) ) : null ); const newTotals = $derived( calculateNutritionalInfo( editableIngredients.map((ing) => ({ ...ing.baseValues, quantity: Number(ing.quantity) || 0 })) ) ); </script> <Dialog.Root bind:open onOpenChange={onOpenChange}> <Dialog.Content class="sm:max-w-[600px]"> <Dialog.Header> <Dialog.Title>Editar Cantidades: {recipe?.title}</Dialog.Title> <Dialog.Description> Ajusta las cantidades en gramos para esta preparación específica. Los cambios no afectarán a la receta original. </Dialog.Description> </Dialog.Header> <div class="grid gap-4 py-4"> {#each editableIngredients as ingredient (ingredient.id)} <div class="grid grid-cols-4 items-center gap-4"> <Label for={ingredient.id} class="text-right col-span-2">{ingredient.name}</Label> <Input id={ingredient.id} type="number" bind:value={ingredient.quantity} class="col-span-2" /> </div> {/each} </div> <hr /> <!-- Justificación: Se añade un data-testid al contenedor para poder seleccionarlo de forma inequívoca en los tests. --> <div data-testid="comparison-section" class="grid grid-cols-2 gap-x-8 gap-y-2 mt-4 text-sm"> <h3 class="font-semibold col-span-2">Comparativa Nutricional</h3> <div class="font-medium text-muted-foreground">Original</div> <div class="font-medium text-muted-foreground">Recalculado</div> <div>Calorías: {originalTotals?.totalCalories.toFixed(0) ?? 0} kcal</div> <div class="font-semibold">Calorías: {newTotals.totalCalories.toFixed(0)} kcal</div> <div>Proteínas: {originalTotals?.totalProtein.toFixed(1) ?? 0} g</div> <div class="font-semibold">Proteínas: {newTotals.totalProtein.toFixed(1)} g</div> <div>Grasas: {originalTotals?.totalFat.toFixed(1) ?? 0} g</div> <div class="font-semibold">Grasas: {newTotals.totalFat.toFixed(1)} g</div> <div>Carbohidratos: {originalTotals?.totalCarbs.toFixed(1) ?? 0} g</div> <div class="font-semibold">Carbohidratos: {newTotals.totalCarbs.toFixed(1)} g</div> </div> <Dialog.Footer> <!-- Justificación: Se añade un data-testid al botón para seleccionarlo sin ambigüedad. --> <Button data-testid="dialog-close-button" onclick={() => onOpenChange(false)}>Cerrar</Button> </Dialog.Footer> </Dialog.Content> </Dialog.Root>

// --- Ruta: src/lib/components/recipes/DeleteRecipeDialog.svelte ---
<!-- --> <script lang="ts"> import { enhance, applyAction } from '$app/forms'; import * as AlertDialog from '$lib/components/ui/alert-dialog/index.js'; import { Button } from '$lib/components/ui/button/index.js'; import { toast } from 'svelte-sonner'; type Recipe = { id: string; title: string; }; let { recipe, open = $bindable(), onOpenChange }: { recipe: Recipe | null; open?: boolean; onOpenChange: (isOpen: boolean) => void; } = $props(); let formElement: HTMLFormElement; function handleConfirmClick() { if (formElement) { formElement.requestSubmit(); } } </script> <AlertDialog.Root bind:open onOpenChange={onOpenChange}> <AlertDialog.Content> <AlertDialog.Header> <AlertDialog.Title>¿Estás absolutely seguro?</AlertDialog.Title> <AlertDialog.Description> Esta acción no se puede deshacer. Esto eliminará permanentemente la receta de <strong>{@html recipe?.title ?? 'seleccionada'}</strong>. </AlertDialog.Description> </AlertDialog.Header> <form method="POST" action="?/delete" bind:this={formElement} use:enhance={() => { onOpenChange(false); const toastId = toast.loading('Eliminando receta...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Receta eliminada correctamente.', { id: toastId }); } else if (result.type === 'failure') { toast.error('No se pudo eliminar la receta.', { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <input type="hidden" name="id" value={recipe?.id} /> </form> <AlertDialog.Footer> <AlertDialog.Cancel>Cancelar</AlertDialog.Cancel> <AlertDialog.Action onclick={handleConfirmClick}> <Button variant="destructive">Eliminar</Button> </AlertDialog.Action> </AlertDialog.Footer> </AlertDialog.Content> </AlertDialog.Root>

// --- Ruta: src/lib/components/diary/NutritionalSummary.svelte ---
<!-- Ruta: src/lib/components/diary/NutritionalSummary.svelte --> <script lang="ts"> import MacroBar from '$lib/components/shared/MacroBar.svelte'; import type { AggregatedNutrients } from '$lib/utils'; import { Skeleton } from '$lib/components/ui/skeleton'; let { nutrients, days, isLoading = false }: { nutrients: AggregatedNutrients; days: number; isLoading?: boolean; } = $props(); </script> <div class="space-y-6"> {#if isLoading} <!-- Skeleton for Totales --> <div class="space-y-2"> <Skeleton class="h-6 w-48" /> <div class="p-4 border rounded-lg bg-muted/50 space-y-3"> <div class="flex justify-between items-baseline"> <Skeleton class="h-5 w-16" /> <Skeleton class="h-6 w-24" /> </div> <Skeleton class="h-5 w-full" /> </div> </div> <!-- Skeleton for Promedio --> <div class="space-y-2"> <Skeleton class="h-6 w-40" /> <div class="p-4 border rounded-lg bg-muted/50 space-y-3"> <div class="flex justify-between items-baseline"> <Skeleton class="h-5 w-16" /> <Skeleton class="h-6 w-24" /> </div> <Skeleton class="h-5 w-full" /> </div> </div> {:else} <!-- Totales del Periodo --> <div> <h3 class="text-lg font-semibold mb-2">Totales del período ({days} día{days > 1 ? 's' : ''})</h3> <div class="p-4 border rounded-lg bg-muted/50"> <div class="flex justify-between items-baseline mb-2"> <span class="text-sm font-medium">Calorías</span> <span class="text-lg font-bold" >{nutrients.total.calories.toLocaleString('es-ES', { maximumFractionDigits: 0 })} kcal</span > </div> <MacroBar protein={nutrients.total.protein} carbs={nutrients.total.carbs} fat={nutrients.total.fat} /> </div> </div> <!-- Promedio Diario --> {#if days > 1} <div> <h3 class="text-lg font-semibold mb-2">Promedio diario</h3> <div class="p-4 border rounded-lg bg-muted/50"> <div class="flex justify-between items-baseline mb-2"> <span class="text-sm font-medium">Calorías</span> <span class="text-lg font-bold" >{nutrients.average.calories.toLocaleString('es-ES', { maximumFractionDigits: 0 })} kcal</span > </div> <MacroBar protein={nutrients.average.protein} carbs={nutrients.average.carbs} fat={nutrients.average.fat} /> </div> </div> {/if} {/if} </div>

// --- Ruta: src/lib/components/diary/EditEntryDialog.svelte ---
<!-- Ruta: src/lib/components/diary/EditEntryDialog.svelte --> <script lang="ts"> import { calculateNutritionalInfo, type CalculableProduct } from '$lib/recipeCalculator'; import * as Dialog from '$lib/components/ui/dialog/index.js'; import { Input } from '$lib/components/ui/input/index.js'; import { Label } from '$lib/components/ui/label/index.js'; import { Button } from '$lib/components/ui/button/index.js'; import type { DiaryEntry } from '@prisma/client'; type IngredientJson = { id: string; name: string; quantity: number; baseValues: Omit<CalculableProduct, 'quantity'>; }; type EditableIngredient = IngredientJson; let { entry, open = $bindable(), onOpenChange, onSave }: { entry: DiaryEntry | null; open?: boolean; onOpenChange: (isOpen: boolean) => void; onSave: (updatedEntry: DiaryEntry) => void; } = $props(); let editableQuantity = $state(0); let editableIngredients = $state<EditableIngredient[]>([]); $effect(() => { if (open && entry) { if (entry.type === 'PRODUCT') { editableQuantity = entry.quantity; editableIngredients = []; } else if (entry.type === 'RECIPE' && entry.ingredients) { const ingredients = entry.ingredients; if (Array.isArray(ingredients)) { editableIngredients = ingredients as EditableIngredient[]; } editableQuantity = 0; } } else { editableQuantity = 0; editableIngredients = []; } }); const originalTotals = $derived( entry ? { totalCalories: entry.calories, totalProtein: entry.protein, totalFat: entry.fat, totalCarbs: entry.carbs } : null ); const newTotals = $derived( entry?.type === 'PRODUCT' ? calculateNutritionalInfo([ { calories: entry.calories / entry.quantity * editableQuantity, protein: entry.protein / entry.quantity * editableQuantity, fat: entry.fat / entry.quantity * editableQuantity, carbs: entry.carbs / entry.quantity * editableQuantity, quantity: editableQuantity } ]) : calculateNutritionalInfo( editableIngredients.map((ing) => ({ ...ing.baseValues, quantity: Number(ing.quantity) || 0 })) ) ); function handleSaveChanges() { if (!entry) return; const updatedEntry: DiaryEntry = { ...entry, quantity: entry.type === 'PRODUCT' ? editableQuantity : entry.quantity, calories: newTotals.totalCalories, protein: newTotals.totalProtein, fat: newTotals.totalFat, carbs: newTotals.totalCarbs, ingredients: entry.type === 'RECIPE' ? (editableIngredients as unknown as import('@prisma/client').Prisma.JsonArray) : null }; onSave(updatedEntry); onOpenChange(false); } </script> <Dialog.Root bind:open {onOpenChange}> <Dialog.Content class="sm:max-w-[600px]"> <Dialog.Header> <Dialog.Title>Editar Entrada: {entry?.name}</Dialog.Title> <Dialog.Description> Ajusta las cantidades para esta entrada. Los cambios se guardarán en tu diario. </Dialog.Description> </Dialog.Header> <div class="grid gap-4 py-4"> {#if entry?.type === 'PRODUCT'} <div class="grid grid-cols-4 items-center gap-4"> <Label for="quantity" class="text-right">Cantidad (g)</Label> <Input id="quantity" type="number" bind:value={editableQuantity} class="col-span-3" /> </div> {:else if entry?.type === 'RECIPE'} {#each editableIngredients as ingredient (ingredient.id)} <div class="grid grid-cols-4 items-center gap-4"> <Label for={ingredient.id} class="text-right col-span-2">{ingredient.name}</Label> <Input id={ingredient.id} type="number" bind:value={ingredient.quantity} class="col-span-2" /> </div> {/each} {/if} </div> <hr /> <div class="grid grid-cols-2 gap-x-8 gap-y-2 mt-4 text-sm"> <h3 class="font-semibold col-span-2">Comparativa Nutricional</h3> <div class="font-medium text-muted-foreground">Original</div> <div class="font-medium text-muted-foreground">Recalculado</div> <div>Calorías: {originalTotals?.totalCalories.toFixed(0) ?? 0} kcal</div> <div class="font-semibold">Calorías: {newTotals.totalCalories.toFixed(0)} kcal</div> <div>Proteínas: {originalTotals?.totalProtein.toFixed(1) ?? 0} g</div> <div class="font-semibold">Proteínas: {newTotals.totalProtein.toFixed(1)} g</div> <div>Grasas: {originalTotals?.totalFat.toFixed(1) ?? 0} g</div> <div class="font-semibold">Grasas: {newTotals.totalFat.toFixed(1)} g</div> <div>Carbohidratos: {originalTotals?.totalCarbs.toFixed(1) ?? 0} g</div> <div class="font-semibold">Carbohidratos: {newTotals.totalCarbs.toFixed(1)} g</div> </div> <Dialog.Footer> <Button variant="outline" onclick={() => onOpenChange(false)}>Cancelar</Button> <Button onclick={handleSaveChanges}>Guardar Cambios</Button> </Dialog.Footer> </Dialog.Content> </Dialog.Root>

// --- Ruta: src/lib/components/diary/DiaryEntryList.svelte ---
<!-- Ruta: src/lib/components/diary/DiaryEntryList.svelte --> <script lang="ts"> import type { DiaryEntry } from '@prisma/client'; import MacroBar from '$lib/components/shared/MacroBar.svelte'; import { Button } from '$lib/components/ui/button'; import * as AlertDialog from '$lib/components/ui/alert-dialog'; import Pencil from 'lucide-svelte/icons/pencil'; import Trash2 from 'lucide-svelte/icons/trash-2'; import EditEntryDialog from './EditEntryDialog.svelte'; import { Separator } from '$lib/components/ui/separator'; import { Skeleton } from '$lib/components/ui/skeleton'; import { ArrowUp, ArrowDown } from 'lucide-svelte'; import { formatInTimeZone } from 'date-fns-tz'; import { getLocalTimeZone } from '@internationalized/date'; let { entries, onDelete, isLoading = false }: { entries: DiaryEntry[]; onDelete: (entry: DiaryEntry) => void; isLoading?: boolean; } = $props(); let sortOrder: 'asc' | 'desc' = $state('asc'); const timezone = getLocalTimeZone(); let selectedEntry = $state<DiaryEntry | null>(null); let entryToDelete = $state<DiaryEntry | null>(null); let isEditDialogOpen = $state(false); let isDeleteDialogOpen = $state(false); const groupedEntriesArray = $derived(() => { if (entries.length === 0) return []; const map = new Map<string, DiaryEntry[]>(); for (const entry of entries) { const dateKey = formatInTimeZone(entry.date, timezone, 'yyyy-MM-dd'); if (!map.has(dateKey)) { map.set(dateKey, []); } map.get(dateKey)!.push(entry); } const sorted = Array.from(map.entries()).sort((a, b) => { if (sortOrder === 'asc') { return a[0].localeCompare(b[0]); } else { return b[0].localeCompare(a[0]); } }); return sorted; }); const dateFormatter = new Intl.DateTimeFormat('es-ES', { dateStyle: 'full' }); function toggleSortOrder() { sortOrder = sortOrder === 'asc' ? 'desc' : 'asc'; } function handleOpenEditDialog(entry: DiaryEntry) { selectedEntry = entry; isEditDialogOpen = true; } function handleOpenDeleteDialog(entry: DiaryEntry) { entryToDelete = entry; isDeleteDialogOpen = true; } function confirmDelete() { if (entryToDelete) { onDelete(entryToDelete); } isDeleteDialogOpen = false; } async function handleSave(updatedEntry: DiaryEntry) { try { const response = await fetch(`/api/diary/${updatedEntry.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(updatedEntry) }); if (response.ok) { const result = await response.json(); const index = entries.findIndex((e) => e.id === result.id); if (index !== -1) { entries[index] = result; } } else { console.error('Error al actualizar la entrada:', await response.text()); } } catch (error) { console.error('Error de red al actualizar:', error); } } </script> <div class="p-4 border rounded-lg bg-card text-card-foreground"> <div class="flex justify-between items-center mb-4"> <h2 class="text-xl font-light">Comidas</h2> <Button onclick={toggleSortOrder} variant="ghost" size="sm"> {#if sortOrder === 'asc'} <ArrowUp class="h-4 w-4 mr-2" /> <span>Más antiguos</span> {:else} <ArrowDown class="h-4 w-4 mr-2" /> <span>Más recientes</span> {/if} </Button> </div> <div class="space-y-4"> {#if isLoading} <div class="space-y-3"> {#each { length: 4 } as _} <div class="flex flex-row items-start md:items-center gap-4 rounded-lg border p-3 bg-card" > <div class="flex-1 min-w-0 space-y-2"> <Skeleton class="h-5 w-3/4" /> <Skeleton class="h-4 w-1/2" /> </div> <div class="w-40 md:w-64 flex-shrink-0"> <Skeleton class="h-5 w-full" /> </div> <div class="flex gap-2 self-end md:self-center"> <Skeleton class="h-9 w-9" /> <Skeleton class="h-9 w-9" /> </div> </div> {/each} </div> {:else if groupedEntriesArray().length === 0} <p class="text-center text-muted-foreground py-8"> No hay entradas para la fecha seleccionada. </p> {:else} {#each groupedEntriesArray() as [dateKey, dayEntries] (dateKey)} <div class="day-group pt-4 pb-4"> <div class="flex items-center gap-4 mb-3"> <h3 class="text-lg font-semibold whitespace-nowrap"> {dateFormatter.format(new Date(dateKey + 'T00:00:00'))} </h3> <Separator class="flex-1" /> </div> <div class="space-y-3"> {#each dayEntries as entry (entry.id)} <div class="flex flex-row items-start md:items-center gap-4 rounded-lg border p-3 bg-card" > <!-- Nombre y cantidad (apilable) --> <div class="flex-1 min-w-0"> <p class="font-semibold whitespace-normal">{entry.name}</p> <p class="text-sm text-muted-foreground"> {entry.quantity.toFixed(0)}g &bull; {entry.calories.toFixed(0)} kcal </p> </div> <!-- MacroBar (ocupa más espacio en pantallas grandes) --> <div class="w-40 md:w-64 flex-shrink-0"> <MacroBar protein={entry.protein} carbs={entry.carbs} fat={entry.fat} /> </div> <!-- Botones de acción --> <div class="flex gap-2 self-end md:self-center"> <Button onclick={() => handleOpenEditDialog(entry)} variant="ghost" size="icon" > <Pencil class="h-4 w-4" /> <span class="sr-only">Editar</span> </Button> <Button onclick={() => handleOpenDeleteDialog(entry)} variant="ghost" size="icon" > <Trash2 class="h-4 w-4" /> <span class="sr-only">Eliminar</span> </Button> </div> </div> {/each} </div> </div> {/each} {/if} </div> </div> <!-- Diálogo de Edición --> <EditEntryDialog entry={selectedEntry} bind:open={isEditDialogOpen} onOpenChange={(isOpen) => (isEditDialogOpen = isOpen)} onSave={handleSave} /> <!-- Diálogo de Confirmación de Eliminación --> <AlertDialog.Root bind:open={isDeleteDialogOpen}> <AlertDialog.Content> <AlertDialog.Header> <AlertDialog.Title>¿Estás seguro?</AlertDialog.Title> <AlertDialog.Description> Esta acción no se puede deshacer. Se eliminará permanentemente la entrada "{entryToDelete?.name}" de tu diario. </AlertDialog.Description> </AlertDialog.Header> <AlertDialog.Footer> <AlertDialog.Cancel>Cancelar</AlertDialog.Cancel> <AlertDialog.Action onclick={confirmDelete}>Eliminar</AlertDialog.Action> </AlertDialog.Footer> </AlertDialog.Content> </AlertDialog.Root>

// --- Ruta: src/lib/components/diary/AddItemPanel.svelte ---
<!-- Ruta: src/lib/components/diary/AddItemPanel.svelte --> <script lang="ts"> import { browser } from '$app/environment'; import * as Popover from '$lib/components/ui/popover'; import * as Command from '$lib/components/ui/command'; import ChevronsUpDown from 'lucide-svelte/icons/chevrons-up-down'; import type { Product } from '@prisma/client'; import type { FullRecipe } from '$lib/models/recipe'; import DatePicker from '$lib/components/shared/DatePicker.svelte'; import { getLocalTimeZone, today, type DateValue } from '@internationalized/date'; type SearchResult = (Product & { type: 'PRODUCT' }) | (FullRecipe & { type: 'RECIPE' }); let { onAddItem }: { onAddItem: (data: { item: SearchResult; date: Date }) => void } = $props(); let addDate: DateValue = $state(today(getLocalTimeZone())); let open = $state(false); let searchTerm = $state(''); let searchResults = $state<SearchResult[]>([]); let isLoading = $state(false); let controller: AbortController; let triggerWrapperEl: HTMLDivElement | null = $state(null); $effect(() => { if (browser && open && triggerWrapperEl) { const contentEl = document.querySelector<HTMLDivElement>('[data-add-item-popover-content]'); if (contentEl) { const rect = triggerWrapperEl.getBoundingClientRect(); contentEl.style.width = `${rect.width}px`; } } }); $effect(() => { controller?.abort(); const query = searchTerm; if (query.length < 2) { searchResults = []; isLoading = false; return; } controller = new AbortController(); async function search() { isLoading = true; try { const response = await fetch(`/api/search/all?q=${encodeURIComponent(query)}`, { signal: controller.signal }); if (response.ok) { searchResults = await response.json(); } } catch (e) { if (e instanceof DOMException && e.name === 'AbortError') return; console.error('Failed to search items', e); searchResults = []; } finally { isLoading = false; } } search(); }); function handleSelect(item: SearchResult) { onAddItem({ item, date: addDate.toDate(getLocalTimeZone()) }); searchTerm = ''; open = false; } </script> <div class="flex flex-col md:flex-row gap-3"> <div class="flex-1"> <p class="text-sm font-medium mb-2">Fecha</p> <DatePicker bind:value={addDate} /> </div> <div class="flex-1" bind:this={triggerWrapperEl}> <p class="text-sm font-medium mb-2">Producto o Receta</p> <Popover.Root bind:open> <Popover.Trigger class="flex h-10 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50" role="combobox" > Añadir producto o receta... <ChevronsUpDown class="ml-2 h-4 w-4 shrink-0 opacity-50" /> </Popover.Trigger> <Popover.Content data-add-item-popover-content class="p-0"> <Command.Root filter={() => 1}> <Command.Input bind:value={searchTerm} placeholder="Buscar..." /> <Command.List> <Command.Empty> {#if isLoading} Buscando... {:else if searchTerm.length < 2} Escribe al menos 2 caracteres. {:else} No se encontraron resultados. {/if} </Command.Empty> {#each searchResults as item (`${item.type}-${item.id}`)} <Command.Item onSelect={() => handleSelect(item)} value={item.type === 'PRODUCT' ? item.name : item.title} > <div class="flex items-center gap-3 w-full"> <span class="text-xs font-bold text-muted-foreground w-16"> {item.type === 'PRODUCT' ? 'PROD' : 'RECETA'} </span> <span class="truncate"> {item.type === 'PRODUCT' ? item.name : item.title} </span> </div> </Command.Item> {/each} </Command.List> </Command.Root> </Popover.Content> </Popover.Root> </div> </div>

// --- Ruta: src/lib/components/admin/SortableHeader.svelte ---
<script lang="ts"> import { ArrowDown, ArrowUp } from 'lucide-svelte'; import * as Table from '$lib/components/ui/table'; import { cn } from '$lib/utils'; import { page } from '$app/state'; let { class: className = '', column, label } = $props<{ class?: string; column: string; label: string }>(); const currentSort = $derived(page.url.searchParams.get('sort')); const currentOrder = $derived(page.url.searchParams.get('order')); const currentSearch = $derived(page.url.searchParams.get('search')); const isActive = $derived(currentSort === column); const nextOrder = $derived(isActive && currentOrder === 'asc' ? 'desc' : 'asc'); let href = $state(''); $effect(() => { const params = new URLSearchParams(); if (currentSearch) { params.set('search', currentSearch); } params.set('sort', column); params.set('order', nextOrder); href = `?${params.toString()}`; }); </script> <Table.Head class={cn('p-0', className)}> <a {href} class="flex w-full items-center gap-2 p-4 no-underline hover:bg-muted/50"> <span>{label}</span> {#if isActive} {#if currentOrder === 'asc'} <ArrowUp class="h-4 w-4" /> {:else} <ArrowDown class="h-4 w-4" /> {/if} {/if} </a> </Table.Head>

// --- Ruta: src/lib/components/admin/ProductsMobileView.svelte ---
<script lang="ts"> import { Input } from '$lib/components/ui/input'; import type { PageData } from '../../../routes/admin/products/$types'; import { Search, X, Plus, UtensilsCrossed } from 'lucide-svelte'; import ProductActions from '$lib/components/admin/ProductActions.svelte'; import MacroBar from '$lib/components/shared/MacroBar.svelte'; import { Button } from '$lib/components/ui/button'; import AddCustomProductDialog from '$lib/components/shared/AddCustomProductDialog.svelte'; let { data, form = $bindable(), searchTerm = $bindable(), editingProductName = $bindable(), editingProductId = $bindable() } = $props<{ data: PageData; form: any; searchTerm: string; editingProductName: string; editingProductId: string | null; }>(); let isAddDialogOpen = $state(false); </script> <div class="block md:hidden mt-16"> <div class="mb-4 flex gap-2"> <Button variant="outline" size="sm" href="/admin/products/off" class="flex-1"> <UtensilsCrossed class="mr-2 h-4 w-4" /> Buscar en OFF </Button> <Button onclick={() => (isAddDialogOpen = true)} size="sm" class="flex-1"> <Plus class="mr-2 h-4 w-4" /> Añadir </Button> </div> <div class="mb-4 flex items-center justify-between gap-2"> <div class="relative flex-grow"> <Search class="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" /> <Input class="pl-8 pr-8" placeholder="Buscar..." bind:value={searchTerm} /> {#if searchTerm} <button onclick={() => (searchTerm = '')} class="absolute right-2.5 top-2.5 rounded-full p-0.5 text-muted-foreground transition-colors hover:bg-muted" aria-label="Limpiar búsqueda" > <X class="h-4 w-4" /> </button> {/if} </div> </div> <div class="space-y-4"> {#each data.products as product (product.id)} <div class="flex flex-col space-y-3 rounded-lg border p-4"> <div class="flex items-baseline justify-between"> <span class="break-words pr-2 font-medium">{product.name}</span> <span class="whitespace-nowrap text-sm text-muted-foreground"> {product.calories?.toFixed(0)} kcal </span> </div> <MacroBar protein={product.protein} carbs={product.carbs} fat={product.fat} /> <div class="flex"> <ProductActions bind:editingProductName bind:editingProductId {product} mode="buttons" /> </div> </div> {:else} <p class="text-center text-muted-foreground">No hay productos.</p> {/each} </div> <AddCustomProductDialog bind:open={isAddDialogOpen} bind:form /> </div>

// --- Ruta: src/lib/components/admin/ProductsDesktopView.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import { Input } from '$lib/components/ui/input'; import * as Separator from '$lib/components/ui/separator'; import * as Table from '$lib/components/ui/table'; import type { PageData } from '../../../routes/admin/products/$types'; import { Card, CardContent, CardHeader } from '$lib/components/ui/card'; import { Plus, Search, X, UtensilsCrossed } from 'lucide-svelte'; import SortableHeader from '$lib/components/admin/SortableHeader.svelte'; import ProductActions from '$lib/components/admin/ProductActions.svelte'; import MacroBar from '$lib/components/shared/MacroBar.svelte'; import AddCustomProductDialog from '$lib/components/shared/AddCustomProductDialog.svelte'; let { data, form = $bindable(), searchTerm = $bindable(), editingProductId = $bindable(), editingProductName = $bindable() } = $props<{ data: PageData; form: any; searchTerm: string; editingProductId: string | null; editingProductName: string; }>(); let isAddDialogOpen = $state(false); </script> <div class="hidden md:block"> <Card> <CardHeader> <div class="flex flex-row items-center justify-between gap-4 pt-4"> <div class="flex flex-1 items-center justify-end gap-2"> <div class="relative flex-grow"> <Search class="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" /> <Input class="pl-8 pr-8" placeholder="Buscar..." bind:value={searchTerm} /> {#if searchTerm} <button onclick={() => (searchTerm = '')} class="absolute right-2.5 top-2.5 rounded-full p-0.5 text-muted-foreground transition-colors hover:bg-muted" aria-label="Limpiar búsqueda" > <X class="h-4 w-4" /> </button> {/if} </div> <a href="/admin/products/off" class={buttonVariants({ variant: 'outline' })}> <UtensilsCrossed class="h-4 w-4" /> </a> <Button onclick={() => (isAddDialogOpen = true)}> <Plus class="h-4 w-4" /> </Button> <AddCustomProductDialog bind:open={isAddDialogOpen} bind:form /> </div> </div> </CardHeader> <CardContent> <Table.Root class="w-full table-fixed"> <Table.Header> <Table.Row> <SortableHeader column="name" label="Nombre" class="w-[30%]" /> <SortableHeader column="calories" label="kcal" class="w-[12%] justify-end" /> <Table.Head class="w-[46%]"></Table.Head> <Table.Head class="w-[12%] text-right"></Table.Head> </Table.Row> </Table.Header> <Table.Body> {#each data.products as product, i (product.id)} <Table.Row> <Table.Cell class="break-words font-medium whitespace-normal">{product.name}</Table.Cell> <Table.Cell class="text-right">{product.calories?.toFixed(0) ?? 'N/A'}</Table.Cell> <Table.Cell class="px-6"> <MacroBar protein={product.protein} carbs={product.carbs} fat={product.fat} /> </Table.Cell> <Table.Cell class="text-right"> <ProductActions {product} bind:editingProductId bind:editingProductName /> </Table.Cell> </Table.Row> {#if i < data.products.length - 1} <tr class="border-none !bg-transparent hover:!bg-transparent" ><td class="p-0" colspan="4"><Separator.Root /></td></tr > {/if} {:else} <Table.Row> <Table.Cell colspan={4} class="text-center">No hay productos.</Table.Cell> </Table.Row> {/each} </Table.Body> </Table.Root> </CardContent> </Card> </div>

// --- Ruta: src/lib/components/admin/ProductActions.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import * as Dialog from '$lib/components/ui/dialog'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import { enhance, applyAction } from '$app/forms'; import type { Product } from '@prisma/client'; import { toast } from 'svelte-sonner'; import { invalidateAll } from '$app/navigation'; import { Pencil, Trash2, Calculator, MoreVertical, Image } from 'lucide-svelte'; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator, DropdownMenuTrigger } from '$lib/components/ui/dropdown-menu'; import ImageManager from '$lib/components/shared/ImageManager.svelte'; let { product, editingProductName = $bindable(), editingProductId = $bindable(), mode = 'dropdown' } = $props<{ product: Product; editingProductName: string; editingProductId: string | null; mode?: 'dropdown' | 'buttons'; }>(); let calories = $state(product.calories); let protein = $state(product.protein); let fat = $state(product.fat); let carbs = $state(product.carbs); let isDeleteDialogOpen = $state(false); let isCalcDialogOpen = $state(false); let isEditDialogOpen = $state(false); let isImageDialogOpen = $state(false); let editingImageUrl = $state<string | null>(null); let quantity = $state(100); const calculatedMacros = $derived( ((() => { const factor = quantity / 100; return { calories: (product.calories * factor).toFixed(1), protein: (product.protein * factor).toFixed(1), fat: (product.fat * factor).toFixed(1), carbs: (product.carbs * factor).toFixed(1) }; })()) ); function openEditDialog() { editingProductId = product.id; editingProductName = product.name; calories = product.calories; protein = product.protein; fat = product.fat; carbs = product.carbs; isEditDialogOpen = true; } function closeEditDialog() { editingProductId = null; isEditDialogOpen = false; } $effect(() => { if (editingProductId !== product.id) { isEditDialogOpen = false; } }); </script> {#if mode === 'dropdown'} <!-- Menú Desplegable de Acciones --> <DropdownMenu> <DropdownMenuTrigger class={buttonVariants({ variant: 'ghost', size: 'icon' })} onclick={(e) => { e.stopPropagation(); e.preventDefault(); }} > <MoreVertical class="h-4 w-4" /> <span class="sr-only">Abrir menú</span> </DropdownMenuTrigger> <DropdownMenuContent align="end" onclick={(e) => e.stopPropagation()}> <DropdownMenuItem onclick={() => (isCalcDialogOpen = true)}> <Calculator class="mr-2 h-4 w-4" /> <span>Calcular</span> </DropdownMenuItem> <DropdownMenuItem onclick={openEditDialog}> <Pencil class="mr-2 h-4 w-4" /> <span>Editar</span> </DropdownMenuItem> <DropdownMenuItem onclick={() => { editingImageUrl = product.imageUrl; isImageDialogOpen = true; }} > <Image class="mr-2 h-4 w-4" /> <span>Imagen</span> </DropdownMenuItem> <DropdownMenuSeparator /> <DropdownMenuItem onclick={() => (isDeleteDialogOpen = true)} class="text-destructive focus:text-destructive" > <Trash2 class="mr-2 h-4 w-4" /> <span>Eliminar</span> </DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> {:else} <div class="flex flex-1 gap-2 pt-2"> <Button variant="outline" size="sm" class="flex-1" onclick={() => (isCalcDialogOpen = true)}> <Calculator class="h-4 w-4" /> </Button> <Button variant="outline" size="sm" class="flex-1" onclick={openEditDialog}> <Pencil class="h-4 w-4" /> </Button> <Button variant="outline" size="sm" class="flex-1" onclick={() => { editingImageUrl = product.imageUrl; isImageDialogOpen = true; }} > <Image class="h-4 w-4" /> </Button> <Button variant="destructive" size="sm" class="flex-1" onclick={() => (isDeleteDialogOpen = true)} > <Trash2 class="h-4 w-4" /> </Button> </div> {/if} <!-- Diálogo de Calcular --> <Dialog.Root bind:open={isCalcDialogOpen}> <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Calcular Nutrientes</Dialog.Title> <Dialog.Description >Calcula los macros para una cantidad específica de {product.name}.</Dialog.Description > </Dialog.Header> <div class="grid gap-4 py-4"> <div class="grid grid-cols-4 items-center gap-4"> <Label for="quantity" class="text-right">Cantidad (g)</Label> <Input id="quantity" type="number" bind:value={quantity} class="col-span-3 hide-arrows" /> </div> <div class="mt-4 rounded-lg bg-muted/50 p-4"> <h4 class="mb-2 font-semibold">Nutrientes para {quantity}g:</h4> <div class="space-y-1 text-sm"> <p><strong>Calorías:</strong> {Number(calculatedMacros.calories).toFixed(0)} kcal</p> <p><strong>Proteínas:</strong> {calculatedMacros.protein} g</p> <p><strong>Grasas:</strong> {calculatedMacros.fat} g</p> <p><strong>Carbohidratos:</strong> {calculatedMacros.carbs} g</p> </div> </div> </div> </Dialog.Content> </Dialog.Root> <!-- Diálogo de Editar --> <Dialog.Root open={isEditDialogOpen} onOpenChange={(isOpen) => { if (!isOpen) { closeEditDialog(); } }} > <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Editar Producto</Dialog.Title> </Dialog.Header> <form method="POST" action="?/update" use:enhance={() => { const toastId = toast.loading('Actualizando producto...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Producto actualizado.', { id: toastId }); closeEditDialog(); await invalidateAll(); } else if (result.type === 'failure') { toast.error('Error al actualizar.', { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <input type="hidden" name="id" value={product.id} /> <div class="grid gap-4 py-4"> <div class="grid grid-cols-4 items-center gap-4"> <Label for="name-edit-{product.id}" class="text-right">Nombre</Label> <Input id="name-edit-{product.id}" name="name" bind:value={editingProductName} class="col-span-3" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="calories-edit-{product.id}" class="text-right">Calorías</Label> <Input id="calories-edit-{product.id}" name="calories" type="number" step="0.01" bind:value={calories} class="col-span-3 hide-arrows" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="protein-edit-{product.id}" class="text-right">Proteínas</Label> <Input id="protein-edit-{product.id}" name="protein" type="number" step="0.01" bind:value={protein} class="col-span-3 hide-arrows" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="fat-edit-{product.id}" class="text-right">Grasas</Label> <Input id="fat-edit-{product.id}" name="fat" type="number" step="0.01" bind:value={fat} class="col-span-3 hide-arrows" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="carbs-edit-{product.id}" class="text-right">Carbohidratos</Label> <Input id="carbs-edit-{product.id}" name="carbs" type="number" step="0.01" bind:value={carbs} class="col-span-3 hide-arrows" /> </div> </div> <Dialog.Footer> <Button type="submit">Guardar Cambios</Button> </Dialog.Footer> </form> </Dialog.Content> </Dialog.Root> <!-- Diálogo de Eliminar --> <Dialog.Root bind:open={isDeleteDialogOpen}> <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Confirmar Eliminación</Dialog.Title> <Dialog.Description> ¿Estás seguro de que quieres eliminar el producto "{product.name}"? Esta acción no se puede deshacer. </Dialog.Description> </Dialog.Header> <form method="POST" action="?/delete" use:enhance={({ formElement }) => { const toastId = toast.loading('Eliminando producto...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Producto eliminado.', { id: toastId }); isDeleteDialogOpen = false; await invalidateAll(); } else if (result.type === 'failure') { let message = 'Error al eliminar. Puede que esté en uso en una receta.'; if (result.data && typeof (result.data as any).message === 'string') { message = (result.data as any).message; } toast.error(message, { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <input type="hidden" name="id" value={product.id} /> <Dialog.Footer> <Dialog.Close class={buttonVariants({ variant: 'outline' })}>Cancelar</Dialog.Close> <Button variant="destructive" type="submit">Eliminar</Button> </Dialog.Footer> </form> </Dialog.Content> </Dialog.Root> <!-- Diálogo de Imagen --> <Dialog.Root bind:open={isImageDialogOpen}> <Dialog.Content class="max-w-2xl"> <Dialog.Header> <Dialog.Title>Gestionar Imagen</Dialog.Title> <Dialog.Description> Sube un archivo o pega una URL para asignarla como imagen del producto "{product.name}". </Dialog.Description> </Dialog.Header> <form method="POST" action="?/updateImage" use:enhance={() => { const toastId = toast.loading('Actualizando imagen...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Imagen actualizada.', { id: toastId }); isImageDialogOpen = false; await invalidateAll(); } else if (result.type === 'failure') { let message = 'Error al actualizar la imagen.'; if (result.data && typeof (result.data as any).message === 'string') { message = (result.data as any).message; } toast.error(message, { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <input type="hidden" name="id" value={product.id} /> <div class="py-4"> <ImageManager bind:imageUrl={editingImageUrl} /> </div> <Dialog.Footer> <Button type="submit">Guardar Imagen</Button> </Dialog.Footer> </form> </Dialog.Content> </Dialog.Root>

// --- Ruta: src/lib/components/admin/OFFProductDialog.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import * as Dialog from '$lib/components/ui/dialog'; import { Input } from '$lib/components/ui/input'; import { Label } from '$lib/components/ui/label'; import { enhance, applyAction } from '$app/forms'; import { toast } from 'svelte-sonner'; import { invalidateAll } from '$app/navigation'; type ProductData = { id: string; name: string; imageUrl: string | null; calories: number; protein: number; fat: number; carbs: number; }; let { product, open = $bindable(), onProductAdded = (id: string) => {} } = $props<{ product: ProductData; open: boolean; onProductAdded?: (id: string) => void; }>(); let name = $state(product.name); let calories = $state(product.calories); let protein = $state(product.protein); let fat = $state(product.fat); let carbs = $state(product.carbs); let displayCalories = $state(product.calories.toFixed(2)); let displayProtein = $state(product.protein.toFixed(2)); let displayFat = $state(product.fat.toFixed(2)); let displayCarbs = $state(product.carbs.toFixed(2)); $effect(() => { name = product.name; calories = product.calories; protein = product.protein; fat = product.fat; carbs = product.carbs; displayCalories = product.calories.toFixed(2); displayProtein = product.protein.toFixed(2); displayFat = product.fat.toFixed(2); displayCarbs = product.carbs.toFixed(2); }); </script> <Dialog.Root bind:open> <Dialog.Content class="sm:max-w-[425px]"> <Dialog.Header> <Dialog.Title>Añadir Producto</Dialog.Title> <Dialog.Description> Revisa y ajusta los datos del producto antes de añadirlo a tu base de datos. </Dialog.Description> </Dialog.Header> <form method="POST" action="?/add" use:enhance={() => { const toastId = toast.loading('Añadiendo producto...'); return async ({ result }) => { await applyAction(result); if (result.type === 'success') { toast.success('Producto añadido correctamente.', { id: toastId }); open = false; onProductAdded(product.id); await invalidateAll(); } else if (result.type === 'failure') { let message = 'Error al añadir el producto.'; if (result.data && typeof (result.data as any).error === 'string') { message = (result.data as any).error; } toast.error(message, { id: toastId }); } else { toast.dismiss(toastId); } }; }} > <input type="hidden" name="barcode" value={product.id} /> <input type="hidden" name="imageUrl" value={product.imageUrl ?? ''} /> <input type="hidden" name="calories" value={calories} /> <input type="hidden" name="protein" value={protein} /> <input type="hidden" name="fat" value={fat} /> <input type="hidden" name="carbs" value={carbs} /> <div class="grid gap-4 py-4"> <div class="grid grid-cols-4 items-center gap-4"> <Label for="name-add-{product.id}" class="text-right">Nombre</Label> <Input id="name-add-{product.id}" name="name" bind:value={name} class="col-span-3" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="calories-add-{product.id}" class="text-right">Calorías</Label> <Input id="calories-add-{product.id}" type="number" step="0.01" value={displayCalories} oninput={(e) => { displayCalories = e.currentTarget.value; calories = e.currentTarget.valueAsNumber; }} class="col-span-3 hide-arrows" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="protein-add-{product.id}" class="text-right">Proteínas</Label> <Input id="protein-add-{product.id}" type="number" step="0.01" value={displayProtein} oninput={(e) => { displayProtein = e.currentTarget.value; protein = e.currentTarget.valueAsNumber; }} class="col-span-3 hide-arrows" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="fat-add-{product.id}" class="text-right">Grasas</Label> <Input id="fat-add-{product.id}" type="number" step="0.01" value={displayFat} oninput={(e) => { displayFat = e.currentTarget.value; fat = e.currentTarget.valueAsNumber; }} class="col-span-3 hide-arrows" /> </div> <div class="grid grid-cols-4 items-center gap-4"> <Label for="carbs-add-{product.id}" class="text-right">Carbohidratos</Label> <Input id="carbs-add-{product.id}" type="number" step="0.01" value={displayCarbs} oninput={(e) => { displayCarbs = e.currentTarget.value; carbs = e.currentTarget.valueAsNumber; }} class="col-span-3 hide-arrows" /> </div> </div> <Dialog.Footer> <Dialog.Close class={buttonVariants({ variant: 'outline' })} type="button">Cancelar</Dialog.Close> <Button type="submit">Añadir a la Base de Datos</Button> </Dialog.Footer> </form> </Dialog.Content> </Dialog.Root>

// --- Ruta: src/lib/components/admin/ConfirmIncompleteProductDialog.svelte ---
<script lang="ts"> import * as AlertDialog from '$lib/components/ui/alert-dialog/index.js'; let { open = $bindable(), productName, onConfirm = () => {}, onCancel = () => {} } = $props<{ open: boolean; productName: string; onConfirm: () => void; onCancel: () => void; }>(); function handleCancel() { open = false; onCancel(); } function handleConfirm() { open = false; onConfirm(); } </script> <AlertDialog.Root bind:open onOpenChange={(isOpen) => { if (!isOpen) { onCancel(); } }} > <AlertDialog.Content> <AlertDialog.Header> <AlertDialog.Title>Datos incompletos</AlertDialog.Title> <AlertDialog.Description> El producto "<strong>{@html productName}</strong>" tiene valores nutricionales incompletos o en cero. ¿Quieres añadirlo de todas formas? Podrás editar los valores manualmente. </AlertDialog.Description> </AlertDialog.Header> <AlertDialog.Footer> <AlertDialog.Cancel onclick={handleCancel}>No, descartar</AlertDialog.Cancel> <AlertDialog.Action onclick={handleConfirm}>Sí, añadir</AlertDialog.Action> </AlertDialog.Footer> </AlertDialog.Content> </AlertDialog.Root>

// --- Ruta: src/routes/recetas/[slug]/editar/+page.svelte ---
<!-- Ruta: src/routes/recetas/[slug]/editar/+page.svelte --> <script lang="ts"> import RecipeForm from '$lib/components/recipes/RecipeForm.svelte'; import type { PageData, ActionData } from './$types'; import { goto } from '$app/navigation'; let { data, form }: { data: PageData; form: ActionData } = $props(); async function handleSuccess() { await goto(`/recetas/${data.recipe.slug}`); } </script> <div class="container mx-auto p-4 md:px-24 mt-16 md:mt-0"> <RecipeForm recipeId={data.recipe.id} initialData={data.recipe} {form} cardTitle="Editar Receta" submitButtonText="Actualizar Receta" onSuccess={handleSuccess} /> </div>

// --- Ruta: src/routes/recetas/[slug]/editar/+page.server.ts ---
const getRecipeSteps = (stepsData: unknown): string[] => { if (Array.isArray(stepsData)) { return stepsData.map(String); } if (typeof stepsData === 'string') { try { const parsed = JSON.parse(stepsData); return Array.isArray(parsed) ? parsed.map(String) : [String(stepsData)]; } catch { return [String(stepsData)]; } } return ['']; }; export const load: PageServerLoad = async ({ params }) => { const recipe = await recipeService.getBySlug(params.slug); if (!recipe) { throw error(404, 'Receta no encontrada'); } return { recipe: { ...recipe, steps: getRecipeSteps(recipe.steps) } }; }; export const actions: Actions = { default: async ({ request, params }) => { const formData = await request.formData(); const data = Object.fromEntries(formData.entries()); const dataToValidate = { ...data, ingredients: JSON.parse(data.ingredients as string), urls: JSON.parse(data.urls as string), steps: JSON.parse(data.steps as string) }; const validation = RecipeSchema.safeParse(dataToValidate); if (!validation.success) { const response = createFailResponse('La validación falló. Revisa los campos.', validation.error); return fail(400, response); } let updatedRecipe; try { const originalRecipe = await recipeService.getBySlug(params.slug); if (!originalRecipe) { throw error(404, 'Receta no encontrada para actualizar'); } updatedRecipe = await recipeService.update(originalRecipe.id, validation.data); if (!updatedRecipe) { return fail(500, createFailResponse('No se pudo actualizar la receta.')); } } catch (err) { if (err && typeof err === 'object' && 'status' in err) { throw err; } console.error(err); const response = createFailResponse('No se pudo actualizar la receta en el servidor.'); return fail(500, response); } throw redirect(303, `/recetas/${updatedRecipe.slug}`); } };

// --- Ruta: src/routes/api/recipes/search/+server.ts ---
const RECIPES_PER_PAGE = 50; export const POST: RequestHandler = async ({ request }) => { const requestId = `req_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`; console.log(`\n--- [${requestId}] INICIO: Petición de búsqueda recibida ---`); try { const body = await request.json(); console.log(`[${requestId}] BODY RECIBIDO:`, JSON.stringify(body, null, 2)); const filters = SearchFiltersSchema.parse(body); console.log(`[${requestId}] FILTROS VALIDADOS:`, JSON.stringify(filters, null, 2)); const queryOptions = { ...filters, limit: RECIPES_PER_PAGE + 1 }; console.log(`[${requestId}] QUERY OPTIONS (para recipeService):`, JSON.stringify(queryOptions, null, 2)); const recipesPlusOne = await recipeService.findAdvanced(queryOptions); const hasMore = recipesPlusOne.length > RECIPES_PER_PAGE; const recipes = recipesPlusOne.slice(0, RECIPES_PER_PAGE); console.log(`[${requestId}] RESULTADO: ${recipes.length} recetas encontradas. ¿Hay más?: ${hasMore}`); console.log(`--- [${requestId}] FIN: Petición completada exitosamente ---`); return json({ recipes, hasMore }); } catch (error) { console.error(`--- [${requestId}] ERROR: Ha ocurrido un error en el endpoint ---`, error); if (error instanceof ZodError) { return json({ message: 'Datos de búsqueda inválidos', errors: error.flatten() }, { status: 400 }); } return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

// --- Ruta: src/routes/api/recipes/[id]/+server.ts ---
export const GET: RequestHandler = async ({ params }) => { try { const recipe = await recipeService.getById(params.id); if (!recipe) { return json(createFailResponse('Receta no encontrada'), { status: 404 }); } return json(recipe); } catch (error) { console.error(`Error fetching recipe ${params.id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const PUT: RequestHandler = async ({ request, params }) => { try { const body = await request.json(); const validatedData = RecipeSchema.parse(body); const updatedRecipe = await recipeService.update(params.id, validatedData); if (!updatedRecipe) { return json(createFailResponse('Receta no encontrada para actualizar'), { status: 404 }); } return json(updatedRecipe); } catch (error) { if (error instanceof ZodError) { return json(createFailResponse('La validación falló', error), { status: 400 }); } console.error(`Error updating recipe ${params.id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const DELETE: RequestHandler = async ({ params }) => { try { await recipeService.deleteById(params.id); return new Response(null, { status: 204 }); } catch (error) { console.error(`Error deleting recipe ${params.id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/routes/api/search/all/+server.ts ---
export const GET: RequestHandler = async ({ url }) => { try { const query = url.searchParams.get('q'); if (!query || query.length < 2) { return json( createFailResponse('Se requiere un término de búsqueda de al menos 2 caracteres'), { status: 400 } ); } const [products, recipes] = await Promise.all([ productService.searchByName(query), recipeService.findPaginated(query, 20, 0) ]); const combinedResults = [ ...products.map((p) => ({ ...p, type: 'PRODUCT' })), ...recipes.map((r) => ({ ...r, type: 'RECIPE' })) ]; combinedResults.sort((a, b) => { const nameA = 'name' in a ? a.name : a.title; const nameB = 'name' in b ? b.name : b.title; return nameA.localeCompare(nameB); }); return json(combinedResults); } catch (error) { console.error('Error en la búsqueda unificada:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/routes/api/diary/[id]/+server.ts ---
export const PUT: RequestHandler = async ({ request, params }) => { try { const entryId = params.id; if (!entryId) { return json(createFailResponse('Falta el ID de la entrada'), { status: 400 }); } const body = await request.json(); const updatedEntry = await diaryService.updateDiaryEntry(entryId, body); if (!updatedEntry) { return json(createFailResponse('Entrada no encontrada'), { status: 404 }); } return json(updatedEntry, { status: 200 }); } catch (error) { if (error instanceof ZodError) { return json(createFailResponse('La validación falló', error), { status: 400 }); } console.error('Error updating diary entry:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const DELETE: RequestHandler = async ({ params }) => { try { const entryId = params.id; if (!entryId) { return json(createFailResponse('Falta el ID de la entrada'), { status: 400 }); } const deletedEntry = await diaryService.deleteDiaryEntry(entryId); if (!deletedEntry) { return json(createFailResponse('Entrada no encontrada'), { status: 404 }); } return json({ success: true, message: 'Entrada eliminada con éxito' }, { status: 200 }); } catch (error) { console.error('Error deleting diary entry:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/routes/api/diary/[...date]/+server.ts ---
export const GET: RequestHandler = async ({ params }) => { try { const dateParam = params.date; if (!dateParam) { return json(createFailResponse('Parámetro de fecha no proporcionado'), { status: 400 }); } const [startDateStr, endDateStr] = dateParam.split('/'); const startDate = new Date(startDateStr); const endDate = endDateStr ? new Date(endDateStr) : new Date(startDate); if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) { return json(createFailResponse('Formato de fecha inválido'), { status: 400 }); } startDate.setHours(0, 0, 0, 0); endDate.setHours(23, 59, 59, 999); const userId = 'juanjocerero'; const entries = await diaryService.getDiaryEntries(userId, startDate, endDate); return json(entries); } catch (error) { console.error('Error fetching diary entries:', error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/routes/api/products/search/+server.ts ---
type OffProduct = { code: string; product_name: string; image_front_small_url?: string; nutriments: { 'energy-kcal_100g'?: number; 'proteins_100g'?: number; 'fat_100g'?: number; 'carbohydrates_100g'?: number; }; }; export const GET: RequestHandler = ({ url, fetch }) => { const query = url.searchParams.get('q'); const page = url.searchParams.get('page') ?? '1'; if (!query) { return json({ error: 'Query parameter "q" is required' }, { status: 400 }); } const abortController = new AbortController(); const stream = new ReadableStream({ async start(controller) { type SearchResult = { id: string; name: string; source: 'local' | 'off'; imageUrl: string | null; }; const sendEvent = (event: string, data: object) => { try { controller.enqueue(`event: ${event}\ndata: ${JSON.stringify(data)}\n\n`); } catch (e) { console.warn(`Stream enqueue failed: ${(e as Error).message}`); } }; try { const localResults = await productService.searchByName(query); const localBarcodes = new Set<string>(); if (localResults.length > 0) { const formattedLocalResults: SearchResult[] = localResults.map((p: Product) => { if (p.barcode) localBarcodes.add(p.barcode); return { id: p.id, name: p.name, source: 'local', imageUrl: p.imageUrl }; }); sendEvent('local_results', formattedLocalResults); } const brands = ['Hacendado', 'Mercadona']; const offSearchPromises = brands.map((brand) => { const offQuery = `${query} ${brand}`; const offUrl = `https: offQuery )} &search_simple=1&action=process&json=1&page_size=20&page=${page}&fields=code,product_name,image_front_small_url,nutriments`; return fetch(offUrl, { signal: abortController.signal }) .then((res) => { if (!res.ok) throw new Error(`API returned status ${res.status}`); return res.json(); }) .then((response) => { const offProducts = response?.products ?? []; const uniqueOffProducts: SearchResult[] = offProducts .filter((p: OffProduct) => p.code && !localBarcodes.has(p.code)) .map((p: OffProduct) => { localBarcodes.add(p.code); const parseNutriment = (value: unknown): number => { if (typeof value === 'number') return value; if (typeof value === 'string') { const parsed = parseFloat(value); return isNaN(parsed) ? 0 : parsed; } return 0; }; return { id: p.code, name: p.product_name, source: 'off' as const, imageUrl: p.image_front_small_url || null, calories: parseNutriment(p.nutriments?.['energy-kcal_100g']), protein: parseNutriment(p.nutriments?.['proteins_100g']), fat: parseNutriment(p.nutriments?.['fat_100g']), carbs: parseNutriment(p.nutriments?.['carbohydrates_100g']) }; }); if (uniqueOffProducts.length > 0) { sendEvent('message', uniqueOffProducts); } }) .catch((err) => { if (err.name !== 'AbortError') { console.error(`Failed to fetch from ${brand}: ${err.message}`); sendEvent('stream_error', { source: 'off-api', message: `Error con la marca ${brand}` }); } }); }); await Promise.allSettled(offSearchPromises); } catch (error) { if (error instanceof Error && error.name !== 'AbortError') { console.error('[Search Stream Error]', error); const errorMessage = error instanceof Error ? error.message : 'Unknown stream error'; sendEvent('stream_error', { source: 'server', message: errorMessage }); } } finally { sendEvent('close', { message: 'Stream closed' }); if (!abortController.signal.aborted) { controller.close(); } } }, cancel(reason) { console.log('Stream cancelled by client.', reason); abortController.abort(reason); } }); return new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', Connection: 'keep-alive' } }); };

// --- Ruta: src/routes/api/products/details/+server.ts ---
export const GET: RequestHandler = async ({ url }) => { const idsParam = url.searchParams.get('ids'); if (!idsParam) { return json({ message: 'Missing "ids" query parameter' }, { status: 400 }); } const ids = idsParam.split(',').filter(Boolean); if (ids.length === 0) { return json([]); } try { const products = await productService.getByIds(ids); return json(products); } catch (error) { console.error('Failed to fetch product details:', error); return json({ message: 'An error occurred while fetching product details.' }, { status: 500 }); } };

// --- Ruta: src/routes/api/products/autocomplete/+server.ts ---
export const GET: RequestHandler = async ({ url }) => { const query = url.searchParams.get('q'); if (!query) { return json({ error: 'Query parameter "q" is required' }, { status: 400 }); } try { const products = await productService.searchByName(query); const results = products.map((product: Product) => ({ id: product.id, name: product.name, type: product.barcode ? 'product' : 'custom', source: 'local', imageUrl: product.imageUrl })); return json(results); } catch (error) { console.error('Error en el endpoint de autocompletado de productos:', error); return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

// --- Ruta: src/routes/api/products/[id]/+server.ts ---
export const PUT: RequestHandler = async ({ request, params }) => { const { id } = params; if (!id) { return json(createFailResponse('Id de producto requerido'), { status: 400 }); } try { const body = await request.json(); const validatedData = ProductSchema.parse(body); const updatedProduct = await productService.update(id, validatedData); return json(updatedProduct); } catch (error) { if (error instanceof ZodError) { return json(createFailResponse('La validación falló', error), { status: 400 }); } console.error(`Error actualizando producto con id ${id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } }; export const DELETE: RequestHandler = async ({ params }) => { const { id } = params; if (!id) { return json(createFailResponse('Id de producto requerido'), { status: 400 }); } try { await productService.delete(id); return new Response(null, { status: 204 }); } catch (error) { console.error(`Error eliminando producto ${id}:`, error); return json(createFailResponse('Error interno del servidor'), { status: 500 }); } };

// --- Ruta: src/routes/admin/products/off/+page.svelte ---
<script lang="ts"> import { Button, buttonVariants } from '$lib/components/ui/button'; import { Input } from '$lib/components/ui/input'; import { Card, CardContent, CardHeader, CardTitle } from '$lib/components/ui/card'; import { fade } from 'svelte/transition'; import { flip } from 'svelte/animate'; import { ArrowLeft, X, Plus } from 'lucide-svelte'; import OFFProductDialog from '$lib/components/admin/OFFProductDialog.svelte'; import ConfirmIncompleteProductDialog from '$lib/components/admin/ConfirmIncompleteProductDialog.svelte'; import AddCustomProductDialog from '$lib/components/shared/AddCustomProductDialog.svelte'; type SearchResult = { id: string; name: string; source: 'local' | 'off'; imageUrl: string | null; calories: number; protein: number; fat: number; carbs: number; }; let productToEdit = $state<SearchResult | null>(null); let isEditDialogOpen = $state(false); let productToCheck = $state<SearchResult | null>(null); let isConfirmDialogOpen = $state(false); let isAddCustomDialogOpen = $state(false); let customProductForm = $state<any>(null); let searchTerm = $state(''); let results = $state<SearchResult[]>([]); let isLoading = $state(false); let searchAttempted = $state(false); let page = $state(1); let hasMore = $state(true); function searchProducts(loadMore = false) { if (isLoading) return; if (!loadMore) { results = []; page = 1; hasMore = true; } isLoading = true; searchAttempted = true; const pageToFetch = page; page++; const eventSource = new EventSource( `/api/products/search?q=${encodeURIComponent(searchTerm)}&page=${pageToFetch}` ); const addResults = (newResults: SearchResult[]) => { if (newResults.length > 0) { const existingIds = new Set(results.map((r) => r.id)); const uniqueNewResults = newResults.filter((r) => !existingIds.has(r.id)); results = [...results, ...uniqueNewResults]; } }; eventSource.addEventListener('local_results', (event) => { const newResults = JSON.parse(event.data); addResults(newResults); }); eventSource.addEventListener('message', (event) => { const newResults = JSON.parse(event.data); const PAGE_SIZE = 20; if (newResults.length < PAGE_SIZE) { hasMore = false; } addResults(newResults); }); eventSource.addEventListener('stream_error', (event) => { const errorData = JSON.parse((event as MessageEvent).data); console.error('Error de stream recibido:', errorData); isLoading = false; eventSource.close(); }); eventSource.onerror = (err) => { console.error('Error en la conexión de EventSource:', err); isLoading = false; eventSource.close(); }; eventSource.addEventListener('close', () => { isLoading = false; eventSource.close(); }); } $effect(() => { if (searchTerm.length < 3) { results = []; searchAttempted = false; isLoading = false; hasMore = true; page = 1; } else { const handler = setTimeout(() => { searchProducts(); }, 300); return () => clearTimeout(handler); } }); function handleAddClick(product: SearchResult) { const hasIncompleteData = !product.calories || !product.protein || !product.fat || !product.carbs; if (hasIncompleteData) { productToCheck = product; isConfirmDialogOpen = true; } else { productToEdit = product; isEditDialogOpen = true; } } function handleConfirmAdd() { if (!productToCheck) return; productToEdit = productToCheck; isEditDialogOpen = true; productToCheck = null; } function handleCancelAdd() { if (!productToCheck) return; results = results.filter((p) => p.id !== productToCheck!.id); productToCheck = null; } function handleProductAdded(addedProductId: string) { results = results.filter((p) => p.id !== addedProductId); } function onVisible(node: HTMLElement, callback: () => void) { const observer = new IntersectionObserver((entries) => { if (entries[0].isIntersecting) { callback(); } }); observer.observe(node); return { destroy() { observer.unobserve(node); } }; } </script> <div class="container mx-auto mt-16 p-4 md:py-8 md:px-24"> <div class="space-y-8 p-4 md:p-8"> <div class="flex items-center gap-4"> <a href="/admin/products" class={buttonVariants({ variant: 'outline', size: 'icon' })}> <ArrowLeft class="h-4 w-4" /> </a> <h1 class="text-xl font-bold">Añadir productos desde OpenFoodFacts</h1> </div> <div class="flex items-center gap-2"> <div class="relative flex-grow"> <Input bind:value={searchTerm} placeholder="Buscar por nombre (ej. tomate frito)..." class="pr-10" /> {#if searchTerm} <Button onclick={() => (searchTerm = '')} variant="ghost" size="icon" class="absolute right-0 top-0 h-full rounded-l-none" > <X class="h-4 w-4" /> </Button> {/if} </div> </div> {#if isLoading && results.length === 0} <div class="flex justify-center py-8"> <div class="spinner"></div> </div> {:else if results.length > 0} <div class="grid grid-cols-2 gap-4 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6"> {#each results as result, i (result.id)} <div animate:flip={{ duration: 300 }} in:fade={{ duration: 250, delay: i * 20 }}> <Card class={result.source === 'local' ? 'ring-2 ring-green-500' : ''}> <CardHeader> <img src={result.imageUrl || 'https: alt={result.name} class="aspect-square w-full rounded-md object-cover" /> </CardHeader> <CardContent class="flex flex-col justify-between space-y-4"> <CardTitle class="text-sm">{result.name}</CardTitle> {#if result.source === 'off'} <Button onclick={() => handleAddClick(result)} class="w-full"> Añadir </Button> {:else} <Button class="w-full" disabled>Añadido</Button> {/if} </CardContent> </Card> </div> {/each} </div> {#if isLoading && results.length > 0} <div class="flex justify-center py-4"> <div class="spinner"></div> </div> {:else if !hasMore && results.length > 0} <div class="py-8 text-center text-gray-500"> <p>No hay más resultados.</p> <Button onclick={() => (isAddCustomDialogOpen = true)} variant="link" class="mt-4"> <Plus class="mr-2 h-4 w-4" /> Añadir producto personalizado </Button> </div> {:else if hasMore && !isLoading} <div use:onVisible={() => searchProducts(true)} class="h-10"></div> {/if} {:else if !isLoading && searchAttempted} <div class="py-8 text-center text-gray-500"> <p>No se encontraron resultados para tu búsqueda.</p> <Button onclick={() => (isAddCustomDialogOpen = true)} variant="link" class="mt-4"> <Plus class="mr-2 h-4 w-4" /> Añadir producto personalizado </Button> </div> {/if} </div> {#if productToCheck} <ConfirmIncompleteProductDialog bind:open={isConfirmDialogOpen} productName={productToCheck.name} onConfirm={handleConfirmAdd} onCancel={handleCancelAdd} /> {/if} {#if productToEdit} <OFFProductDialog bind:open={isEditDialogOpen} product={productToEdit} onProductAdded={handleProductAdded} /> {/if} <AddCustomProductDialog bind:open={isAddCustomDialogOpen} bind:form={customProductForm} action="/admin/products?/addCustom" /> </div> <style> .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #09f; animation: spin 1s ease infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } </style>

// --- Ruta: src/routes/admin/products/off/+page.server.ts ---
const addProductSchema = z.object({ barcode: z.string(), name: z.string().min(1, 'El nombre no puede estar vacío'), imageUrl: z.string().url().optional().or(z.literal('')), calories: z.coerce.number().min(0, 'Las calorías deben ser un número positivo'), protein: z.coerce.number().min(0, 'Las proteínas deben ser un número positivo'), fat: z.coerce.number().min(0, 'Las grasas deben ser un número positivo'), carbs: z.coerce.number().min(0, 'Los carbohidratos deben ser un número positivo') }); export const actions: Actions = { add: async ({ request }) => { const data = await request.formData(); const parsed = addProductSchema.safeParse(Object.fromEntries(data)); if (!parsed.success) { const error = parsed.error.flatten().fieldErrors; return fail(400, { success: false, error: Object.values(error).flat().join(', ') }); } try { const existingProduct = await productService.findByBarcodeInDbOnly(parsed.data.barcode); if (existingProduct) { return fail(409, { success: false, error: 'Ya existe un producto con este código de barras.' }); } const newProduct = await productService.create(parsed.data); return { success: true, product: newProduct }; } catch (error) { console.error(error); return fail(500, { success: false, error: 'Error interno del servidor al crear el producto.' }); } } };

// --- Ruta: src/lib/components/ui/textarea/textarea.svelte ---
<script lang="ts"> import { cn, type WithElementRef, type WithoutChildren } from "$lib/utils.js"; import type { HTMLTextareaAttributes } from "svelte/elements"; let { ref = $bindable(null), value = $bindable(), class: className, ...restProps }: WithoutChildren<WithElementRef<HTMLTextareaAttributes>> = $props(); </script> <textarea bind:this={ref} data-slot="textarea" class={cn( "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 field-sizing-content shadow-xs flex min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base outline-none transition-[color,box-shadow] focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", className )} bind:value {...restProps} ></textarea>

// --- Ruta: src/lib/components/ui/textarea/index.ts ---
export { Root, Root as Textarea, };

// --- Ruta: src/lib/components/ui/table/table.svelte ---
<script lang="ts"> import type { HTMLTableAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLTableAttributes> = $props(); </script> <div data-slot="table-container" class="relative w-full overflow-x-auto"> <table bind:this={ref} data-slot="table" class={cn("w-full caption-bottom text-sm", className)} {...restProps} > {@render children?.()} </table> </div>

// --- Ruta: src/lib/components/ui/table/table-row.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLTableRowElement>> = $props(); </script> <tr bind:this={ref} data-slot="table-row" class={cn( "hover:[&,&>svelte-css-wrapper]:[&>th,td]:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors", className )} {...restProps} > {@render children?.()} </tr>

// --- Ruta: src/lib/components/ui/table/table-header.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props(); </script> <thead bind:this={ref} data-slot="table-header" class={cn("[&_tr]:border-b", className)} {...restProps} > {@render children?.()} </thead>

// --- Ruta: src/lib/components/ui/table/table-head.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLThAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLThAttributes> = $props(); </script> <th bind:this={ref} data-slot="table-head" class={cn( "text-foreground h-10 whitespace-nowrap bg-clip-padding px-2 text-left align-middle font-medium [&:has([role=checkbox])]:pr-0", className )} {...restProps} > {@render children?.()} </th>

// --- Ruta: src/lib/components/ui/table/table-footer.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props(); </script> <tfoot bind:this={ref} data-slot="table-footer" class={cn("bg-muted/50 border-t font-medium [&>tr]:last:border-b-0", className)} {...restProps} > {@render children?.()} </tfoot>

// --- Ruta: src/lib/components/ui/table/table-cell.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLTdAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLTdAttributes> = $props(); </script> <td bind:this={ref} data-slot="table-cell" class={cn( "whitespace-nowrap bg-clip-padding p-2 align-middle [&:has([role=checkbox])]:pr-0", className )} {...restProps} > {@render children?.()} </td>

// --- Ruta: src/lib/components/ui/table/table-caption.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLElement>> = $props(); </script> <caption bind:this={ref} data-slot="table-caption" class={cn("text-muted-foreground mt-4 text-sm", className)} {...restProps} > {@render children?.()} </caption>

// --- Ruta: src/lib/components/ui/table/table-body.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLTableSectionElement>> = $props(); </script> <tbody bind:this={ref} data-slot="table-body" class={cn("[&_tr:last-child]:border-0", className)} {...restProps} > {@render children?.()} </tbody>

// --- Ruta: src/lib/components/ui/table/index.ts ---
export { Root, Body, Caption, Cell, Footer, Head, Header, Row, Root as Table, Body as TableBody, Caption as TableCaption, Cell as TableCell, Footer as TableFooter, Head as TableHead, Header as TableHeader, Row as TableRow, };

// --- Ruta: src/lib/components/ui/skeleton/skeleton.svelte ---
<script lang="ts"> import { cn, type WithElementRef, type WithoutChildren } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, ...restProps }: WithoutChildren<WithElementRef<HTMLAttributes<HTMLDivElement>>> = $props(); </script> <div bind:this={ref} data-slot="skeleton" class={cn("bg-accent animate-pulse rounded-md", className)} {...restProps} ></div>

// --- Ruta: src/lib/components/ui/skeleton/index.ts ---
export { Root, Root as Skeleton, };

// --- Ruta: src/lib/components/ui/switch/switch.svelte ---
<script lang="ts"> import { Switch as SwitchPrimitive } from "bits-ui"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, checked = $bindable(false), ...restProps }: WithoutChildrenOrChild<SwitchPrimitive.RootProps> = $props(); </script> <SwitchPrimitive.Root bind:ref bind:checked data-slot="switch" class={cn( "data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 shadow-xs peer inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent outline-none transition-all focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", className )} {...restProps} > <SwitchPrimitive.Thumb data-slot="switch-thumb" class={cn( "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0" )} /> </SwitchPrimitive.Root>

// --- Ruta: src/lib/components/ui/switch/index.ts ---
export { Root, Root as Switch, };

// --- Ruta: src/lib/components/ui/separator/separator.svelte ---
<script lang="ts"> import { Separator as SeparatorPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: SeparatorPrimitive.RootProps = $props(); </script> <SeparatorPrimitive.Root bind:ref data-slot="separator" class={cn( "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=vertical]:h-full data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-px", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/separator/index.ts ---
export { Root, Root as Separator, };

// --- Ruta: src/lib/components/ui/select/select-trigger.svelte ---
<script lang="ts"> import { Select as SelectPrimitive } from "bits-ui"; import ChevronDownIcon from "@lucide/svelte/icons/chevron-down"; import { cn, type WithoutChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, size = "default", ...restProps }: WithoutChild<SelectPrimitive.TriggerProps> & { size?: "sm" | "default"; } = $props(); </script> <SelectPrimitive.Trigger bind:ref data-slot="select-trigger" data-size={size} class={cn( "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 shadow-xs flex w-fit select-none items-center justify-between gap-2 whitespace-nowrap rounded-md border bg-transparent px-3 py-2 text-sm outline-none transition-[color,box-shadow] focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} > {@render children?.()} <ChevronDownIcon class="size-4 opacity-50" /> </SelectPrimitive.Trigger>

// --- Ruta: src/lib/components/ui/select/select-separator.svelte ---
<script lang="ts"> import type { Separator as SeparatorPrimitive } from "bits-ui"; import { Separator } from "$lib/components/ui/separator/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: SeparatorPrimitive.RootProps = $props(); </script> <Separator bind:ref data-slot="select-separator" class={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/select/select-scroll-up-button.svelte ---
<script lang="ts"> import ChevronUpIcon from "@lucide/svelte/icons/chevron-up"; import { Select as SelectPrimitive } from "bits-ui"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: WithoutChildrenOrChild<SelectPrimitive.ScrollUpButtonProps> = $props(); </script> <SelectPrimitive.ScrollUpButton bind:ref data-slot="select-scroll-up-button" class={cn("flex cursor-default items-center justify-center py-1", className)} {...restProps} > <ChevronUpIcon class="size-4" /> </SelectPrimitive.ScrollUpButton>

// --- Ruta: src/lib/components/ui/select/select-scroll-down-button.svelte ---
<script lang="ts"> import ChevronDownIcon from "@lucide/svelte/icons/chevron-down"; import { Select as SelectPrimitive } from "bits-ui"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: WithoutChildrenOrChild<SelectPrimitive.ScrollDownButtonProps> = $props(); </script> <SelectPrimitive.ScrollDownButton bind:ref data-slot="select-scroll-down-button" class={cn("flex cursor-default items-center justify-center py-1", className)} {...restProps} > <ChevronDownIcon class="size-4" /> </SelectPrimitive.ScrollDownButton>

// --- Ruta: src/lib/components/ui/select/select-label.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> & {} = $props(); </script> <div bind:this={ref} data-slot="select-label" class={cn("text-muted-foreground px-2 py-1.5 text-xs", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/select/select-item.svelte ---
<script lang="ts"> import CheckIcon from "@lucide/svelte/icons/check"; import { Select as SelectPrimitive } from "bits-ui"; import { cn, type WithoutChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, value, label, children: childrenProp, ...restProps }: WithoutChild<SelectPrimitive.ItemProps> = $props(); </script> <SelectPrimitive.Item bind:ref {value} data-slot="select-item" class={cn( "data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2 relative flex w-full cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-2 pr-8 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} > {#snippet children({ selected, highlighted })} <span class="absolute right-2 flex size-3.5 items-center justify-center"> {#if selected} <CheckIcon class="size-4" /> {/if} </span> {#if childrenProp} {@render childrenProp({ selected, highlighted })} {:else} {label || value} {/if} {/snippet} </SelectPrimitive.Item>

// --- Ruta: src/lib/components/ui/select/select-group.svelte ---
<script lang="ts"> import { Select as SelectPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: SelectPrimitive.GroupProps = $props(); </script> <SelectPrimitive.Group data-slot="select-group" {...restProps} />

// --- Ruta: src/lib/components/ui/select/select-group-heading.svelte ---
<script lang="ts"> import { Select as SelectPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; import type { ComponentProps } from "svelte"; let { ref = $bindable(null), class: className, children, ...restProps }: ComponentProps<typeof SelectPrimitive.GroupHeading> = $props(); </script> <SelectPrimitive.GroupHeading bind:ref data-slot="select-group-heading" class={cn("text-muted-foreground px-2 py-1.5 text-xs", className)} {...restProps} > {@render children?.()} </SelectPrimitive.GroupHeading>

// --- Ruta: src/lib/components/ui/select/select-content.svelte ---
<script lang="ts"> import { Select as SelectPrimitive } from "bits-ui"; import SelectScrollUpButton from "./select-scroll-up-button.svelte"; import SelectScrollDownButton from "./select-scroll-down-button.svelte"; import { cn, type WithoutChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, sideOffset = 4, portalProps, children, ...restProps }: WithoutChild<SelectPrimitive.ContentProps> & { portalProps?: SelectPrimitive.PortalProps; } = $props(); </script> <SelectPrimitive.Portal {...portalProps}> <SelectPrimitive.Content bind:ref {sideOffset} data-slot="select-content" class={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 max-h-(--bits-select-content-available-height) origin-(--bits-select-content-transform-origin) relative z-50 min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border shadow-md data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", className )} {...restProps} > <SelectScrollUpButton /> <SelectPrimitive.Viewport class={cn( "h-(--bits-select-anchor-height) min-w-(--bits-select-anchor-width) w-full scroll-my-1 p-1" )} > {@render children?.()} </SelectPrimitive.Viewport> <SelectScrollDownButton /> </SelectPrimitive.Content> </SelectPrimitive.Portal>

// --- Ruta: src/lib/components/ui/select/index.ts ---
const Root = SelectPrimitive.Root; export { Root, Group, Label, Item, Content, Trigger, Separator, ScrollDownButton, ScrollUpButton, GroupHeading, Root as Select, Group as SelectGroup, Label as SelectLabel, Item as SelectItem, Content as SelectContent, Trigger as SelectTrigger, Separator as SelectSeparator, ScrollDownButton as SelectScrollDownButton, ScrollUpButton as SelectScrollUpButton, GroupHeading as SelectGroupHeading, };

// --- Ruta: src/lib/components/ui/tooltip/tooltip-trigger.svelte ---
<script lang="ts"> import { Tooltip as TooltipPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: TooltipPrimitive.TriggerProps = $props(); </script> <TooltipPrimitive.Trigger bind:ref data-slot="tooltip-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/tooltip/tooltip-content.svelte ---
<script lang="ts"> import { Tooltip as TooltipPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, sideOffset = 0, side = "top", children, arrowClasses, ...restProps }: TooltipPrimitive.ContentProps & { arrowClasses?: string; } = $props(); </script> <TooltipPrimitive.Portal> <TooltipPrimitive.Content bind:ref data-slot="tooltip-content" {sideOffset} {side} class={cn( "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-tooltip-content-transform-origin) z-50 w-fit text-balance rounded-md px-3 py-1.5 text-xs", className )} {...restProps} > {@render children?.()} <TooltipPrimitive.Arrow> {#snippet child({ props })} <div class={cn( "bg-primary z-50 size-2.5 rotate-45 rounded-[2px]", "data-[side=top]:translate-x-1/2 data-[side=top]:translate-y-[calc(-50%_+_2px)]", "data-[side=bottom]:-translate-x-1/2 data-[side=bottom]:-translate-y-[calc(-50%_+_1px)]", "data-[side=right]:translate-x-[calc(50%_+_2px)] data-[side=right]:translate-y-1/2", "data-[side=left]:-translate-y-[calc(50%_-_3px)]", arrowClasses )} {...props} ></div> {/snippet} </TooltipPrimitive.Arrow> </TooltipPrimitive.Content> </TooltipPrimitive.Portal>

// --- Ruta: src/lib/components/ui/tooltip/index.ts ---
const Root = TooltipPrimitive.Root; const Provider = TooltipPrimitive.Provider; const Portal = TooltipPrimitive.Portal; export { Root, Trigger, Content, Provider, Portal, Root as Tooltip, Content as TooltipContent, Trigger as TooltipTrigger, Provider as TooltipProvider, Portal as TooltipPortal, };

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import * as RangeCalendar from "./index.js"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; import type { ButtonVariant } from "$lib/components/ui/button/index.js"; import type { Snippet } from "svelte"; import { isEqualMonth, type DateValue } from "@internationalized/date"; let { ref = $bindable(null), value = $bindable(), placeholder = $bindable(), weekdayFormat = "short", class: className, buttonVariant = "ghost", captionLayout = "label", locale = "en-US", months: monthsProp, years, monthFormat: monthFormatProp, yearFormat = "numeric", day, disableDaysOutsideMonth = false, ...restProps }: WithoutChildrenOrChild<RangeCalendarPrimitive.RootProps> & { buttonVariant?: ButtonVariant; captionLayout?: "dropdown" | "dropdown-months" | "dropdown-years" | "label"; months?: RangeCalendarPrimitive.MonthSelectProps["months"]; years?: RangeCalendarPrimitive.YearSelectProps["years"]; monthFormat?: RangeCalendarPrimitive.MonthSelectProps["monthFormat"]; yearFormat?: RangeCalendarPrimitive.YearSelectProps["yearFormat"]; day?: Snippet<[{ day: DateValue; outsideMonth: boolean }]>; } = $props(); const monthFormat = $derived.by(() => { if (monthFormatProp) return monthFormatProp; if (captionLayout.startsWith("dropdown")) return "short"; return "long"; }); </script> <RangeCalendarPrimitive.Root bind:ref bind:value bind:placeholder {weekdayFormat} {disableDaysOutsideMonth} class={cn( "bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", className )} {locale} {monthFormat} {yearFormat} {...restProps} > {#snippet children({ months, weekdays })} <RangeCalendar.Months> <RangeCalendar.Nav> <RangeCalendar.PrevButton variant={buttonVariant} /> <RangeCalendar.NextButton variant={buttonVariant} /> </RangeCalendar.Nav> {#each months as month, monthIndex (month)} <RangeCalendar.Month> <RangeCalendar.Header> <RangeCalendar.Caption {captionLayout} months={monthsProp} {monthFormat} {years} {yearFormat} month={month.value} bind:placeholder {locale} {monthIndex} /> </RangeCalendar.Header> <RangeCalendar.Grid> <RangeCalendar.GridHead> <RangeCalendar.GridRow class="select-none"> {#each weekdays as weekday (weekday)} <RangeCalendar.HeadCell> {weekday.slice(0, 2)} </RangeCalendar.HeadCell> {/each} </RangeCalendar.GridRow> </RangeCalendar.GridHead> <RangeCalendar.GridBody> {#each month.weeks as weekDates (weekDates)} <RangeCalendar.GridRow class="mt-2 w-full"> {#each weekDates as date (date)} <RangeCalendar.Cell {date} month={month.value}> {#if day} {@render day({ day: date, outsideMonth: !isEqualMonth(date, month.value), })} {:else} <RangeCalendar.Day /> {/if} </RangeCalendar.Cell> {/each} </RangeCalendar.GridRow> {/each} </RangeCalendar.GridBody> </RangeCalendar.Grid> </RangeCalendar.Month> {/each} </RangeCalendar.Months> {/snippet} </RangeCalendarPrimitive.Root>

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-year-select.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; import ChevronDownIcon from "@lucide/svelte/icons/chevron-down"; let { ref = $bindable(null), class: className, value, ...restProps }: WithoutChildrenOrChild<RangeCalendarPrimitive.YearSelectProps> = $props(); </script> <span class={cn( "has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative flex rounded-md border", className )} > <RangeCalendarPrimitive.YearSelect bind:ref class="absolute inset-0 opacity-0" {...restProps}> {#snippet child({ props, yearItems, selectedYearItem })} <select {...props} {value}> {#each yearItems as yearItem (yearItem.value)} <option value={yearItem.value} selected={value !== undefined ? yearItem.value === value : yearItem.value === selectedYearItem.value} > {yearItem.label} </option> {/each} </select> <span class="[&>svg]:text-muted-foreground flex h-8 select-none items-center gap-1 rounded-md pl-2 pr-1 text-sm font-medium [&>svg]:size-3.5" aria-hidden="true" > {yearItems.find((item) => item.value === value)?.label || selectedYearItem.label} <ChevronDownIcon class="size-4" /> </span> {/snippet} </RangeCalendarPrimitive.YearSelect> </span>

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-prev-button.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import ChevronLeftIcon from "@lucide/svelte/icons/chevron-left"; import { buttonVariants, type ButtonVariant } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, variant = "ghost", ...restProps }: RangeCalendarPrimitive.PrevButtonProps & { variant?: ButtonVariant; } = $props(); </script> {#snippet Fallback()} <ChevronLeftIcon class="size-4" /> {/snippet} <RangeCalendarPrimitive.PrevButton bind:ref class={cn( buttonVariants({ variant }), "size-(--cell-size) select-none bg-transparent p-0 disabled:opacity-50 rtl:rotate-180", className )} children={children || Fallback} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-next-button.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import ChevronRightIcon from "@lucide/svelte/icons/chevron-right"; import { buttonVariants, type ButtonVariant } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, variant = "ghost", ...restProps }: RangeCalendarPrimitive.NextButtonProps & { variant?: ButtonVariant; } = $props(); </script> {#snippet Fallback()} <ChevronRightIcon class="size-4" /> {/snippet} <RangeCalendarPrimitive.NextButton bind:ref class={cn( buttonVariants({ variant }), "size-(--cell-size) select-none bg-transparent p-0 disabled:opacity-50 rtl:rotate-180", className )} children={children || Fallback} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-nav.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLElement>> = $props(); </script> <nav {...restProps} bind:this={ref} class={cn("absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1", className)} > {@render children?.()} </nav>

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-months.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} class={cn("relative flex flex-col gap-4 md:flex-row", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-month.svelte ---
<script lang="ts"> import { type WithElementRef, cn } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLElement>> = $props(); </script> <div {...restProps} bind:this={ref} class={cn("flex flex-col", className)}> {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-month-select.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; import ChevronDownIcon from "@lucide/svelte/icons/chevron-down"; let { ref = $bindable(null), class: className, value, onchange, ...restProps }: WithoutChildrenOrChild<RangeCalendarPrimitive.MonthSelectProps> = $props(); </script> <span class={cn( "has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative flex rounded-md border", className )} > <RangeCalendarPrimitive.MonthSelect bind:ref class="absolute inset-0 opacity-0" {...restProps}> {#snippet child({ props, monthItems, selectedMonthItem })} <select {...props} {value} {onchange}> {#each monthItems as monthItem (monthItem.value)} <option value={monthItem.value} selected={value !== undefined ? monthItem.value === value : monthItem.value === selectedMonthItem.value} > {monthItem.label} </option> {/each} </select> <span class="[&>svg]:text-muted-foreground flex h-8 select-none items-center gap-1 rounded-md pl-2 pr-1 text-sm font-medium [&>svg]:size-3.5" aria-hidden="true" > {monthItems.find((item) => item.value === value)?.label || selectedMonthItem.label} <ChevronDownIcon class="size-4" /> </span> {/snippet} </RangeCalendarPrimitive.MonthSelect> </span>

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-heading.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: RangeCalendarPrimitive.HeadingProps = $props(); </script> <RangeCalendarPrimitive.Heading bind:ref class={cn("px-(--cell-size) text-sm font-medium", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-header.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: RangeCalendarPrimitive.HeaderProps = $props(); </script> <RangeCalendarPrimitive.Header bind:ref class={cn( "h-(--cell-size) flex w-full items-center justify-center gap-1.5 text-sm font-medium", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-head-cell.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: RangeCalendarPrimitive.HeadCellProps = $props(); </script> <RangeCalendarPrimitive.HeadCell bind:ref class={cn( "text-muted-foreground w-(--cell-size) rounded-md text-[0.8rem] font-normal", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-grid.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: RangeCalendarPrimitive.GridProps = $props(); </script> <RangeCalendarPrimitive.Grid bind:ref class={cn("mt-4 flex w-full border-collapse flex-col gap-1", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-grid-row.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: RangeCalendarPrimitive.GridRowProps = $props(); </script> <RangeCalendarPrimitive.GridRow bind:ref class={cn("flex", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-day.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { buttonVariants } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: RangeCalendarPrimitive.DayProps = $props(); </script> <RangeCalendarPrimitive.Day bind:ref class={cn( buttonVariants({ variant: "ghost" }), "size-(--cell-size) flex select-none flex-col items-center justify-center gap-1 whitespace-nowrap p-0 font-normal leading-none", "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground [&[data-today][data-disabled]]:text-muted-foreground data-[range-middle]:rounded-none", "data-[range-start]:bg-primary dark:data-[range-start]:hover:bg-accent data-[range-start]:text-primary-foreground", "data-[range-end]:bg-primary dark:data-[range-end]:hover:bg-accent data-[range-end]:text-primary-foreground", "[&[data-outside-month]:not([data-selected])]:text-muted-foreground [&[data-outside-month]:not([data-selected])]:hover:text-accent-foreground", "data-[disabled]:text-muted-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", "data-[unavailable]:line-through", "dark:data-[range-middle]:hover:bg-accent/0", "dark:hover:text-accent-foreground", "focus:border-ring focus:ring-ring/50 focus:relative", "[&>span]:text-xs [&>span]:opacity-70", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-cell.svelte ---
<script lang="ts"> import { RangeCalendar as RangeCalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: RangeCalendarPrimitive.CellProps = $props(); </script> <RangeCalendarPrimitive.Cell bind:ref class={cn( "size-(--cell-size) dark:[&:has([data-range-start])]:hover:bg-accent dark:[&:has([data-range-end])]:hover:bg-accent [&:has([data-range-middle])]:bg-accent dark:[&:has([data-range-middle])]:hover:bg-accent/50 [&:has([data-selected])]:bg-accent relative p-0 text-center text-sm focus-within:z-20 data-[range-middle]:rounded-r-md [&:first-child[data-selected]_[data-bits-day]]:rounded-l-md [&:has([data-range-end])]:rounded-r-md [&:has([data-range-middle])]:rounded-none first:[&:has([data-range-middle])]:rounded-l-md last:[&:has([data-range-middle])]:rounded-r-md [&:has([data-range-start])]:rounded-l-md [&:last-child[data-selected]_[data-bits-day]]:rounded-r-md", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/range-calendar/range-calendar-caption.svelte ---
<script lang="ts"> import type { ComponentProps } from "svelte"; import type RangeCalendar from "./range-calendar.svelte"; import RangeCalendarMonthSelect from "./range-calendar-month-select.svelte"; import RangeCalendarYearSelect from "./range-calendar-year-select.svelte"; import { DateFormatter, getLocalTimeZone, type DateValue } from "@internationalized/date"; let { captionLayout, months, monthFormat, years, yearFormat, month, locale, placeholder = $bindable(), monthIndex = 0, }: { captionLayout: ComponentProps<typeof RangeCalendar>["captionLayout"]; months: ComponentProps<typeof RangeCalendarMonthSelect>["months"]; monthFormat: ComponentProps<typeof RangeCalendarMonthSelect>["monthFormat"]; years: ComponentProps<typeof RangeCalendarYearSelect>["years"]; yearFormat: ComponentProps<typeof RangeCalendarYearSelect>["yearFormat"]; month: DateValue; placeholder: DateValue | undefined; locale: string; monthIndex: number; } = $props(); function formatYear(date: DateValue) { const dateObj = date.toDate(getLocalTimeZone()); if (typeof yearFormat === "function") return yearFormat(dateObj.getFullYear()); return new DateFormatter(locale, { year: yearFormat }).format(dateObj); } function formatMonth(date: DateValue) { const dateObj = date.toDate(getLocalTimeZone()); if (typeof monthFormat === "function") return monthFormat(dateObj.getMonth() + 1); return new DateFormatter(locale, { month: monthFormat }).format(dateObj); } </script> {#snippet MonthSelect()} <RangeCalendarMonthSelect {months} {monthFormat} value={month.month} onchange={(e) => { if (!placeholder) return; const v = Number.parseInt(e.currentTarget.value); const newPlaceholder = placeholder.set({ month: v }); placeholder = newPlaceholder.subtract({ months: monthIndex }); }} /> {/snippet} {#snippet YearSelect()} <RangeCalendarYearSelect {years} {yearFormat} value={month.year} /> {/snippet} {#if captionLayout === "dropdown"} {@render MonthSelect()} {@render YearSelect()} {:else if captionLayout === "dropdown-months"} {@render MonthSelect()} {#if placeholder} {formatYear(placeholder)} {/if} {:else if captionLayout === "dropdown-years"} {#if placeholder} {formatMonth(placeholder)} {/if} {@render YearSelect()} {:else} {formatMonth(month)} {formatYear(month)} {/if}

// --- Ruta: src/lib/components/ui/range-calendar/index.ts ---
const GridHead = RangeCalendarPrimitive.GridHead; const GridBody = RangeCalendarPrimitive.GridBody; export { Day, Cell, Grid, Header, Months, GridRow, Heading, GridBody, GridHead, HeadCell, NextButton, PrevButton, MonthSelect, YearSelect, Caption, Nav, Month, Root as RangeCalendar, };

// --- Ruta: src/lib/components/ui/label/label.svelte ---
<script lang="ts"> import { Label as LabelPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: LabelPrimitive.RootProps = $props(); </script> <LabelPrimitive.Root bind:ref data-slot="label" class={cn( "flex select-none items-center gap-2 text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-50 group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/label/index.ts ---
export { Root, Root as Label, };

// --- Ruta: src/lib/components/ui/popover/popover-trigger.svelte ---
<script lang="ts"> import { cn } from "$lib/utils.js"; import { Popover as PopoverPrimitive } from "bits-ui"; let { ref = $bindable(null), class: className, ...restProps }: PopoverPrimitive.TriggerProps = $props(); </script> <PopoverPrimitive.Trigger bind:ref data-slot="popover-trigger" class={cn("", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/popover/popover-content.svelte ---
<script lang="ts"> import { cn } from "$lib/utils.js"; import { Popover as PopoverPrimitive } from "bits-ui"; let { ref = $bindable(null), class: className, sideOffset = 4, align = "center", portalProps, ...restProps }: PopoverPrimitive.ContentProps & { portalProps?: PopoverPrimitive.PortalProps; } = $props(); </script> <PopoverPrimitive.Portal {...portalProps}> <PopoverPrimitive.Content bind:ref data-slot="popover-content" {sideOffset} {align} class={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-popover-content-transform-origin) outline-hidden z-50 w-72 rounded-md border p-4 shadow-md", className )} {...restProps} /> </PopoverPrimitive.Portal>

// --- Ruta: src/lib/components/ui/popover/index.ts ---
const Root = PopoverPrimitive.Root; const Close = PopoverPrimitive.Close; export { Root, Content, Trigger, Close, Root as Popover, Content as PopoverContent, Trigger as PopoverTrigger, Close as PopoverClose, };

// --- Ruta: src/lib/components/ui/input/input.svelte ---
<script lang="ts"> import type { HTMLInputAttributes, HTMLInputTypeAttribute } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; type InputType = Exclude<HTMLInputTypeAttribute, "file">; type Props = WithElementRef< Omit<HTMLInputAttributes, "type"> & ({ type: "file"; files?: FileList } | { type?: InputType; files?: undefined }) >; let { ref = $bindable(null), value = $bindable(), type, files = $bindable(), class: className, ...restProps }: Props = $props(); </script> {#if type === "file"} <input bind:this={ref} data-slot="input" class={cn( "selection:bg-primary dark:bg-input/30 selection:text-primary-foreground border-input ring-offset-background placeholder:text-muted-foreground shadow-xs flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 pt-1.5 text-sm font-medium outline-none transition-[color,box-shadow] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", className )} type="file" bind:files bind:value {...restProps} /> {:else} <input bind:this={ref} data-slot="input" class={cn( "border-input bg-background selection:bg-primary dark:bg-input/30 selection:text-primary-foreground ring-offset-background placeholder:text-muted-foreground shadow-xs flex h-9 w-full min-w-0 rounded-md border px-3 py-1 text-base outline-none transition-[color,box-shadow] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", className )} {type} bind:value {...restProps} /> {/if}

// --- Ruta: src/lib/components/ui/input/index.ts ---
export { Root, Root as Input, };

// --- Ruta: src/lib/components/ui/dialog/index.ts ---
const Root = DialogPrimitive.Dialog.Root; const Portal = DialogPrimitive.Dialog.Portal; export { Root, Title, Portal, Footer, Header, Trigger, Overlay, Content, Description, Close, Root as Dialog, Title as DialogTitle, Portal as DialogPortal, Footer as DialogFooter, Header as DialogHeader, Trigger as DialogTrigger, Overlay as DialogOverlay, Content as DialogContent, Description as DialogDescription, Close as DialogClose, };

// --- Ruta: src/lib/components/ui/dialog/dialog-trigger.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: DialogPrimitive.TriggerProps = $props(); </script> <DialogPrimitive.Trigger bind:ref data-slot="dialog-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-title.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DialogPrimitive.TitleProps = $props(); </script> <DialogPrimitive.Title bind:ref data-slot="dialog-title" class={cn("text-lg font-semibold leading-none", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-overlay.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DialogPrimitive.OverlayProps = $props(); </script> <DialogPrimitive.Overlay bind:ref data-slot="dialog-overlay" class={cn( "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-header.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="dialog-header" class={cn("flex flex-col gap-2 text-center sm:text-left", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/dialog/dialog-footer.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="dialog-footer" class={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/dialog/dialog-description.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DialogPrimitive.DescriptionProps = $props(); </script> <DialogPrimitive.Description bind:ref data-slot="dialog-description" class={cn("text-muted-foreground text-sm", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/dialog/dialog-content.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; import XIcon from "@lucide/svelte/icons/x"; import type { Snippet } from "svelte"; import * as Dialog from "./index.js"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, portalProps, children, showCloseButton = true, ...restProps }: WithoutChildrenOrChild<DialogPrimitive.ContentProps> & { portalProps?: DialogPrimitive.PortalProps; children: Snippet; showCloseButton?: boolean; } = $props(); </script> <Dialog.Portal {...portalProps}> <Dialog.Overlay /> <DialogPrimitive.Content bind:ref data-slot="dialog-content" class={cn( "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", className )} {...restProps} > {@render children?.()} {#if showCloseButton} <DialogPrimitive.Close class="ring-offset-background focus:ring-ring rounded-xs focus:outline-hidden absolute right-4 top-4 opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 disabled:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0" > <XIcon /> <span class="sr-only">Close</span> </DialogPrimitive.Close> {/if} </DialogPrimitive.Content> </Dialog.Portal>

// --- Ruta: src/lib/components/ui/dialog/dialog-close.svelte ---
<script lang="ts"> import { Dialog as DialogPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: DialogPrimitive.CloseProps = $props(); </script> <DialogPrimitive.Close bind:ref data-slot="dialog-close" {...restProps} />

// --- Ruta: src/lib/components/ui/command/index.ts ---
const Loading = CommandPrimitive.Loading; export { Root, Dialog, Empty, Group, Item, LinkItem, Input, List, Separator, Shortcut, Loading, Root as Command, Dialog as CommandDialog, Empty as CommandEmpty, Group as CommandGroup, Item as CommandItem, LinkItem as CommandLinkItem, Input as CommandInput, List as CommandList, Separator as CommandSeparator, Shortcut as CommandShortcut, Loading as CommandLoading, };

// --- Ruta: src/lib/components/ui/command/command.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), value = $bindable(""), class: className, ...restProps }: CommandPrimitive.RootProps = $props(); </script> <CommandPrimitive.Root bind:value bind:ref data-slot="command" class={cn( "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-shortcut.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLSpanElement>> = $props(); </script> <span bind:this={ref} data-slot="command-shortcut" class={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)} {...restProps} > {@render children?.()} </span>

// --- Ruta: src/lib/components/ui/command/command-separator.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.SeparatorProps = $props(); </script> <CommandPrimitive.Separator bind:ref data-slot="command-separator" class={cn("bg-border -mx-1 h-px", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-list.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.ListProps = $props(); </script> <CommandPrimitive.List bind:ref data-slot="command-list" class={cn("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-link-item.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.LinkItemProps = $props(); </script> <CommandPrimitive.LinkItem bind:ref data-slot="command-item" class={cn( "aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-item.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.ItemProps = $props(); </script> <CommandPrimitive.Item bind:ref data-slot="command-item" class={cn( "aria-selected:bg-accent aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-input.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import SearchIcon from "@lucide/svelte/icons/search"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, value = $bindable(""), ...restProps }: CommandPrimitive.InputProps = $props(); </script> <div class="flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"> <SearchIcon class="size-4 shrink-0 opacity-50" /> <CommandPrimitive.Input data-slot="command-input" class={cn( "placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", className )} bind:ref {...restProps} bind:value /> </div>

// --- Ruta: src/lib/components/ui/command/command-group.svelte ---
<script lang="ts"> import { Command as CommandPrimitive, useId } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, heading, value, ...restProps }: CommandPrimitive.GroupProps & { heading?: string; } = $props(); </script> <CommandPrimitive.Group bind:ref data-slot="command-group" class={cn("text-foreground overflow-hidden p-1", className)} value={value ?? heading ?? `----${useId()}`} {...restProps} > {#if heading} <CommandPrimitive.GroupHeading class="text-muted-foreground px-2 py-1.5 text-xs font-medium" > {heading} </CommandPrimitive.GroupHeading> {/if} <CommandPrimitive.GroupItems {children} /> </CommandPrimitive.Group>

// --- Ruta: src/lib/components/ui/command/command-empty.svelte ---
<script lang="ts"> import { Command as CommandPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CommandPrimitive.EmptyProps = $props(); </script> <CommandPrimitive.Empty bind:ref data-slot="command-empty" class={cn("py-6 text-center text-sm", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/command/command-dialog.svelte ---
<script lang="ts"> import type { Command as CommandPrimitive, Dialog as DialogPrimitive } from "bits-ui"; import type { Snippet } from "svelte"; import Command from "./command.svelte"; import * as Dialog from "$lib/components/ui/dialog/index.js"; import type { WithoutChildrenOrChild } from "$lib/utils.js"; let { open = $bindable(false), ref = $bindable(null), value = $bindable(""), title = "Command Palette", description = "Search for a command to run", portalProps, children, ...restProps }: WithoutChildrenOrChild<DialogPrimitive.RootProps> & WithoutChildrenOrChild<CommandPrimitive.RootProps> & { portalProps?: DialogPrimitive.PortalProps; children: Snippet; title?: string; description?: string; } = $props(); </script> <Dialog.Root bind:open {...restProps}> <Dialog.Header class="sr-only"> <Dialog.Title>{title}</Dialog.Title> <Dialog.Description>{description}</Dialog.Description> </Dialog.Header> <Dialog.Content class="overflow-hidden p-0" {portalProps}> <Command class="**:data-[slot=command-input-wrapper]:h-12 [&_[data-command-group]:not([hidden])_~[data-command-group]]:pt-0 [&_[data-command-group]]:px-2 [&_[data-command-input-wrapper]_svg]:h-5 [&_[data-command-input-wrapper]_svg]:w-5 [&_[data-command-input]]:h-12 [&_[data-command-item]]:px-2 [&_[data-command-item]]:py-3 [&_[data-command-item]_svg]:h-5 [&_[data-command-item]_svg]:w-5" {...restProps} bind:value bind:ref {children} /> </Dialog.Content> </Dialog.Root>

// --- Ruta: src/lib/components/ui/collapsible/index.ts ---
export { Root, Content, Trigger, Root as Collapsible, Content as CollapsibleContent, Trigger as CollapsibleTrigger, };

// --- Ruta: src/lib/components/ui/collapsible/collapsible.svelte ---
<script lang="ts"> import { Collapsible as CollapsiblePrimitive } from "bits-ui"; let { ref = $bindable(null), open = $bindable(false), ...restProps }: CollapsiblePrimitive.RootProps = $props(); </script> <CollapsiblePrimitive.Root bind:ref bind:open data-slot="collapsible" {...restProps} />

// --- Ruta: src/lib/components/ui/collapsible/collapsible-trigger.svelte ---
<script lang="ts"> import { Collapsible as CollapsiblePrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: CollapsiblePrimitive.TriggerProps = $props(); </script> <CollapsiblePrimitive.Trigger bind:ref data-slot="collapsible-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/collapsible/collapsible-content.svelte ---
<script lang="ts"> import { Collapsible as CollapsiblePrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: CollapsiblePrimitive.ContentProps = $props(); </script> <CollapsiblePrimitive.Content bind:ref data-slot="collapsible-content" {...restProps} />

// --- Ruta: src/lib/components/ui/collapsible/CollapsiblePanel.svelte ---
<script lang="ts"> import { slide } from 'svelte/transition'; import ChevronDown from 'lucide-svelte/icons/chevron-down'; import type { Snippet } from 'svelte'; let { title, startOpen = true, children }: { title: string; startOpen?: boolean; children: Snippet } = $props(); let isOpen = $state(startOpen); $effect(() => { isOpen = startOpen; }); function toggle() { isOpen = !isOpen; } </script> <div class="rounded-lg border"> <h2> <button onclick={toggle} class="flex w-full items-center justify-between p-4 text-lg font-semibold" aria-expanded={isOpen} > {title} <ChevronDown class={`h-5 w-5 transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} /> </button> </h2> {#if isOpen} <div transition:slide={{ duration: 200 }} class="p-4 pt-0"> {@render children()} </div> {/if} </div>

// --- Ruta: src/lib/components/ui/dropdown-menu/index.ts ---
const Sub = DropdownMenuPrimitive.Sub; const Root = DropdownMenuPrimitive.Root; export { CheckboxItem, Content, Root as DropdownMenu, CheckboxItem as DropdownMenuCheckboxItem, Content as DropdownMenuContent, Group as DropdownMenuGroup, Item as DropdownMenuItem, Label as DropdownMenuLabel, RadioGroup as DropdownMenuRadioGroup, RadioItem as DropdownMenuRadioItem, Separator as DropdownMenuSeparator, Shortcut as DropdownMenuShortcut, Sub as DropdownMenuSub, SubContent as DropdownMenuSubContent, SubTrigger as DropdownMenuSubTrigger, Trigger as DropdownMenuTrigger, GroupHeading as DropdownMenuGroupHeading, Group, GroupHeading, Item, Label, RadioGroup, RadioItem, Root, Separator, Shortcut, Sub, SubContent, SubTrigger, Trigger, };

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-trigger.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: DropdownMenuPrimitive.TriggerProps = $props(); </script> <DropdownMenuPrimitive.Trigger bind:ref data-slot="dropdown-menu-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-sub-trigger.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import ChevronRightIcon from "@lucide/svelte/icons/chevron-right"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, inset, children, ...restProps }: DropdownMenuPrimitive.SubTriggerProps & { inset?: boolean; } = $props(); </script> <DropdownMenuPrimitive.SubTrigger bind:ref data-slot="dropdown-menu-sub-trigger" data-inset={inset} class={cn( "data-highlighted:bg-accent data-highlighted:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground outline-hidden [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} > {@render children?.()} <ChevronRightIcon class="ml-auto size-4" /> </DropdownMenuPrimitive.SubTrigger>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-sub-content.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DropdownMenuPrimitive.SubContentProps = $props(); </script> <DropdownMenuPrimitive.SubContent bind:ref data-slot="dropdown-menu-sub-content" class={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-(--bits-dropdown-menu-content-transform-origin) z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-shortcut.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLSpanElement>> = $props(); </script> <span bind:this={ref} data-slot="dropdown-menu-shortcut" class={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)} {...restProps} > {@render children?.()} </span>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-separator.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: DropdownMenuPrimitive.SeparatorProps = $props(); </script> <DropdownMenuPrimitive.Separator bind:ref data-slot="dropdown-menu-separator" class={cn("bg-border -mx-1 my-1 h-px", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-radio-item.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import CircleIcon from "@lucide/svelte/icons/circle"; import { cn, type WithoutChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children: childrenProp, ...restProps }: WithoutChild<DropdownMenuPrimitive.RadioItemProps> = $props(); </script> <DropdownMenuPrimitive.RadioItem bind:ref data-slot="dropdown-menu-radio-item" class={cn( "focus:bg-accent focus:text-accent-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-8 pr-2 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} > {#snippet children({ checked })} <span class="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center"> {#if checked} <CircleIcon class="size-2 fill-current" /> {/if} </span> {@render childrenProp?.({ checked })} {/snippet} </DropdownMenuPrimitive.RadioItem>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-radio-group.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), value = $bindable(), ...restProps }: DropdownMenuPrimitive.RadioGroupProps = $props(); </script> <DropdownMenuPrimitive.RadioGroup bind:ref bind:value data-slot="dropdown-menu-radio-group" {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-label.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, inset, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> & { inset?: boolean; } = $props(); </script> <div bind:this={ref} data-slot="dropdown-menu-label" data-inset={inset} class={cn("px-2 py-1.5 text-sm font-semibold data-[inset]:pl-8", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-item.svelte ---
<script lang="ts"> import { cn } from "$lib/utils.js"; import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), class: className, inset, variant = "default", ...restProps }: DropdownMenuPrimitive.ItemProps & { inset?: boolean; variant?: "default" | "destructive"; } = $props(); </script> <DropdownMenuPrimitive.Item bind:ref data-slot="dropdown-menu-item" data-inset={inset} data-variant={variant} class={cn( "data-highlighted:bg-accent data-highlighted:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:data-highlighted:bg-destructive/10 dark:data-[variant=destructive]:data-highlighted:bg-destructive/20 data-[variant=destructive]:data-highlighted:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[inset]:pl-8 data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-group.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: DropdownMenuPrimitive.GroupProps = $props(); </script> <DropdownMenuPrimitive.Group bind:ref data-slot="dropdown-menu-group" {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-group-heading.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; import type { ComponentProps } from "svelte"; let { ref = $bindable(null), class: className, inset, ...restProps }: ComponentProps<typeof DropdownMenuPrimitive.GroupHeading> & { inset?: boolean; } = $props(); </script> <DropdownMenuPrimitive.GroupHeading bind:ref data-slot="dropdown-menu-group-heading" data-inset={inset} class={cn("px-2 py-1.5 text-sm font-semibold data-[inset]:pl-8", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-content.svelte ---
<script lang="ts"> import { cn } from "$lib/utils.js"; import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; let { ref = $bindable(null), sideOffset = 4, portalProps, class: className, ...restProps }: DropdownMenuPrimitive.ContentProps & { portalProps?: DropdownMenuPrimitive.PortalProps; } = $props(); </script> <DropdownMenuPrimitive.Portal {...portalProps}> <DropdownMenuPrimitive.Content bind:ref data-slot="dropdown-menu-content" {sideOffset} class={cn( "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 max-h-(--bits-dropdown-menu-content-available-height) origin-(--bits-dropdown-menu-content-transform-origin) z-50 min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border p-1 shadow-md outline-none", className )} {...restProps} /> </DropdownMenuPrimitive.Portal>

// --- Ruta: src/lib/components/ui/dropdown-menu/dropdown-menu-checkbox-item.svelte ---
<script lang="ts"> import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui"; import CheckIcon from "@lucide/svelte/icons/check"; import MinusIcon from "@lucide/svelte/icons/minus"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; import type { Snippet } from "svelte"; let { ref = $bindable(null), checked = $bindable(false), indeterminate = $bindable(false), class: className, children: childrenProp, ...restProps }: WithoutChildrenOrChild<DropdownMenuPrimitive.CheckboxItemProps> & { children?: Snippet; } = $props(); </script> <DropdownMenuPrimitive.CheckboxItem bind:ref bind:checked bind:indeterminate data-slot="dropdown-menu-checkbox-item" class={cn( "focus:bg-accent focus:text-accent-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pl-8 pr-2 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", className )} {...restProps} > {#snippet children({ checked, indeterminate })} <span class="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center"> {#if indeterminate} <MinusIcon class="size-4" /> {:else} <CheckIcon class={cn("size-4", !checked && "text-transparent")} /> {/if} </span> {@render childrenProp?.()} {/snippet} </DropdownMenuPrimitive.CheckboxItem>

// --- Ruta: src/lib/components/ui/button/index.ts ---
type ButtonProps, type ButtonSize, type ButtonVariant, buttonVariants, } from "./button.svelte"; export { Root, type ButtonProps as Props, Root as Button, buttonVariants, type ButtonProps, type ButtonSize, type ButtonVariant, };

// --- Ruta: src/lib/components/ui/button/button.svelte ---
<script lang="ts" module> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAnchorAttributes, HTMLButtonAttributes } from "svelte/elements"; import { type VariantProps, tv } from "tailwind-variants"; export const buttonVariants = tv({ base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", variants: { variant: { default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90", destructive: "bg-destructive shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60 text-white", outline: "bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border", secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50", link: "text-primary underline-offset-4 hover:underline", }, size: { default: "h-9 px-4 py-2 has-[>svg]:px-3", sm: "h-8 gap-1.5 rounded-md px-3 has-[>svg]:px-2.5", lg: "h-10 rounded-md px-6 has-[>svg]:px-4", icon: "size-9", }, }, defaultVariants: { variant: "default", size: "default", }, }); export type ButtonVariant = VariantProps<typeof buttonVariants>["variant"]; export type ButtonSize = VariantProps<typeof buttonVariants>["size"]; export type ButtonProps = WithElementRef<HTMLButtonAttributes> & WithElementRef<HTMLAnchorAttributes> & { variant?: ButtonVariant; size?: ButtonSize; }; </script> <script lang="ts"> let { class: className, variant = "default", size = "default", ref = $bindable(null), href = undefined, type = "button", disabled, children, ...restProps }: ButtonProps = $props(); </script> {#if href} <a bind:this={ref} data-slot="button" class={cn(buttonVariants({ variant, size }), className)} href={disabled ? undefined : href} aria-disabled={disabled} role={disabled ? "link" : undefined} tabindex={disabled ? -1 : undefined} {...restProps} > {@render children?.()} </a> {:else} <button bind:this={ref} data-slot="button" class={cn(buttonVariants({ variant, size }), className)} {type} {disabled} {...restProps} > {@render children?.()} </button> {/if}

// --- Ruta: src/lib/components/ui/badge/index.ts ---
export { default as Badge } from "./badge.svelte"; export { badgeVariants, type BadgeVariant } from "./badge.svelte";

// --- Ruta: src/lib/components/ui/badge/badge.svelte ---
<script lang="ts" module> import { type VariantProps, tv } from "tailwind-variants"; export const badgeVariants = tv({ base: "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex w-fit shrink-0 items-center justify-center gap-1 overflow-hidden whitespace-nowrap rounded-md border px-2 py-0.5 text-xs font-medium transition-[color,box-shadow] focus-visible:ring-[3px] [&>svg]:pointer-events-none [&>svg]:size-3", variants: { variant: { default: "bg-primary text-primary-foreground [a&]:hover:bg-primary/90 border-transparent", secondary: "bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90 border-transparent", destructive: "bg-destructive [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/70 border-transparent text-white", outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground", }, }, defaultVariants: { variant: "default", }, }); export type BadgeVariant = VariantProps<typeof badgeVariants>["variant"]; </script> <script lang="ts"> import type { HTMLAnchorAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), href, class: className, variant = "default", children, ...restProps }: WithElementRef<HTMLAnchorAttributes> & { variant?: BadgeVariant; } = $props(); </script> <svelte:element this={href ? "a" : "span"} bind:this={ref} data-slot="badge" {href} class={cn(badgeVariants({ variant }), className)} {...restProps} > {@render children?.()} </svelte:element>

// --- Ruta: src/lib/components/ui/card/index.ts ---
export { Root, Content, Description, Footer, Header, Title, Action, Root as Card, Content as CardContent, Description as CardDescription, Footer as CardFooter, Header as CardHeader, Title as CardTitle, Action as CardAction, };

// --- Ruta: src/lib/components/ui/card/card.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card" class={cn( "bg-card text-card-foreground flex flex-col gap-6 pb-6 rounded-xl border shadow-sm", className )} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-title.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-title" class={cn("font-semibold leading-none", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-header.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-header" class={cn( "@container/card-header has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6 grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6", className )} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-footer.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-footer" class={cn("[.border-t]:pt-6 flex items-center px-6", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-description.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLParagraphElement>> = $props(); </script> <p bind:this={ref} data-slot="card-description" class={cn("text-muted-foreground text-sm", className)} {...restProps} > {@render children?.()} </p>

// --- Ruta: src/lib/components/ui/card/card-content.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-content" class={cn("px-6", className)} {...restProps}> {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/card/card-action.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="card-action" class={cn("col-start-2 row-span-2 row-start-1 self-start justify-self-end", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/calendar/index.ts ---
export { Day, Cell, Grid, Header, Months, GridRow, Heading, GridBody, GridHead, HeadCell, NextButton, PrevButton, Nav, Month, YearSelect, MonthSelect, Caption, Root as Calendar, };

// --- Ruta: src/lib/components/ui/calendar/calendar.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import * as Calendar from "./index.js"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; import type { ButtonVariant } from "../button/button.svelte"; import { isEqualMonth, type DateValue } from "@internationalized/date"; import type { Snippet } from "svelte"; let { ref = $bindable(null), value = $bindable(), placeholder = $bindable(), class: className, weekdayFormat = "short", buttonVariant = "ghost", captionLayout = "label", locale = "en-US", months: monthsProp, years, monthFormat: monthFormatProp, yearFormat = "numeric", day, disableDaysOutsideMonth = false, ...restProps }: WithoutChildrenOrChild<CalendarPrimitive.RootProps> & { buttonVariant?: ButtonVariant; captionLayout?: "dropdown" | "dropdown-months" | "dropdown-years" | "label"; months?: CalendarPrimitive.MonthSelectProps["months"]; years?: CalendarPrimitive.YearSelectProps["years"]; monthFormat?: CalendarPrimitive.MonthSelectProps["monthFormat"]; yearFormat?: CalendarPrimitive.YearSelectProps["yearFormat"]; day?: Snippet<[{ day: DateValue; outsideMonth: boolean }]>; } = $props(); const monthFormat = $derived.by(() => { if (monthFormatProp) return monthFormatProp; if (captionLayout.startsWith("dropdown")) return "short"; return "long"; }); </script> <!-- Discriminated Unions + Destructing (required for bindable) do not get along, so we shut typescript up by casting `value` to `never`. --> <CalendarPrimitive.Root bind:value={value as never} bind:ref bind:placeholder {weekdayFormat} {disableDaysOutsideMonth} class={cn( "bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", className )} {locale} {monthFormat} {yearFormat} {...restProps} > {#snippet children({ months, weekdays })} <Calendar.Months> <Calendar.Nav> <Calendar.PrevButton variant={buttonVariant} /> <Calendar.NextButton variant={buttonVariant} /> </Calendar.Nav> {#each months as month, monthIndex (month)} <Calendar.Month> <Calendar.Header> <Calendar.Caption {captionLayout} months={monthsProp} {monthFormat} {years} {yearFormat} month={month.value} bind:placeholder {locale} {monthIndex} /> </Calendar.Header> <Calendar.Grid> <Calendar.GridHead> <Calendar.GridRow class="select-none"> {#each weekdays as weekday (weekday)} <Calendar.HeadCell> {weekday.slice(0, 2)} </Calendar.HeadCell> {/each} </Calendar.GridRow> </Calendar.GridHead> <Calendar.GridBody> {#each month.weeks as weekDates (weekDates)} <Calendar.GridRow class="mt-2 w-full"> {#each weekDates as date (date)} <Calendar.Cell {date} month={month.value}> {#if day} {@render day({ day: date, outsideMonth: !isEqualMonth(date, month.value), })} {:else} <Calendar.Day /> {/if} </Calendar.Cell> {/each} </Calendar.GridRow> {/each} </Calendar.GridBody> </Calendar.Grid> </Calendar.Month> {/each} </Calendar.Months> {/snippet} </CalendarPrimitive.Root>

// --- Ruta: src/lib/components/ui/calendar/calendar-year-select.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; import ChevronDownIcon from "@lucide/svelte/icons/chevron-down"; let { ref = $bindable(null), class: className, value, ...restProps }: WithoutChildrenOrChild<CalendarPrimitive.YearSelectProps> = $props(); </script> <span class={cn( "has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative flex rounded-md border", className )} > <CalendarPrimitive.YearSelect bind:ref class="absolute inset-0 opacity-0" {...restProps}> {#snippet child({ props, yearItems, selectedYearItem })} <select {...props} {value}> {#each yearItems as yearItem (yearItem.value)} <option value={yearItem.value} selected={value !== undefined ? yearItem.value === value : yearItem.value === selectedYearItem.value} > {yearItem.label} </option> {/each} </select> <span class="[&>svg]:text-muted-foreground flex h-8 select-none items-center gap-1 rounded-md pl-2 pr-1 text-sm font-medium [&>svg]:size-3.5" aria-hidden="true" > {yearItems.find((item) => item.value === value)?.label || selectedYearItem.label} <ChevronDownIcon class="size-4" /> </span> {/snippet} </CalendarPrimitive.YearSelect> </span>

// --- Ruta: src/lib/components/ui/calendar/calendar-prev-button.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import ChevronLeftIcon from "@lucide/svelte/icons/chevron-left"; import { buttonVariants, type ButtonVariant } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, variant = "ghost", ...restProps }: CalendarPrimitive.PrevButtonProps & { variant?: ButtonVariant; } = $props(); </script> {#snippet Fallback()} <ChevronLeftIcon class="size-4" /> {/snippet} <CalendarPrimitive.PrevButton bind:ref class={cn( buttonVariants({ variant }), "size-(--cell-size) select-none bg-transparent p-0 disabled:opacity-50 rtl:rotate-180", className )} children={children || Fallback} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-next-button.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import ChevronRightIcon from "@lucide/svelte/icons/chevron-right"; import { buttonVariants, type ButtonVariant } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, variant = "ghost", ...restProps }: CalendarPrimitive.NextButtonProps & { variant?: ButtonVariant; } = $props(); </script> {#snippet Fallback()} <ChevronRightIcon class="size-4" /> {/snippet} <CalendarPrimitive.NextButton bind:ref class={cn( buttonVariants({ variant }), "size-(--cell-size) select-none bg-transparent p-0 disabled:opacity-50 rtl:rotate-180", className )} children={children || Fallback} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-nav.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLElement>> = $props(); </script> <nav {...restProps} bind:this={ref} class={cn("absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1", className)} > {@render children?.()} </nav>

// --- Ruta: src/lib/components/ui/calendar/calendar-months.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} class={cn("relative flex flex-col gap-4 md:flex-row", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/calendar/calendar-month.svelte ---
<script lang="ts"> import { type WithElementRef, cn } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLElement>> = $props(); </script> <div {...restProps} bind:this={ref} class={cn("flex flex-col", className)}> {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/calendar/calendar-month-select.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn, type WithoutChildrenOrChild } from "$lib/utils.js"; import ChevronDownIcon from "@lucide/svelte/icons/chevron-down"; let { ref = $bindable(null), class: className, value, onchange, ...restProps }: WithoutChildrenOrChild<CalendarPrimitive.MonthSelectProps> = $props(); </script> <span class={cn( "has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative flex rounded-md border", className )} > <CalendarPrimitive.MonthSelect bind:ref class="absolute inset-0 opacity-0" {...restProps}> {#snippet child({ props, monthItems, selectedMonthItem })} <select {...props} {value} {onchange}> {#each monthItems as monthItem (monthItem.value)} <option value={monthItem.value} selected={value !== undefined ? monthItem.value === value : monthItem.value === selectedMonthItem.value} > {monthItem.label} </option> {/each} </select> <span class="[&>svg]:text-muted-foreground flex h-8 select-none items-center gap-1 rounded-md pl-2 pr-1 text-sm font-medium [&>svg]:size-3.5" aria-hidden="true" > {monthItems.find((item) => item.value === value)?.label || selectedMonthItem.label} <ChevronDownIcon class="size-4" /> </span> {/snippet} </CalendarPrimitive.MonthSelect> </span>

// --- Ruta: src/lib/components/ui/calendar/calendar-heading.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.HeadingProps = $props(); </script> <CalendarPrimitive.Heading bind:ref class={cn("px-(--cell-size) text-sm font-medium", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-header.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.HeaderProps = $props(); </script> <CalendarPrimitive.Header bind:ref class={cn( "h-(--cell-size) flex w-full items-center justify-center gap-1.5 text-sm font-medium", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-head-cell.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.HeadCellProps = $props(); </script> <CalendarPrimitive.HeadCell bind:ref class={cn( "text-muted-foreground w-(--cell-size) rounded-md text-[0.8rem] font-normal", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-grid.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.GridProps = $props(); </script> <CalendarPrimitive.Grid bind:ref class={cn("mt-4 flex w-full border-collapse flex-col gap-1", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-grid-row.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.GridRowProps = $props(); </script> <CalendarPrimitive.GridRow bind:ref class={cn("flex", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-grid-head.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.GridHeadProps = $props(); </script> <CalendarPrimitive.GridHead bind:ref class={cn(className)} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-grid-body.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.GridBodyProps = $props(); </script> <CalendarPrimitive.GridBody bind:ref class={cn(className)} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-day.svelte ---
<script lang="ts"> import { buttonVariants } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; import { Calendar as CalendarPrimitive } from "bits-ui"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.DayProps = $props(); </script> <CalendarPrimitive.Day bind:ref class={cn( buttonVariants({ variant: "ghost" }), "size-(--cell-size) flex select-none flex-col items-center justify-center gap-1 whitespace-nowrap p-0 font-normal leading-none", "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground [&[data-today][data-disabled]]:text-muted-foreground", "data-[selected]:bg-primary dark:data-[selected]:hover:bg-accent/50 data-[selected]:text-primary-foreground", "[&[data-outside-month]:not([data-selected])]:text-muted-foreground [&[data-outside-month]:not([data-selected])]:hover:text-accent-foreground", "data-[disabled]:text-muted-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", "data-[unavailable]:text-muted-foreground data-[unavailable]:line-through", "dark:hover:text-accent-foreground", "focus:border-ring focus:ring-ring/50 focus:relative", "[&>span]:text-xs [&>span]:opacity-70", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-cell.svelte ---
<script lang="ts"> import { Calendar as CalendarPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: CalendarPrimitive.CellProps = $props(); </script> <CalendarPrimitive.Cell bind:ref class={cn( "size-(--cell-size) relative p-0 text-center text-sm focus-within:z-20 [&:first-child[data-selected]_[data-bits-day]]:rounded-l-md [&:last-child[data-selected]_[data-bits-day]]:rounded-r-md", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/calendar/calendar-caption.svelte ---
<script lang="ts"> import type { ComponentProps } from "svelte"; import type Calendar from "./calendar.svelte"; import CalendarMonthSelect from "./calendar-month-select.svelte"; import CalendarYearSelect from "./calendar-year-select.svelte"; import { DateFormatter, getLocalTimeZone, type DateValue } from "@internationalized/date"; let { captionLayout, months, monthFormat, years, yearFormat, month, locale, placeholder = $bindable(), monthIndex = 0, }: { captionLayout: ComponentProps<typeof Calendar>["captionLayout"]; months: ComponentProps<typeof CalendarMonthSelect>["months"]; monthFormat: ComponentProps<typeof CalendarMonthSelect>["monthFormat"]; years: ComponentProps<typeof CalendarYearSelect>["years"]; yearFormat: ComponentProps<typeof CalendarYearSelect>["yearFormat"]; month: DateValue; placeholder: DateValue | undefined; locale: string; monthIndex: number; } = $props(); function formatYear(date: DateValue) { const dateObj = date.toDate(getLocalTimeZone()); if (typeof yearFormat === "function") return yearFormat(dateObj.getFullYear()); return new DateFormatter(locale, { year: yearFormat }).format(dateObj); } function formatMonth(date: DateValue) { const dateObj = date.toDate(getLocalTimeZone()); if (typeof monthFormat === "function") return monthFormat(dateObj.getMonth() + 1); return new DateFormatter(locale, { month: monthFormat }).format(dateObj); } </script> {#snippet MonthSelect()} <CalendarMonthSelect {months} {monthFormat} value={month.month} onchange={(e) => { if (!placeholder) return; const v = Number.parseInt(e.currentTarget.value); const newPlaceholder = placeholder.set({ month: v }); placeholder = newPlaceholder.subtract({ months: monthIndex }); }} /> {/snippet} {#snippet YearSelect()} <CalendarYearSelect {years} {yearFormat} value={month.year} /> {/snippet} {#if captionLayout === "dropdown"} {@render MonthSelect()} {@render YearSelect()} {:else if captionLayout === "dropdown-months"} {@render MonthSelect()} {#if placeholder} {formatYear(placeholder)} {/if} {:else if captionLayout === "dropdown-years"} {#if placeholder} {formatMonth(placeholder)} {/if} {@render YearSelect()} {:else} {formatMonth(month)} {formatYear(month)} {/if}

// --- Ruta: src/lib/components/ui/alert/index.ts ---
export { alertVariants, type AlertVariant } from "./alert.svelte"; export { Root, Description, Title, Root as Alert, Description as AlertDescription, Title as AlertTitle, };

// --- Ruta: src/lib/components/ui/alert/alert.svelte ---
<script lang="ts" module> import { type VariantProps, tv } from "tailwind-variants"; export const alertVariants = tv({ base: "relative grid w-full grid-cols-[0_1fr] items-start gap-y-0.5 rounded-lg border px-4 py-3 text-sm has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] has-[>svg]:gap-x-3 [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current", variants: { variant: { default: "bg-card text-card-foreground", destructive: "text-destructive bg-card *:data-[slot=alert-description]:text-destructive/90 [&>svg]:text-current", }, }, defaultVariants: { variant: "default", }, }); export type AlertVariant = VariantProps<typeof alertVariants>["variant"]; </script> <script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, variant = "default", children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> & { variant?: AlertVariant; } = $props(); </script> <div bind:this={ref} data-slot="alert" class={cn(alertVariants({ variant }), className)} {...restProps} role="alert" > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert/alert-title.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="alert-title" class={cn("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert/alert-description.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="alert-description" class={cn( "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed", className )} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert-dialog/index.ts ---
const Root = AlertDialogPrimitive.Root; const Portal = AlertDialogPrimitive.Portal; export { Root, Title, Action, Cancel, Portal, Footer, Header, Trigger, Overlay, Content, Description, Root as AlertDialog, Title as AlertDialogTitle, Action as AlertDialogAction, Cancel as AlertDialogCancel, Portal as AlertDialogPortal, Footer as AlertDialogFooter, Header as AlertDialogHeader, Trigger as AlertDialogTrigger, Overlay as AlertDialogOverlay, Content as AlertDialogContent, Description as AlertDialogDescription, };

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-trigger.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; let { ref = $bindable(null), ...restProps }: AlertDialogPrimitive.TriggerProps = $props(); </script> <AlertDialogPrimitive.Trigger bind:ref data-slot="alert-dialog-trigger" {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-title.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.TitleProps = $props(); </script> <AlertDialogPrimitive.Title bind:ref data-slot="alert-dialog-title" class={cn("text-lg font-semibold", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-overlay.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.OverlayProps = $props(); </script> <AlertDialogPrimitive.Overlay bind:ref data-slot="alert-dialog-overlay" class={cn( "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className )} {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-header.svelte ---
<script lang="ts"> import type { HTMLAttributes } from "svelte/elements"; import { cn, type WithElementRef } from "$lib/utils.js"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="alert-dialog-header" class={cn("flex flex-col gap-2 text-center sm:text-left", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-footer.svelte ---
<script lang="ts"> import { cn, type WithElementRef } from "$lib/utils.js"; import type { HTMLAttributes } from "svelte/elements"; let { ref = $bindable(null), class: className, children, ...restProps }: WithElementRef<HTMLAttributes<HTMLDivElement>> = $props(); </script> <div bind:this={ref} data-slot="alert-dialog-footer" class={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)} {...restProps} > {@render children?.()} </div>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-description.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.DescriptionProps = $props(); </script> <AlertDialogPrimitive.Description bind:ref data-slot="alert-dialog-description" class={cn("text-muted-foreground text-sm", className)} {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-content.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import AlertDialogOverlay from "./alert-dialog-overlay.svelte"; import { cn, type WithoutChild, type WithoutChildrenOrChild } from "$lib/utils.js"; let { ref = $bindable(null), class: className, portalProps, ...restProps }: WithoutChild<AlertDialogPrimitive.ContentProps> & { portalProps?: WithoutChildrenOrChild<AlertDialogPrimitive.PortalProps>; } = $props(); </script> <AlertDialogPrimitive.Portal {...portalProps}> <AlertDialogOverlay /> <AlertDialogPrimitive.Content bind:ref data-slot="alert-dialog-content" class={cn( "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", className )} {...restProps} /> </AlertDialogPrimitive.Portal>

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-cancel.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { buttonVariants } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.CancelProps = $props(); </script> <AlertDialogPrimitive.Cancel bind:ref data-slot="alert-dialog-cancel" class={cn(buttonVariants({ variant: "outline" }), className)} {...restProps} />

// --- Ruta: src/lib/components/ui/alert-dialog/alert-dialog-action.svelte ---
<script lang="ts"> import { AlertDialog as AlertDialogPrimitive } from "bits-ui"; import { buttonVariants } from "$lib/components/ui/button/index.js"; import { cn } from "$lib/utils.js"; let { ref = $bindable(null), class: className, ...restProps }: AlertDialogPrimitive.ActionProps = $props(); </script> <AlertDialogPrimitive.Action bind:ref data-slot="alert-dialog-action" class={cn(buttonVariants(), className)} {...restProps} />

// --- Ruta: src/routes/api/products/details/[id]/+server.ts ---
type ProductDetails = CalculableProduct & { name: string; imageUrl?: string | null; }; async function fetchProductFromOFF( barcode: string, fetchFn: typeof fetch ): Promise<ProductDetails | null> { try { const response = await fetchFn(`https: if (!response.ok) return null; const data = await response.json(); if (data.status !== 1 || !data.product) return null; const offProduct = data.product; const nutriments = offProduct.nutriments; if ( !offProduct.product_name || nutriments?.['energy-kcal_100g'] === undefined || nutriments?.proteins_100g === undefined || nutriments?.fat_100g === undefined || nutriments?.carbohydrates_100g === undefined ) { return null; } return { name: offProduct.product_name, imageUrl: offProduct.image_url || null, quantity: 100, calories: nutriments['energy-kcal_100g'] ?? 0, protein: nutriments.proteins_100g ?? 0, fat: nutriments.fat_100g ?? 0, carbs: nutriments.carbohydrates_100g ?? 0 }; } catch (error) { console.error(`[OFF Fetch Error] Failed to fetch product ${barcode}:`, error); return null; } } export const GET: RequestHandler = async ({ params, url, fetch }) => { const { id } = params; const source = url.searchParams.get('source'); if (!source) { return json({ message: 'Missing "source" query parameter' }, { status: 400 }); } try { let productDetails: ProductDetails | null = null; if (source === 'local') { const products = await productService.getByIds([id]); const product = products[0]; if (product) { productDetails = { ...product, quantity: 100 }; } } else if (source === 'off') { productDetails = await fetchProductFromOFF(id, fetch); } if (!productDetails) { return json({ message: `Product with id ${id} not found` }, { status: 404 }); } return json(productDetails); } catch (error) { console.error(`Failed to fetch product details for id ${id}:`, error); return json( { message: 'An error occurred while fetching product details.' }, { status: 500 } ); } };

// --- Ruta: src/routes/api/products/search/barcode/[barcode]/+server.ts ---
export const GET: RequestHandler = async ({ params }) => { const { barcode } = params; if (!barcode) { return json({ message: 'El código de barras es requerido' }, { status: 400 }); } try { const product = await productService.findByBarcode(barcode); if (!product) { return json({ message: 'Producto no encontrado' }, { status: 404 }); } return json(product); } catch (error) { console.error(`Error searching for barcode ${barcode}:`, error); return json({ message: 'Error interno del servidor' }, { status: 500 }); } };

