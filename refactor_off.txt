Ayúdame a hacer un cambio muy importante en la aplicación, que requiere modificar la arquitectura de la base de datos y buena parte de los componentes de lógica y presentación. El proyecto que vas a analizar y sobre el que vas a trabajar está hecho con el stack Node.js / Typescript / SvelteKit / Svelte 5 / Shadcn-Svelte / Prisma para la base de datos.
Voy a irte dando una explicación detallada de la problemática y dando a la vez acceso al código de los ficheros involucrados en esta funcionalidad. Necesito que uses toda esta información. Vamos al lío. 
Como puedes ver en @prisma/schema.db, esta aplicación se nutre de dos tipos de objetos de ingrediente distintos. Uno de ellos proviene de la API de OpenFoodFacts, y se refleja en el tipo Product, y el otro es uno creado por el administrador de la aplicación, y se refleja en el tipo CustomIngredient. Como ves, hay campos que comparten, pero otros son exclusivos de la API de OpenFoodFacts. 
Anteriormente, en la aplicación, distinguíamos estos dos tipos de ingredientes porque incluíamos una funcionalidad de sincronización con la API de OpenFoodFacts que se ejecuta desde @src/lib/components/admin/IngredientsDesktopView.svelte o src/lib/components/admin/IngredientsMobileView.svelte. Sin embargo, tras desplegar la aplicación, me he dado cuenta de que el caso de uso de esta funcionalidad es nulo, ya que es mucho más habitual que los usuarios revisen estos datos personalmente. Si la sincronización los sobreescribe después, han hecho un esfuerzo para nada. 
Esta refactorización tiene 5 objetivos claros: 
1. Eliminar las duplicidades derivadas de tener dos tipos de ingredientes en la base de datos. A partir de ahora, todos los objetos mantendrán las propiedades del tipo CustomIngredient. Todos los objetos pasarán a ser de tipo Product, pero el objeto Product mantendrá la misma estructura y campos del objeto CustomIngredient. El objeto CustomIngredient desaparecerá.
2. Convertir la importación de productos de la API de OpenFoodFacts, que se llama desde las vistas anteriores, en una simple labor de "traducción" desde los objetos de la API a nuestro nuevo tipo Product de Postgresql. Ya no guardaremos el objeto fullPayload, pero sí guardaremos su código de barras en un nuevo campo "barcode", que ahora mismo guardamos en el "id" de Product, por si en el futuro tenemos que referenciarlo en peticiones a la API. También eliminaremos los campos "imageUrl", "isNameManuallySet" y "brand" del objeto. De esta forma, ambos productos podrán tener ids autogenerados. Además, esto hará que la base de datos sea más ligera y la respuesta más rápida. En términos de relaciones, una receta seguirá teniendo un conjunto de ingredientes, y un ingrediente podrá formar parte de multitud de recetas.
3. Eliminar por completo la funcionalidad de sincronización con OpenFoodFacts de la aplicación. Esto hará que la aplicación se simplifique mucho en conjunción con la eliminación del manejo de tipos que son diferentes aunque representan el mismo tipo de objeto. Por ejemplo, podremos eliminar la existencia de diferentes diálogos para la edición de ingredientes, ya que ahora podrán editarse los campos de todos los productos al no ser necesaria la sincronización con OpenFoodFacts. 
4. Cambiar la base de datos que usamos desde SQLite a Postgresql, que es la base de datos que estoy usando en el entorno de producción. Ya que vamos a hacer un reseteo completo de la base de datos a un estado completamente nuevo, es el momento de acometer este cambio. 
5. Ajustar el fichero @prisma/seed.ts para reflejar la nueva estructura. 
6. Comprobar si otros elementos clave de la aplicación, como @src/lib/components/recipes/RecipeForm.svelte, se ven afectados por estos cambios. Si es así, actualizar o modificar lo que sea necesario para cumplir con el nuevo patrón de la base de datos. 

Esto supondrá además también algunos cambios en la vista de ingredientes, tanto en escritorio como en móvil, que te detallo a continuación: 
0. Renombrar Ingredientes por Productos en las vistas y en la lógica. En el futuro, la aplicación también debe estar preparada para manejar Productos como elementos "standalone", y no solo como ingredientes de recetas, ya que muchos de ellos pueden ser elementos comestibles completos de por sí, como por ejemplo las frutas.
1. Incluir un nuevo botón "Añadir desde OpenFoodFacts" a ambas vistas que lleve a @src/routes/admin/ingredientes/off/+page.svelte. 
2. Quitar el botón de Ir al Inicio de las vistas. Ya hemos implementado un menú en nuestro layout que realiza esta función y está disponible en todas las vistas.
3. Quitar el botón de Refrescar Datos de las vistas. Con las funcionalidades que implementamos, la vista y la base de datos deberían estar siempre sincronizadas. 
4. Refactorizar los diálogos de edición de ingredientes para que dejen de ser solo dos y sean uno solo, que es el que actualmente se usa con los CustomIngredient y que permite editar tanto su nombre como su valor calórico y sus macronutrientes. De paso, permite que todos los campos de calorías y macronutrientes contengan dos números decimales, y elimina con tailwind css las flechas de los input numéricos.
5. Añadir a la vista de ingredientes/productos un nuevo botón a la columna de acciones que permita calcular el número de calorías de cualquier producto/ingrediente. En este momento, la información nutricional de todos los productos se añade siempre en valores por 100 gramos para estar de acuerdo con el modelado de la API de OpenFoodFacts.
6. Aprovecha para hacer con las clases de shadcn-svelte que la barra de búsqueda de la vista de escritorio ocupe todo el ancho que queda disponible en su fila. 

Entiendo que la refactorización que te estoy pidiendo es bastante compleja y afecta a diferentes partes de la aplicación. Por eso, necesito que pienses con calma, en detalle y paso a paso. Estos son los pasos que quiero que tomes:
1. ENTIENDE lo que te estoy pidiendo en profundidad. El alcance de los cambios, el orden en que deben hacerse, la mejor manera de estructurar la refactorización para no romper la aplicación en el proceso.
2. ANALIZA la base de código que te doy y estudia si necesitas acceso a más ficheros para desarrollar un conocimiento más completo del problema. Si es así, pídelo antes de avanzar más.
3. RAZONA sobre las implicaciones de los cambios y su alcance para no dejarte atrás ningún elemento importante en la refactorización que pueda romper el despliegue tras haber finalizado el proceso.
4. SINTETIZA Y ORDENA los cambios que tienes que realizar y desarrolla con ellos un plan de implementación de la refactorización. El plan debe estar dividido en hitos. A su vez, cada hito debe estar dividido en pasos atómicos que puedan irse implementando y probando de manera individual. Tendrás que detenerte después de cada paso atómico para que yo pueda comprobar los cambios que estás haciendo y depurar los errores si los hubiera. 
5. CONCLUYE desarrollando el mejor plan posible para mejorar nuestra aplicación.

Analiza todos estos requerimientos y, antes que nada, pregúntame si tienes dudas, necesitas aclaraciones o acceso a más código para desarrollar el mejor plan de refactorización posible. 


Algunas puntualizaciones para que las tengas en cuenta: 
1. Tendrás que eliminar o modificar todas las migraciones previas de Prisma, que estaban hechas para trabajar sobre SQLite y ya no servirán. 
2. Aquí tienes el fichero ingredientService.ts: @src/lib/server/services/ingredientService.ts 
3. Si mucho no me equivoco, los objetos Product ya van a mostrar en las vistas todos los campos de los que disponen (salvo el barcode, que no es necesario que lo vea el usuario). Creo que es seguro eliminar por completo la vista de detalles de Producto de la aplicación, que además hasta ahora no se ha usado para nada en la base de código. 
4.  Si crees que hay más elementos que pueden estar afectados por este cambio en la base de datos, dímelo y te dejo revisarlos antes de continuar.

