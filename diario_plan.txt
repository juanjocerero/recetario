# Plan de Implementación: Funcionalidad de Diario

Este plan detalla los pasos para implementar la funcionalidad de seguimiento de consumo diario ("Diario") en la aplicación.

## Hito 1: Backend y Base de Datos

**Objetivo:** Establecer el modelo de datos, las rutas de API y la lógica de negocio necesarios para gestionar las entradas del diario.

*   **Paso 1.1: Modificar el Esquema de la Base de Datos**
    *   **Qué:** Añadir el nuevo modelo `DiaryEntry` al fichero `prisma/schema.prisma` según la propuesta de diseño. Se incluirán campos para `id`, `date`, `userId`, `type`, `name`, `quantity`, valores nutricionales (`calories`, `protein`, `fat`, `carbs`), un campo `Json` para `ingredients`, y las relaciones opcionales `baseProductId` y `baseRecipeId`. El campo userId será opcional de momento, ya que solo hay un usuario en la aplicación. La funcionalidad de gestión de usuarios se implementará más tarde.
    *   **Por qué:** Es la base sobre la que se construirá toda la funcionalidad. El esquema propuesto garantiza la integridad de los datos históricos y permite la edición independiente de las entradas.
    *   **Verificación:** Detenerse y revisar que el modelo se ha añadido correctamente y que se han establecido todas las claves y optimizaciones necesarias para asegurar el rendimiento de la aplicación en PostgreSQL.


*   **Paso 1.2: Aplicar la Migración de la Base de Datos**
    *   **Qué:** Ejecutar `npx prisma migrate dev --name add-diary-entries` en la terminal.
    *   **Por qué:** Este comando actualiza la base de datos PostgreSQL para que coincida con el nuevo esquema de Prisma, creando la tabla `DiaryEntry` y sus columnas.
     *   **Verificación:** Detenerse y asegurarse de que se ha creado correctamente.

*   **Paso 1.3: Crear Servicios de Lógica de Negocio**
    *   **Qué:** Crear un nuevo fichero `src/lib/server/services/diaryService.ts`. Este servicio contendrá funciones para:
        1.  `getDiaryEntries(userId, startDate, endDate)`: Obtener entradas para un rango de fechas.
        2.  `addDiaryEntry(userId, entryData)`: Añadir una nueva entrada (producto o receta).
        3.  `updateDiaryEntry(entryId, updates)`: Modificar una entrada existente (ej. cantidad o ingredientes JSON).
        4.  `deleteDiaryEntry(entryId)`: Eliminar una entrada.
        5.  `getAggregatedNutrients(entries)`: Calcular totales y promedios a partir de una lista de entradas.
    *   **Por qué:** Centraliza toda la lógica de interacción con la base de datos, manteniendo los endpoints limpios y siguiendo la arquitectura existente (`recipeService.ts`, `productService.ts`).
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 1.4: Crear Endpoints de la API**
    *   **Qué:** Crear los ficheros necesarios bajo una nueva ruta `src/routes/api/diary/`.
        *   `[...date]/+server.ts`: Un endpoint que gestionará `GET` para obtener entradas por día o rango de fechas.
        *   `+server.ts`: Gestionará `POST` para crear nuevas entradas.
        *   `[id]/+server.ts`: Gestionará `PUT` para actualizar y `DELETE` para eliminar entradas.
    *   **Por qué:** Proporciona la interfaz necesaria para que el frontend pueda interactuar con el backend de forma segura y estructurada.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 1.5: Crear Endpoint de Búsqueda Unificada**
    *   **Qué:** Crear un nuevo endpoint en `src/routes/api/search/all/+server.ts`. Este endpoint aceptará un término de búsqueda (`q`) y devolverá una lista combinada de `Product` y `Recipe` que coincidan, añadiendo un campo `type` a cada resultado.
    *   **Por qué:** Es un requisito clave para el buscador "Añadir elementos", que debe buscar en ambas tablas simultáneamente.
     *   **Verificación:** Detenerse y dar al usuario instrucciones para hacer curls de prueba a este endpoint y asegurarse de que los resultados se muestran correctamente en la consola de desarrollo. Esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

## Hito 2: Interfaz de Usuario - Vista Principal del Diario

**Objetivo:** Construir la interfaz principal donde el usuario visualizará y gestionará su diario.

*   **Paso 2.1: Crear la Ruta y Página Principal del Diario**
    *   **Qué:** Crear la estructura de ficheros para la nueva ruta: `src/routes/diario/+page.svelte` y `src/routes/diario/+page.server.ts`.
    *   **Por qué:** Establece el nuevo apartado "Diario" en la aplicación. El `+page.server.ts` cargará los datos iniciales para el día actual.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 2.2: Implementar el Selector de Fecha**
    *   **Qué:** Añadir un componente de calendario de `shadcn-svelte` en `+page.svelte`. Se configurará para permitir la selección de un rango de fechas. El estado del rango seleccionado (`startDate`, `endDate`) será reactivo.
    *   **Por qué:** Permite al usuario navegar entre días y seleccionar rangos para la vista semanal, cumpliendo ambos requisitos con un solo componente.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 2.3: Crear el Panel de Resumen Nutricional**
    *   **Qué:** Crear un componente `src/lib/components/diary/NutritionalSummary.svelte`. Este componente recibirá los datos nutricionales totales y medios y los mostrará, reutilizando el `MacroBar.svelte` existente.
    *   **Por qué:** Presenta la información clave de un vistazo. Se dividirá en dos secciones: "Totales del Periodo" y "Promedio Diario" (este último solo visible si el rango es > 1 día).
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 2.4: Crear la Lista de Entradas del Diario**
    *   **Qué:** Crear un componente `src/lib/components/diary/DiaryEntryList.svelte`. Este componente recibirá la lista de entradas del día/periodo y las renderizará. Cada fila mostrará el nombre, calorías, una `MacroBar` y botones de acción (editar, eliminar).
    *   **Por qué:** Es el núcleo de la vista, mostrando los alimentos consumidos de forma clara y ordenada.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

## Hito 3: Añadir y Editar Entradas

**Objetivo:** Implementar la funcionalidad interactiva para que los usuarios puedan poblar y modificar su diario.

*   **Paso 3.1: Refactorizar el Diálogo de Edición de Cantidades**
    *   **Qué:** Modificar `src/lib/components/recipes/EditQuantitiesDialog.svelte` para que sea más genérico. Se llamará `EditEntryDialog.svelte` y podrá manejar tanto la edición de cantidad de un producto como la edición de la lista de ingredientes de una receta (que se pasará como el objeto JSON).
    *   **Por qué:** Reutiliza la lógica de UI existente como se solicitó, adaptándola para que funcione con el nuevo modelo de `DiaryEntry` y su campo `ingredients`.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 3.2: Crear el Componente "Añadir Elemento"**
    *   **Qué:** Crear `src/lib/components/diary/AddItemPanel.svelte`. Este componente contendrá un `Collapsible` de `shadcn-svelte`. Dentro, habrá un campo de búsqueda que llame al endpoint de búsqueda unificada (`/api/search/all`).
    *   **Por qué:** Proporciona la interfaz para que los usuarios busquen y añadan nuevos elementos a su diario.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 3.3: Implementar la Lógica de Adición**
    *   **Qué:** Cuando un usuario seleccione un ítem de los resultados de búsqueda, se llamará al `diaryService` para crear la `DiaryEntry` correspondiente. Si es una receta, se copiarán sus ingredientes al campo JSON. La UI se actualizará reactivamente para mostrar la nueva entrada en la lista.
    *   **Por qué:** Completa el flujo de añadir un nuevo alimento al diario.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 3.4: Implementar la Lógica de Eliminación y Edición**
    *   **Qué:** Conectar los botones de la `DiaryEntryList` a las funciones correspondientes. El botón de eliminar llamará al endpoint `DELETE /api/diary/[id]`. El botón de editar abrirá el `EditEntryDialog.svelte` refactorizado.
    *   **Por qué:** Permite al usuario gestionar las entradas de su diario, corrigiendo errores o ajustando cantidades.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

## Hito 4: Poblar la Base de Datos con Datos de Prueba (Seeding)

**Objetivo:** Generar datos de prueba realistas para verificar la funcionalidad completa.

*   **Paso 4.1: Modificar el Script de Seeding**
    *   **Qué:** Añadir una nueva fase al final del fichero `prisma/seed.ts`.
    *   **Por qué:** Asegura que los datos del diario se creen después de que ya existan los productos y recetas necesarios.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

*   **Paso 4.2: Implementar la Lógica de Creación de Diarios**
    *   **Qué:**
        1.  Limpiar la tabla `DiaryEntry` al inicio del script.
        2.  Definir un `userId` de prueba (ej. `test-user@example.com`).
        3.  Iterar sobre los días del 3 al 10 de agosto de 2025.
        4.  Para cada día, seleccionar aleatoriamente entre 5 y 10 elementos (mezcla de `Product` y `Recipe`) de los ya creados.
        5.  Para cada elemento, crear una `DiaryEntry`, asignando una hora aleatoria dentro de ese día.
        6.  Si el elemento es una receta, copiar su estructura de ingredientes y cantidades al campo `ingredients` de la `DiaryEntry`.
        7.  Calcular y almacenar los valores nutricionales en la propia entrada.
    *   **Por qué:** Crea un conjunto de datos completo y realista que permite probar la vista de día, la vista de semana, los cálculos de totales y promedios, y la ordenación cronológica.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores o dé instrucciones para continuar.

## Hito 5: Diseñar un plan de pruebas manual para el usuario 
**Objetivo:** Aseguarse de que la implementación es completa y correcta antes de dar por finalizado el trabajo. 

*   **Paso 5.1: Diseñar un plan de pruebas*
    *   **Qué:** Crear un plan de pruebas manuales para asegurarse de que todas las vistas, endpoints y funcionalidades de la nueva implementación se han realizado correctamente. Comunicar el plan al usuario dividido en pasos atómicos relativos a cada funcionalidad individual.
    *   **Por qué:** Asegura que todo el trabajo es correcto antes de darlo por finalizado.
    *   **Verificación:** Detenerse y esperar a que el usuario informe de posibles errores.

## Otras consideraciones importantes: Contexto y ficheros de código de la base de datos ya existentes para tener como referencia o guía de diseño:
1. El esquema de la base de datos: `@prisma/schema.prisma`
2. El diálogo de edición de cantidades de una receta:  `@src/lib/components/recipes/RecipeCard.svelte`
3. La barra de distribución de macronutrientes: `@src/lib/components/shared/MacroBar.svelte`
4. Vista de ejemplo de grid de recetas para inspirarte en el diseño: `@src/routes/+page.svelte`
5. Vista de ejemplo de lista de productos para inspirarte en el diseño: `@src/lib/components/admin/ProductsDesktopView.svelte y src/lib/components/admin/ProductsMobileView.svelte`
6. Vista de creación y edición de nuevas recetas: `@src/lib/components/recipes/RecipeForm.svelte`
7. Vista de edición de productos: `@src/lib/components/admin/OFFProductDialog.svelte`
8. Vista de edición de cantidades: `@src/lib/components/recipes/EditQuantitiesDialog.svelte`

Si tienes alguna duda o necesitas aclarar aspectos o tener acceso a otras partes de la base de código, dímelo antes de continuar.
